{"version":3,"file":"video-lazy.min.js","sources":["../src/video-lazy.js"],"sourcesContent":["/**\n * @license\n * Video.js 8.10.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/main/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n        typeof define === 'function' && define.amd ? define(factory) :\n            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.videojs = factory());\n})(this, (function () { 'use strict';\n\n    var version$5 = \"8.10.0\";\n\n    /**\n     * An Object that contains lifecycle hooks as keys which point to an array\n     * of functions that are run when a lifecycle is triggered\n     *\n     * @private\n     */\n    const hooks_ = {};\n\n    /**\n     * Get a list of hooks for a specific lifecycle\n     *\n     * @param  {string} type\n     *         the lifecycle to get hooks from\n     *\n     * @param  {Function|Function[]} [fn]\n     *         Optionally add a hook (or hooks) to the lifecycle that your are getting.\n     *\n     * @return {Array}\n     *         an array of hooks, or an empty array if there are none.\n     */\n    const hooks = function (type, fn) {\n        hooks_[type] = hooks_[type] || [];\n        if (fn) {\n            hooks_[type] = hooks_[type].concat(fn);\n        }\n        return hooks_[type];\n    };\n\n    /**\n     * Add a function hook to a specific videojs lifecycle.\n     *\n     * @param {string} type\n     *        the lifecycle to hook the function to.\n     *\n     * @param {Function|Function[]}\n     *        The function or array of functions to attach.\n     */\n    const hook = function (type, fn) {\n        hooks(type, fn);\n    };\n\n    /**\n     * Remove a hook from a specific videojs lifecycle.\n     *\n     * @param  {string} type\n     *         the lifecycle that the function hooked to\n     *\n     * @param  {Function} fn\n     *         The hooked function to remove\n     *\n     * @return {boolean}\n     *         The function that was removed or undef\n     */\n    const removeHook = function (type, fn) {\n        const index = hooks(type).indexOf(fn);\n        if (index <= -1) {\n            return false;\n        }\n        hooks_[type] = hooks_[type].slice();\n        hooks_[type].splice(index, 1);\n        return true;\n    };\n\n    /**\n     * Add a function hook that will only run once to a specific videojs lifecycle.\n     *\n     * @param {string} type\n     *        the lifecycle to hook the function to.\n     *\n     * @param {Function|Function[]}\n     *        The function or array of functions to attach.\n     */\n    const hookOnce = function (type, fn) {\n        hooks(type, [].concat(fn).map(original => {\n            const wrapper = (...args) => {\n                removeHook(type, wrapper);\n                return original(...args);\n            };\n            return wrapper;\n        }));\n    };\n\n    /**\n     * @file fullscreen-api.js\n     * @module fullscreen-api\n     */\n\n    /**\n     * Store the browser-specific methods for the fullscreen API.\n     *\n     * @type {Object}\n     * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n     * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n     */\n    const FullscreenApi = {\n        prefixed: true\n    };\n\n    // browser API methods\n    const apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'],\n        // WebKit\n        ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen']];\n    const specApi = apiMap[0];\n    let browserApi;\n\n    // determine the supported set of functions\n    for (let i = 0; i < apiMap.length; i++) {\n        // check for exitFullscreen function\n        if (apiMap[i][1] in document) {\n            browserApi = apiMap[i];\n            break;\n        }\n    }\n\n    // map the browser API names to the spec API names\n    if (browserApi) {\n        for (let i = 0; i < browserApi.length; i++) {\n            FullscreenApi[specApi[i]] = browserApi[i];\n        }\n        FullscreenApi.prefixed = browserApi[0] !== specApi[0];\n    }\n\n    /**\n     * @file create-logger.js\n     * @module create-logger\n     */\n\n        // This is the private tracking variable for the logging history.\n    let history = [];\n\n    /**\n     * Log messages to the console and history based on the type of message\n     *\n     * @private\n     * @param  {string} name\n     *         The name of the console method to use.\n     *\n     * @param  {Object} log\n     *         The arguments to be passed to the matching console method.\n     *\n     * @param {string} [styles]\n     *        styles for name\n     */\n    const LogByTypeFactory = (name, log, styles) => (type, level, args) => {\n        const lvl = log.levels[level];\n        const lvlRegExp = new RegExp(`^(${lvl})$`);\n        let resultName = name;\n        if (type !== 'log') {\n            // Add the type to the front of the message when it's not \"log\".\n            args.unshift(type.toUpperCase() + ':');\n        }\n        if (styles) {\n            resultName = `%c${name}`;\n            args.unshift(styles);\n        }\n\n        // Add console prefix after adding to history.\n        args.unshift(resultName + ':');\n\n        // Add a clone of the args at this point to history.\n        if (history) {\n            history.push([].concat(args));\n\n            // only store 1000 history entries\n            const splice = history.length - 1000;\n            history.splice(0, splice > 0 ? splice : 0);\n        }\n\n        // If there's no console then don't try to output messages, but they will\n        // still be stored in history.\n        if (!window.console) {\n            return;\n        }\n\n        // Was setting these once outside of this function, but containing them\n        // in the function makes it easier to test cases where console doesn't exist\n        // when the module is executed.\n        let fn = window.console[type];\n        if (!fn && type === 'debug') {\n            // Certain browsers don't have support for console.debug. For those, we\n            // should default to the closest comparable log.\n            fn = window.console.info || window.console.log;\n        }\n\n        // Bail out if there's no console or if this type is not allowed by the\n        // current logging level.\n        if (!fn || !lvl || !lvlRegExp.test(type)) {\n            return;\n        }\n        fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\n    };\n    function createLogger$1(name, delimiter = ':', styles = '') {\n        // This is the private tracking variable for logging level.\n        let level = 'info';\n\n        // the curried logByType bound to the specific log and history\n        let logByType;\n\n        /**\n         * Logs plain debug messages. Similar to `console.log`.\n         *\n         * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n         * of our JSDoc template, we cannot properly document this as both a function\n         * and a namespace, so its function signature is documented here.\n         *\n         * #### Arguments\n         * ##### *args\n         * *[]\n         *\n         * Any combination of values that could be passed to `console.log()`.\n         *\n         * #### Return Value\n         *\n         * `undefined`\n         *\n         * @namespace\n         * @param    {...*} args\n         *           One or more messages or objects that should be logged.\n         */\n        const log = function (...args) {\n            logByType('log', level, args);\n        };\n\n        // This is the logByType helper that the logging methods below use\n        logByType = LogByTypeFactory(name, log, styles);\n\n        /**\n         * Create a new subLogger which chains the old name to the new name.\n         *\n         * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\n         * ```js\n         *  mylogger('foo');\n         *  // > VIDEOJS: player: foo\n         * ```\n         *\n         * @param {string} subName\n         *        The name to add call the new logger\n         * @param {string} [subDelimiter]\n         *        Optional delimiter\n         * @param {string} [subStyles]\n         *        Optional styles\n         * @return {Object}\n         */\n        log.createLogger = (subName, subDelimiter, subStyles) => {\n            const resultDelimiter = subDelimiter !== undefined ? subDelimiter : delimiter;\n            const resultStyles = subStyles !== undefined ? subStyles : styles;\n            const resultName = `${name} ${resultDelimiter} ${subName}`;\n            return createLogger$1(resultName, resultDelimiter, resultStyles);\n        };\n\n        /**\n         * Create a new logger.\n         *\n         * @param {string} newName\n         *        The name for the new logger\n         * @param {string} [newDelimiter]\n         *        Optional delimiter\n         * @param {string} [newStyles]\n         *        Optional styles\n         * @return {Object}\n         */\n        log.createNewLogger = (newName, newDelimiter, newStyles) => {\n            return createLogger$1(newName, newDelimiter, newStyles);\n        };\n\n        /**\n         * Enumeration of available logging levels, where the keys are the level names\n         * and the values are `|`-separated strings containing logging methods allowed\n         * in that logging level. These strings are used to create a regular expression\n         * matching the function name being called.\n         *\n         * Levels provided by Video.js are:\n         *\n         * - `off`: Matches no calls. Any value that can be cast to `false` will have\n         *   this effect. The most restrictive.\n         * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n         *   `log.warn`, and `log.error`).\n         * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n         * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n         * - `warn`: Matches `log.warn` and `log.error` calls.\n         * - `error`: Matches only `log.error` calls.\n         *\n         * @type {Object}\n         */\n        log.levels = {\n            all: 'debug|log|warn|error',\n            off: '',\n            debug: 'debug|log|warn|error',\n            info: 'log|warn|error',\n            warn: 'warn|error',\n            error: 'error',\n            DEFAULT: level\n        };\n\n        /**\n         * Get or set the current logging level.\n         *\n         * If a string matching a key from {@link module:log.levels} is provided, acts\n         * as a setter.\n         *\n         * @param  {'all'|'debug'|'info'|'warn'|'error'|'off'} [lvl]\n         *         Pass a valid level to set a new logging level.\n         *\n         * @return {string}\n         *         The current logging level.\n         */\n        log.level = lvl => {\n            if (typeof lvl === 'string') {\n                if (!log.levels.hasOwnProperty(lvl)) {\n                    throw new Error(`\"${lvl}\" in not a valid log level`);\n                }\n                level = lvl;\n            }\n            return level;\n        };\n\n        /**\n         * Returns an array containing everything that has been logged to the history.\n         *\n         * This array is a shallow clone of the internal history record. However, its\n         * contents are _not_ cloned; so, mutating objects inside this array will\n         * mutate them in history.\n         *\n         * @return {Array}\n         */\n        log.history = () => history ? [].concat(history) : [];\n\n        /**\n         * Allows you to filter the history by the given logger name\n         *\n         * @param {string} fname\n         *        The name to filter by\n         *\n         * @return {Array}\n         *         The filtered list to return\n         */\n        log.history.filter = fname => {\n            return (history || []).filter(historyItem => {\n                // if the first item in each historyItem includes `fname`, then it's a match\n                return new RegExp(`.*${fname}.*`).test(historyItem[0]);\n            });\n        };\n\n        /**\n         * Clears the internal history tracking, but does not prevent further history\n         * tracking.\n         */\n        log.history.clear = () => {\n            if (history) {\n                history.length = 0;\n            }\n        };\n\n        /**\n         * Disable history tracking if it is currently enabled.\n         */\n        log.history.disable = () => {\n            if (history !== null) {\n                history.length = 0;\n                history = null;\n            }\n        };\n\n        /**\n         * Enable history tracking if it is currently disabled.\n         */\n        log.history.enable = () => {\n            if (history === null) {\n                history = [];\n            }\n        };\n\n        /**\n         * Logs error messages. Similar to `console.error`.\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as an error\n         */\n        log.error = (...args) => logByType('error', level, args);\n\n        /**\n         * Logs warning messages. Similar to `console.warn`.\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as a warning.\n         */\n        log.warn = (...args) => logByType('warn', level, args);\n\n        /**\n         * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n         * log if `console.debug` is not available\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as debug.\n         */\n        log.debug = (...args) => logByType('debug', level, args);\n        return log;\n    }\n\n    /**\n     * @file log.js\n     * @module log\n     */\n    const log$1 = createLogger$1('VIDEOJS');\n    const createLogger = log$1.createLogger;\n\n    /**\n     * @file obj.js\n     * @module obj\n     */\n\n    /**\n     * @callback obj:EachCallback\n     *\n     * @param {*} value\n     *        The current key for the object that is being iterated over.\n     *\n     * @param {string} key\n     *        The current key-value for object that is being iterated over\n     */\n\n    /**\n     * @callback obj:ReduceCallback\n     *\n     * @param {*} accum\n     *        The value that is accumulating over the reduce loop.\n     *\n     * @param {*} value\n     *        The current key for the object that is being iterated over.\n     *\n     * @param {string} key\n     *        The current key-value for object that is being iterated over\n     *\n     * @return {*}\n     *         The new accumulated value.\n     */\n    const toString$1 = Object.prototype.toString;\n\n    /**\n     * Get the keys of an Object\n     *\n     * @param {Object}\n     *        The Object to get the keys from\n     *\n     * @return {string[]}\n     *         An array of the keys from the object. Returns an empty array if the\n     *         object passed in was invalid or had no keys.\n     *\n     * @private\n     */\n    const keys = function (object) {\n        return isObject$1(object) ? Object.keys(object) : [];\n    };\n\n    /**\n     * Array-like iteration for objects.\n     *\n     * @param {Object} object\n     *        The object to iterate over\n     *\n     * @param {obj:EachCallback} fn\n     *        The callback function which is called for each key in the object.\n     */\n    function each(object, fn) {\n        keys(object).forEach(key => fn(object[key], key));\n    }\n\n    /**\n     * Array-like reduce for objects.\n     *\n     * @param {Object} object\n     *        The Object that you want to reduce.\n     *\n     * @param {Function} fn\n     *         A callback function which is called for each key in the object. It\n     *         receives the accumulated value and the per-iteration value and key\n     *         as arguments.\n     *\n     * @param {*} [initial = 0]\n     *        Starting value\n     *\n     * @return {*}\n     *         The final accumulated value.\n     */\n    function reduce(object, fn, initial = 0) {\n        return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);\n    }\n\n    /**\n     * Returns whether a value is an object of any kind - including DOM nodes,\n     * arrays, regular expressions, etc. Not functions, though.\n     *\n     * This avoids the gotcha where using `typeof` on a `null` value\n     * results in `'object'`.\n     *\n     * @param  {Object} value\n     * @return {boolean}\n     */\n    function isObject$1(value) {\n        return !!value && typeof value === 'object';\n    }\n\n    /**\n     * Returns whether an object appears to be a \"plain\" object - that is, a\n     * direct instance of `Object`.\n     *\n     * @param  {Object} value\n     * @return {boolean}\n     */\n    function isPlain(value) {\n        return isObject$1(value) && toString$1.call(value) === '[object Object]' && value.constructor === Object;\n    }\n\n    /**\n     * Merge two objects recursively.\n     *\n     * Performs a deep merge like\n     * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges\n     * plain objects (not arrays, elements, or anything else).\n     *\n     * Non-plain object values will be copied directly from the right-most\n     * argument.\n     *\n     * @param   {Object[]} sources\n     *          One or more objects to merge into a new object.\n     *\n     * @return {Object}\n     *          A new object that is the merged result of all sources.\n     */\n    function merge$2(...sources) {\n        const result = {};\n        sources.forEach(source => {\n            if (!source) {\n                return;\n            }\n            each(source, (value, key) => {\n                if (!isPlain(value)) {\n                    result[key] = value;\n                    return;\n                }\n                if (!isPlain(result[key])) {\n                    result[key] = {};\n                }\n                result[key] = merge$2(result[key], value);\n            });\n        });\n        return result;\n    }\n\n    /**\n     * Returns an array of values for a given object\n     *\n     * @param  {Object} source - target object\n     * @return {Array<unknown>} - object values\n     */\n    function values$1(source = {}) {\n        const result = [];\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                const value = source[key];\n                result.push(value);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Object.defineProperty but \"lazy\", which means that the value is only set after\n     * it is retrieved the first time, rather than being set right away.\n     *\n     * @param {Object} obj the object to set the property on\n     * @param {string} key the key for the property to set\n     * @param {Function} getValue the function used to get the value when it is needed.\n     * @param {boolean} setter whether a setter should be allowed or not\n     */\n    function defineLazyProperty(obj, key, getValue, setter = true) {\n        const set = value => Object.defineProperty(obj, key, {\n            value,\n            enumerable: true,\n            writable: true\n        });\n        const options = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                const value = getValue();\n                set(value);\n                return value;\n            }\n        };\n        if (setter) {\n            options.set = set;\n        }\n        return Object.defineProperty(obj, key, options);\n    }\n\n    var Obj = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        each: each,\n        reduce: reduce,\n        isObject: isObject$1,\n        isPlain: isPlain,\n        merge: merge$2,\n        values: values$1,\n        defineLazyProperty: defineLazyProperty\n    });\n\n    /**\n     * @file browser.js\n     * @module browser\n     */\n\n    /**\n     * Whether or not this device is an iPod.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_IPOD = false;\n\n    /**\n     * The detected iOS version - or `null`.\n     *\n     * @static\n     * @type {string|null}\n     */\n    let IOS_VERSION = null;\n\n    /**\n     * Whether or not this is an Android device.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_ANDROID = false;\n\n    /**\n     * The detected Android version - or `null` if not Android or indeterminable.\n     *\n     * @static\n     * @type {number|string|null}\n     */\n    let ANDROID_VERSION;\n\n    /**\n     * Whether or not this is Mozilla Firefox.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_FIREFOX = false;\n\n    /**\n     * Whether or not this is Microsoft Edge.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_EDGE = false;\n\n    /**\n     * Whether or not this is any Chromium Browser\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_CHROMIUM = false;\n\n    /**\n     * Whether or not this is any Chromium browser that is not Edge.\n     *\n     * This will also be `true` for Chrome on iOS, which will have different support\n     * as it is actually Safari under the hood.\n     *\n     * Deprecated, as the behaviour to not match Edge was to prevent Legacy Edge's UA matching.\n     * IS_CHROMIUM should be used instead.\n     * \"Chromium but not Edge\" could be explicitly tested with IS_CHROMIUM && !IS_EDGE\n     *\n     * @static\n     * @deprecated\n     * @type {Boolean}\n     */\n    let IS_CHROME = false;\n\n    /**\n     * The detected Chromium version - or `null`.\n     *\n     * @static\n     * @type {number|null}\n     */\n    let CHROMIUM_VERSION = null;\n\n    /**\n     * The detected Google Chrome version - or `null`.\n     * This has always been the _Chromium_ version, i.e. would return on Chromium Edge.\n     * Deprecated, use CHROMIUM_VERSION instead.\n     *\n     * @static\n     * @deprecated\n     * @type {number|null}\n     */\n    let CHROME_VERSION = null;\n\n    /**\n     * The detected Internet Explorer version - or `null`.\n     *\n     * @static\n     * @deprecated\n     * @type {number|null}\n     */\n    let IE_VERSION = null;\n\n    /**\n     * Whether or not this is desktop Safari.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_SAFARI = false;\n\n    /**\n     * Whether or not this is a Windows machine.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_WINDOWS = false;\n\n    /**\n     * Whether or not this device is an iPad.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_IPAD = false;\n\n    /**\n     * Whether or not this device is an iPhone.\n     *\n     * @static\n     * @type {Boolean}\n     */\n        // The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n        // to identify iPhones, we need to exclude iPads.\n        // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\n    let IS_IPHONE = false;\n\n    /**\n     * Whether or not this device is touch-enabled.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));\n    const UAD = window.navigator && window.navigator.userAgentData;\n    if (UAD && UAD.platform && UAD.brands) {\n        // If userAgentData is present, use it instead of userAgent to avoid warnings\n        // Currently only implemented on Chromium\n        // userAgentData does not expose Android version, so ANDROID_VERSION remains `null`\n\n        IS_ANDROID = UAD.platform === 'Android';\n        IS_EDGE = Boolean(UAD.brands.find(b => b.brand === 'Microsoft Edge'));\n        IS_CHROMIUM = Boolean(UAD.brands.find(b => b.brand === 'Chromium'));\n        IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n        CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find(b => b.brand === 'Chromium') || {}).version || null;\n        IS_WINDOWS = UAD.platform === 'Windows';\n    }\n\n    // If the browser is not Chromium, either userAgentData is not present which could be an old Chromium browser,\n    //  or it's a browser that has added userAgentData since that we don't have tests for yet. In either case,\n    // the checks need to be made agiainst the regular userAgent string.\n    if (!IS_CHROMIUM) {\n        const USER_AGENT = window.navigator && window.navigator.userAgent || '';\n        IS_IPOD = /iPod/i.test(USER_AGENT);\n        IOS_VERSION = function () {\n            const match = USER_AGENT.match(/OS (\\d+)_/i);\n            if (match && match[1]) {\n                return match[1];\n            }\n            return null;\n        }();\n        IS_ANDROID = /Android/i.test(USER_AGENT);\n        ANDROID_VERSION = function () {\n            // This matches Android Major.Minor.Patch versions\n            // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n            const match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n            if (!match) {\n                return null;\n            }\n            const major = match[1] && parseFloat(match[1]);\n            const minor = match[2] && parseFloat(match[2]);\n            if (major && minor) {\n                return parseFloat(match[1] + '.' + match[2]);\n            } else if (major) {\n                return major;\n            }\n            return null;\n        }();\n        IS_FIREFOX = /Firefox/i.test(USER_AGENT);\n        IS_EDGE = /Edg/i.test(USER_AGENT);\n        IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);\n        IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n        CHROMIUM_VERSION = CHROME_VERSION = function () {\n            const match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n            if (match && match[2]) {\n                return parseFloat(match[2]);\n            }\n            return null;\n        }();\n        IE_VERSION = function () {\n            const result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n            let version = result && parseFloat(result[1]);\n            if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n                // IE 11 has a different user agent string than other IE versions\n                version = 11.0;\n            }\n            return version;\n        }();\n        IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\n        IS_WINDOWS = /Windows/i.test(USER_AGENT);\n        IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);\n        IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\n    }\n\n    /**\n     * Whether or not this is an iOS device.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\n    /**\n     * Whether or not this is any flavor of Safari - including iOS.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\n\n    var browser = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        get IS_IPOD () { return IS_IPOD; },\n        get IOS_VERSION () { return IOS_VERSION; },\n        get IS_ANDROID () { return IS_ANDROID; },\n        get ANDROID_VERSION () { return ANDROID_VERSION; },\n        get IS_FIREFOX () { return IS_FIREFOX; },\n        get IS_EDGE () { return IS_EDGE; },\n        get IS_CHROMIUM () { return IS_CHROMIUM; },\n        get IS_CHROME () { return IS_CHROME; },\n        get CHROMIUM_VERSION () { return CHROMIUM_VERSION; },\n        get CHROME_VERSION () { return CHROME_VERSION; },\n        get IE_VERSION () { return IE_VERSION; },\n        get IS_SAFARI () { return IS_SAFARI; },\n        get IS_WINDOWS () { return IS_WINDOWS; },\n        get IS_IPAD () { return IS_IPAD; },\n        get IS_IPHONE () { return IS_IPHONE; },\n        TOUCH_ENABLED: TOUCH_ENABLED,\n        IS_IOS: IS_IOS,\n        IS_ANY_SAFARI: IS_ANY_SAFARI\n    });\n\n    /**\n     * @file dom.js\n     * @module dom\n     */\n\n    /**\n     * Detect if a value is a string with any non-whitespace characters.\n     *\n     * @private\n     * @param  {string} str\n     *         The string to check\n     *\n     * @return {boolean}\n     *         Will be `true` if the string is non-blank, `false` otherwise.\n     *\n     */\n    function isNonBlankString(str) {\n        // we use str.trim as it will trim any whitespace characters\n        // from the front or back of non-whitespace characters. aka\n        // Any string that contains non-whitespace characters will\n        // still contain them after `trim` but whitespace only strings\n        // will have a length of 0, failing this check.\n        return typeof str === 'string' && Boolean(str.trim());\n    }\n\n    /**\n     * Throws an error if the passed string has whitespace. This is used by\n     * class methods to be relatively consistent with the classList API.\n     *\n     * @private\n     * @param  {string} str\n     *         The string to check for whitespace.\n     *\n     * @throws {Error}\n     *         Throws an error if there is whitespace in the string.\n     */\n    function throwIfWhitespace(str) {\n        // str.indexOf instead of regex because str.indexOf is faster performance wise.\n        if (str.indexOf(' ') >= 0) {\n            throw new Error('class has illegal whitespace characters');\n        }\n    }\n\n    /**\n     * Whether the current DOM interface appears to be real (i.e. not simulated).\n     *\n     * @return {boolean}\n     *         Will be `true` if the DOM appears to be real, `false` otherwise.\n     */\n    function isReal() {\n        // Both document and window will never be undefined thanks to `global`.\n        return document === window.document;\n    }\n\n    /**\n     * Determines, via duck typing, whether or not a value is a DOM element.\n     *\n     * @param  {*} value\n     *         The value to check.\n     *\n     * @return {boolean}\n     *         Will be `true` if the value is a DOM element, `false` otherwise.\n     */\n    function isEl(value) {\n        return isObject$1(value) && value.nodeType === 1;\n    }\n\n    /**\n     * Determines if the current DOM is embedded in an iframe.\n     *\n     * @return {boolean}\n     *         Will be `true` if the DOM is embedded in an iframe, `false`\n     *         otherwise.\n     */\n    function isInFrame() {\n        // We need a try/catch here because Safari will throw errors when attempting\n        // to get either `parent` or `self`\n        try {\n            return window.parent !== window.self;\n        } catch (x) {\n            return true;\n        }\n    }\n\n    /**\n     * Creates functions to query the DOM using a given method.\n     *\n     * @private\n     * @param   {string} method\n     *          The method to create the query with.\n     *\n     * @return  {Function}\n     *          The query method\n     */\n    function createQuerier(method) {\n        return function (selector, context) {\n            if (!isNonBlankString(selector)) {\n                return document[method](null);\n            }\n            if (isNonBlankString(context)) {\n                context = document.querySelector(context);\n            }\n            const ctx = isEl(context) ? context : document;\n            return ctx[method] && ctx[method](selector);\n        };\n    }\n\n    /**\n     * Creates an element and applies properties, attributes, and inserts content.\n     *\n     * @param  {string} [tagName='div']\n     *         Name of tag to be created.\n     *\n     * @param  {Object} [properties={}]\n     *         Element properties to be applied.\n     *\n     * @param  {Object} [attributes={}]\n     *         Element attributes to be applied.\n     *\n     * @param {ContentDescriptor} [content]\n     *        A content descriptor object.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    function createEl(tagName = 'div', properties = {}, attributes = {}, content) {\n        const el = document.createElement(tagName);\n        Object.getOwnPropertyNames(properties).forEach(function (propName) {\n            const val = properties[propName];\n\n            // Handle textContent since it's not supported everywhere and we have a\n            // method for it.\n            if (propName === 'textContent') {\n                textContent(el, val);\n            } else if (el[propName] !== val || propName === 'tabIndex') {\n                el[propName] = val;\n            }\n        });\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            el.setAttribute(attrName, attributes[attrName]);\n        });\n        if (content) {\n            appendContent(el, content);\n        }\n        return el;\n    }\n\n    /**\n     * Injects text into an element, replacing any existing contents entirely.\n     *\n     * @param  {HTMLElement} el\n     *         The element to add text content into\n     *\n     * @param  {string} text\n     *         The text content to add.\n     *\n     * @return {Element}\n     *         The element with added text content.\n     */\n    function textContent(el, text) {\n        if (typeof el.textContent === 'undefined') {\n            el.innerText = text;\n        } else {\n            el.textContent = text;\n        }\n        return el;\n    }\n\n    /**\n     * Insert an element as the first child node of another\n     *\n     * @param {Element} child\n     *        Element to insert\n     *\n     * @param {Element} parent\n     *        Element to insert child into\n     */\n    function prependTo(child, parent) {\n        if (parent.firstChild) {\n            parent.insertBefore(child, parent.firstChild);\n        } else {\n            parent.appendChild(child);\n        }\n    }\n\n    /**\n     * Check if an element has a class name.\n     *\n     * @param  {Element} element\n     *         Element to check\n     *\n     * @param  {string} classToCheck\n     *         Class name to check for\n     *\n     * @return {boolean}\n     *         Will be `true` if the element has a class, `false` otherwise.\n     *\n     * @throws {Error}\n     *         Throws an error if `classToCheck` has white space.\n     */\n    function hasClass(element, classToCheck) {\n        throwIfWhitespace(classToCheck);\n        return element.classList.contains(classToCheck);\n    }\n\n    /**\n     * Add a class name to an element.\n     *\n     * @param  {Element} element\n     *         Element to add class name to.\n     *\n     * @param  {...string} classesToAdd\n     *         One or more class name to add.\n     *\n     * @return {Element}\n     *         The DOM element with the added class name.\n     */\n    function addClass(element, ...classesToAdd) {\n        element.classList.add(...classesToAdd.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n        return element;\n    }\n\n    /**\n     * Remove a class name from an element.\n     *\n     * @param  {Element} element\n     *         Element to remove a class name from.\n     *\n     * @param  {...string} classesToRemove\n     *         One or more class name to remove.\n     *\n     * @return {Element}\n     *         The DOM element with class name removed.\n     */\n    function removeClass(element, ...classesToRemove) {\n        // Protect in case the player gets disposed\n        if (!element) {\n            log$1.warn(\"removeClass was called with an element that doesn't exist\");\n            return null;\n        }\n        element.classList.remove(...classesToRemove.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n        return element;\n    }\n\n    /**\n     * The callback definition for toggleClass.\n     *\n     * @callback module:dom~PredicateCallback\n     * @param    {Element} element\n     *           The DOM element of the Component.\n     *\n     * @param    {string} classToToggle\n     *           The `className` that wants to be toggled\n     *\n     * @return   {boolean|undefined}\n     *           If `true` is returned, the `classToToggle` will be added to the\n     *           `element`. If `false`, the `classToToggle` will be removed from\n     *           the `element`. If `undefined`, the callback will be ignored.\n     */\n\n    /**\n     * Adds or removes a class name to/from an element depending on an optional\n     * condition or the presence/absence of the class name.\n     *\n     * @param  {Element} element\n     *         The element to toggle a class name on.\n     *\n     * @param  {string} classToToggle\n     *         The class that should be toggled.\n     *\n     * @param  {boolean|module:dom~PredicateCallback} [predicate]\n     *         See the return value for {@link module:dom~PredicateCallback}\n     *\n     * @return {Element}\n     *         The element with a class that has been toggled.\n     */\n    function toggleClass(element, classToToggle, predicate) {\n        if (typeof predicate === 'function') {\n            predicate = predicate(element, classToToggle);\n        }\n        if (typeof predicate !== 'boolean') {\n            predicate = undefined;\n        }\n        classToToggle.split(/\\s+/).forEach(className => element.classList.toggle(className, predicate));\n        return element;\n    }\n\n    /**\n     * Apply attributes to an HTML element.\n     *\n     * @param {Element} el\n     *        Element to add attributes to.\n     *\n     * @param {Object} [attributes]\n     *        Attributes to be applied.\n     */\n    function setAttributes(el, attributes) {\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            const attrValue = attributes[attrName];\n            if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n                el.removeAttribute(attrName);\n            } else {\n                el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n            }\n        });\n    }\n\n    /**\n     * Get an element's attribute values, as defined on the HTML tag.\n     *\n     * Attributes are not the same as properties. They're defined on the tag\n     * or with setAttribute.\n     *\n     * @param  {Element} tag\n     *         Element from which to get tag attributes.\n     *\n     * @return {Object}\n     *         All attributes of the element. Boolean attributes will be `true` or\n     *         `false`, others will be strings.\n     */\n    function getAttributes(tag) {\n        const obj = {};\n\n        // known boolean attributes\n        // we can check for matching boolean properties, but not all browsers\n        // and not all tags know about these attributes, so, we still want to check them manually\n        const knownBooleans = ['autoplay', 'controls', 'playsinline', 'loop', 'muted', 'default', 'defaultMuted'];\n        if (tag && tag.attributes && tag.attributes.length > 0) {\n            const attrs = tag.attributes;\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                const attrName = attrs[i].name;\n                /** @type {boolean|string} */\n                let attrVal = attrs[i].value;\n\n                // check for known booleans\n                // the matching element property will return a value for typeof\n                if (knownBooleans.includes(attrName)) {\n                    // the value of an included boolean attribute is typically an empty\n                    // string ('') which would equal false if we just check for a false value.\n                    // we also don't want support bad code like autoplay='false'\n                    attrVal = attrVal !== null ? true : false;\n                }\n                obj[attrName] = attrVal;\n            }\n        }\n        return obj;\n    }\n\n    /**\n     * Get the value of an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to get the value of.\n     *\n     * @return {string}\n     *         The value of the attribute.\n     */\n    function getAttribute(el, attribute) {\n        return el.getAttribute(attribute);\n    }\n\n    /**\n     * Set the value of an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to set.\n     *\n     * @param {string} value\n     *        Value to set the attribute to.\n     */\n    function setAttribute(el, attribute, value) {\n        el.setAttribute(attribute, value);\n    }\n\n    /**\n     * Remove an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to remove.\n     */\n    function removeAttribute(el, attribute) {\n        el.removeAttribute(attribute);\n    }\n\n    /**\n     * Attempt to block the ability to select text.\n     */\n    function blockTextSelection() {\n        document.body.focus();\n        document.onselectstart = function () {\n            return false;\n        };\n    }\n\n    /**\n     * Turn off text selection blocking.\n     */\n    function unblockTextSelection() {\n        document.onselectstart = function () {\n            return true;\n        };\n    }\n\n    /**\n     * Identical to the native `getBoundingClientRect` function, but ensures that\n     * the method is supported at all (it is in all browsers we claim to support)\n     * and that the element is in the DOM before continuing.\n     *\n     * This wrapper function also shims properties which are not provided by some\n     * older browsers (namely, IE8).\n     *\n     * Additionally, some browsers do not support adding properties to a\n     * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n     * properties (except `x` and `y` which are not widely supported). This helps\n     * avoid implementations where keys are non-enumerable.\n     *\n     * @param  {Element} el\n     *         Element whose `ClientRect` we want to calculate.\n     *\n     * @return {Object|undefined}\n     *         Always returns a plain object - or `undefined` if it cannot.\n     */\n    function getBoundingClientRect(el) {\n        if (el && el.getBoundingClientRect && el.parentNode) {\n            const rect = el.getBoundingClientRect();\n            const result = {};\n            ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(k => {\n                if (rect[k] !== undefined) {\n                    result[k] = rect[k];\n                }\n            });\n            if (!result.height) {\n                result.height = parseFloat(computedStyle(el, 'height'));\n            }\n            if (!result.width) {\n                result.width = parseFloat(computedStyle(el, 'width'));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Represents the position of a DOM element on the page.\n     *\n     * @typedef  {Object} module:dom~Position\n     *\n     * @property {number} left\n     *           Pixels to the left.\n     *\n     * @property {number} top\n     *           Pixels from the top.\n     */\n\n    /**\n     * Get the position of an element in the DOM.\n     *\n     * Uses `getBoundingClientRect` technique from John Resig.\n     *\n     * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n     *\n     * @param  {Element} el\n     *         Element from which to get offset.\n     *\n     * @return {module:dom~Position}\n     *         The position of the element that was passed in.\n     */\n    function findPosition(el) {\n        if (!el || el && !el.offsetParent) {\n            return {\n                left: 0,\n                top: 0,\n                width: 0,\n                height: 0\n            };\n        }\n        const width = el.offsetWidth;\n        const height = el.offsetHeight;\n        let left = 0;\n        let top = 0;\n        while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {\n            left += el.offsetLeft;\n            top += el.offsetTop;\n            el = el.offsetParent;\n        }\n        return {\n            left,\n            top,\n            width,\n            height\n        };\n    }\n\n    /**\n     * Represents x and y coordinates for a DOM element or mouse pointer.\n     *\n     * @typedef  {Object} module:dom~Coordinates\n     *\n     * @property {number} x\n     *           x coordinate in pixels\n     *\n     * @property {number} y\n     *           y coordinate in pixels\n     */\n\n    /**\n     * Get the pointer position within an element.\n     *\n     * The base on the coordinates are the bottom left of the element.\n     *\n     * @param  {Element} el\n     *         Element on which to get the pointer position on.\n     *\n     * @param  {Event} event\n     *         Event object.\n     *\n     * @return {module:dom~Coordinates}\n     *         A coordinates object corresponding to the mouse position.\n     *\n     */\n    function getPointerPosition(el, event) {\n        const translated = {\n            x: 0,\n            y: 0\n        };\n        if (IS_IOS) {\n            let item = el;\n            while (item && item.nodeName.toLowerCase() !== 'html') {\n                const transform = computedStyle(item, 'transform');\n                if (/^matrix/.test(transform)) {\n                    const values = transform.slice(7, -1).split(/,\\s/).map(Number);\n                    translated.x += values[4];\n                    translated.y += values[5];\n                } else if (/^matrix3d/.test(transform)) {\n                    const values = transform.slice(9, -1).split(/,\\s/).map(Number);\n                    translated.x += values[12];\n                    translated.y += values[13];\n                }\n                item = item.parentNode;\n            }\n        }\n        const position = {};\n        const boxTarget = findPosition(event.target);\n        const box = findPosition(el);\n        const boxW = box.width;\n        const boxH = box.height;\n        let offsetY = event.offsetY - (box.top - boxTarget.top);\n        let offsetX = event.offsetX - (box.left - boxTarget.left);\n        if (event.changedTouches) {\n            offsetX = event.changedTouches[0].pageX - box.left;\n            offsetY = event.changedTouches[0].pageY + box.top;\n            if (IS_IOS) {\n                offsetX -= translated.x;\n                offsetY -= translated.y;\n            }\n        }\n        position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\n        position.x = Math.max(0, Math.min(1, offsetX / boxW));\n        return position;\n    }\n\n    /**\n     * Determines, via duck typing, whether or not a value is a text node.\n     *\n     * @param  {*} value\n     *         Check if this value is a text node.\n     *\n     * @return {boolean}\n     *         Will be `true` if the value is a text node, `false` otherwise.\n     */\n    function isTextNode$1(value) {\n        return isObject$1(value) && value.nodeType === 3;\n    }\n\n    /**\n     * Empties the contents of an element.\n     *\n     * @param  {Element} el\n     *         The element to empty children from\n     *\n     * @return {Element}\n     *         The element with no children\n     */\n    function emptyEl(el) {\n        while (el.firstChild) {\n            el.removeChild(el.firstChild);\n        }\n        return el;\n    }\n\n    /**\n     * This is a mixed value that describes content to be injected into the DOM\n     * via some method. It can be of the following types:\n     *\n     * Type       | Description\n     * -----------|-------------\n     * `string`   | The value will be normalized into a text node.\n     * `Element`  | The value will be accepted as-is.\n     * `Text`     | A TextNode. The value will be accepted as-is.\n     * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).\n     * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.\n     *\n     * @typedef {string|Element|Text|Array|Function} ContentDescriptor\n     */\n\n    /**\n     * Normalizes content for eventual insertion into the DOM.\n     *\n     * This allows a wide range of content definition methods, but helps protect\n     * from falling into the trap of simply writing to `innerHTML`, which could\n     * be an XSS concern.\n     *\n     * The content for an element can be passed in multiple types and\n     * combinations, whose behavior is as follows:\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Array}\n     *         All of the content that was passed in, normalized to an array of\n     *         elements or text nodes.\n     */\n    function normalizeContent(content) {\n        // First, invoke content if it is a function. If it produces an array,\n        // that needs to happen before normalization.\n        if (typeof content === 'function') {\n            content = content();\n        }\n\n        // Next up, normalize to an array, so one or many items can be normalized,\n        // filtered, and returned.\n        return (Array.isArray(content) ? content : [content]).map(value => {\n            // First, invoke value if it is a function to produce a new value,\n            // which will be subsequently normalized to a Node of some kind.\n            if (typeof value === 'function') {\n                value = value();\n            }\n            if (isEl(value) || isTextNode$1(value)) {\n                return value;\n            }\n            if (typeof value === 'string' && /\\S/.test(value)) {\n                return document.createTextNode(value);\n            }\n        }).filter(value => value);\n    }\n\n    /**\n     * Normalizes and appends content to an element.\n     *\n     * @param  {Element} el\n     *         Element to append normalized content to.\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Element}\n     *         The element with appended normalized content.\n     */\n    function appendContent(el, content) {\n        normalizeContent(content).forEach(node => el.appendChild(node));\n        return el;\n    }\n\n    /**\n     * Normalizes and inserts content into an element; this is identical to\n     * `appendContent()`, except it empties the element first.\n     *\n     * @param {Element} el\n     *        Element to insert normalized content into.\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Element}\n     *         The element with inserted normalized content.\n     */\n    function insertContent(el, content) {\n        return appendContent(emptyEl(el), content);\n    }\n\n    /**\n     * Check if an event was a single left click.\n     *\n     * @param  {MouseEvent} event\n     *         Event object.\n     *\n     * @return {boolean}\n     *         Will be `true` if a single left click, `false` otherwise.\n     */\n    function isSingleLeftClick(event) {\n        // Note: if you create something draggable, be sure to\n        // call it on both `mousedown` and `mousemove` event,\n        // otherwise `mousedown` should be enough for a button\n\n        if (event.button === undefined && event.buttons === undefined) {\n            // Why do we need `buttons` ?\n            // Because, middle mouse sometimes have this:\n            // e.button === 0 and e.buttons === 4\n            // Furthermore, we want to prevent combination click, something like\n            // HOLD middlemouse then left click, that would be\n            // e.button === 0, e.buttons === 5\n            // just `button` is not gonna work\n\n            // Alright, then what this block does ?\n            // this is for chrome `simulate mobile devices`\n            // I want to support this as well\n\n            return true;\n        }\n        if (event.button === 0 && event.buttons === undefined) {\n            // Touch screen, sometimes on some specific device, `buttons`\n            // doesn't have anything (safari on ios, blackberry...)\n\n            return true;\n        }\n\n        // `mouseup` event on a single left click has\n        // `button` and `buttons` equal to 0\n        if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\n            return true;\n        }\n        if (event.button !== 0 || event.buttons !== 1) {\n            // This is the reason we have those if else block above\n            // if any special case we can catch and let it slide\n            // we do it above, when get to here, this definitely\n            // is-not-left-click\n\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Finds a single DOM element matching `selector` within the optional\n     * `context` of another DOM element (defaulting to `document`).\n     *\n     * @param  {string} selector\n     *         A valid CSS selector, which will be passed to `querySelector`.\n     *\n     * @param  {Element|String} [context=document]\n     *         A DOM element within which to query. Can also be a selector\n     *         string in which case the first matching element will be used\n     *         as context. If missing (or no element matches selector), falls\n     *         back to `document`.\n     *\n     * @return {Element|null}\n     *         The element that was found or null.\n     */\n    const $ = createQuerier('querySelector');\n\n    /**\n     * Finds a all DOM elements matching `selector` within the optional\n     * `context` of another DOM element (defaulting to `document`).\n     *\n     * @param  {string} selector\n     *         A valid CSS selector, which will be passed to `querySelectorAll`.\n     *\n     * @param  {Element|String} [context=document]\n     *         A DOM element within which to query. Can also be a selector\n     *         string in which case the first matching element will be used\n     *         as context. If missing (or no element matches selector), falls\n     *         back to `document`.\n     *\n     * @return {NodeList}\n     *         A element list of elements that were found. Will be empty if none\n     *         were found.\n     *\n     */\n    const $$ = createQuerier('querySelectorAll');\n\n    /**\n     * A safe getComputedStyle.\n     *\n     * This is needed because in Firefox, if the player is loaded in an iframe with\n     * `display:none`, then `getComputedStyle` returns `null`, so, we do a\n     * null-check to make sure that the player doesn't break in these cases.\n     *\n     * @param    {Element} el\n     *           The element you want the computed style of\n     *\n     * @param    {string} prop\n     *           The property name you want\n     *\n     * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n     */\n    function computedStyle(el, prop) {\n        if (!el || !prop) {\n            return '';\n        }\n        if (typeof window.getComputedStyle === 'function') {\n            let computedStyleValue;\n            try {\n                computedStyleValue = window.getComputedStyle(el);\n            } catch (e) {\n                return '';\n            }\n            return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';\n        }\n        return '';\n    }\n\n    /**\n     * Copy document style sheets to another window.\n     *\n     * @param    {Window} win\n     *           The window element you want to copy the document style sheets to.\n     *\n     */\n    function copyStyleSheetsToWindow(win) {\n        [...document.styleSheets].forEach(styleSheet => {\n            try {\n                const cssRules = [...styleSheet.cssRules].map(rule => rule.cssText).join('');\n                const style = document.createElement('style');\n                style.textContent = cssRules;\n                win.document.head.appendChild(style);\n            } catch (e) {\n                const link = document.createElement('link');\n                link.rel = 'stylesheet';\n                link.type = styleSheet.type;\n                // For older Safari this has to be the string; on other browsers setting the MediaList works\n                link.media = styleSheet.media.mediaText;\n                link.href = styleSheet.href;\n                win.document.head.appendChild(link);\n            }\n        });\n    }\n\n    var Dom = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        isReal: isReal,\n        isEl: isEl,\n        isInFrame: isInFrame,\n        createEl: createEl,\n        textContent: textContent,\n        prependTo: prependTo,\n        hasClass: hasClass,\n        addClass: addClass,\n        removeClass: removeClass,\n        toggleClass: toggleClass,\n        setAttributes: setAttributes,\n        getAttributes: getAttributes,\n        getAttribute: getAttribute,\n        setAttribute: setAttribute,\n        removeAttribute: removeAttribute,\n        blockTextSelection: blockTextSelection,\n        unblockTextSelection: unblockTextSelection,\n        getBoundingClientRect: getBoundingClientRect,\n        findPosition: findPosition,\n        getPointerPosition: getPointerPosition,\n        isTextNode: isTextNode$1,\n        emptyEl: emptyEl,\n        normalizeContent: normalizeContent,\n        appendContent: appendContent,\n        insertContent: insertContent,\n        isSingleLeftClick: isSingleLeftClick,\n        $: $,\n        $$: $$,\n        computedStyle: computedStyle,\n        copyStyleSheetsToWindow: copyStyleSheetsToWindow\n    });\n\n    /**\n     * @file setup.js - Functions for setting up a player without\n     * user interaction based on the data-setup `attribute` of the video tag.\n     *\n     * @module setup\n     */\n    let _windowLoaded = false;\n    let videojs$1;\n\n    /**\n     * Set up any tags that have a data-setup `attribute` when the player is started.\n     */\n    const autoSetup = function () {\n        if (videojs$1.options.autoSetup === false) {\n            return;\n        }\n        const vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n        const audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n        const divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));\n        const mediaEls = vids.concat(audios, divs);\n\n        // Check if any media elements exist\n        if (mediaEls && mediaEls.length > 0) {\n            for (let i = 0, e = mediaEls.length; i < e; i++) {\n                const mediaEl = mediaEls[i];\n\n                // Check if element exists, has getAttribute func.\n                if (mediaEl && mediaEl.getAttribute) {\n                    // Make sure this player hasn't already been set up.\n                    if (mediaEl.player === undefined) {\n                        const options = mediaEl.getAttribute('data-setup');\n\n                        // Check if data-setup attr exists.\n                        // We only auto-setup if they've added the data-setup attr.\n                        if (options !== null) {\n                            // Create new video.js instance.\n                            videojs$1(mediaEl);\n                        }\n                    }\n\n                    // If getAttribute isn't defined, we need to wait for the DOM.\n                } else {\n                    autoSetupTimeout(1);\n                    break;\n                }\n            }\n\n            // No videos were found, so keep looping unless page is finished loading.\n        } else if (!_windowLoaded) {\n            autoSetupTimeout(1);\n        }\n    };\n\n    /**\n     * Wait until the page is loaded before running autoSetup. This will be called in\n     * autoSetup if `hasLoaded` returns false.\n     *\n     * @param {number} wait\n     *        How long to wait in ms\n     *\n     * @param {module:videojs} [vjs]\n     *        The videojs library function\n     */\n    function autoSetupTimeout(wait, vjs) {\n        // Protect against breakage in non-browser environments\n        if (!isReal()) {\n            return;\n        }\n        if (vjs) {\n            videojs$1 = vjs;\n        }\n        window.setTimeout(autoSetup, wait);\n    }\n\n    /**\n     * Used to set the internal tracking of window loaded state to true.\n     *\n     * @private\n     */\n    function setWindowLoaded() {\n        _windowLoaded = true;\n        window.removeEventListener('load', setWindowLoaded);\n    }\n    if (isReal()) {\n        if (document.readyState === 'complete') {\n            setWindowLoaded();\n        } else {\n            /**\n             * Listen for the load event on window, and set _windowLoaded to true.\n             *\n             * We use a standard event listener here to avoid incrementing the GUID\n             * before any players are created.\n             *\n             * @listens load\n             */\n            window.addEventListener('load', setWindowLoaded);\n        }\n    }\n\n    /**\n     * @file stylesheet.js\n     * @module stylesheet\n     */\n\n    /**\n     * Create a DOM style element given a className for it.\n     *\n     * @param {string} className\n     *        The className to add to the created style element.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    const createStyleElement = function (className) {\n        const style = document.createElement('style');\n        style.className = className;\n        return style;\n    };\n\n    /**\n     * Add text to a DOM element.\n     *\n     * @param {Element} el\n     *        The Element to add text content to.\n     *\n     * @param {string} content\n     *        The text to add to the element.\n     */\n    const setTextContent = function (el, content) {\n        if (el.styleSheet) {\n            el.styleSheet.cssText = content;\n        } else {\n            el.textContent = content;\n        }\n    };\n\n    /**\n     * @file dom-data.js\n     * @module dom-data\n     */\n\n    /**\n     * Element Data Store.\n     *\n     * Allows for binding data to an element without putting it directly on the\n     * element. Ex. Event listeners are stored here.\n     * (also from jsninja.com, slightly modified and updated for closure compiler)\n     *\n     * @type {Object}\n     * @private\n     */\n    var DomData = new WeakMap();\n\n    /**\n     * @file guid.js\n     * @module guid\n     */\n\n        // Default value for GUIDs. This allows us to reset the GUID counter in tests.\n        //\n        // The initial GUID is 3 because some users have come to rely on the first\n        // default player ID ending up as `vjs_video_3`.\n        //\n        // See: https://github.com/videojs/video.js/pull/6216\n    const _initialGuid = 3;\n\n    /**\n     * Unique ID for an element or function\n     *\n     * @type {Number}\n     */\n    let _guid = _initialGuid;\n\n    /**\n     * Get a unique auto-incrementing ID by number that has not been returned before.\n     *\n     * @return {number}\n     *         A new unique ID.\n     */\n    function newGUID() {\n        return _guid++;\n    }\n\n    /**\n     * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n     * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n     * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n     * robust as jquery's, so there's probably some differences.\n     *\n     * @file events.js\n     * @module events\n     */\n\n    /**\n     * Clean up the listener cache and dispatchers\n     *\n     * @param {Element|Object} elem\n     *        Element to clean up\n     *\n     * @param {string} type\n     *        Type of event to clean up\n     */\n    function _cleanUpEvents(elem, type) {\n        if (!DomData.has(elem)) {\n            return;\n        }\n        const data = DomData.get(elem);\n\n        // Remove the events of a particular type if there are none left\n        if (data.handlers[type].length === 0) {\n            delete data.handlers[type];\n            // data.handlers[type] = null;\n            // Setting to null was causing an error with data.handlers\n\n            // Remove the meta-handler from the element\n            if (elem.removeEventListener) {\n                elem.removeEventListener(type, data.dispatcher, false);\n            } else if (elem.detachEvent) {\n                elem.detachEvent('on' + type, data.dispatcher);\n            }\n        }\n\n        // Remove the events object if there are no types left\n        if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n            delete data.handlers;\n            delete data.dispatcher;\n            delete data.disabled;\n        }\n\n        // Finally remove the element data if there is no data left\n        if (Object.getOwnPropertyNames(data).length === 0) {\n            DomData.delete(elem);\n        }\n    }\n\n    /**\n     * Loops through an array of event types and calls the requested method for each type.\n     *\n     * @param {Function} fn\n     *        The event method we want to use.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind listeners to\n     *\n     * @param {string[]} types\n     *        Type of event to bind to.\n     *\n     * @param {Function} callback\n     *        Event listener.\n     */\n    function _handleMultipleEvents(fn, elem, types, callback) {\n        types.forEach(function (type) {\n            // Call the event method for each one of the types\n            fn(elem, type, callback);\n        });\n    }\n\n    /**\n     * Fix a native event to have standard property values\n     *\n     * @param {Object} event\n     *        Event object to fix.\n     *\n     * @return {Object}\n     *         Fixed event object.\n     */\n    function fixEvent(event) {\n        if (event.fixed_) {\n            return event;\n        }\n        function returnTrue() {\n            return true;\n        }\n        function returnFalse() {\n            return false;\n        }\n\n        // Test if fixing up is needed\n        // Used to check if !event.stopPropagation instead of isPropagationStopped\n        // But native events return true for stopPropagation, but don't have\n        // other expected methods like isPropagationStopped. Seems to be a problem\n        // with the Javascript Ninja code. So we're just overriding all events now.\n        if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {\n            const old = event || window.event;\n            event = {};\n            // Clone the old object so that we can modify the values event = {};\n            // IE8 Doesn't like when you mess with native event properties\n            // Firefox returns false for event.hasOwnProperty('type') and other props\n            //  which makes copying more difficult.\n            // TODO: Probably best to create a whitelist of event props\n            for (const key in old) {\n                // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n                // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n                // and webkitMovementX/Y\n                // Lighthouse complains if Event.path is copied\n                if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY' && key !== 'path') {\n                    // Chrome 32+ warns if you try to copy deprecated returnValue, but\n                    // we still want to if preventDefault isn't supported (IE8).\n                    if (!(key === 'returnValue' && old.preventDefault)) {\n                        event[key] = old[key];\n                    }\n                }\n            }\n\n            // The event occurred on this element\n            if (!event.target) {\n                event.target = event.srcElement || document;\n            }\n\n            // Handle which other element the event is related to\n            if (!event.relatedTarget) {\n                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n            }\n\n            // Stop the default browser action\n            event.preventDefault = function () {\n                if (old.preventDefault) {\n                    old.preventDefault();\n                }\n                event.returnValue = false;\n                old.returnValue = false;\n                event.defaultPrevented = true;\n            };\n            event.defaultPrevented = false;\n\n            // Stop the event from bubbling\n            event.stopPropagation = function () {\n                if (old.stopPropagation) {\n                    old.stopPropagation();\n                }\n                event.cancelBubble = true;\n                old.cancelBubble = true;\n                event.isPropagationStopped = returnTrue;\n            };\n            event.isPropagationStopped = returnFalse;\n\n            // Stop the event from bubbling and executing other handlers\n            event.stopImmediatePropagation = function () {\n                if (old.stopImmediatePropagation) {\n                    old.stopImmediatePropagation();\n                }\n                event.isImmediatePropagationStopped = returnTrue;\n                event.stopPropagation();\n            };\n            event.isImmediatePropagationStopped = returnFalse;\n\n            // Handle mouse position\n            if (event.clientX !== null && event.clientX !== undefined) {\n                const doc = document.documentElement;\n                const body = document.body;\n                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n            }\n\n            // Handle key presses\n            event.which = event.charCode || event.keyCode;\n\n            // Fix button for mouse clicks:\n            // 0 == left; 1 == middle; 2 == right\n            if (event.button !== null && event.button !== undefined) {\n                // The following is disabled because it does not pass videojs-standard\n                // and... yikes.\n                /* eslint-disable */\n                event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n                /* eslint-enable */\n            }\n        }\n\n        event.fixed_ = true;\n        // Returns fixed-up instance\n        return event;\n    }\n\n    /**\n     * Whether passive event listeners are supported\n     */\n    let _supportsPassive;\n    const supportsPassive = function () {\n        if (typeof _supportsPassive !== 'boolean') {\n            _supportsPassive = false;\n            try {\n                const opts = Object.defineProperty({}, 'passive', {\n                    get() {\n                        _supportsPassive = true;\n                    }\n                });\n                window.addEventListener('test', null, opts);\n                window.removeEventListener('test', null, opts);\n            } catch (e) {\n                // disregard\n            }\n        }\n        return _supportsPassive;\n    };\n\n    /**\n     * Touch events Chrome expects to be passive\n     */\n    const passiveEvents = ['touchstart', 'touchmove'];\n\n    /**\n     * Add an event listener to element\n     * It stores the handler function in a separate cache object\n     * and adds a generic handler to the element's event,\n     * along with a unique id (guid) to the element.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind listeners to\n     *\n     * @param {string|string[]} type\n     *        Type of event to bind to.\n     *\n     * @param {Function} fn\n     *        Event listener.\n     */\n    function on(elem, type, fn) {\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(on, elem, type, fn);\n        }\n        if (!DomData.has(elem)) {\n            DomData.set(elem, {});\n        }\n        const data = DomData.get(elem);\n\n        // We need a place to store all our handler data\n        if (!data.handlers) {\n            data.handlers = {};\n        }\n        if (!data.handlers[type]) {\n            data.handlers[type] = [];\n        }\n        if (!fn.guid) {\n            fn.guid = newGUID();\n        }\n        data.handlers[type].push(fn);\n        if (!data.dispatcher) {\n            data.disabled = false;\n            data.dispatcher = function (event, hash) {\n                if (data.disabled) {\n                    return;\n                }\n                event = fixEvent(event);\n                const handlers = data.handlers[event.type];\n                if (handlers) {\n                    // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n                    const handlersCopy = handlers.slice(0);\n                    for (let m = 0, n = handlersCopy.length; m < n; m++) {\n                        if (event.isImmediatePropagationStopped()) {\n                            break;\n                        } else {\n                            try {\n                                handlersCopy[m].call(elem, event, hash);\n                            } catch (e) {\n                                log$1.error(e);\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        if (data.handlers[type].length === 1) {\n            if (elem.addEventListener) {\n                let options = false;\n                if (supportsPassive() && passiveEvents.indexOf(type) > -1) {\n                    options = {\n                        passive: true\n                    };\n                }\n                elem.addEventListener(type, data.dispatcher, options);\n            } else if (elem.attachEvent) {\n                elem.attachEvent('on' + type, data.dispatcher);\n            }\n        }\n    }\n\n    /**\n     * Removes event listeners from an element\n     *\n     * @param {Element|Object} elem\n     *        Object to remove listeners from.\n     *\n     * @param {string|string[]} [type]\n     *        Type of listener to remove. Don't include to remove all events from element.\n     *\n     * @param {Function} [fn]\n     *        Specific listener to remove. Don't include to remove listeners for an event\n     *        type.\n     */\n    function off(elem, type, fn) {\n        // Don't want to add a cache object through getElData if not needed\n        if (!DomData.has(elem)) {\n            return;\n        }\n        const data = DomData.get(elem);\n\n        // If no events exist, nothing to unbind\n        if (!data.handlers) {\n            return;\n        }\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(off, elem, type, fn);\n        }\n\n        // Utility function\n        const removeType = function (el, t) {\n            data.handlers[t] = [];\n            _cleanUpEvents(el, t);\n        };\n\n        // Are we removing all bound events?\n        if (type === undefined) {\n            for (const t in data.handlers) {\n                if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n                    removeType(elem, t);\n                }\n            }\n            return;\n        }\n        const handlers = data.handlers[type];\n\n        // If no handlers exist, nothing to unbind\n        if (!handlers) {\n            return;\n        }\n\n        // If no listener was provided, remove all listeners for type\n        if (!fn) {\n            removeType(elem, type);\n            return;\n        }\n\n        // We're only removing a single handler\n        if (fn.guid) {\n            for (let n = 0; n < handlers.length; n++) {\n                if (handlers[n].guid === fn.guid) {\n                    handlers.splice(n--, 1);\n                }\n            }\n        }\n        _cleanUpEvents(elem, type);\n    }\n\n    /**\n     * Trigger an event for an element\n     *\n     * @param {Element|Object} elem\n     *        Element to trigger an event on\n     *\n     * @param {EventTarget~Event|string} event\n     *        A string (the type) or an event object with a type attribute\n     *\n     * @param {Object} [hash]\n     *        data hash to pass along with the event\n     *\n     * @return {boolean|undefined}\n     *         Returns the opposite of `defaultPrevented` if default was\n     *         prevented. Otherwise, returns `undefined`\n     */\n    function trigger(elem, event, hash) {\n        // Fetches element data and a reference to the parent (for bubbling).\n        // Don't want to add a data object to cache for every parent,\n        // so checking hasElData first.\n        const elemData = DomData.has(elem) ? DomData.get(elem) : {};\n        const parent = elem.parentNode || elem.ownerDocument;\n        // type = event.type || event,\n        // handler;\n\n        // If an event name was passed as a string, creates an event out of it\n        if (typeof event === 'string') {\n            event = {\n                type: event,\n                target: elem\n            };\n        } else if (!event.target) {\n            event.target = elem;\n        }\n\n        // Normalizes the event properties.\n        event = fixEvent(event);\n\n        // If the passed element has a dispatcher, executes the established handlers.\n        if (elemData.dispatcher) {\n            elemData.dispatcher.call(elem, event, hash);\n        }\n\n        // Unless explicitly stopped or the event does not bubble (e.g. media events)\n        // recursively calls this function to bubble the event up the DOM.\n        if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n            trigger.call(null, parent, event, hash);\n\n            // If at the top of the DOM, triggers the default action unless disabled.\n        } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {\n            if (!DomData.has(event.target)) {\n                DomData.set(event.target, {});\n            }\n            const targetData = DomData.get(event.target);\n\n            // Checks if the target has a default action for this event.\n            if (event.target[event.type]) {\n                // Temporarily disables event dispatching on the target as we have already executed the handler.\n                targetData.disabled = true;\n                // Executes the default action.\n                if (typeof event.target[event.type] === 'function') {\n                    event.target[event.type]();\n                }\n                // Re-enables event dispatching.\n                targetData.disabled = false;\n            }\n        }\n\n        // Inform the triggerer if the default was prevented by returning false\n        return !event.defaultPrevented;\n    }\n\n    /**\n     * Trigger a listener only once for an event.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind to.\n     *\n     * @param {string|string[]} type\n     *        Name/type of event\n     *\n     * @param {Event~EventListener} fn\n     *        Event listener function\n     */\n    function one(elem, type, fn) {\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(one, elem, type, fn);\n        }\n        const func = function () {\n            off(elem, type, func);\n            fn.apply(this, arguments);\n        };\n\n        // copy the guid to the new function so it can removed using the original function's ID\n        func.guid = fn.guid = fn.guid || newGUID();\n        on(elem, type, func);\n    }\n\n    /**\n     * Trigger a listener only once and then turn if off for all\n     * configured events\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind to.\n     *\n     * @param {string|string[]} type\n     *        Name/type of event\n     *\n     * @param {Event~EventListener} fn\n     *        Event listener function\n     */\n    function any(elem, type, fn) {\n        const func = function () {\n            off(elem, type, func);\n            fn.apply(this, arguments);\n        };\n\n        // copy the guid to the new function so it can removed using the original function's ID\n        func.guid = fn.guid = fn.guid || newGUID();\n\n        // multiple ons, but one off for everything\n        on(elem, type, func);\n    }\n\n    var Events = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        fixEvent: fixEvent,\n        on: on,\n        off: off,\n        trigger: trigger,\n        one: one,\n        any: any\n    });\n\n    /**\n     * @file fn.js\n     * @module fn\n     */\n    const UPDATE_REFRESH_INTERVAL = 30;\n\n    /**\n     * A private, internal-only function for changing the context of a function.\n     *\n     * It also stores a unique id on the function so it can be easily removed from\n     * events.\n     *\n     * @private\n     * @function\n     * @param    {*} context\n     *           The object to bind as scope.\n     *\n     * @param    {Function} fn\n     *           The function to be bound to a scope.\n     *\n     * @param    {number} [uid]\n     *           An optional unique ID for the function to be set\n     *\n     * @return   {Function}\n     *           The new function that will be bound into the context given\n     */\n    const bind_ = function (context, fn, uid) {\n        // Make sure the function has a unique ID\n        if (!fn.guid) {\n            fn.guid = newGUID();\n        }\n\n        // Create the new function that changes the context\n        const bound = fn.bind(context);\n\n        // Allow for the ability to individualize this function\n        // Needed in the case where multiple objects might share the same prototype\n        // IF both items add an event listener with the same function, then you try to remove just one\n        // it will remove both because they both have the same guid.\n        // when using this, you need to use the bind method when you remove the listener as well.\n        // currently used in text tracks\n        bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n        return bound;\n    };\n\n    /**\n     * Wraps the given function, `fn`, with a new function that only invokes `fn`\n     * at most once per every `wait` milliseconds.\n     *\n     * @function\n     * @param    {Function} fn\n     *           The function to be throttled.\n     *\n     * @param    {number}   wait\n     *           The number of milliseconds by which to throttle.\n     *\n     * @return   {Function}\n     */\n    const throttle = function (fn, wait) {\n        let last = window.performance.now();\n        const throttled = function (...args) {\n            const now = window.performance.now();\n            if (now - last >= wait) {\n                fn(...args);\n                last = now;\n            }\n        };\n        return throttled;\n    };\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked.\n     *\n     * Inspired by lodash and underscore implementations.\n     *\n     * @function\n     * @param    {Function} func\n     *           The function to wrap with debounce behavior.\n     *\n     * @param    {number} wait\n     *           The number of milliseconds to wait after the last invocation.\n     *\n     * @param    {boolean} [immediate]\n     *           Whether or not to invoke the function immediately upon creation.\n     *\n     * @param    {Object} [context=window]\n     *           The \"context\" in which the debounced function should debounce. For\n     *           example, if this function should be tied to a Video.js player,\n     *           the player can be passed here. Alternatively, defaults to the\n     *           global `window` object.\n     *\n     * @return   {Function}\n     *           A debounced function.\n     */\n    const debounce = function (func, wait, immediate, context = window) {\n        let timeout;\n        const cancel = () => {\n            context.clearTimeout(timeout);\n            timeout = null;\n        };\n\n        /* eslint-disable consistent-this */\n        const debounced = function () {\n            const self = this;\n            const args = arguments;\n            let later = function () {\n                timeout = null;\n                later = null;\n                if (!immediate) {\n                    func.apply(self, args);\n                }\n            };\n            if (!timeout && immediate) {\n                func.apply(self, args);\n            }\n            context.clearTimeout(timeout);\n            timeout = context.setTimeout(later, wait);\n        };\n        /* eslint-enable consistent-this */\n\n        debounced.cancel = cancel;\n        return debounced;\n    };\n\n    var Fn = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        UPDATE_REFRESH_INTERVAL: UPDATE_REFRESH_INTERVAL,\n        bind_: bind_,\n        throttle: throttle,\n        debounce: debounce\n    });\n\n    /**\n     * @file src/js/event-target.js\n     */\n    let EVENT_MAP;\n\n    /**\n     * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n     * adds shorthand functions that wrap around lengthy functions. For example:\n     * the `on` function is a wrapper around `addEventListener`.\n     *\n     * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n     * @class EventTarget\n     */\n    class EventTarget$2 {\n        /**\n         * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n         * function that will get called when an event with a certain name gets triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to call with `EventTarget`s\n         */\n        on(type, fn) {\n            // Remove the addEventListener alias before calling Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            on(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n         * This makes it so that the `event listener` will no longer get called when the\n         * named event happens.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to remove.\n         */\n        off(type, fn) {\n            off(this, type, fn);\n        }\n        /**\n         * This function will add an `event listener` that gets triggered only once. After the\n         * first trigger it will get removed. This is like adding an `event listener`\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        one(type, fn) {\n            // Remove the addEventListener aliasing Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            one(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * This function will add an `event listener` that gets triggered only once and is\n         * removed from all events. This is like adding an array of `event listener`s\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the\n         * first time it is triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        any(type, fn) {\n            // Remove the addEventListener aliasing Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            any(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * This function causes an event to happen. This will then cause any `event listeners`\n         * that are waiting for that event, to get called. If there are no `event listeners`\n         * for an event then nothing will happen.\n         *\n         * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n         * Trigger will also call the `on` + `uppercaseEventName` function.\n         *\n         * Example:\n         * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n         * `onClick` if it exists.\n         *\n         * @param {string|EventTarget~Event|Object} event\n         *        The name of the event, an `Event`, or an object with a key of type set to\n         *        an event name.\n         */\n        trigger(event) {\n            const type = event.type || event;\n\n            // deprecation\n            // In a future version we should default target to `this`\n            // similar to how we default the target to `elem` in\n            // `Events.trigger`. Right now the default `target` will be\n            // `document` due to the `Event.fixEvent` call.\n            if (typeof event === 'string') {\n                event = {\n                    type\n                };\n            }\n            event = fixEvent(event);\n            if (this.allowedEvents_[type] && this['on' + type]) {\n                this['on' + type](event);\n            }\n            trigger(this, event);\n        }\n        queueTrigger(event) {\n            // only set up EVENT_MAP if it'll be used\n            if (!EVENT_MAP) {\n                EVENT_MAP = new Map();\n            }\n            const type = event.type || event;\n            let map = EVENT_MAP.get(this);\n            if (!map) {\n                map = new Map();\n                EVENT_MAP.set(this, map);\n            }\n            const oldTimeout = map.get(type);\n            map.delete(type);\n            window.clearTimeout(oldTimeout);\n            const timeout = window.setTimeout(() => {\n                map.delete(type);\n                // if we cleared out all timeouts for the current target, delete its map\n                if (map.size === 0) {\n                    map = null;\n                    EVENT_MAP.delete(this);\n                }\n                this.trigger(event);\n            }, 0);\n            map.set(type, timeout);\n        }\n    }\n\n    /**\n     * A Custom DOM event.\n     *\n     * @typedef {CustomEvent} Event\n     * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n     */\n\n    /**\n     * All event listeners should follow the following format.\n     *\n     * @callback EventListener\n     * @this {EventTarget}\n     *\n     * @param {Event} event\n     *        the event that triggered this function\n     *\n     * @param {Object} [hash]\n     *        hash of data sent during the event\n     */\n\n    /**\n     * An object containing event names as keys and booleans as values.\n     *\n     * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n     *         will have extra functionality. See that function for more information.\n     *\n     * @property EventTarget.prototype.allowedEvents_\n     * @protected\n     */\n    EventTarget$2.prototype.allowedEvents_ = {};\n\n    /**\n     * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#on}\n     */\n    EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;\n\n    /**\n     * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#off}\n     */\n    EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;\n\n    /**\n     * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#trigger}\n     */\n    EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;\n\n    /**\n     * @file mixins/evented.js\n     * @module evented\n     */\n    const objName = obj => {\n        if (typeof obj.name === 'function') {\n            return obj.name();\n        }\n        if (typeof obj.name === 'string') {\n            return obj.name;\n        }\n        if (obj.name_) {\n            return obj.name_;\n        }\n        if (obj.constructor && obj.constructor.name) {\n            return obj.constructor.name;\n        }\n        return typeof obj;\n    };\n\n    /**\n     * Returns whether or not an object has had the evented mixin applied.\n     *\n     * @param  {Object} object\n     *         An object to test.\n     *\n     * @return {boolean}\n     *         Whether or not the object appears to be evented.\n     */\n    const isEvented = object => object instanceof EventTarget$2 || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(k => typeof object[k] === 'function');\n\n    /**\n     * Adds a callback to run after the evented mixin applied.\n     *\n     * @param  {Object} target\n     *         An object to Add\n     * @param  {Function} callback\n     *         The callback to run.\n     */\n    const addEventedCallback = (target, callback) => {\n        if (isEvented(target)) {\n            callback();\n        } else {\n            if (!target.eventedCallbacks) {\n                target.eventedCallbacks = [];\n            }\n            target.eventedCallbacks.push(callback);\n        }\n    };\n\n    /**\n     * Whether a value is a valid event type - non-empty string or array.\n     *\n     * @private\n     * @param  {string|Array} type\n     *         The type value to test.\n     *\n     * @return {boolean}\n     *         Whether or not the type is a valid event type.\n     */\n    const isValidEventType = type =>\n        // The regex here verifies that the `type` contains at least one non-\n        // whitespace character.\n        typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length;\n\n    /**\n     * Validates a value to determine if it is a valid event target. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the target does not appear to be a valid event target.\n     *\n     * @param  {Object} target\n     *         The object to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateTarget = (target, obj, fnName) => {\n        if (!target || !target.nodeName && !isEvented(target)) {\n            throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);\n        }\n    };\n\n    /**\n     * Validates a value to determine if it is a valid event target. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the type does not appear to be a valid event type.\n     *\n     * @param  {string|Array} type\n     *         The type to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateEventType = (type, obj, fnName) => {\n        if (!isValidEventType(type)) {\n            throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);\n        }\n    };\n\n    /**\n     * Validates a value to determine if it is a valid listener. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the listener is not a function.\n     *\n     * @param  {Function} listener\n     *         The listener to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateListener = (listener, obj, fnName) => {\n        if (typeof listener !== 'function') {\n            throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);\n        }\n    };\n\n    /**\n     * Takes an array of arguments given to `on()` or `one()`, validates them, and\n     * normalizes them into an object.\n     *\n     * @private\n     * @param  {Object} self\n     *         The evented object on which `on()` or `one()` was called. This\n     *         object will be bound as the `this` value for the listener.\n     *\n     * @param  {Array} args\n     *         An array of arguments passed to `on()` or `one()`.\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     *\n     * @return {Object}\n     *         An object containing useful values for `on()` or `one()` calls.\n     */\n    const normalizeListenArgs = (self, args, fnName) => {\n        // If the number of arguments is less than 3, the target is always the\n        // evented object itself.\n        const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n        let target;\n        let type;\n        let listener;\n        if (isTargetingSelf) {\n            target = self.eventBusEl_;\n\n            // Deal with cases where we got 3 arguments, but we are still listening to\n            // the evented object itself.\n            if (args.length >= 3) {\n                args.shift();\n            }\n            [type, listener] = args;\n        } else {\n            [target, type, listener] = args;\n        }\n        validateTarget(target, self, fnName);\n        validateEventType(type, self, fnName);\n        validateListener(listener, self, fnName);\n        listener = bind_(self, listener);\n        return {\n            isTargetingSelf,\n            target,\n            type,\n            listener\n        };\n    };\n\n    /**\n     * Adds the listener to the event type(s) on the target, normalizing for\n     * the type of target.\n     *\n     * @private\n     * @param  {Element|Object} target\n     *         A DOM node or evented object.\n     *\n     * @param  {string} method\n     *         The event binding method to use (\"on\" or \"one\").\n     *\n     * @param  {string|Array} type\n     *         One or more event type(s).\n     *\n     * @param  {Function} listener\n     *         A listener function.\n     */\n    const listen = (target, method, type, listener) => {\n        validateTarget(target, target, method);\n        if (target.nodeName) {\n            Events[method](target, type, listener);\n        } else {\n            target[method](type, listener);\n        }\n    };\n\n    /**\n     * Contains methods that provide event capabilities to an object which is passed\n     * to {@link module:evented|evented}.\n     *\n     * @mixin EventedMixin\n     */\n    const EventedMixin = {\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        on(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'on');\n            listen(target, 'on', type, listener);\n\n            // If this object is listening to another evented object.\n            if (!isTargetingSelf) {\n                // If this object is disposed, remove the listener.\n                const removeListenerOnDispose = () => this.off(target, type, listener);\n\n                // Use the same function ID as the listener so we can remove it later it\n                // using the ID of the original listener.\n                removeListenerOnDispose.guid = listener.guid;\n\n                // Add a listener to the target's dispose event as well. This ensures\n                // that if the target is disposed BEFORE this object, we remove the\n                // removal listener that was just added. Otherwise, we create a memory leak.\n                const removeRemoverOnTargetDispose = () => this.off('dispose', removeListenerOnDispose);\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                removeRemoverOnTargetDispose.guid = listener.guid;\n                listen(this, 'on', 'dispose', removeListenerOnDispose);\n                listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n            }\n        },\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object. The listener will be called once per event and then removed.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        one(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'one');\n\n            // Targeting this evented object.\n            if (isTargetingSelf) {\n                listen(target, 'one', type, listener);\n\n                // Targeting another evented object.\n            } else {\n                // TODO: This wrapper is incorrect! It should only\n                //       remove the wrapper for the event type that called it.\n                //       Instead all listeners are removed on the first trigger!\n                //       see https://github.com/videojs/video.js/issues/5962\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                wrapper.guid = listener.guid;\n                listen(target, 'one', type, wrapper);\n            }\n        },\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object. The listener will only be called once for the first event that is triggered\n         * then removed.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        any(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'any');\n\n            // Targeting this evented object.\n            if (isTargetingSelf) {\n                listen(target, 'any', type, listener);\n\n                // Targeting another evented object.\n            } else {\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                wrapper.guid = listener.guid;\n                listen(target, 'any', type, wrapper);\n            }\n        },\n        /**\n         * Removes listener(s) from event(s) on an evented object.\n         *\n         * @param  {string|Array|Element|Object} [targetOrType]\n         *         If this is a string or array, it represents the event type(s).\n         *\n         *         Another evented object can be passed here instead, in which case\n         *         ALL 3 arguments are _required_.\n         *\n         * @param  {string|Array|Function} [typeOrListener]\n         *         If the first argument was a string or array, this may be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function; otherwise, _all_ listeners bound to the\n         *         event type(s) will be removed.\n         */\n        off(targetOrType, typeOrListener, listener) {\n            // Targeting this evented object.\n            if (!targetOrType || isValidEventType(targetOrType)) {\n                off(this.eventBusEl_, targetOrType, typeOrListener);\n\n                // Targeting another evented object.\n            } else {\n                const target = targetOrType;\n                const type = typeOrListener;\n\n                // Fail fast and in a meaningful way!\n                validateTarget(target, this, 'off');\n                validateEventType(type, this, 'off');\n                validateListener(listener, this, 'off');\n\n                // Ensure there's at least a guid, even if the function hasn't been used\n                listener = bind_(this, listener);\n\n                // Remove the dispose listener on this evented object, which was given\n                // the same guid as the event listener in on().\n                this.off('dispose', listener);\n                if (target.nodeName) {\n                    off(target, type, listener);\n                    off(target, 'dispose', listener);\n                } else if (isEvented(target)) {\n                    target.off(type, listener);\n                    target.off('dispose', listener);\n                }\n            }\n        },\n        /**\n         * Fire an event on this evented object, causing its listeners to be called.\n         *\n         * @param   {string|Object} event\n         *          An event type or an object with a type property.\n         *\n         * @param   {Object} [hash]\n         *          An additional object to pass along to listeners.\n         *\n         * @return {boolean}\n         *          Whether or not the default behavior was prevented.\n         */\n        trigger(event, hash) {\n            validateTarget(this.eventBusEl_, this, 'trigger');\n            const type = event && typeof event !== 'string' ? event.type : event;\n            if (!isValidEventType(type)) {\n                throw new Error(`Invalid event type for ${objName(this)}#trigger; ` + 'must be a non-empty string or object with a type key that has a non-empty value.');\n            }\n            return trigger(this.eventBusEl_, event, hash);\n        }\n    };\n\n    /**\n     * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n     *\n     * @param  {Object} target\n     *         The object to which to add event methods.\n     *\n     * @param  {Object} [options={}]\n     *         Options for customizing the mixin behavior.\n     *\n     * @param  {string} [options.eventBusKey]\n     *         By default, adds a `eventBusEl_` DOM element to the target object,\n     *         which is used as an event bus. If the target object already has a\n     *         DOM element that should be used, pass its key here.\n     *\n     * @return {Object}\n     *         The target object.\n     */\n    function evented(target, options = {}) {\n        const {\n            eventBusKey\n        } = options;\n\n        // Set or create the eventBusEl_.\n        if (eventBusKey) {\n            if (!target[eventBusKey].nodeName) {\n                throw new Error(`The eventBusKey \"${eventBusKey}\" does not refer to an element.`);\n            }\n            target.eventBusEl_ = target[eventBusKey];\n        } else {\n            target.eventBusEl_ = createEl('span', {\n                className: 'vjs-event-bus'\n            });\n        }\n        Object.assign(target, EventedMixin);\n        if (target.eventedCallbacks) {\n            target.eventedCallbacks.forEach(callback => {\n                callback();\n            });\n        }\n\n        // When any evented object is disposed, it removes all its listeners.\n        target.on('dispose', () => {\n            target.off();\n            [target, target.el_, target.eventBusEl_].forEach(function (val) {\n                if (val && DomData.has(val)) {\n                    DomData.delete(val);\n                }\n            });\n            window.setTimeout(() => {\n                target.eventBusEl_ = null;\n            }, 0);\n        });\n        return target;\n    }\n\n    /**\n     * @file mixins/stateful.js\n     * @module stateful\n     */\n\n    /**\n     * Contains methods that provide statefulness to an object which is passed\n     * to {@link module:stateful}.\n     *\n     * @mixin StatefulMixin\n     */\n    const StatefulMixin = {\n        /**\n         * A hash containing arbitrary keys and values representing the state of\n         * the object.\n         *\n         * @type {Object}\n         */\n        state: {},\n        /**\n         * Set the state of an object by mutating its\n         * {@link module:stateful~StatefulMixin.state|state} object in place.\n         *\n         * @fires   module:stateful~StatefulMixin#statechanged\n         * @param   {Object|Function} stateUpdates\n         *          A new set of properties to shallow-merge into the plugin state.\n         *          Can be a plain object or a function returning a plain object.\n         *\n         * @return {Object|undefined}\n         *          An object containing changes that occurred. If no changes\n         *          occurred, returns `undefined`.\n         */\n        setState(stateUpdates) {\n            // Support providing the `stateUpdates` state as a function.\n            if (typeof stateUpdates === 'function') {\n                stateUpdates = stateUpdates();\n            }\n            let changes;\n            each(stateUpdates, (value, key) => {\n                // Record the change if the value is different from what's in the\n                // current state.\n                if (this.state[key] !== value) {\n                    changes = changes || {};\n                    changes[key] = {\n                        from: this.state[key],\n                        to: value\n                    };\n                }\n                this.state[key] = value;\n            });\n\n            // Only trigger \"statechange\" if there were changes AND we have a trigger\n            // function. This allows us to not require that the target object be an\n            // evented object.\n            if (changes && isEvented(this)) {\n                /**\n                 * An event triggered on an object that is both\n                 * {@link module:stateful|stateful} and {@link module:evented|evented}\n                 * indicating that its state has changed.\n                 *\n                 * @event    module:stateful~StatefulMixin#statechanged\n                 * @type     {Object}\n                 * @property {Object} changes\n                 *           A hash containing the properties that were changed and\n                 *           the values they were changed `from` and `to`.\n                 */\n                this.trigger({\n                    changes,\n                    type: 'statechanged'\n                });\n            }\n            return changes;\n        }\n    };\n\n    /**\n     * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n     * object.\n     *\n     * If the target object is {@link module:evented|evented} and has a\n     * `handleStateChanged` method, that method will be automatically bound to the\n     * `statechanged` event on itself.\n     *\n     * @param   {Object} target\n     *          The object to be made stateful.\n     *\n     * @param   {Object} [defaultState]\n     *          A default set of properties to populate the newly-stateful object's\n     *          `state` property.\n     *\n     * @return {Object}\n     *          Returns the `target`.\n     */\n    function stateful(target, defaultState) {\n        Object.assign(target, StatefulMixin);\n\n        // This happens after the mixing-in because we need to replace the `state`\n        // added in that step.\n        target.state = Object.assign({}, target.state, defaultState);\n\n        // Auto-bind the `handleStateChanged` method of the target object if it exists.\n        if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n            target.on('statechanged', target.handleStateChanged);\n        }\n        return target;\n    }\n\n    /**\n     * @file str.js\n     * @module to-lower-case\n     */\n\n    /**\n     * Lowercase the first letter of a string.\n     *\n     * @param {string} string\n     *        String to be lowercased\n     *\n     * @return {string}\n     *         The string with a lowercased first letter\n     */\n    const toLowerCase = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toLowerCase());\n    };\n\n    /**\n     * Uppercase the first letter of a string.\n     *\n     * @param {string} string\n     *        String to be uppercased\n     *\n     * @return {string}\n     *         The string with an uppercased first letter\n     */\n    const toTitleCase$1 = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toUpperCase());\n    };\n\n    /**\n     * Compares the TitleCase versions of the two strings for equality.\n     *\n     * @param {string} str1\n     *        The first string to compare\n     *\n     * @param {string} str2\n     *        The second string to compare\n     *\n     * @return {boolean}\n     *         Whether the TitleCase versions of the strings are equal\n     */\n    const titleCaseEquals = function (str1, str2) {\n        return toTitleCase$1(str1) === toTitleCase$1(str2);\n    };\n\n    var Str = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        toLowerCase: toLowerCase,\n        toTitleCase: toTitleCase$1,\n        titleCaseEquals: titleCaseEquals\n    });\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    function unwrapExports (x) {\n        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n\n    function createCommonjsModule(fn, module) {\n        return module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    var keycode = createCommonjsModule(function (module, exports) {\n        // Source: http://jsfiddle.net/vWx8V/\n        // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n        /**\n         * Conenience method returns corresponding value for given keyName or keyCode.\n         *\n         * @param {Mixed} keyCode {Number} or keyName {String}\n         * @return {Mixed}\n         * @api public\n         */\n\n        function keyCode(searchInput) {\n            // Keyboard Events\n            if (searchInput && 'object' === typeof searchInput) {\n                var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;\n                if (hasKeyCode) searchInput = hasKeyCode;\n            }\n\n            // Numbers\n            if ('number' === typeof searchInput) return names[searchInput];\n\n            // Everything else (cast to string)\n            var search = String(searchInput);\n\n            // check codes\n            var foundNamedKey = codes[search.toLowerCase()];\n            if (foundNamedKey) return foundNamedKey;\n\n            // check aliases\n            var foundNamedKey = aliases[search.toLowerCase()];\n            if (foundNamedKey) return foundNamedKey;\n\n            // weird character?\n            if (search.length === 1) return search.charCodeAt(0);\n            return undefined;\n        }\n\n        /**\n         * Compares a keyboard event with a given keyCode or keyName.\n         *\n         * @param {Event} event Keyboard event that should be tested\n         * @param {Mixed} keyCode {Number} or keyName {String}\n         * @return {Boolean}\n         * @api public\n         */\n        keyCode.isEventKey = function isEventKey(event, nameOrCode) {\n            if (event && 'object' === typeof event) {\n                var keyCode = event.which || event.keyCode || event.charCode;\n                if (keyCode === null || keyCode === undefined) {\n                    return false;\n                }\n                if (typeof nameOrCode === 'string') {\n                    // check codes\n                    var foundNamedKey = codes[nameOrCode.toLowerCase()];\n                    if (foundNamedKey) {\n                        return foundNamedKey === keyCode;\n                    }\n\n                    // check aliases\n                    var foundNamedKey = aliases[nameOrCode.toLowerCase()];\n                    if (foundNamedKey) {\n                        return foundNamedKey === keyCode;\n                    }\n                } else if (typeof nameOrCode === 'number') {\n                    return nameOrCode === keyCode;\n                }\n                return false;\n            }\n        };\n        exports = module.exports = keyCode;\n\n        /**\n         * Get by name\n         *\n         *   exports.code['enter'] // => 13\n         */\n\n        var codes = exports.code = exports.codes = {\n            'backspace': 8,\n            'tab': 9,\n            'enter': 13,\n            'shift': 16,\n            'ctrl': 17,\n            'alt': 18,\n            'pause/break': 19,\n            'caps lock': 20,\n            'esc': 27,\n            'space': 32,\n            'page up': 33,\n            'page down': 34,\n            'end': 35,\n            'home': 36,\n            'left': 37,\n            'up': 38,\n            'right': 39,\n            'down': 40,\n            'insert': 45,\n            'delete': 46,\n            'command': 91,\n            'left command': 91,\n            'right command': 93,\n            'numpad *': 106,\n            'numpad +': 107,\n            'numpad -': 109,\n            'numpad .': 110,\n            'numpad /': 111,\n            'num lock': 144,\n            'scroll lock': 145,\n            'my computer': 182,\n            'my calculator': 183,\n            ';': 186,\n            '=': 187,\n            ',': 188,\n            '-': 189,\n            '.': 190,\n            '/': 191,\n            '`': 192,\n            '[': 219,\n            '\\\\': 220,\n            ']': 221,\n            \"'\": 222\n        };\n\n        // Helper aliases\n\n        var aliases = exports.aliases = {\n            'windows': 91,\n            '⇧': 16,\n            '⌥': 18,\n            '⌃': 17,\n            '⌘': 91,\n            'ctl': 17,\n            'control': 17,\n            'option': 18,\n            'pause': 19,\n            'break': 19,\n            'caps': 20,\n            'return': 13,\n            'escape': 27,\n            'spc': 32,\n            'spacebar': 32,\n            'pgup': 33,\n            'pgdn': 34,\n            'ins': 45,\n            'del': 46,\n            'cmd': 91\n        };\n\n        /*!\n     * Programatically add the following\n     */\n\n        // lower case chars\n        for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;\n\n        // numbers\n        for (var i = 48; i < 58; i++) codes[i - 48] = i;\n\n        // function keys\n        for (i = 1; i < 13; i++) codes['f' + i] = i + 111;\n\n        // numpad keys\n        for (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96;\n\n        /**\n         * Get by code\n         *\n         *   exports.name[13] // => 'Enter'\n         */\n\n        var names = exports.names = exports.title = {}; // title for backward compat\n\n        // Create reverse mapping\n        for (i in codes) names[codes[i]] = i;\n\n        // Add aliases\n        for (var alias in aliases) {\n            codes[alias] = aliases[alias];\n        }\n    });\n    keycode.code;\n    keycode.codes;\n    keycode.aliases;\n    keycode.names;\n    keycode.title;\n\n    /**\n     * Player Component - Base class for all UI objects\n     *\n     * @file component.js\n     */\n\n    /**\n     * Base class for all UI Components.\n     * Components are UI objects which represent both a javascript object and an element\n     * in the DOM. They can be children of other components, and can have\n     * children themselves.\n     *\n     * Components can also use methods from {@link EventTarget}\n     */\n    class Component$1 {\n        /**\n         * A callback that is called when a component is ready. Does not have any\n         * parameters and any callback value will be ignored.\n         *\n         * @callback ReadyCallback\n         * @this Component\n         */\n\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of component options.\n         *\n         * @param {Object[]} [options.children]\n         *        An array of children objects to initialize this component with. Children objects have\n         *        a name property that will be used if more than one component of the same type needs to be\n         *        added.\n         *\n         * @param  {string} [options.className]\n         *         A class or space separated list of classes to add the component\n         *\n         * @param {ReadyCallback} [ready]\n         *        Function that gets called when the `Component` is ready.\n         */\n        constructor(player, options, ready) {\n            // The component might be the player itself and we can't pass `this` to super\n            if (!player && this.play) {\n                this.player_ = player = this; // eslint-disable-line\n            } else {\n                this.player_ = player;\n            }\n            this.isDisposed_ = false;\n\n            // Hold the reference to the parent component via `addChild` method\n            this.parentComponent_ = null;\n\n            // Make a copy of prototype.options_ to protect against overriding defaults\n            this.options_ = merge$2({}, this.options_);\n\n            // Updated options with supplied options\n            options = this.options_ = merge$2(this.options_, options);\n\n            // Get ID from options or options element if one is supplied\n            this.id_ = options.id || options.el && options.el.id;\n\n            // If there was no ID from the options, generate one\n            if (!this.id_) {\n                // Don't require the player ID function in the case of mock players\n                const id = player && player.id && player.id() || 'no_player';\n                this.id_ = `${id}_component_${newGUID()}`;\n            }\n            this.name_ = options.name || null;\n\n            // Create element if one wasn't provided in options\n            if (options.el) {\n                this.el_ = options.el;\n            } else if (options.createEl !== false) {\n                this.el_ = this.createEl();\n            }\n            if (options.className && this.el_) {\n                options.className.split(' ').forEach(c => this.addClass(c));\n            }\n\n            // Remove the placeholder event methods. If the component is evented, the\n            // real methods are added next\n            ['on', 'off', 'one', 'any', 'trigger'].forEach(fn => {\n                this[fn] = undefined;\n            });\n\n            // if evented is anything except false, we want to mixin in evented\n            if (options.evented !== false) {\n                // Make this an evented object and use `el_`, if available, as its event bus\n                evented(this, {\n                    eventBusKey: this.el_ ? 'el_' : null\n                });\n                this.handleLanguagechange = this.handleLanguagechange.bind(this);\n                this.on(this.player_, 'languagechange', this.handleLanguagechange);\n            }\n            stateful(this, this.constructor.defaultState);\n            this.children_ = [];\n            this.childIndex_ = {};\n            this.childNameIndex_ = {};\n            this.setTimeoutIds_ = new Set();\n            this.setIntervalIds_ = new Set();\n            this.rafIds_ = new Set();\n            this.namedRafs_ = new Map();\n            this.clearingTimersOnDispose_ = false;\n\n            // Add any child components in options\n            if (options.initChildren !== false) {\n                this.initChildren();\n            }\n\n            // Don't want to trigger ready here or it will go before init is actually\n            // finished for all children that run this constructor\n            this.ready(ready);\n            if (options.reportTouchActivity !== false) {\n                this.enableTouchActivity();\n            }\n        }\n\n        // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.\n        // They are replaced or removed in the constructor\n\n        /**\n         * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n         * function that will get called when an event with a certain name gets triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to call with `EventTarget`s\n         */\n        on(type, fn) {}\n\n        /**\n         * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n         * This makes it so that the `event listener` will no longer get called when the\n         * named event happens.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} [fn]\n         *        The function to remove. If not specified, all listeners managed by Video.js will be removed.\n         */\n        off(type, fn) {}\n\n        /**\n         * This function will add an `event listener` that gets triggered only once. After the\n         * first trigger it will get removed. This is like adding an `event listener`\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        one(type, fn) {}\n\n        /**\n         * This function will add an `event listener` that gets triggered only once and is\n         * removed from all events. This is like adding an array of `event listener`s\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the\n         * first time it is triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        any(type, fn) {}\n\n        /**\n         * This function causes an event to happen. This will then cause any `event listeners`\n         * that are waiting for that event, to get called. If there are no `event listeners`\n         * for an event then nothing will happen.\n         *\n         * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n         * Trigger will also call the `on` + `uppercaseEventName` function.\n         *\n         * Example:\n         * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n         * `onClick` if it exists.\n         *\n         * @param {string|Event|Object} event\n         *        The name of the event, an `Event`, or an object with a key of type set to\n         *        an event name.\n         *\n         * @param {Object} [hash]\n         *        Optionally extra argument to pass through to an event listener\n         */\n        trigger(event, hash) {}\n\n        /**\n         * Dispose of the `Component` and all child components.\n         *\n         * @fires Component#dispose\n         *\n         * @param {Object} options\n         * @param {Element} options.originalEl element with which to replace player element\n         */\n        dispose(options = {}) {\n            // Bail out if the component has already been disposed.\n            if (this.isDisposed_) {\n                return;\n            }\n            if (this.readyQueue_) {\n                this.readyQueue_.length = 0;\n            }\n\n            /**\n             * Triggered when a `Component` is disposed.\n             *\n             * @event Component#dispose\n             * @type {Event}\n             *\n             * @property {boolean} [bubbles=false]\n             *           set to false so that the dispose event does not\n             *           bubble up\n             */\n            this.trigger({\n                type: 'dispose',\n                bubbles: false\n            });\n            this.isDisposed_ = true;\n\n            // Dispose all children.\n            if (this.children_) {\n                for (let i = this.children_.length - 1; i >= 0; i--) {\n                    if (this.children_[i].dispose) {\n                        this.children_[i].dispose();\n                    }\n                }\n            }\n\n            // Delete child references\n            this.children_ = null;\n            this.childIndex_ = null;\n            this.childNameIndex_ = null;\n            this.parentComponent_ = null;\n            if (this.el_) {\n                // Remove element from DOM\n                if (this.el_.parentNode) {\n                    if (options.restoreEl) {\n                        this.el_.parentNode.replaceChild(options.restoreEl, this.el_);\n                    } else {\n                        this.el_.parentNode.removeChild(this.el_);\n                    }\n                }\n                this.el_ = null;\n            }\n\n            // remove reference to the player after disposing of the element\n            this.player_ = null;\n        }\n\n        /**\n         * Determine whether or not this component has been disposed.\n         *\n         * @return {boolean}\n         *         If the component has been disposed, will be `true`. Otherwise, `false`.\n         */\n        isDisposed() {\n            return Boolean(this.isDisposed_);\n        }\n\n        /**\n         * Return the {@link Player} that the `Component` has attached to.\n         *\n         * @return { import('./player').default }\n         *         The player that this `Component` has attached to.\n         */\n        player() {\n            return this.player_;\n        }\n\n        /**\n         * Deep merge of options objects with new options.\n         * > Note: When both `obj` and `options` contain properties whose values are objects.\n         *         The two properties get merged using {@link module:obj.merge}\n         *\n         * @param {Object} obj\n         *        The object that contains new options.\n         *\n         * @return {Object}\n         *         A new object of `this.options_` and `obj` merged together.\n         */\n        options(obj) {\n            if (!obj) {\n                return this.options_;\n            }\n            this.options_ = merge$2(this.options_, obj);\n            return this.options_;\n        }\n\n        /**\n         * Get the `Component`s DOM element\n         *\n         * @return {Element}\n         *         The DOM element for this `Component`.\n         */\n        el() {\n            return this.el_;\n        }\n\n        /**\n         * Create the `Component`s DOM element.\n         *\n         * @param {string} [tagName]\n         *        Element's DOM node type. e.g. 'div'\n         *\n         * @param {Object} [properties]\n         *        An object of properties that should be set.\n         *\n         * @param {Object} [attributes]\n         *        An object of attributes that should be set.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tagName, properties, attributes) {\n            return createEl(tagName, properties, attributes);\n        }\n\n        /**\n         * Localize a string given the string in english.\n         *\n         * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n         * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n         *\n         * If a `defaultValue` is provided, it'll use that over `string`,\n         * if a value isn't found in provided language files.\n         * This is useful if you want to have a descriptive key for token replacement\n         * but have a succinct localized string and not require `en.json` to be included.\n         *\n         * Currently, it is used for the progress bar timing.\n         * ```js\n         * {\n         *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n         * }\n         * ```\n         * It is then used like so:\n         * ```js\n         * this.localize('progress bar timing: currentTime={1} duration{2}',\n         *               [this.player_.currentTime(), this.player_.duration()],\n         *               '{1} of {2}');\n         * ```\n         *\n         * Which outputs something like: `01:23 of 24:56`.\n         *\n         *\n         * @param {string} string\n         *        The string to localize and the key to lookup in the language files.\n         * @param {string[]} [tokens]\n         *        If the current item has token replacements, provide the tokens here.\n         * @param {string} [defaultValue]\n         *        Defaults to `string`. Can be a default value to use for token replacement\n         *        if the lookup key is needed to be separate.\n         *\n         * @return {string}\n         *         The localized string or if no localization exists the english string.\n         */\n        localize(string, tokens, defaultValue = string) {\n            const code = this.player_.language && this.player_.language();\n            const languages = this.player_.languages && this.player_.languages();\n            const language = languages && languages[code];\n            const primaryCode = code && code.split('-')[0];\n            const primaryLang = languages && languages[primaryCode];\n            let localizedString = defaultValue;\n            if (language && language[string]) {\n                localizedString = language[string];\n            } else if (primaryLang && primaryLang[string]) {\n                localizedString = primaryLang[string];\n            }\n            if (tokens) {\n                localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n                    const value = tokens[index - 1];\n                    let ret = value;\n                    if (typeof value === 'undefined') {\n                        ret = match;\n                    }\n                    return ret;\n                });\n            }\n            return localizedString;\n        }\n\n        /**\n         * Handles language change for the player in components. Should be overridden by sub-components.\n         *\n         * @abstract\n         */\n        handleLanguagechange() {}\n\n        /**\n         * Return the `Component`s DOM element. This is where children get inserted.\n         * This will usually be the the same as the element returned in {@link Component#el}.\n         *\n         * @return {Element}\n         *         The content element for this `Component`.\n         */\n        contentEl() {\n            return this.contentEl_ || this.el_;\n        }\n\n        /**\n         * Get this `Component`s ID\n         *\n         * @return {string}\n         *         The id of this `Component`\n         */\n        id() {\n            return this.id_;\n        }\n\n        /**\n         * Get the `Component`s name. The name gets used to reference the `Component`\n         * and is set during registration.\n         *\n         * @return {string}\n         *         The name of this `Component`.\n         */\n        name() {\n            return this.name_;\n        }\n\n        /**\n         * Get an array of all child components\n         *\n         * @return {Array}\n         *         The children\n         */\n        children() {\n            return this.children_;\n        }\n\n        /**\n         * Returns the child `Component` with the given `id`.\n         *\n         * @param {string} id\n         *        The id of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The child `Component` with the given `id` or undefined.\n         */\n        getChildById(id) {\n            return this.childIndex_[id];\n        }\n\n        /**\n         * Returns the child `Component` with the given `name`.\n         *\n         * @param {string} name\n         *        The name of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The child `Component` with the given `name` or undefined.\n         */\n        getChild(name) {\n            if (!name) {\n                return;\n            }\n            return this.childNameIndex_[name];\n        }\n\n        /**\n         * Returns the descendant `Component` following the givent\n         * descendant `names`. For instance ['foo', 'bar', 'baz'] would\n         * try to get 'foo' on the current component, 'bar' on the 'foo'\n         * component and 'baz' on the 'bar' component and return undefined\n         * if any of those don't exist.\n         *\n         * @param {...string[]|...string} names\n         *        The name of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The descendant `Component` following the given descendant\n         *         `names` or undefined.\n         */\n        getDescendant(...names) {\n            // flatten array argument into the main array\n            names = names.reduce((acc, n) => acc.concat(n), []);\n            let currentChild = this;\n            for (let i = 0; i < names.length; i++) {\n                currentChild = currentChild.getChild(names[i]);\n                if (!currentChild || !currentChild.getChild) {\n                    return;\n                }\n            }\n            return currentChild;\n        }\n\n        /**\n         * Adds an SVG icon element to another element or component.\n         *\n         * @param {string} iconName\n         *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'\n         *\n         * @param {Element} [el=this.el()]\n         *        Element to set the title on. Defaults to the current Component's element.\n         *\n         * @return {Element}\n         *        The newly created icon element.\n         */\n        setIcon(iconName, el = this.el()) {\n            // TODO: In v9 of video.js, we will want to remove font icons entirely.\n            // This means this check, as well as the others throughout the code, and\n            // the unecessary CSS for font icons, will need to be removed.\n            // See https://github.com/videojs/video.js/pull/8260 as to which components\n            // need updating.\n            if (!this.player_.options_.experimentalSvgIcons) {\n                return;\n            }\n            const xmlnsURL = 'http://www.w3.org/2000/svg';\n\n            // The below creates an element in the format of:\n            // <span><svg><use>....</use></svg></span>\n            const iconContainer = createEl('span', {\n                className: 'vjs-icon-placeholder vjs-svg-icon'\n            }, {\n                'aria-hidden': 'true'\n            });\n            const svgEl = document.createElementNS(xmlnsURL, 'svg');\n            svgEl.setAttributeNS(null, 'viewBox', '0 0 512 512');\n            const useEl = document.createElementNS(xmlnsURL, 'use');\n            svgEl.appendChild(useEl);\n            useEl.setAttributeNS(null, 'href', `#vjs-icon-${iconName}`);\n            iconContainer.appendChild(svgEl);\n\n            // Replace a pre-existing icon if one exists.\n            if (this.iconIsSet_) {\n                el.replaceChild(iconContainer, el.querySelector('.vjs-icon-placeholder'));\n            } else {\n                el.appendChild(iconContainer);\n            }\n            this.iconIsSet_ = true;\n            return iconContainer;\n        }\n\n        /**\n         * Add a child `Component` inside the current `Component`.\n         *\n         * @param {string|Component} child\n         *        The name or instance of a child to add.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of options that will get passed to children of\n         *        the child.\n         *\n         * @param {number} [index=this.children_.length]\n         *        The index to attempt to add a child into.\n         *\n         *\n         * @return {Component}\n         *         The `Component` that gets added as a child. When using a string the\n         *         `Component` will get created by this process.\n         */\n        addChild(child, options = {}, index = this.children_.length) {\n            let component;\n            let componentName;\n\n            // If child is a string, create component with options\n            if (typeof child === 'string') {\n                componentName = toTitleCase$1(child);\n                const componentClassName = options.componentClass || componentName;\n\n                // Set name through options\n                options.name = componentName;\n\n                // Create a new object & element for this controls set\n                // If there's no .player_, this is a player\n                const ComponentClass = Component$1.getComponent(componentClassName);\n                if (!ComponentClass) {\n                    throw new Error(`Component ${componentClassName} does not exist`);\n                }\n\n                // data stored directly on the videojs object may be\n                // misidentified as a component to retain\n                // backwards-compatibility with 4.x. check to make sure the\n                // component class can be instantiated.\n                if (typeof ComponentClass !== 'function') {\n                    return null;\n                }\n                component = new ComponentClass(this.player_ || this, options);\n\n                // child is a component instance\n            } else {\n                component = child;\n            }\n            if (component.parentComponent_) {\n                component.parentComponent_.removeChild(component);\n            }\n            this.children_.splice(index, 0, component);\n            component.parentComponent_ = this;\n            if (typeof component.id === 'function') {\n                this.childIndex_[component.id()] = component;\n            }\n\n            // If a name wasn't used to create the component, check if we can use the\n            // name function of the component\n            componentName = componentName || component.name && toTitleCase$1(component.name());\n            if (componentName) {\n                this.childNameIndex_[componentName] = component;\n                this.childNameIndex_[toLowerCase(componentName)] = component;\n            }\n\n            // Add the UI object's element to the container div (box)\n            // Having an element is not required\n            if (typeof component.el === 'function' && component.el()) {\n                // If inserting before a component, insert before that component's element\n                let refNode = null;\n                if (this.children_[index + 1]) {\n                    // Most children are components, but the video tech is an HTML element\n                    if (this.children_[index + 1].el_) {\n                        refNode = this.children_[index + 1].el_;\n                    } else if (isEl(this.children_[index + 1])) {\n                        refNode = this.children_[index + 1];\n                    }\n                }\n                this.contentEl().insertBefore(component.el(), refNode);\n            }\n\n            // Return so it can stored on parent object if desired.\n            return component;\n        }\n\n        /**\n         * Remove a child `Component` from this `Component`s list of children. Also removes\n         * the child `Component`s element from this `Component`s element.\n         *\n         * @param {Component} component\n         *        The child `Component` to remove.\n         */\n        removeChild(component) {\n            if (typeof component === 'string') {\n                component = this.getChild(component);\n            }\n            if (!component || !this.children_) {\n                return;\n            }\n            let childFound = false;\n            for (let i = this.children_.length - 1; i >= 0; i--) {\n                if (this.children_[i] === component) {\n                    childFound = true;\n                    this.children_.splice(i, 1);\n                    break;\n                }\n            }\n            if (!childFound) {\n                return;\n            }\n            component.parentComponent_ = null;\n            this.childIndex_[component.id()] = null;\n            this.childNameIndex_[toTitleCase$1(component.name())] = null;\n            this.childNameIndex_[toLowerCase(component.name())] = null;\n            const compEl = component.el();\n            if (compEl && compEl.parentNode === this.contentEl()) {\n                this.contentEl().removeChild(component.el());\n            }\n        }\n\n        /**\n         * Add and initialize default child `Component`s based upon options.\n         */\n        initChildren() {\n            const children = this.options_.children;\n            if (children) {\n                // `this` is `parent`\n                const parentOptions = this.options_;\n                const handleAdd = child => {\n                    const name = child.name;\n                    let opts = child.opts;\n\n                    // Allow options for children to be set at the parent options\n                    // e.g. videojs(id, { controlBar: false });\n                    // instead of videojs(id, { children: { controlBar: false });\n                    if (parentOptions[name] !== undefined) {\n                        opts = parentOptions[name];\n                    }\n\n                    // Allow for disabling default components\n                    // e.g. options['children']['posterImage'] = false\n                    if (opts === false) {\n                        return;\n                    }\n\n                    // Allow options to be passed as a simple boolean if no configuration\n                    // is necessary.\n                    if (opts === true) {\n                        opts = {};\n                    }\n\n                    // We also want to pass the original player options\n                    // to each component as well so they don't need to\n                    // reach back into the player for options later.\n                    opts.playerOptions = this.options_.playerOptions;\n\n                    // Create and add the child component.\n                    // Add a direct reference to the child by name on the parent instance.\n                    // If two of the same component are used, different names should be supplied\n                    // for each\n                    const newChild = this.addChild(name, opts);\n                    if (newChild) {\n                        this[name] = newChild;\n                    }\n                };\n\n                // Allow for an array of children details to passed in the options\n                let workingChildren;\n                const Tech = Component$1.getComponent('Tech');\n                if (Array.isArray(children)) {\n                    workingChildren = children;\n                } else {\n                    workingChildren = Object.keys(children);\n                }\n                workingChildren\n                    // children that are in this.options_ but also in workingChildren  would\n                    // give us extra children we do not want. So, we want to filter them out.\n                    .concat(Object.keys(this.options_).filter(function (child) {\n                        return !workingChildren.some(function (wchild) {\n                            if (typeof wchild === 'string') {\n                                return child === wchild;\n                            }\n                            return child === wchild.name;\n                        });\n                    })).map(child => {\n                    let name;\n                    let opts;\n                    if (typeof child === 'string') {\n                        name = child;\n                        opts = children[name] || this.options_[name] || {};\n                    } else {\n                        name = child.name;\n                        opts = child;\n                    }\n                    return {\n                        name,\n                        opts\n                    };\n                }).filter(child => {\n                    // we have to make sure that child.name isn't in the techOrder since\n                    // techs are registered as Components but can't aren't compatible\n                    // See https://github.com/videojs/video.js/issues/2772\n                    const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));\n                    return c && !Tech.isTech(c);\n                }).forEach(handleAdd);\n            }\n        }\n\n        /**\n         * Builds the default DOM class name. Should be overridden by sub-components.\n         *\n         * @return {string}\n         *         The DOM class name for this object.\n         *\n         * @abstract\n         */\n        buildCSSClass() {\n            // Child classes can include a function that does:\n            // return 'CLASS NAME' + this._super();\n            return '';\n        }\n\n        /**\n         * Bind a listener to the component's ready state.\n         * Different from event listeners in that if the ready event has already happened\n         * it will trigger the function immediately.\n         *\n         * @param {ReadyCallback} fn\n         *        Function that gets called when the `Component` is ready.\n         *\n         * @return {Component}\n         *         Returns itself; method can be chained.\n         */\n        ready(fn, sync = false) {\n            if (!fn) {\n                return;\n            }\n            if (!this.isReady_) {\n                this.readyQueue_ = this.readyQueue_ || [];\n                this.readyQueue_.push(fn);\n                return;\n            }\n            if (sync) {\n                fn.call(this);\n            } else {\n                // Call the function asynchronously by default for consistency\n                this.setTimeout(fn, 1);\n            }\n        }\n\n        /**\n         * Trigger all the ready listeners for this `Component`.\n         *\n         * @fires Component#ready\n         */\n        triggerReady() {\n            this.isReady_ = true;\n\n            // Ensure ready is triggered asynchronously\n            this.setTimeout(function () {\n                const readyQueue = this.readyQueue_;\n\n                // Reset Ready Queue\n                this.readyQueue_ = [];\n                if (readyQueue && readyQueue.length > 0) {\n                    readyQueue.forEach(function (fn) {\n                        fn.call(this);\n                    }, this);\n                }\n\n                // Allow for using event listeners also\n                /**\n                 * Triggered when a `Component` is ready.\n                 *\n                 * @event Component#ready\n                 * @type {Event}\n                 */\n                this.trigger('ready');\n            }, 1);\n        }\n\n        /**\n         * Find a single DOM element matching a `selector`. This can be within the `Component`s\n         * `contentEl()` or another custom context.\n         *\n         * @param {string} selector\n         *        A valid CSS selector, which will be passed to `querySelector`.\n         *\n         * @param {Element|string} [context=this.contentEl()]\n         *        A DOM element within which to query. Can also be a selector string in\n         *        which case the first matching element will get used as context. If\n         *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n         *        nothing it falls back to `document`.\n         *\n         * @return {Element|null}\n         *         the dom element that was found, or null\n         *\n         * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n         */\n        $(selector, context) {\n            return $(selector, context || this.contentEl());\n        }\n\n        /**\n         * Finds all DOM element matching a `selector`. This can be within the `Component`s\n         * `contentEl()` or another custom context.\n         *\n         * @param {string} selector\n         *        A valid CSS selector, which will be passed to `querySelectorAll`.\n         *\n         * @param {Element|string} [context=this.contentEl()]\n         *        A DOM element within which to query. Can also be a selector string in\n         *        which case the first matching element will get used as context. If\n         *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n         *        nothing it falls back to `document`.\n         *\n         * @return {NodeList}\n         *         a list of dom elements that were found\n         *\n         * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n         */\n        $$(selector, context) {\n            return $$(selector, context || this.contentEl());\n        }\n\n        /**\n         * Check if a component's element has a CSS class name.\n         *\n         * @param {string} classToCheck\n         *        CSS class name to check.\n         *\n         * @return {boolean}\n         *         - True if the `Component` has the class.\n         *         - False if the `Component` does not have the class`\n         */\n        hasClass(classToCheck) {\n            return hasClass(this.el_, classToCheck);\n        }\n\n        /**\n         * Add a CSS class name to the `Component`s element.\n         *\n         * @param {...string} classesToAdd\n         *        One or more CSS class name to add.\n         */\n        addClass(...classesToAdd) {\n            addClass(this.el_, ...classesToAdd);\n        }\n\n        /**\n         * Remove a CSS class name from the `Component`s element.\n         *\n         * @param {...string} classesToRemove\n         *        One or more CSS class name to remove.\n         */\n        removeClass(...classesToRemove) {\n            removeClass(this.el_, ...classesToRemove);\n        }\n\n        /**\n         * Add or remove a CSS class name from the component's element.\n         * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n         * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n         *\n         * @param  {string} classToToggle\n         *         The class to add or remove based on (@link Component#hasClass}\n         *\n         * @param  {boolean|Dom~predicate} [predicate]\n         *         An {@link Dom~predicate} function or a boolean\n         */\n        toggleClass(classToToggle, predicate) {\n            toggleClass(this.el_, classToToggle, predicate);\n        }\n\n        /**\n         * Show the `Component`s element if it is hidden by removing the\n         * 'vjs-hidden' class name from it.\n         */\n        show() {\n            this.removeClass('vjs-hidden');\n        }\n\n        /**\n         * Hide the `Component`s element if it is currently showing by adding the\n         * 'vjs-hidden` class name to it.\n         */\n        hide() {\n            this.addClass('vjs-hidden');\n        }\n\n        /**\n         * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n         * class name to it. Used during fadeIn/fadeOut.\n         *\n         * @private\n         */\n        lockShowing() {\n            this.addClass('vjs-lock-showing');\n        }\n\n        /**\n         * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n         * class name from it. Used during fadeIn/fadeOut.\n         *\n         * @private\n         */\n        unlockShowing() {\n            this.removeClass('vjs-lock-showing');\n        }\n\n        /**\n         * Get the value of an attribute on the `Component`s element.\n         *\n         * @param {string} attribute\n         *        Name of the attribute to get the value from.\n         *\n         * @return {string|null}\n         *         - The value of the attribute that was asked for.\n         *         - Can be an empty string on some browsers if the attribute does not exist\n         *           or has no value\n         *         - Most browsers will return null if the attribute does not exist or has\n         *           no value.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n         */\n        getAttribute(attribute) {\n            return getAttribute(this.el_, attribute);\n        }\n\n        /**\n         * Set the value of an attribute on the `Component`'s element\n         *\n         * @param {string} attribute\n         *        Name of the attribute to set.\n         *\n         * @param {string} value\n         *        Value to set the attribute to.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n         */\n        setAttribute(attribute, value) {\n            setAttribute(this.el_, attribute, value);\n        }\n\n        /**\n         * Remove an attribute from the `Component`s element.\n         *\n         * @param {string} attribute\n         *        Name of the attribute to remove.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n         */\n        removeAttribute(attribute) {\n            removeAttribute(this.el_, attribute);\n        }\n\n        /**\n         * Get or set the width of the component based upon the CSS styles.\n         * See {@link Component#dimension} for more detailed information.\n         *\n         * @param {number|string} [num]\n         *        The width that you want to set postfixed with '%', 'px' or nothing.\n         *\n         * @param {boolean} [skipListeners]\n         *        Skip the componentresize event trigger\n         *\n         * @return {number|undefined}\n         *         The width when getting, zero if there is no width\n         */\n        width(num, skipListeners) {\n            return this.dimension('width', num, skipListeners);\n        }\n\n        /**\n         * Get or set the height of the component based upon the CSS styles.\n         * See {@link Component#dimension} for more detailed information.\n         *\n         * @param {number|string} [num]\n         *        The height that you want to set postfixed with '%', 'px' or nothing.\n         *\n         * @param {boolean} [skipListeners]\n         *        Skip the componentresize event trigger\n         *\n         * @return {number|undefined}\n         *         The height when getting, zero if there is no height\n         */\n        height(num, skipListeners) {\n            return this.dimension('height', num, skipListeners);\n        }\n\n        /**\n         * Set both the width and height of the `Component` element at the same time.\n         *\n         * @param  {number|string} width\n         *         Width to set the `Component`s element to.\n         *\n         * @param  {number|string} height\n         *         Height to set the `Component`s element to.\n         */\n        dimensions(width, height) {\n            // Skip componentresize listeners on width for optimization\n            this.width(width, true);\n            this.height(height);\n        }\n\n        /**\n         * Get or set width or height of the `Component` element. This is the shared code\n         * for the {@link Component#width} and {@link Component#height}.\n         *\n         * Things to know:\n         * - If the width or height in an number this will return the number postfixed with 'px'.\n         * - If the width/height is a percent this will return the percent postfixed with '%'\n         * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n         *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n         *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n         *   for more information\n         * - If you want the computed style of the component, use {@link Component#currentWidth}\n         *   and {@link {Component#currentHeight}\n         *\n         * @fires Component#componentresize\n         *\n         * @param {string} widthOrHeight\n         8        'width' or 'height'\n         *\n         * @param  {number|string} [num]\n         8         New dimension\n         *\n         * @param  {boolean} [skipListeners]\n         *         Skip componentresize event trigger\n         *\n         * @return {number|undefined}\n         *         The dimension when getting or 0 if unset\n         */\n        dimension(widthOrHeight, num, skipListeners) {\n            if (num !== undefined) {\n                // Set to zero if null or literally NaN (NaN !== NaN)\n                if (num === null || num !== num) {\n                    num = 0;\n                }\n\n                // Check if using css width/height (% or px) and adjust\n                if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n                    this.el_.style[widthOrHeight] = num;\n                } else if (num === 'auto') {\n                    this.el_.style[widthOrHeight] = '';\n                } else {\n                    this.el_.style[widthOrHeight] = num + 'px';\n                }\n\n                // skipListeners allows us to avoid triggering the resize event when setting both width and height\n                if (!skipListeners) {\n                    /**\n                     * Triggered when a component is resized.\n                     *\n                     * @event Component#componentresize\n                     * @type {Event}\n                     */\n                    this.trigger('componentresize');\n                }\n                return;\n            }\n\n            // Not setting a value, so getting it\n            // Make sure element exists\n            if (!this.el_) {\n                return 0;\n            }\n\n            // Get dimension value from style\n            const val = this.el_.style[widthOrHeight];\n            const pxIndex = val.indexOf('px');\n            if (pxIndex !== -1) {\n                // Return the pixel value with no 'px'\n                return parseInt(val.slice(0, pxIndex), 10);\n            }\n\n            // No px so using % or no style was set, so falling back to offsetWidth/height\n            // If component has display:none, offset will return 0\n            // TODO: handle display:none and no dimension style using px\n            return parseInt(this.el_['offset' + toTitleCase$1(widthOrHeight)], 10);\n        }\n\n        /**\n         * Get the computed width or the height of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @param {string} widthOrHeight\n         *        A string containing 'width' or 'height'. Whichever one you want to get.\n         *\n         * @return {number}\n         *         The dimension that gets asked for or 0 if nothing was set\n         *         for that dimension.\n         */\n        currentDimension(widthOrHeight) {\n            let computedWidthOrHeight = 0;\n            if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n                throw new Error('currentDimension only accepts width or height value');\n            }\n            computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);\n\n            // remove 'px' from variable and parse as integer\n            computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n            // if the computed value is still 0, it's possible that the browser is lying\n            // and we want to check the offset values.\n            // This code also runs wherever getComputedStyle doesn't exist.\n            if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {\n                const rule = `offset${toTitleCase$1(widthOrHeight)}`;\n                computedWidthOrHeight = this.el_[rule];\n            }\n            return computedWidthOrHeight;\n        }\n\n        /**\n         * An object that contains width and height values of the `Component`s\n         * computed style. Uses `window.getComputedStyle`.\n         *\n         * @typedef {Object} Component~DimensionObject\n         *\n         * @property {number} width\n         *           The width of the `Component`s computed style.\n         *\n         * @property {number} height\n         *           The height of the `Component`s computed style.\n         */\n\n        /**\n         * Get an object that contains computed width and height values of the\n         * component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {Component~DimensionObject}\n         *         The computed dimensions of the component's element.\n         */\n        currentDimensions() {\n            return {\n                width: this.currentDimension('width'),\n                height: this.currentDimension('height')\n            };\n        }\n\n        /**\n         * Get the computed width of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {number}\n         *         The computed width of the component's element.\n         */\n        currentWidth() {\n            return this.currentDimension('width');\n        }\n\n        /**\n         * Get the computed height of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {number}\n         *         The computed height of the component's element.\n         */\n        currentHeight() {\n            return this.currentDimension('height');\n        }\n\n        /**\n         * Set the focus to this component\n         */\n        focus() {\n            this.el_.focus();\n        }\n\n        /**\n         * Remove the focus from this component\n         */\n        blur() {\n            this.el_.blur();\n        }\n\n        /**\n         * When this Component receives a `keydown` event which it does not process,\n         *  it passes the event to the Player for handling.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         */\n        handleKeyDown(event) {\n            if (this.player_) {\n                // We only stop propagation here because we want unhandled events to fall\n                // back to the browser. Exclude Tab for focus trapping.\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.stopPropagation();\n                }\n                this.player_.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Many components used to have a `handleKeyPress` method, which was poorly\n         * named because it listened to a `keydown` event. This method name now\n         * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`\n         * will not see their method calls stop working.\n         *\n         * @param {KeyboardEvent} event\n         *        The event that caused this function to be called.\n         */\n        handleKeyPress(event) {\n            this.handleKeyDown(event);\n        }\n\n        /**\n         * Emit a 'tap' events when touch event support gets detected. This gets used to\n         * support toggling the controls through a tap on the video. They get enabled\n         * because every sub-component would have extra overhead otherwise.\n         *\n         * @protected\n         * @fires Component#tap\n         * @listens Component#touchstart\n         * @listens Component#touchmove\n         * @listens Component#touchleave\n         * @listens Component#touchcancel\n         * @listens Component#touchend\n         */\n        emitTapEvents() {\n            // Track the start time so we can determine how long the touch lasted\n            let touchStart = 0;\n            let firstTouch = null;\n\n            // Maximum movement allowed during a touch event to still be considered a tap\n            // Other popular libs use anywhere from 2 (hammer.js) to 15,\n            // so 10 seems like a nice, round number.\n            const tapMovementThreshold = 10;\n\n            // The maximum length a touch can be while still being considered a tap\n            const touchTimeThreshold = 200;\n            let couldBeTap;\n            this.on('touchstart', function (event) {\n                // If more than one finger, don't consider treating this as a click\n                if (event.touches.length === 1) {\n                    // Copy pageX/pageY from the object\n                    firstTouch = {\n                        pageX: event.touches[0].pageX,\n                        pageY: event.touches[0].pageY\n                    };\n                    // Record start time so we can detect a tap vs. \"touch and hold\"\n                    touchStart = window.performance.now();\n                    // Reset couldBeTap tracking\n                    couldBeTap = true;\n                }\n            });\n            this.on('touchmove', function (event) {\n                // If more than one finger, don't consider treating this as a click\n                if (event.touches.length > 1) {\n                    couldBeTap = false;\n                } else if (firstTouch) {\n                    // Some devices will throw touchmoves for all but the slightest of taps.\n                    // So, if we moved only a small distance, this could still be a tap\n                    const xdiff = event.touches[0].pageX - firstTouch.pageX;\n                    const ydiff = event.touches[0].pageY - firstTouch.pageY;\n                    const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n                    if (touchDistance > tapMovementThreshold) {\n                        couldBeTap = false;\n                    }\n                }\n            });\n            const noTap = function () {\n                couldBeTap = false;\n            };\n\n            // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n            this.on('touchleave', noTap);\n            this.on('touchcancel', noTap);\n\n            // When the touch ends, measure how long it took and trigger the appropriate\n            // event\n            this.on('touchend', function (event) {\n                firstTouch = null;\n                // Proceed only if the touchmove/leave/cancel event didn't happen\n                if (couldBeTap === true) {\n                    // Measure how long the touch lasted\n                    const touchTime = window.performance.now() - touchStart;\n\n                    // Make sure the touch was less than the threshold to be considered a tap\n                    if (touchTime < touchTimeThreshold) {\n                        // Don't let browser turn this into a click\n                        event.preventDefault();\n                        /**\n                         * Triggered when a `Component` is tapped.\n                         *\n                         * @event Component#tap\n                         * @type {MouseEvent}\n                         */\n                        this.trigger('tap');\n                        // It may be good to copy the touchend event object and change the\n                        // type to tap, if the other event properties aren't exact after\n                        // Events.fixEvent runs (e.g. event.target)\n                    }\n                }\n            });\n        }\n\n        /**\n         * This function reports user activity whenever touch events happen. This can get\n         * turned off by any sub-components that wants touch events to act another way.\n         *\n         * Report user touch activity when touch events occur. User activity gets used to\n         * determine when controls should show/hide. It is simple when it comes to mouse\n         * events, because any mouse event should show the controls. So we capture mouse\n         * events that bubble up to the player and report activity when that happens.\n         * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n         * controls. So touch events can't help us at the player level either.\n         *\n         * User activity gets checked asynchronously. So what could happen is a tap event\n         * on the video turns the controls off. Then the `touchend` event bubbles up to\n         * the player. Which, if it reported user activity, would turn the controls right\n         * back on. We also don't want to completely block touch events from bubbling up.\n         * Furthermore a `touchmove` event and anything other than a tap, should not turn\n         * controls back on.\n         *\n         * @listens Component#touchstart\n         * @listens Component#touchmove\n         * @listens Component#touchend\n         * @listens Component#touchcancel\n         */\n        enableTouchActivity() {\n            // Don't continue if the root player doesn't support reporting user activity\n            if (!this.player() || !this.player().reportUserActivity) {\n                return;\n            }\n\n            // listener for reporting that the user is active\n            const report = bind_(this.player(), this.player().reportUserActivity);\n            let touchHolding;\n            this.on('touchstart', function () {\n                report();\n                // For as long as the they are touching the device or have their mouse down,\n                // we consider them active even if they're not moving their finger or mouse.\n                // So we want to continue to update that they are active\n                this.clearInterval(touchHolding);\n                // report at the same interval as activityCheck\n                touchHolding = this.setInterval(report, 250);\n            });\n            const touchEnd = function (event) {\n                report();\n                // stop the interval that maintains activity if the touch is holding\n                this.clearInterval(touchHolding);\n            };\n            this.on('touchmove', report);\n            this.on('touchend', touchEnd);\n            this.on('touchcancel', touchEnd);\n        }\n\n        /**\n         * A callback that has no parameters and is bound into `Component`s context.\n         *\n         * @callback Component~GenericCallback\n         * @this Component\n         */\n\n        /**\n         * Creates a function that runs after an `x` millisecond timeout. This function is a\n         * wrapper around `window.setTimeout`. There are a few reasons to use this one\n         * instead though:\n         * 1. It gets cleared via  {@link Component#clearTimeout} when\n         *    {@link Component#dispose} gets called.\n         * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n         *\n         * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n         *         will cause its dispose listener not to get cleaned up! Please use\n         *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n         *\n         * @param {Component~GenericCallback} fn\n         *        The function that will be run after `timeout`.\n         *\n         * @param {number} timeout\n         *        Timeout in milliseconds to delay before executing the specified function.\n         *\n         * @return {number}\n         *         Returns a timeout ID that gets used to identify the timeout. It can also\n         *         get used in {@link Component#clearTimeout} to clear the timeout that\n         *         was set.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n         */\n        setTimeout(fn, timeout) {\n            // declare as variables so they are properly available in timeout function\n            // eslint-disable-next-line\n            var timeoutId;\n            fn = bind_(this, fn);\n            this.clearTimersOnDispose_();\n            timeoutId = window.setTimeout(() => {\n                if (this.setTimeoutIds_.has(timeoutId)) {\n                    this.setTimeoutIds_.delete(timeoutId);\n                }\n                fn();\n            }, timeout);\n            this.setTimeoutIds_.add(timeoutId);\n            return timeoutId;\n        }\n\n        /**\n         * Clears a timeout that gets created via `window.setTimeout` or\n         * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n         * use this function instead of `window.clearTimout`. If you don't your dispose\n         * listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} timeoutId\n         *        The id of the timeout to clear. The return value of\n         *        {@link Component#setTimeout} or `window.setTimeout`.\n         *\n         * @return {number}\n         *         Returns the timeout id that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n         */\n        clearTimeout(timeoutId) {\n            if (this.setTimeoutIds_.has(timeoutId)) {\n                this.setTimeoutIds_.delete(timeoutId);\n                window.clearTimeout(timeoutId);\n            }\n            return timeoutId;\n        }\n\n        /**\n         * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n         * around `window.setInterval`. There are a few reasons to use this one instead though.\n         * 1. It gets cleared via  {@link Component#clearInterval} when\n         *    {@link Component#dispose} gets called.\n         * 2. The function callback will be a {@link Component~GenericCallback}\n         *\n         * @param {Component~GenericCallback} fn\n         *        The function to run every `x` seconds.\n         *\n         * @param {number} interval\n         *        Execute the specified function every `x` milliseconds.\n         *\n         * @return {number}\n         *         Returns an id that can be used to identify the interval. It can also be be used in\n         *         {@link Component#clearInterval} to clear the interval.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n         */\n        setInterval(fn, interval) {\n            fn = bind_(this, fn);\n            this.clearTimersOnDispose_();\n            const intervalId = window.setInterval(fn, interval);\n            this.setIntervalIds_.add(intervalId);\n            return intervalId;\n        }\n\n        /**\n         * Clears an interval that gets created via `window.setInterval` or\n         * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}\n         * use this function instead of `window.clearInterval`. If you don't your dispose\n         * listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} intervalId\n         *        The id of the interval to clear. The return value of\n         *        {@link Component#setInterval} or `window.setInterval`.\n         *\n         * @return {number}\n         *         Returns the interval id that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n         */\n        clearInterval(intervalId) {\n            if (this.setIntervalIds_.has(intervalId)) {\n                this.setIntervalIds_.delete(intervalId);\n                window.clearInterval(intervalId);\n            }\n            return intervalId;\n        }\n\n        /**\n         * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n         * with a few extra bonuses:\n         *\n         * - Supports browsers that do not support rAF by falling back to\n         *   {@link Component#setTimeout}.\n         *\n         * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n         *   bound to the component).\n         *\n         * - Automatic cancellation of the rAF callback is handled if the component\n         *   is disposed before it is called.\n         *\n         * @param  {Component~GenericCallback} fn\n         *         A function that will be bound to this component and executed just\n         *         before the browser's next repaint.\n         *\n         * @return {number}\n         *         Returns an rAF ID that gets used to identify the timeout. It can\n         *         also be used in {@link Component#cancelAnimationFrame} to cancel\n         *         the animation frame callback.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n         */\n        requestAnimationFrame(fn) {\n            this.clearTimersOnDispose_();\n\n            // declare as variables so they are properly available in rAF function\n            // eslint-disable-next-line\n            var id;\n            fn = bind_(this, fn);\n            id = window.requestAnimationFrame(() => {\n                if (this.rafIds_.has(id)) {\n                    this.rafIds_.delete(id);\n                }\n                fn();\n            });\n            this.rafIds_.add(id);\n            return id;\n        }\n\n        /**\n         * Request an animation frame, but only one named animation\n         * frame will be queued. Another will never be added until\n         * the previous one finishes.\n         *\n         * @param {string} name\n         *        The name to give this requestAnimationFrame\n         *\n         * @param  {Component~GenericCallback} fn\n         *         A function that will be bound to this component and executed just\n         *         before the browser's next repaint.\n         */\n        requestNamedAnimationFrame(name, fn) {\n            if (this.namedRafs_.has(name)) {\n                return;\n            }\n            this.clearTimersOnDispose_();\n            fn = bind_(this, fn);\n            const id = this.requestAnimationFrame(() => {\n                fn();\n                if (this.namedRafs_.has(name)) {\n                    this.namedRafs_.delete(name);\n                }\n            });\n            this.namedRafs_.set(name, id);\n            return name;\n        }\n\n        /**\n         * Cancels a current named animation frame if it exists.\n         *\n         * @param {string} name\n         *        The name of the requestAnimationFrame to cancel.\n         */\n        cancelNamedAnimationFrame(name) {\n            if (!this.namedRafs_.has(name)) {\n                return;\n            }\n            this.cancelAnimationFrame(this.namedRafs_.get(name));\n            this.namedRafs_.delete(name);\n        }\n\n        /**\n         * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n         * (rAF).\n         *\n         * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n         * use this function instead of `window.cancelAnimationFrame`. If you don't,\n         * your dispose listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} id\n         *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n         *\n         * @return {number}\n         *         Returns the rAF ID that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n         */\n        cancelAnimationFrame(id) {\n            if (this.rafIds_.has(id)) {\n                this.rafIds_.delete(id);\n                window.cancelAnimationFrame(id);\n            }\n            return id;\n        }\n\n        /**\n         * A function to setup `requestAnimationFrame`, `setTimeout`,\n         * and `setInterval`, clearing on dispose.\n         *\n         * > Previously each timer added and removed dispose listeners on it's own.\n         * For better performance it was decided to batch them all, and use `Set`s\n         * to track outstanding timer ids.\n         *\n         * @private\n         */\n        clearTimersOnDispose_() {\n            if (this.clearingTimersOnDispose_) {\n                return;\n            }\n            this.clearingTimersOnDispose_ = true;\n            this.one('dispose', () => {\n                [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(([idName, cancelName]) => {\n                    // for a `Set` key will actually be the value again\n                    // so forEach((val, val) =>` but for maps we want to use\n                    // the key.\n                    this[idName].forEach((val, key) => this[cancelName](key));\n                });\n                this.clearingTimersOnDispose_ = false;\n            });\n        }\n\n        /**\n         * Register a `Component` with `videojs` given the name and the component.\n         *\n         * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n         *         should be registered using {@link Tech.registerTech} or\n         *         {@link videojs:videojs.registerTech}.\n         *\n         * > NOTE: This function can also be seen on videojs as\n         *         {@link videojs:videojs.registerComponent}.\n         *\n         * @param {string} name\n         *        The name of the `Component` to register.\n         *\n         * @param {Component} ComponentToRegister\n         *        The `Component` class to register.\n         *\n         * @return {Component}\n         *         The `Component` that was registered.\n         */\n        static registerComponent(name, ComponentToRegister) {\n            if (typeof name !== 'string' || !name) {\n                throw new Error(`Illegal component name, \"${name}\"; must be a non-empty string.`);\n            }\n            const Tech = Component$1.getComponent('Tech');\n\n            // We need to make sure this check is only done if Tech has been registered.\n            const isTech = Tech && Tech.isTech(ComponentToRegister);\n            const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);\n            if (isTech || !isComp) {\n                let reason;\n                if (isTech) {\n                    reason = 'techs must be registered using Tech.registerTech()';\n                } else {\n                    reason = 'must be a Component subclass';\n                }\n                throw new Error(`Illegal component, \"${name}\"; ${reason}.`);\n            }\n            name = toTitleCase$1(name);\n            if (!Component$1.components_) {\n                Component$1.components_ = {};\n            }\n            const Player = Component$1.getComponent('Player');\n            if (name === 'Player' && Player && Player.players) {\n                const players = Player.players;\n                const playerNames = Object.keys(players);\n\n                // If we have players that were disposed, then their name will still be\n                // in Players.players. So, we must loop through and verify that the value\n                // for each item is not null. This allows registration of the Player component\n                // after all players have been disposed or before any were created.\n                if (players && playerNames.length > 0 && playerNames.map(pname => players[pname]).every(Boolean)) {\n                    throw new Error('Can not register Player component after player has been created.');\n                }\n            }\n            Component$1.components_[name] = ComponentToRegister;\n            Component$1.components_[toLowerCase(name)] = ComponentToRegister;\n            return ComponentToRegister;\n        }\n\n        /**\n         * Get a `Component` based on the name it was registered with.\n         *\n         * @param {string} name\n         *        The Name of the component to get.\n         *\n         * @return {typeof Component}\n         *         The `Component` that got registered under the given name.\n         */\n        static getComponent(name) {\n            if (!name || !Component$1.components_) {\n                return;\n            }\n            return Component$1.components_[name];\n        }\n    }\n    Component$1.registerComponent('Component', Component$1);\n\n    /**\n     * @file time.js\n     * @module time\n     */\n\n    /**\n     * Returns the time for the specified index at the start or end\n     * of a TimeRange object.\n     *\n     * @typedef    {Function} TimeRangeIndex\n     *\n     * @param      {number} [index=0]\n     *             The range number to return the time for.\n     *\n     * @return     {number}\n     *             The time offset at the specified index.\n     *\n     * @deprecated The index argument must be provided.\n     *             In the future, leaving it out will throw an error.\n     */\n\n    /**\n     * An object that contains ranges of time, which mimics {@link TimeRanges}.\n     *\n     * @typedef  {Object} TimeRange\n     *\n     * @property {number} length\n     *           The number of time ranges represented by this object.\n     *\n     * @property {module:time~TimeRangeIndex} start\n     *           Returns the time offset at which a specified time range begins.\n     *\n     * @property {module:time~TimeRangeIndex} end\n     *           Returns the time offset at which a specified time range ends.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n     */\n\n    /**\n     * Check if any of the time ranges are over the maximum index.\n     *\n     * @private\n     * @param   {string} fnName\n     *          The function name to use for logging\n     *\n     * @param   {number} index\n     *          The index to check\n     *\n     * @param   {number} maxIndex\n     *          The maximum possible index\n     *\n     * @throws  {Error} if the timeRanges provided are over the maxIndex\n     */\n    function rangeCheck(fnName, index, maxIndex) {\n        if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n            throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);\n        }\n    }\n\n    /**\n     * Get the time for the specified index at the start or end\n     * of a TimeRange object.\n     *\n     * @private\n     * @param      {string} fnName\n     *             The function name to use for logging\n     *\n     * @param      {string} valueIndex\n     *             The property that should be used to get the time. should be\n     *             'start' or 'end'\n     *\n     * @param      {Array} ranges\n     *             An array of time ranges\n     *\n     * @param      {Array} [rangeIndex=0]\n     *             The index to start the search at\n     *\n     * @return     {number}\n     *             The time that offset at the specified index.\n     *\n     * @deprecated rangeIndex must be set to a value, in the future this will throw an error.\n     * @throws     {Error} if rangeIndex is more than the length of ranges\n     */\n    function getRange(fnName, valueIndex, ranges, rangeIndex) {\n        rangeCheck(fnName, rangeIndex, ranges.length - 1);\n        return ranges[rangeIndex][valueIndex];\n    }\n\n    /**\n     * Create a time range object given ranges of time.\n     *\n     * @private\n     * @param   {Array} [ranges]\n     *          An array of time ranges.\n     *\n     * @return  {TimeRange}\n     */\n    function createTimeRangesObj(ranges) {\n        let timeRangesObj;\n        if (ranges === undefined || ranges.length === 0) {\n            timeRangesObj = {\n                length: 0,\n                start() {\n                    throw new Error('This TimeRanges object is empty');\n                },\n                end() {\n                    throw new Error('This TimeRanges object is empty');\n                }\n            };\n        } else {\n            timeRangesObj = {\n                length: ranges.length,\n                start: getRange.bind(null, 'start', 0, ranges),\n                end: getRange.bind(null, 'end', 1, ranges)\n            };\n        }\n        if (window.Symbol && window.Symbol.iterator) {\n            timeRangesObj[window.Symbol.iterator] = () => (ranges || []).values();\n        }\n        return timeRangesObj;\n    }\n\n    /**\n     * Create a `TimeRange` object which mimics an\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.\n     *\n     * @param {number|Array[]} start\n     *        The start of a single range (a number) or an array of ranges (an\n     *        array of arrays of two numbers each).\n     *\n     * @param {number} end\n     *        The end of a single range. Cannot be used with the array form of\n     *        the `start` argument.\n     *\n     * @return {TimeRange}\n     */\n    function createTimeRanges$1(start, end) {\n        if (Array.isArray(start)) {\n            return createTimeRangesObj(start);\n        } else if (start === undefined || end === undefined) {\n            return createTimeRangesObj();\n        }\n        return createTimeRangesObj([[start, end]]);\n    }\n\n    /**\n     * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in\n     * seconds) will force a number of leading zeros to cover the length of the\n     * guide.\n     *\n     * @private\n     * @param  {number} seconds\n     *         Number of seconds to be turned into a string\n     *\n     * @param  {number} guide\n     *         Number (in seconds) to model the string after\n     *\n     * @return {string}\n     *         Time formatted as H:MM:SS or M:SS\n     */\n    const defaultImplementation = function (seconds, guide) {\n        seconds = seconds < 0 ? 0 : seconds;\n        let s = Math.floor(seconds % 60);\n        let m = Math.floor(seconds / 60 % 60);\n        let h = Math.floor(seconds / 3600);\n        const gm = Math.floor(guide / 60 % 60);\n        const gh = Math.floor(guide / 3600);\n\n        // handle invalid times\n        if (isNaN(seconds) || seconds === Infinity) {\n            // '-' is false for all relational operators (e.g. <, >=) so this setting\n            // will add the minimum number of fields specified by the guide\n            h = m = s = '-';\n        }\n\n        // Check if we need to show hours\n        h = h > 0 || gh > 0 ? h + ':' : '';\n\n        // If hours are showing, we may need to add a leading zero.\n        // Always show at least one digit of minutes.\n        m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n        // Check if leading zero is need for seconds\n        s = s < 10 ? '0' + s : s;\n        return h + m + s;\n    };\n\n    // Internal pointer to the current implementation.\n    let implementation = defaultImplementation;\n\n    /**\n     * Replaces the default formatTime implementation with a custom implementation.\n     *\n     * @param {Function} customImplementation\n     *        A function which will be used in place of the default formatTime\n     *        implementation. Will receive the current time in seconds and the\n     *        guide (in seconds) as arguments.\n     */\n    function setFormatTime(customImplementation) {\n        implementation = customImplementation;\n    }\n\n    /**\n     * Resets formatTime to the default implementation.\n     */\n    function resetFormatTime() {\n        implementation = defaultImplementation;\n    }\n\n    /**\n     * Delegates to either the default time formatting function or a custom\n     * function supplied via `setFormatTime`.\n     *\n     * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a\n     * guide (in seconds) will force a number of leading zeros to cover the\n     * length of the guide.\n     *\n     * @example  formatTime(125, 600) === \"02:05\"\n     * @param    {number} seconds\n     *           Number of seconds to be turned into a string\n     *\n     * @param    {number} guide\n     *           Number (in seconds) to model the string after\n     *\n     * @return   {string}\n     *           Time formatted as H:MM:SS or M:SS\n     */\n    function formatTime(seconds, guide = seconds) {\n        return implementation(seconds, guide);\n    }\n\n    var Time = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createTimeRanges: createTimeRanges$1,\n        createTimeRange: createTimeRanges$1,\n        setFormatTime: setFormatTime,\n        resetFormatTime: resetFormatTime,\n        formatTime: formatTime\n    });\n\n    /**\n     * @file buffer.js\n     * @module buffer\n     */\n\n    /**\n     * Compute the percentage of the media that has been buffered.\n     *\n     * @param { import('./time').TimeRange } buffered\n     *        The current `TimeRanges` object representing buffered time ranges\n     *\n     * @param {number} duration\n     *        Total duration of the media\n     *\n     * @return {number}\n     *         Percent buffered of the total duration in decimal form.\n     */\n    function bufferedPercent(buffered, duration) {\n        let bufferedDuration = 0;\n        let start;\n        let end;\n        if (!duration) {\n            return 0;\n        }\n        if (!buffered || !buffered.length) {\n            buffered = createTimeRanges$1(0, 0);\n        }\n        for (let i = 0; i < buffered.length; i++) {\n            start = buffered.start(i);\n            end = buffered.end(i);\n\n            // buffered end can be bigger than duration by a very small fraction\n            if (end > duration) {\n                end = duration;\n            }\n            bufferedDuration += end - start;\n        }\n        return bufferedDuration / duration;\n    }\n\n    /**\n     * @file media-error.js\n     */\n\n    /**\n     * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n     *\n     * @param {number|string|Object|MediaError} value\n     *        This can be of multiple types:\n     *        - number: should be a standard error code\n     *        - string: an error message (the code will be 0)\n     *        - Object: arbitrary properties\n     *        - `MediaError` (native): used to populate a video.js `MediaError` object\n     *        - `MediaError` (video.js): will return itself if it's already a\n     *          video.js `MediaError` object.\n     *\n     * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n     * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n     *\n     * @class MediaError\n     */\n    function MediaError(value) {\n        // Allow redundant calls to this constructor to avoid having `instanceof`\n        // checks peppered around the code.\n        if (value instanceof MediaError) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            this.code = value;\n        } else if (typeof value === 'string') {\n            // default code is zero, so this is a custom error\n            this.message = value;\n        } else if (isObject$1(value)) {\n            // We assign the `code` property manually because native `MediaError` objects\n            // do not expose it as an own/enumerable property of the object.\n            if (typeof value.code === 'number') {\n                this.code = value.code;\n            }\n            Object.assign(this, value);\n        }\n        if (!this.message) {\n            this.message = MediaError.defaultMessages[this.code] || '';\n        }\n    }\n\n    /**\n     * The error code that refers two one of the defined `MediaError` types\n     *\n     * @type {Number}\n     */\n    MediaError.prototype.code = 0;\n\n    /**\n     * An optional message that to show with the error. Message is not part of the HTML5\n     * video spec but allows for more informative custom errors.\n     *\n     * @type {String}\n     */\n    MediaError.prototype.message = '';\n\n    /**\n     * An optional status code that can be set by plugins to allow even more detail about\n     * the error. For example a plugin might provide a specific HTTP status code and an\n     * error message for that code. Then when the plugin gets that error this class will\n     * know how to display an error message for it. This allows a custom message to show\n     * up on the `Player` error overlay.\n     *\n     * @type {Array}\n     */\n    MediaError.prototype.status = null;\n\n    /**\n     * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n     * specification listed under {@link MediaError} for more information.\n     *\n     * @enum {array}\n     * @readonly\n     * @property {string} 0 - MEDIA_ERR_CUSTOM\n     * @property {string} 1 - MEDIA_ERR_ABORTED\n     * @property {string} 2 - MEDIA_ERR_NETWORK\n     * @property {string} 3 - MEDIA_ERR_DECODE\n     * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n     * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n     */\n    MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n    /**\n     * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n     *\n     * @type {Array}\n     * @constant\n     */\n    MediaError.defaultMessages = {\n        1: 'You aborted the media playback',\n        2: 'A network error caused the media download to fail part-way.',\n        3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n        4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n        5: 'The media is encrypted and we do not have the keys to decrypt it.'\n    };\n\n    // Add types as properties on MediaError\n    // e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n    for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n        MediaError[MediaError.errorTypes[errNum]] = errNum;\n        // values should be accessible on both the class and instance\n        MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n    }\n\n    var tuple = SafeParseTuple;\n    function SafeParseTuple(obj, reviver) {\n        var json;\n        var error = null;\n        try {\n            json = JSON.parse(obj, reviver);\n        } catch (err) {\n            error = err;\n        }\n        return [error, json];\n    }\n\n    /**\n     * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n     *\n     * @param  {Object}  value\n     *         An object that may or may not be `Promise`-like.\n     *\n     * @return {boolean}\n     *         Whether or not the object is `Promise`-like.\n     */\n    function isPromise(value) {\n        return value !== undefined && value !== null && typeof value.then === 'function';\n    }\n\n    /**\n     * Silence a Promise-like object.\n     *\n     * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n     * play promise\" rejection error messages.\n     *\n     * @param  {Object} value\n     *         An object that may or may not be `Promise`-like.\n     */\n    function silencePromise(value) {\n        if (isPromise(value)) {\n            value.then(null, e => {});\n        }\n    }\n\n    /**\n     * @file text-track-list-converter.js Utilities for capturing text track state and\n     * re-creating tracks based on a capture.\n     *\n     * @module text-track-list-converter\n     */\n\n    /**\n     * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n     * represents the {@link TextTrack}'s state.\n     *\n     * @param {TextTrack} track\n     *        The text track to query.\n     *\n     * @return {Object}\n     *         A serializable javascript representation of the TextTrack.\n     * @private\n     */\n    const trackToJson_ = function (track) {\n        const ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce((acc, prop, i) => {\n            if (track[prop]) {\n                acc[prop] = track[prop];\n            }\n            return acc;\n        }, {\n            cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n                return {\n                    startTime: cue.startTime,\n                    endTime: cue.endTime,\n                    text: cue.text,\n                    id: cue.id\n                };\n            })\n        });\n        return ret;\n    };\n\n    /**\n     * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n     * state of all {@link TextTrack}s currently configured. The return array is compatible with\n     * {@link text-track-list-converter:jsonToTextTracks}.\n     *\n     * @param { import('../tech/tech').default } tech\n     *        The tech object to query\n     *\n     * @return {Array}\n     *         A serializable javascript representation of the {@link Tech}s\n     *         {@link TextTrackList}.\n     */\n    const textTracksToJson = function (tech) {\n        const trackEls = tech.$$('track');\n        const trackObjs = Array.prototype.map.call(trackEls, t => t.track);\n        const tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n            const json = trackToJson_(trackEl.track);\n            if (trackEl.src) {\n                json.src = trackEl.src;\n            }\n            return json;\n        });\n        return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n            return trackObjs.indexOf(track) === -1;\n        }).map(trackToJson_));\n    };\n\n    /**\n     * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n     * object {@link TextTrack} representations.\n     *\n     * @param {Array} json\n     *        An array of `TextTrack` representation objects, like those that would be\n     *        produced by `textTracksToJson`.\n     *\n     * @param {Tech} tech\n     *        The `Tech` to create the `TextTrack`s on.\n     */\n    const jsonToTextTracks = function (json, tech) {\n        json.forEach(function (track) {\n            const addedTrack = tech.addRemoteTextTrack(track).track;\n            if (!track.src && track.cues) {\n                track.cues.forEach(cue => addedTrack.addCue(cue));\n            }\n        });\n        return tech.textTracks();\n    };\n    var textTrackConverter = {\n        textTracksToJson,\n        jsonToTextTracks,\n        trackToJson_\n    };\n\n    /**\n     * @file modal-dialog.js\n     */\n    const MODAL_CLASS_NAME = 'vjs-modal-dialog';\n\n    /**\n     * The `ModalDialog` displays over the video and its controls, which blocks\n     * interaction with the player until it is closed.\n     *\n     * Modal dialogs include a \"Close\" button and will close when that button\n     * is activated - or when ESC is pressed anywhere.\n     *\n     * @extends Component\n     */\n    class ModalDialog extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param { import('./utils/dom').ContentDescriptor} [options.content=undefined]\n         *        Provide customized content for this modal.\n         *\n         * @param {string} [options.description]\n         *        A text description for the modal, primarily for accessibility.\n         *\n         * @param {boolean} [options.fillAlways=false]\n         *        Normally, modals are automatically filled only the first time\n         *        they open. This tells the modal to refresh its content\n         *        every time it opens.\n         *\n         * @param {string} [options.label]\n         *        A text label for the modal, primarily for accessibility.\n         *\n         * @param {boolean} [options.pauseOnOpen=true]\n         *        If `true`, playback will will be paused if playing when\n         *        the modal opens, and resumed when it closes.\n         *\n         * @param {boolean} [options.temporary=true]\n         *        If `true`, the modal can only be opened once; it will be\n         *        disposed as soon as it's closed.\n         *\n         * @param {boolean} [options.uncloseable=false]\n         *        If `true`, the user will not be able to close the modal\n         *        through the UI in the normal ways. Programmatic closing is\n         *        still possible.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.close_ = e => this.close(e);\n            this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;\n            this.closeable(!this.options_.uncloseable);\n            this.content(this.options_.content);\n\n            // Make sure the contentEl is defined AFTER any children are initialized\n            // because we only want the contents of the modal in the contentEl\n            // (not the UI elements like the close button).\n            this.contentEl_ = createEl('div', {\n                className: `${MODAL_CLASS_NAME}-content`\n            }, {\n                role: 'document'\n            });\n            this.descEl_ = createEl('p', {\n                className: `${MODAL_CLASS_NAME}-description vjs-control-text`,\n                id: this.el().getAttribute('aria-describedby')\n            });\n            textContent(this.descEl_, this.description());\n            this.el_.appendChild(this.descEl_);\n            this.el_.appendChild(this.contentEl_);\n        }\n\n        /**\n         * Create the `ModalDialog`'s DOM element\n         *\n         * @return {Element}\n         *         The DOM element that gets created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildCSSClass(),\n                tabIndex: -1\n            }, {\n                'aria-describedby': `${this.id()}_description`,\n                'aria-hidden': 'true',\n                'aria-label': this.label(),\n                'role': 'dialog'\n            });\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.descEl_ = null;\n            this.previouslyActiveEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Returns the label string for this modal. Primarily used for accessibility.\n         *\n         * @return {string}\n         *         the localized or raw label of this modal.\n         */\n        label() {\n            return this.localize(this.options_.label || 'Modal Window');\n        }\n\n        /**\n         * Returns the description string for this modal. Primarily used for\n         * accessibility.\n         *\n         * @return {string}\n         *         The localized or raw description of this modal.\n         */\n        description() {\n            let desc = this.options_.description || this.localize('This is a modal window.');\n\n            // Append a universal closeability message if the modal is closeable.\n            if (this.closeable()) {\n                desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n            }\n            return desc;\n        }\n\n        /**\n         * Opens the modal.\n         *\n         * @fires ModalDialog#beforemodalopen\n         * @fires ModalDialog#modalopen\n         */\n        open() {\n            if (!this.opened_) {\n                const player = this.player();\n\n                /**\n                 * Fired just before a `ModalDialog` is opened.\n                 *\n                 * @event ModalDialog#beforemodalopen\n                 * @type {Event}\n                 */\n                this.trigger('beforemodalopen');\n                this.opened_ = true;\n\n                // Fill content if the modal has never opened before and\n                // never been filled.\n                if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n                    this.fill();\n                }\n\n                // If the player was playing, pause it and take note of its previously\n                // playing state.\n                this.wasPlaying_ = !player.paused();\n                if (this.options_.pauseOnOpen && this.wasPlaying_) {\n                    player.pause();\n                }\n                this.on('keydown', this.handleKeyDown_);\n\n                // Hide controls and note if they were enabled.\n                this.hadControls_ = player.controls();\n                player.controls(false);\n                this.show();\n                this.conditionalFocus_();\n                this.el().setAttribute('aria-hidden', 'false');\n\n                /**\n                 * Fired just after a `ModalDialog` is opened.\n                 *\n                 * @event ModalDialog#modalopen\n                 * @type {Event}\n                 */\n                this.trigger('modalopen');\n                this.hasBeenOpened_ = true;\n            }\n        }\n\n        /**\n         * If the `ModalDialog` is currently open or closed.\n         *\n         * @param  {boolean} [value]\n         *         If given, it will open (`true`) or close (`false`) the modal.\n         *\n         * @return {boolean}\n         *         the current open state of the modaldialog\n         */\n        opened(value) {\n            if (typeof value === 'boolean') {\n                this[value ? 'open' : 'close']();\n            }\n            return this.opened_;\n        }\n\n        /**\n         * Closes the modal, does nothing if the `ModalDialog` is\n         * not open.\n         *\n         * @fires ModalDialog#beforemodalclose\n         * @fires ModalDialog#modalclose\n         */\n        close() {\n            if (!this.opened_) {\n                return;\n            }\n            const player = this.player();\n\n            /**\n             * Fired just before a `ModalDialog` is closed.\n             *\n             * @event ModalDialog#beforemodalclose\n             * @type {Event}\n             */\n            this.trigger('beforemodalclose');\n            this.opened_ = false;\n            if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n                player.play();\n            }\n            this.off('keydown', this.handleKeyDown_);\n            if (this.hadControls_) {\n                player.controls(true);\n            }\n            this.hide();\n            this.el().setAttribute('aria-hidden', 'true');\n\n            /**\n             * Fired just after a `ModalDialog` is closed.\n             *\n             * @event ModalDialog#modalclose\n             * @type {Event}\n             */\n            this.trigger('modalclose');\n            this.conditionalBlur_();\n            if (this.options_.temporary) {\n                this.dispose();\n            }\n        }\n\n        /**\n         * Check to see if the `ModalDialog` is closeable via the UI.\n         *\n         * @param  {boolean} [value]\n         *         If given as a boolean, it will set the `closeable` option.\n         *\n         * @return {boolean}\n         *         Returns the final value of the closable option.\n         */\n        closeable(value) {\n            if (typeof value === 'boolean') {\n                const closeable = this.closeable_ = !!value;\n                let close = this.getChild('closeButton');\n\n                // If this is being made closeable and has no close button, add one.\n                if (closeable && !close) {\n                    // The close button should be a child of the modal - not its\n                    // content element, so temporarily change the content element.\n                    const temp = this.contentEl_;\n                    this.contentEl_ = this.el_;\n                    close = this.addChild('closeButton', {\n                        controlText: 'Close Modal Dialog'\n                    });\n                    this.contentEl_ = temp;\n                    this.on(close, 'close', this.close_);\n                }\n\n                // If this is being made uncloseable and has a close button, remove it.\n                if (!closeable && close) {\n                    this.off(close, 'close', this.close_);\n                    this.removeChild(close);\n                    close.dispose();\n                }\n            }\n            return this.closeable_;\n        }\n\n        /**\n         * Fill the modal's content element with the modal's \"content\" option.\n         * The content element will be emptied before this change takes place.\n         */\n        fill() {\n            this.fillWith(this.content());\n        }\n\n        /**\n         * Fill the modal's content element with arbitrary content.\n         * The content element will be emptied before this change takes place.\n         *\n         * @fires ModalDialog#beforemodalfill\n         * @fires ModalDialog#modalfill\n         *\n         * @param { import('./utils/dom').ContentDescriptor} [content]\n         *        The same rules apply to this as apply to the `content` option.\n         */\n        fillWith(content) {\n            const contentEl = this.contentEl();\n            const parentEl = contentEl.parentNode;\n            const nextSiblingEl = contentEl.nextSibling;\n\n            /**\n             * Fired just before a `ModalDialog` is filled with content.\n             *\n             * @event ModalDialog#beforemodalfill\n             * @type {Event}\n             */\n            this.trigger('beforemodalfill');\n            this.hasBeenFilled_ = true;\n\n            // Detach the content element from the DOM before performing\n            // manipulation to avoid modifying the live DOM multiple times.\n            parentEl.removeChild(contentEl);\n            this.empty();\n            insertContent(contentEl, content);\n            /**\n             * Fired just after a `ModalDialog` is filled with content.\n             *\n             * @event ModalDialog#modalfill\n             * @type {Event}\n             */\n            this.trigger('modalfill');\n\n            // Re-inject the re-filled content element.\n            if (nextSiblingEl) {\n                parentEl.insertBefore(contentEl, nextSiblingEl);\n            } else {\n                parentEl.appendChild(contentEl);\n            }\n\n            // make sure that the close button is last in the dialog DOM\n            const closeButton = this.getChild('closeButton');\n            if (closeButton) {\n                parentEl.appendChild(closeButton.el_);\n            }\n        }\n\n        /**\n         * Empties the content element. This happens anytime the modal is filled.\n         *\n         * @fires ModalDialog#beforemodalempty\n         * @fires ModalDialog#modalempty\n         */\n        empty() {\n            /**\n             * Fired just before a `ModalDialog` is emptied.\n             *\n             * @event ModalDialog#beforemodalempty\n             * @type {Event}\n             */\n            this.trigger('beforemodalempty');\n            emptyEl(this.contentEl());\n\n            /**\n             * Fired just after a `ModalDialog` is emptied.\n             *\n             * @event ModalDialog#modalempty\n             * @type {Event}\n             */\n            this.trigger('modalempty');\n        }\n\n        /**\n         * Gets or sets the modal content, which gets normalized before being\n         * rendered into the DOM.\n         *\n         * This does not update the DOM or fill the modal, but it is called during\n         * that process.\n         *\n         * @param  { import('./utils/dom').ContentDescriptor} [value]\n         *         If defined, sets the internal content value to be used on the\n         *         next call(s) to `fill`. This value is normalized before being\n         *         inserted. To \"clear\" the internal content value, pass `null`.\n         *\n         * @return { import('./utils/dom').ContentDescriptor}\n         *         The current content of the modal dialog\n         */\n        content(value) {\n            if (typeof value !== 'undefined') {\n                this.content_ = value;\n            }\n            return this.content_;\n        }\n\n        /**\n         * conditionally focus the modal dialog if focus was previously on the player.\n         *\n         * @private\n         */\n        conditionalFocus_() {\n            const activeEl = document.activeElement;\n            const playerEl = this.player_.el_;\n            this.previouslyActiveEl_ = null;\n            if (playerEl.contains(activeEl) || playerEl === activeEl) {\n                this.previouslyActiveEl_ = activeEl;\n                this.focus();\n            }\n        }\n\n        /**\n         * conditionally blur the element and refocus the last focused element\n         *\n         * @private\n         */\n        conditionalBlur_() {\n            if (this.previouslyActiveEl_) {\n                this.previouslyActiveEl_.focus();\n                this.previouslyActiveEl_ = null;\n            }\n        }\n\n        /**\n         * Keydown handler. Attached when modal is focused.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Do not allow keydowns to reach out of the modal dialog.\n            event.stopPropagation();\n            if (keycode.isEventKey(event, 'Escape') && this.closeable()) {\n                event.preventDefault();\n                this.close();\n                return;\n            }\n\n            // exit early if it isn't a tab key\n            if (!keycode.isEventKey(event, 'Tab')) {\n                return;\n            }\n            const focusableEls = this.focusableEls_();\n            const activeEl = this.el_.querySelector(':focus');\n            let focusIndex;\n            for (let i = 0; i < focusableEls.length; i++) {\n                if (activeEl === focusableEls[i]) {\n                    focusIndex = i;\n                    break;\n                }\n            }\n            if (document.activeElement === this.el_) {\n                focusIndex = 0;\n            }\n            if (event.shiftKey && focusIndex === 0) {\n                focusableEls[focusableEls.length - 1].focus();\n                event.preventDefault();\n            } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n                focusableEls[0].focus();\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * get all focusable elements\n         *\n         * @private\n         */\n        focusableEls_() {\n            const allChildren = this.el_.querySelectorAll('*');\n            return Array.prototype.filter.call(allChildren, child => {\n                return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n            });\n        }\n    }\n\n    /**\n     * Default options for `ModalDialog` default options.\n     *\n     * @type {Object}\n     * @private\n     */\n    ModalDialog.prototype.options_ = {\n        pauseOnOpen: true,\n        temporary: true\n    };\n    Component$1.registerComponent('ModalDialog', ModalDialog);\n\n    /**\n     * @file track-list.js\n     */\n\n    /**\n     * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n     * {@link VideoTrackList}\n     *\n     * @extends EventTarget\n     */\n    class TrackList extends EventTarget$2 {\n        /**\n         * Create an instance of this class\n         *\n         * @param { import('./track').default[] } tracks\n         *        A list of tracks to initialize the list with.\n         *\n         * @abstract\n         */\n        constructor(tracks = []) {\n            super();\n            this.tracks_ = [];\n\n            /**\n             * @memberof TrackList\n             * @member {number} length\n             *         The current number of `Track`s in the this Trackist.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.tracks_.length;\n                }\n            });\n            for (let i = 0; i < tracks.length; i++) {\n                this.addTrack(tracks[i]);\n            }\n        }\n\n        /**\n         * Add a {@link Track} to the `TrackList`\n         *\n         * @param { import('./track').default } track\n         *        The audio, video, or text track to add to the list.\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            const index = this.tracks_.length;\n            if (!('' + index in this)) {\n                Object.defineProperty(this, index, {\n                    get() {\n                        return this.tracks_[index];\n                    }\n                });\n            }\n\n            // Do not add duplicate tracks\n            if (this.tracks_.indexOf(track) === -1) {\n                this.tracks_.push(track);\n                /**\n                 * Triggered when a track is added to a track list.\n                 *\n                 * @event TrackList#addtrack\n                 * @type {Event}\n                 * @property {Track} track\n                 *           A reference to track that was added.\n                 */\n                this.trigger({\n                    track,\n                    type: 'addtrack',\n                    target: this\n                });\n            }\n\n            /**\n             * Triggered when a track label is changed.\n             *\n             * @event TrackList#addtrack\n             * @type {Event}\n             * @property {Track} track\n             *           A reference to track that was added.\n             */\n            track.labelchange_ = () => {\n                this.trigger({\n                    track,\n                    type: 'labelchange',\n                    target: this\n                });\n            };\n            if (isEvented(track)) {\n                track.addEventListener('labelchange', track.labelchange_);\n            }\n        }\n\n        /**\n         * Remove a {@link Track} from the `TrackList`\n         *\n         * @param { import('./track').default } rtrack\n         *        The audio, video, or text track to remove from the list.\n         *\n         * @fires TrackList#removetrack\n         */\n        removeTrack(rtrack) {\n            let track;\n            for (let i = 0, l = this.length; i < l; i++) {\n                if (this[i] === rtrack) {\n                    track = this[i];\n                    if (track.off) {\n                        track.off();\n                    }\n                    this.tracks_.splice(i, 1);\n                    break;\n                }\n            }\n            if (!track) {\n                return;\n            }\n\n            /**\n             * Triggered when a track is removed from track list.\n             *\n             * @event TrackList#removetrack\n             * @type {Event}\n             * @property {Track} track\n             *           A reference to track that was removed.\n             */\n            this.trigger({\n                track,\n                type: 'removetrack',\n                target: this\n            });\n        }\n\n        /**\n         * Get a Track from the TrackList by a tracks id\n         *\n         * @param {string} id - the id of the track to get\n         * @method getTrackById\n         * @return { import('./track').default }\n         * @private\n         */\n        getTrackById(id) {\n            let result = null;\n            for (let i = 0, l = this.length; i < l; i++) {\n                const track = this[i];\n                if (track.id === id) {\n                    result = track;\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Triggered when a different track is selected/enabled.\n     *\n     * @event TrackList#change\n     * @type {Event}\n     */\n\n    /**\n     * Events that can be called with on + eventName. See {@link EventHandler}.\n     *\n     * @property {Object} TrackList#allowedEvents_\n     * @protected\n     */\n    TrackList.prototype.allowedEvents_ = {\n        change: 'change',\n        addtrack: 'addtrack',\n        removetrack: 'removetrack',\n        labelchange: 'labelchange'\n    };\n\n    // emulate attribute EventHandler support to allow for feature detection\n    for (const event in TrackList.prototype.allowedEvents_) {\n        TrackList.prototype['on' + event] = null;\n    }\n\n    /**\n     * @file audio-track-list.js\n     */\n\n    /**\n     * Anywhere we call this function we diverge from the spec\n     * as we only support one enabled audiotrack at a time\n     *\n     * @param {AudioTrackList} list\n     *        list to work on\n     *\n     * @param { import('./audio-track').default } track\n     *        The track to skip\n     *\n     * @private\n     */\n    const disableOthers$1 = function (list, track) {\n        for (let i = 0; i < list.length; i++) {\n            if (!Object.keys(list[i]).length || track.id === list[i].id) {\n                continue;\n            }\n            // another audio track is enabled, disable it\n            list[i].enabled = false;\n        }\n    };\n\n    /**\n     * The current list of {@link AudioTrack} for a media file.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n     * @extends TrackList\n     */\n    class AudioTrackList extends TrackList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('./audio-track').default[] } [tracks=[]]\n         *        A list of `AudioTrack` to instantiate the list with.\n         */\n        constructor(tracks = []) {\n            // make sure only 1 track is enabled\n            // sorted from last index to first index\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                if (tracks[i].enabled) {\n                    disableOthers$1(tracks, tracks[i]);\n                    break;\n                }\n            }\n            super(tracks);\n            this.changing_ = false;\n        }\n\n        /**\n         * Add an {@link AudioTrack} to the `AudioTrackList`.\n         *\n         * @param { import('./audio-track').default } track\n         *        The AudioTrack to add to the list\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            if (track.enabled) {\n                disableOthers$1(this, track);\n            }\n            super.addTrack(track);\n            // native tracks don't have this\n            if (!track.addEventListener) {\n                return;\n            }\n            track.enabledChange_ = () => {\n                // when we are disabling other tracks (since we don't support\n                // more than one track at a time) we will set changing_\n                // to true so that we don't trigger additional change events\n                if (this.changing_) {\n                    return;\n                }\n                this.changing_ = true;\n                disableOthers$1(this, track);\n                this.changing_ = false;\n                this.trigger('change');\n            };\n\n            /**\n             * @listens AudioTrack#enabledchange\n             * @fires TrackList#change\n             */\n            track.addEventListener('enabledchange', track.enabledChange_);\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n            if (rtrack.removeEventListener && rtrack.enabledChange_) {\n                rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);\n                rtrack.enabledChange_ = null;\n            }\n        }\n    }\n\n    /**\n     * @file video-track-list.js\n     */\n\n    /**\n     * Un-select all other {@link VideoTrack}s that are selected.\n     *\n     * @param {VideoTrackList} list\n     *        list to work on\n     *\n     * @param { import('./video-track').default } track\n     *        The track to skip\n     *\n     * @private\n     */\n    const disableOthers = function (list, track) {\n        for (let i = 0; i < list.length; i++) {\n            if (!Object.keys(list[i]).length || track.id === list[i].id) {\n                continue;\n            }\n            // another video track is enabled, disable it\n            list[i].selected = false;\n        }\n    };\n\n    /**\n     * The current list of {@link VideoTrack} for a video.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n     * @extends TrackList\n     */\n    class VideoTrackList extends TrackList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {VideoTrack[]} [tracks=[]]\n         *        A list of `VideoTrack` to instantiate the list with.\n         */\n        constructor(tracks = []) {\n            // make sure only 1 track is enabled\n            // sorted from last index to first index\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                if (tracks[i].selected) {\n                    disableOthers(tracks, tracks[i]);\n                    break;\n                }\n            }\n            super(tracks);\n            this.changing_ = false;\n\n            /**\n             * @member {number} VideoTrackList#selectedIndex\n             *         The current index of the selected {@link VideoTrack`}.\n             */\n            Object.defineProperty(this, 'selectedIndex', {\n                get() {\n                    for (let i = 0; i < this.length; i++) {\n                        if (this[i].selected) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                },\n                set() {}\n            });\n        }\n\n        /**\n         * Add a {@link VideoTrack} to the `VideoTrackList`.\n         *\n         * @param { import('./video-track').default } track\n         *        The VideoTrack to add to the list\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            if (track.selected) {\n                disableOthers(this, track);\n            }\n            super.addTrack(track);\n            // native tracks don't have this\n            if (!track.addEventListener) {\n                return;\n            }\n            track.selectedChange_ = () => {\n                if (this.changing_) {\n                    return;\n                }\n                this.changing_ = true;\n                disableOthers(this, track);\n                this.changing_ = false;\n                this.trigger('change');\n            };\n\n            /**\n             * @listens VideoTrack#selectedchange\n             * @fires TrackList#change\n             */\n            track.addEventListener('selectedchange', track.selectedChange_);\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n            if (rtrack.removeEventListener && rtrack.selectedChange_) {\n                rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);\n                rtrack.selectedChange_ = null;\n            }\n        }\n    }\n\n    /**\n     * @file text-track-list.js\n     */\n\n    /**\n     * The current list of {@link TextTrack} for a media file.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n     * @extends TrackList\n     */\n    class TextTrackList extends TrackList {\n        /**\n         * Add a {@link TextTrack} to the `TextTrackList`\n         *\n         * @param { import('./text-track').default } track\n         *        The text track to add to the list.\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            super.addTrack(track);\n            if (!this.queueChange_) {\n                this.queueChange_ = () => this.queueTrigger('change');\n            }\n            if (!this.triggerSelectedlanguagechange) {\n                this.triggerSelectedlanguagechange_ = () => this.trigger('selectedlanguagechange');\n            }\n\n            /**\n             * @listens TextTrack#modechange\n             * @fires TrackList#change\n             */\n            track.addEventListener('modechange', this.queueChange_);\n            const nonLanguageTextTrackKind = ['metadata', 'chapters'];\n            if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n                track.addEventListener('modechange', this.triggerSelectedlanguagechange_);\n            }\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n\n            // manually remove the event handlers we added\n            if (rtrack.removeEventListener) {\n                if (this.queueChange_) {\n                    rtrack.removeEventListener('modechange', this.queueChange_);\n                }\n                if (this.selectedlanguagechange_) {\n                    rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);\n                }\n            }\n        }\n    }\n\n    /**\n     * @file html-track-element-list.js\n     */\n\n    /**\n     * The current list of {@link HtmlTrackElement}s.\n     */\n    class HtmlTrackElementList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {HtmlTrackElement[]} [tracks=[]]\n         *        A list of `HtmlTrackElement` to instantiate the list with.\n         */\n        constructor(trackElements = []) {\n            this.trackElements_ = [];\n\n            /**\n             * @memberof HtmlTrackElementList\n             * @member {number} length\n             *         The current number of `Track`s in the this Trackist.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.trackElements_.length;\n                }\n            });\n            for (let i = 0, length = trackElements.length; i < length; i++) {\n                this.addTrackElement_(trackElements[i]);\n            }\n        }\n\n        /**\n         * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n         *\n         * @param {HtmlTrackElement} trackElement\n         *        The track element to add to the list.\n         *\n         * @private\n         */\n        addTrackElement_(trackElement) {\n            const index = this.trackElements_.length;\n            if (!('' + index in this)) {\n                Object.defineProperty(this, index, {\n                    get() {\n                        return this.trackElements_[index];\n                    }\n                });\n            }\n\n            // Do not add duplicate elements\n            if (this.trackElements_.indexOf(trackElement) === -1) {\n                this.trackElements_.push(trackElement);\n            }\n        }\n\n        /**\n         * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n         * {@link TextTrack}.\n         *\n         * @param {TextTrack} track\n         *        The track associated with a track element.\n         *\n         * @return {HtmlTrackElement|undefined}\n         *         The track element that was found or undefined.\n         *\n         * @private\n         */\n        getTrackElementByTrack_(track) {\n            let trackElement_;\n            for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n                if (track === this.trackElements_[i].track) {\n                    trackElement_ = this.trackElements_[i];\n                    break;\n                }\n            }\n            return trackElement_;\n        }\n\n        /**\n         * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n         *\n         * @param {HtmlTrackElement} trackElement\n         *        The track element to remove from the list.\n         *\n         * @private\n         */\n        removeTrackElement_(trackElement) {\n            for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n                if (trackElement === this.trackElements_[i]) {\n                    if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {\n                        this.trackElements_[i].track.off();\n                    }\n                    if (typeof this.trackElements_[i].off === 'function') {\n                        this.trackElements_[i].off();\n                    }\n                    this.trackElements_.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @file text-track-cue-list.js\n     */\n\n    /**\n     * @typedef {Object} TextTrackCueList~TextTrackCue\n     *\n     * @property {string} id\n     *           The unique id for this text track cue\n     *\n     * @property {number} startTime\n     *           The start time for this text track cue\n     *\n     * @property {number} endTime\n     *           The end time for this text track cue\n     *\n     * @property {boolean} pauseOnExit\n     *           Pause when the end time is reached if true.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n     */\n\n    /**\n     * A List of TextTrackCues.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n     */\n    class TextTrackCueList {\n        /**\n         * Create an instance of this class..\n         *\n         * @param {Array} cues\n         *        A list of cues to be initialized with\n         */\n        constructor(cues) {\n            TextTrackCueList.prototype.setCues_.call(this, cues);\n\n            /**\n             * @memberof TextTrackCueList\n             * @member {number} length\n             *         The current number of `TextTrackCue`s in the TextTrackCueList.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.length_;\n                }\n            });\n        }\n\n        /**\n         * A setter for cues in this list. Creates getters\n         * an an index for the cues.\n         *\n         * @param {Array} cues\n         *        An array of cues to set\n         *\n         * @private\n         */\n        setCues_(cues) {\n            const oldLength = this.length || 0;\n            let i = 0;\n            const l = cues.length;\n            this.cues_ = cues;\n            this.length_ = cues.length;\n            const defineProp = function (index) {\n                if (!('' + index in this)) {\n                    Object.defineProperty(this, '' + index, {\n                        get() {\n                            return this.cues_[index];\n                        }\n                    });\n                }\n            };\n            if (oldLength < l) {\n                i = oldLength;\n                for (; i < l; i++) {\n                    defineProp.call(this, i);\n                }\n            }\n        }\n\n        /**\n         * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n         *\n         * @param {string} id\n         *        The id of the cue that should be searched for.\n         *\n         * @return {TextTrackCueList~TextTrackCue|null}\n         *         A single cue or null if none was found.\n         */\n        getCueById(id) {\n            let result = null;\n            for (let i = 0, l = this.length; i < l; i++) {\n                const cue = this[i];\n                if (cue.id === id) {\n                    result = cue;\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @file track-kinds.js\n     */\n\n    /**\n     * All possible `VideoTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n     * @typedef VideoTrack~Kind\n     * @enum\n     */\n    const VideoTrackKind = {\n        alternative: 'alternative',\n        captions: 'captions',\n        main: 'main',\n        sign: 'sign',\n        subtitles: 'subtitles',\n        commentary: 'commentary'\n    };\n\n    /**\n     * All possible `AudioTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n     * @typedef AudioTrack~Kind\n     * @enum\n     */\n    const AudioTrackKind = {\n        'alternative': 'alternative',\n        'descriptions': 'descriptions',\n        'main': 'main',\n        'main-desc': 'main-desc',\n        'translation': 'translation',\n        'commentary': 'commentary'\n    };\n\n    /**\n     * All possible `TextTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n     * @typedef TextTrack~Kind\n     * @enum\n     */\n    const TextTrackKind = {\n        subtitles: 'subtitles',\n        captions: 'captions',\n        descriptions: 'descriptions',\n        chapters: 'chapters',\n        metadata: 'metadata'\n    };\n\n    /**\n     * All possible `TextTrackMode`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n     * @typedef TextTrack~Mode\n     * @enum\n     */\n    const TextTrackMode = {\n        disabled: 'disabled',\n        hidden: 'hidden',\n        showing: 'showing'\n    };\n\n    /**\n     * @file track.js\n     */\n\n    /**\n     * A Track class that contains all of the common functionality for {@link AudioTrack},\n     * {@link VideoTrack}, and {@link TextTrack}.\n     *\n     * > Note: This class should not be used directly\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n     * @extends EventTarget\n     * @abstract\n     */\n    class Track extends EventTarget$2 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {string} [options.kind='']\n         *        A valid kind for the track type you are creating.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @abstract\n         */\n        constructor(options = {}) {\n            super();\n            const trackProps = {\n                id: options.id || 'vjs_track_' + newGUID(),\n                kind: options.kind || '',\n                language: options.language || ''\n            };\n            let label = options.label || '';\n\n            /**\n             * @memberof Track\n             * @member {string} id\n             *         The id of this track. Cannot be changed after creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            /**\n             * @memberof Track\n             * @member {string} kind\n             *         The kind of track that this is. Cannot be changed after creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            /**\n             * @memberof Track\n             * @member {string} language\n             *         The two letter language code for this track. Cannot be changed after\n             *         creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            for (const key in trackProps) {\n                Object.defineProperty(this, key, {\n                    get() {\n                        return trackProps[key];\n                    },\n                    set() {}\n                });\n            }\n\n            /**\n             * @memberof Track\n             * @member {string} label\n             *         The label of this track. Cannot be changed after creation.\n             * @instance\n             *\n             * @fires Track#labelchange\n             */\n            Object.defineProperty(this, 'label', {\n                get() {\n                    return label;\n                },\n                set(newLabel) {\n                    if (newLabel !== label) {\n                        label = newLabel;\n\n                        /**\n                         * An event that fires when label changes on this track.\n                         *\n                         * > Note: This is not part of the spec!\n                         *\n                         * @event Track#labelchange\n                         * @type {Event}\n                         */\n                        this.trigger('labelchange');\n                    }\n                }\n            });\n        }\n    }\n\n    /**\n     * @file url.js\n     * @module url\n     */\n\n    /**\n     * @typedef {Object} url:URLObject\n     *\n     * @property {string} protocol\n     *           The protocol of the url that was parsed.\n     *\n     * @property {string} hostname\n     *           The hostname of the url that was parsed.\n     *\n     * @property {string} port\n     *           The port of the url that was parsed.\n     *\n     * @property {string} pathname\n     *           The pathname of the url that was parsed.\n     *\n     * @property {string} search\n     *           The search query of the url that was parsed.\n     *\n     * @property {string} hash\n     *           The hash of the url that was parsed.\n     *\n     * @property {string} host\n     *           The host of the url that was parsed.\n     */\n\n    /**\n     * Resolve and parse the elements of a URL.\n     *\n     * @function\n     * @param    {String} url\n     *           The url to parse\n     *\n     * @return   {url:URLObject}\n     *           An object of url details\n     */\n    const parseUrl = function (url) {\n        // This entire method can be replace with URL once we are able to drop IE11\n\n        const props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n        // add the url to an anchor and let the browser parse the URL\n        const a = document.createElement('a');\n        a.href = url;\n\n        // Copy the specific URL properties to a new object\n        // This is also needed for IE because the anchor loses its\n        // properties when it's removed from the dom\n        const details = {};\n        for (let i = 0; i < props.length; i++) {\n            details[props[i]] = a[props[i]];\n        }\n\n        // IE adds the port to the host property unlike everyone else. If\n        // a port identifier is added for standard ports, strip it.\n        if (details.protocol === 'http:') {\n            details.host = details.host.replace(/:80$/, '');\n        }\n        if (details.protocol === 'https:') {\n            details.host = details.host.replace(/:443$/, '');\n        }\n        if (!details.protocol) {\n            details.protocol = window.location.protocol;\n        }\n\n        /* istanbul ignore if */\n        if (!details.host) {\n            details.host = window.location.host;\n        }\n        return details;\n    };\n\n    /**\n     * Get absolute version of relative URL.\n     *\n     * @function\n     * @param    {string} url\n     *           URL to make absolute\n     *\n     * @return   {string}\n     *           Absolute URL\n     *\n     * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n     */\n    const getAbsoluteURL = function (url) {\n        // Check if absolute URL\n        if (!url.match(/^https?:\\/\\//)) {\n            // Add the url to an anchor and let the browser parse it to convert to an absolute url\n            const a = document.createElement('a');\n            a.href = url;\n            url = a.href;\n        }\n        return url;\n    };\n\n    /**\n     * Returns the extension of the passed file name. It will return an empty string\n     * if passed an invalid path.\n     *\n     * @function\n     * @param    {string} path\n     *           The fileName path like '/path/to/file.mp4'\n     *\n     * @return  {string}\n     *           The extension in lower case or an empty string if no\n     *           extension could be found.\n     */\n    const getFileExtension = function (path) {\n        if (typeof path === 'string') {\n            const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n            const pathParts = splitPathRe.exec(path);\n            if (pathParts) {\n                return pathParts.pop().toLowerCase();\n            }\n        }\n        return '';\n    };\n\n    /**\n     * Returns whether the url passed is a cross domain request or not.\n     *\n     * @function\n     * @param    {string} url\n     *           The url to check.\n     *\n     * @param    {Object} [winLoc]\n     *           the domain to check the url against, defaults to window.location\n     *\n     * @param    {string} [winLoc.protocol]\n     *           The window location protocol defaults to window.location.protocol\n     *\n     * @param    {string} [winLoc.host]\n     *           The window location host defaults to window.location.host\n     *\n     * @return   {boolean}\n     *           Whether it is a cross domain request or not.\n     */\n    const isCrossOrigin = function (url, winLoc = window.location) {\n        const urlInfo = parseUrl(url);\n\n        // IE8 protocol relative urls will return ':' for protocol\n        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n        // Check if url is for another domain/origin\n        // IE8 doesn't know location.origin, so we won't rely on it here\n        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n        return crossOrigin;\n    };\n\n    var Url = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        parseUrl: parseUrl,\n        getAbsoluteURL: getAbsoluteURL,\n        getFileExtension: getFileExtension,\n        isCrossOrigin: isCrossOrigin\n    });\n\n    var win;\n    if (typeof window !== \"undefined\") {\n        win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n        win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n        win = self;\n    } else {\n        win = {};\n    }\n    var window_1 = win;\n\n    var _extends_1 = createCommonjsModule(function (module) {\n        function _extends() {\n            module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n                return target;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            return _extends.apply(this, arguments);\n        }\n        module.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    });\n    var _extends$1 = unwrapExports(_extends_1);\n\n    var isFunction_1 = isFunction;\n    var toString = Object.prototype.toString;\n    function isFunction(fn) {\n        if (!fn) {\n            return false;\n        }\n        var string = toString.call(fn);\n        return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (\n            // IE8 and below\n            fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\n    }\n\n    var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\n        if (decodeResponseBody === void 0) {\n            decodeResponseBody = false;\n        }\n        return function (err, response, responseBody) {\n            // if the XHR failed, return that error\n            if (err) {\n                callback(err);\n                return;\n            } // if the HTTP status code is 4xx or 5xx, the request also failed\n\n            if (response.statusCode >= 400 && response.statusCode <= 599) {\n                var cause = responseBody;\n                if (decodeResponseBody) {\n                    if (window_1.TextDecoder) {\n                        var charset = getCharset(response.headers && response.headers['content-type']);\n                        try {\n                            cause = new TextDecoder(charset).decode(responseBody);\n                        } catch (e) {}\n                    } else {\n                        cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\n                    }\n                }\n                callback({\n                    cause: cause\n                });\n                return;\n            } // otherwise, request succeeded\n\n            callback(null, responseBody);\n        };\n    };\n    function getCharset(contentTypeHeader) {\n        if (contentTypeHeader === void 0) {\n            contentTypeHeader = '';\n        }\n        return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\n            var _contentType$split = contentType.split('='),\n                type = _contentType$split[0],\n                value = _contentType$split[1];\n            if (type.trim() === 'charset') {\n                return value.trim();\n            }\n            return charset;\n        }, 'utf-8');\n    }\n    var httpHandler = httpResponseHandler;\n\n    createXHR.httpHandler = httpHandler;\n    /**\n     * @license\n     * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\n     * Copyright (c) 2014 David Björklund\n     * Available under the MIT license\n     * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\n     */\n\n    var parseHeaders = function parseHeaders(headers) {\n        var result = {};\n        if (!headers) {\n            return result;\n        }\n        headers.trim().split('\\n').forEach(function (row) {\n            var index = row.indexOf(':');\n            var key = row.slice(0, index).trim().toLowerCase();\n            var value = row.slice(index + 1).trim();\n            if (typeof result[key] === 'undefined') {\n                result[key] = value;\n            } else if (Array.isArray(result[key])) {\n                result[key].push(value);\n            } else {\n                result[key] = [result[key], value];\n            }\n        });\n        return result;\n    };\n    var lib = createXHR; // Allow use of default import syntax in TypeScript\n\n    var default_1 = createXHR;\n    createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;\n    createXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;\n    forEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n        createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n            options = initParams(uri, options, callback);\n            options.method = method.toUpperCase();\n            return _createXHR(options);\n        };\n    });\n    function forEachArray(array, iterator) {\n        for (var i = 0; i < array.length; i++) {\n            iterator(array[i]);\n        }\n    }\n    function isEmpty(obj) {\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) return false;\n        }\n        return true;\n    }\n    function initParams(uri, options, callback) {\n        var params = uri;\n        if (isFunction_1(options)) {\n            callback = options;\n            if (typeof uri === \"string\") {\n                params = {\n                    uri: uri\n                };\n            }\n        } else {\n            params = _extends_1({}, options, {\n                uri: uri\n            });\n        }\n        params.callback = callback;\n        return params;\n    }\n    function createXHR(uri, options, callback) {\n        options = initParams(uri, options, callback);\n        return _createXHR(options);\n    }\n    function _createXHR(options) {\n        if (typeof options.callback === \"undefined\") {\n            throw new Error(\"callback argument missing\");\n        }\n        var called = false;\n        var callback = function cbOnce(err, response, body) {\n            if (!called) {\n                called = true;\n                options.callback(err, response, body);\n            }\n        };\n        function readystatechange() {\n            if (xhr.readyState === 4) {\n                setTimeout(loadFunc, 0);\n            }\n        }\n        function getBody() {\n            // Chrome with requestType=blob throws errors arround when even testing access to responseText\n            var body = undefined;\n            if (xhr.response) {\n                body = xhr.response;\n            } else {\n                body = xhr.responseText || getXml(xhr);\n            }\n            if (isJson) {\n                try {\n                    body = JSON.parse(body);\n                } catch (e) {}\n            }\n            return body;\n        }\n        function errorFunc(evt) {\n            clearTimeout(timeoutTimer);\n            if (!(evt instanceof Error)) {\n                evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n            }\n            evt.statusCode = 0;\n            return callback(evt, failureResponse);\n        } // will load the data & process the response in a special response object\n\n        function loadFunc() {\n            if (aborted) return;\n            var status;\n            clearTimeout(timeoutTimer);\n            if (options.useXDR && xhr.status === undefined) {\n                //IE8 CORS GET successful response doesn't have a status field, but body is fine\n                status = 200;\n            } else {\n                status = xhr.status === 1223 ? 204 : xhr.status;\n            }\n            var response = failureResponse;\n            var err = null;\n            if (status !== 0) {\n                response = {\n                    body: getBody(),\n                    statusCode: status,\n                    method: method,\n                    headers: {},\n                    url: uri,\n                    rawRequest: xhr\n                };\n                if (xhr.getAllResponseHeaders) {\n                    //remember xhr can in fact be XDR for CORS in IE\n                    response.headers = parseHeaders(xhr.getAllResponseHeaders());\n                }\n            } else {\n                err = new Error(\"Internal XMLHttpRequest Error\");\n            }\n            return callback(err, response, response.body);\n        }\n        var xhr = options.xhr || null;\n        if (!xhr) {\n            if (options.cors || options.useXDR) {\n                xhr = new createXHR.XDomainRequest();\n            } else {\n                xhr = new createXHR.XMLHttpRequest();\n            }\n        }\n        var key;\n        var aborted;\n        var uri = xhr.url = options.uri || options.url;\n        var method = xhr.method = options.method || \"GET\";\n        var body = options.body || options.data;\n        var headers = xhr.headers = options.headers || {};\n        var sync = !!options.sync;\n        var isJson = false;\n        var timeoutTimer;\n        var failureResponse = {\n            body: undefined,\n            headers: {},\n            statusCode: 0,\n            method: method,\n            url: uri,\n            rawRequest: xhr\n        };\n        if (\"json\" in options && options.json !== false) {\n            isJson = true;\n            headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n            if (method !== \"GET\" && method !== \"HEAD\") {\n                headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n                body = JSON.stringify(options.json === true ? body : options.json);\n            }\n        }\n        xhr.onreadystatechange = readystatechange;\n        xhr.onload = loadFunc;\n        xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\n\n        xhr.onprogress = function () {// IE must die\n        };\n        xhr.onabort = function () {\n            aborted = true;\n        };\n        xhr.ontimeout = errorFunc;\n        xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\n\n        if (!sync) {\n            xhr.withCredentials = !!options.withCredentials;\n        } // Cannot set timeout with sync request\n        // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n        // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n\n        if (!sync && options.timeout > 0) {\n            timeoutTimer = setTimeout(function () {\n                if (aborted) return;\n                aborted = true; //IE9 may still call readystatechange\n\n                xhr.abort(\"timeout\");\n                var e = new Error(\"XMLHttpRequest timeout\");\n                e.code = \"ETIMEDOUT\";\n                errorFunc(e);\n            }, options.timeout);\n        }\n        if (xhr.setRequestHeader) {\n            for (key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        } else if (options.headers && !isEmpty(options.headers)) {\n            throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n        }\n        if (\"responseType\" in options) {\n            xhr.responseType = options.responseType;\n        }\n        if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n            options.beforeSend(xhr);\n        } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n        // XMLHttpRequest spec says to pass null as body to indicate no body\n        // See https://github.com/naugtur/xhr/issues/100.\n\n        xhr.send(body || null);\n        return xhr;\n    }\n    function getXml(xhr) {\n        // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n        try {\n            if (xhr.responseType === \"document\") {\n                return xhr.responseXML;\n            }\n            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n            if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n                return xhr.responseXML;\n            }\n        } catch (e) {}\n        return null;\n    }\n    function noop$1() {}\n    lib.default = default_1;\n\n    /**\n     * @file text-track.js\n     */\n\n    /**\n     * Takes a webvtt file contents and parses it into cues\n     *\n     * @param {string} srcContent\n     *        webVTT file contents\n     *\n     * @param {TextTrack} track\n     *        TextTrack to add cues to. Cues come from the srcContent.\n     *\n     * @private\n     */\n    const parseCues = function (srcContent, track) {\n        const parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\n        const errors = [];\n        parser.oncue = function (cue) {\n            track.addCue(cue);\n        };\n        parser.onparsingerror = function (error) {\n            errors.push(error);\n        };\n        parser.onflush = function () {\n            track.trigger({\n                type: 'loadeddata',\n                target: track\n            });\n        };\n        parser.parse(srcContent);\n        if (errors.length > 0) {\n            if (window.console && window.console.groupCollapsed) {\n                window.console.groupCollapsed(`Text Track parsing errors for ${track.src}`);\n            }\n            errors.forEach(error => log$1.error(error));\n            if (window.console && window.console.groupEnd) {\n                window.console.groupEnd();\n            }\n        }\n        parser.flush();\n    };\n\n    /**\n     * Load a `TextTrack` from a specified url.\n     *\n     * @param {string} src\n     *        Url to load track from.\n     *\n     * @param {TextTrack} track\n     *        Track to add cues to. Comes from the content at the end of `url`.\n     *\n     * @private\n     */\n    const loadTrack = function (src, track) {\n        const opts = {\n            uri: src\n        };\n        const crossOrigin = isCrossOrigin(src);\n        if (crossOrigin) {\n            opts.cors = crossOrigin;\n        }\n        const withCredentials = track.tech_.crossOrigin() === 'use-credentials';\n        if (withCredentials) {\n            opts.withCredentials = withCredentials;\n        }\n        lib(opts, bind_(this, function (err, response, responseBody) {\n            if (err) {\n                return log$1.error(err, response);\n            }\n            track.loaded_ = true;\n\n            // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n            // NOTE: this is only used for the alt/video.novtt.js build\n            if (typeof window.WebVTT !== 'function') {\n                if (track.tech_) {\n                    // to prevent use before define eslint error, we define loadHandler\n                    // as a let here\n                    track.tech_.any(['vttjsloaded', 'vttjserror'], event => {\n                        if (event.type === 'vttjserror') {\n                            log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);\n                            return;\n                        }\n                        return parseCues(responseBody, track);\n                    });\n                }\n            } else {\n                parseCues(responseBody, track);\n            }\n        }));\n    };\n\n    /**\n     * A representation of a single `TextTrack`.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n     * @extends Track\n     */\n    class TextTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} options={}\n         *        Object of option names and values\n         *\n         * @param { import('../tech/tech').default } options.tech\n         *        A reference to the tech that owns this TextTrack.\n         *\n         * @param {TextTrack~Kind} [options.kind='subtitles']\n         *        A valid text track kind.\n         *\n         * @param {TextTrack~Mode} [options.mode='disabled']\n         *        A valid text track mode.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this TextTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {string} [options.srclang='']\n         *        A valid two character language code. An alternative, but deprioritized\n         *        version of `options.language`\n         *\n         * @param {string} [options.src]\n         *        A url to TextTrack cues.\n         *\n         * @param {boolean} [options.default]\n         *        If this track should default to on or off.\n         */\n        constructor(options = {}) {\n            if (!options.tech) {\n                throw new Error('A tech was not provided.');\n            }\n            const settings = merge$2(options, {\n                kind: TextTrackKind[options.kind] || 'subtitles',\n                language: options.language || options.srclang || ''\n            });\n            let mode = TextTrackMode[settings.mode] || 'disabled';\n            const default_ = settings.default;\n            if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n                mode = 'hidden';\n            }\n            super(settings);\n            this.tech_ = settings.tech;\n            this.cues_ = [];\n            this.activeCues_ = [];\n            this.preload_ = this.tech_.preloadTextTracks !== false;\n            const cues = new TextTrackCueList(this.cues_);\n            const activeCues = new TextTrackCueList(this.activeCues_);\n            let changed = false;\n            this.timeupdateHandler = bind_(this, function (event = {}) {\n                if (this.tech_.isDisposed()) {\n                    return;\n                }\n                if (!this.tech_.isReady_) {\n                    if (event.type !== 'timeupdate') {\n                        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n                    }\n                    return;\n                }\n\n                // Accessing this.activeCues for the side-effects of updating itself\n                // due to its nature as a getter function. Do not remove or cues will\n                // stop updating!\n                // Use the setter to prevent deletion from uglify (pure_getters rule)\n                this.activeCues = this.activeCues;\n                if (changed) {\n                    this.trigger('cuechange');\n                    changed = false;\n                }\n                if (event.type !== 'timeupdate') {\n                    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n                }\n            });\n            const disposeHandler = () => {\n                this.stopTracking();\n            };\n            this.tech_.one('dispose', disposeHandler);\n            if (mode !== 'disabled') {\n                this.startTracking();\n            }\n            Object.defineProperties(this, {\n                /**\n                 * @memberof TextTrack\n                 * @member {boolean} default\n                 *         If this track was set to be on or off by default. Cannot be changed after\n                 *         creation.\n                 * @instance\n                 *\n                 * @readonly\n                 */\n                default: {\n                    get() {\n                        return default_;\n                    },\n                    set() {}\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {string} mode\n                 *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n                 *         not be set if setting to an invalid mode.\n                 * @instance\n                 *\n                 * @fires TextTrack#modechange\n                 */\n                mode: {\n                    get() {\n                        return mode;\n                    },\n                    set(newMode) {\n                        if (!TextTrackMode[newMode]) {\n                            return;\n                        }\n                        if (mode === newMode) {\n                            return;\n                        }\n                        mode = newMode;\n                        if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {\n                            // On-demand load.\n                            loadTrack(this.src, this);\n                        }\n                        this.stopTracking();\n                        if (mode !== 'disabled') {\n                            this.startTracking();\n                        }\n                        /**\n                         * An event that fires when mode changes on this track. This allows\n                         * the TextTrackList that holds this track to act accordingly.\n                         *\n                         * > Note: This is not part of the spec!\n                         *\n                         * @event TextTrack#modechange\n                         * @type {Event}\n                         */\n                        this.trigger('modechange');\n                    }\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {TextTrackCueList} cues\n                 *         The text track cue list for this TextTrack.\n                 * @instance\n                 */\n                cues: {\n                    get() {\n                        if (!this.loaded_) {\n                            return null;\n                        }\n                        return cues;\n                    },\n                    set() {}\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {TextTrackCueList} activeCues\n                 *         The list text track cues that are currently active for this TextTrack.\n                 * @instance\n                 */\n                activeCues: {\n                    get() {\n                        if (!this.loaded_) {\n                            return null;\n                        }\n\n                        // nothing to do\n                        if (this.cues.length === 0) {\n                            return activeCues;\n                        }\n                        const ct = this.tech_.currentTime();\n                        const active = [];\n                        for (let i = 0, l = this.cues.length; i < l; i++) {\n                            const cue = this.cues[i];\n                            if (cue.startTime <= ct && cue.endTime >= ct) {\n                                active.push(cue);\n                            }\n                        }\n                        changed = false;\n                        if (active.length !== this.activeCues_.length) {\n                            changed = true;\n                        } else {\n                            for (let i = 0; i < active.length; i++) {\n                                if (this.activeCues_.indexOf(active[i]) === -1) {\n                                    changed = true;\n                                }\n                            }\n                        }\n                        this.activeCues_ = active;\n                        activeCues.setCues_(this.activeCues_);\n                        return activeCues;\n                    },\n                    // /!\\ Keep this setter empty (see the timeupdate handler above)\n                    set() {}\n                }\n            });\n            if (settings.src) {\n                this.src = settings.src;\n                if (!this.preload_) {\n                    // Tracks will load on-demand.\n                    // Act like we're loaded for other purposes.\n                    this.loaded_ = true;\n                }\n                if (this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {\n                    loadTrack(this.src, this);\n                }\n            } else {\n                this.loaded_ = true;\n            }\n        }\n        startTracking() {\n            // More precise cues based on requestVideoFrameCallback with a requestAnimationFram fallback\n            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n            // Also listen to timeupdate in case rVFC/rAF stops (window in background, audio in video el)\n            this.tech_.on('timeupdate', this.timeupdateHandler);\n        }\n        stopTracking() {\n            if (this.rvf_) {\n                this.tech_.cancelVideoFrameCallback(this.rvf_);\n                this.rvf_ = undefined;\n            }\n            this.tech_.off('timeupdate', this.timeupdateHandler);\n        }\n\n        /**\n         * Add a cue to the internal list of cues.\n         *\n         * @param {TextTrack~Cue} cue\n         *        The cue to add to our internal list\n         */\n        addCue(originalCue) {\n            let cue = originalCue;\n\n            // Testing if the cue is a VTTCue in a way that survives minification\n            if (!('getCueAsHTML' in cue)) {\n                cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n                for (const prop in originalCue) {\n                    if (!(prop in cue)) {\n                        cue[prop] = originalCue[prop];\n                    }\n                }\n\n                // make sure that `id` is copied over\n                cue.id = originalCue.id;\n                cue.originalCue_ = originalCue;\n            }\n            const tracks = this.tech_.textTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                if (tracks[i] !== this) {\n                    tracks[i].removeCue(cue);\n                }\n            }\n            this.cues_.push(cue);\n            this.cues.setCues_(this.cues_);\n        }\n\n        /**\n         * Remove a cue from our internal list\n         *\n         * @param {TextTrack~Cue} removeCue\n         *        The cue to remove from our internal list\n         */\n        removeCue(removeCue) {\n            let i = this.cues_.length;\n            while (i--) {\n                const cue = this.cues_[i];\n                if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {\n                    this.cues_.splice(i, 1);\n                    this.cues.setCues_(this.cues_);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * cuechange - One or more cues in the track have become active or stopped being active.\n     * @protected\n     */\n    TextTrack.prototype.allowedEvents_ = {\n        cuechange: 'cuechange'\n    };\n\n    /**\n     * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n     * only one `AudioTrack` in the list will be enabled at a time.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n     * @extends Track\n     */\n    class AudioTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {AudioTrack~Kind} [options.kind='']\n         *        A valid audio track kind\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {boolean} [options.enabled]\n         *        If this track is the one that is currently playing. If this track is part of\n         *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n         */\n        constructor(options = {}) {\n            const settings = merge$2(options, {\n                kind: AudioTrackKind[options.kind] || ''\n            });\n            super(settings);\n            let enabled = false;\n\n            /**\n             * @memberof AudioTrack\n             * @member {boolean} enabled\n             *         If this `AudioTrack` is enabled or not. When setting this will\n             *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n             * @instance\n             *\n             * @fires VideoTrack#selectedchange\n             */\n            Object.defineProperty(this, 'enabled', {\n                get() {\n                    return enabled;\n                },\n                set(newEnabled) {\n                    // an invalid or unchanged value\n                    if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n                        return;\n                    }\n                    enabled = newEnabled;\n\n                    /**\n                     * An event that fires when enabled changes on this track. This allows\n                     * the AudioTrackList that holds this track to act accordingly.\n                     *\n                     * > Note: This is not part of the spec! Native tracks will do\n                     *         this internally without an event.\n                     *\n                     * @event AudioTrack#enabledchange\n                     * @type {Event}\n                     */\n                    this.trigger('enabledchange');\n                }\n            });\n\n            // if the user sets this track to selected then\n            // set selected to that true value otherwise\n            // we keep it false\n            if (settings.enabled) {\n                this.enabled = settings.enabled;\n            }\n            this.loaded_ = true;\n        }\n    }\n\n    /**\n     * A representation of a single `VideoTrack`.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n     * @extends Track\n     */\n    class VideoTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {string} [options.kind='']\n         *        A valid {@link VideoTrack~Kind}\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {boolean} [options.selected]\n         *        If this track is the one that is currently playing.\n         */\n        constructor(options = {}) {\n            const settings = merge$2(options, {\n                kind: VideoTrackKind[options.kind] || ''\n            });\n            super(settings);\n            let selected = false;\n\n            /**\n             * @memberof VideoTrack\n             * @member {boolean} selected\n             *         If this `VideoTrack` is selected or not. When setting this will\n             *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n             * @instance\n             *\n             * @fires VideoTrack#selectedchange\n             */\n            Object.defineProperty(this, 'selected', {\n                get() {\n                    return selected;\n                },\n                set(newSelected) {\n                    // an invalid or unchanged value\n                    if (typeof newSelected !== 'boolean' || newSelected === selected) {\n                        return;\n                    }\n                    selected = newSelected;\n\n                    /**\n                     * An event that fires when selected changes on this track. This allows\n                     * the VideoTrackList that holds this track to act accordingly.\n                     *\n                     * > Note: This is not part of the spec! Native tracks will do\n                     *         this internally without an event.\n                     *\n                     * @event VideoTrack#selectedchange\n                     * @type {Event}\n                     */\n                    this.trigger('selectedchange');\n                }\n            });\n\n            // if the user sets this track to selected then\n            // set selected to that true value otherwise\n            // we keep it false\n            if (settings.selected) {\n                this.selected = settings.selected;\n            }\n        }\n    }\n\n    /**\n     * @file html-track-element.js\n     */\n\n    /**\n     * A single track represented in the DOM.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n     * @extends EventTarget\n     */\n    class HTMLTrackElement extends EventTarget$2 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} options={}\n         *        Object of option names and values\n         *\n         * @param { import('../tech/tech').default } options.tech\n         *        A reference to the tech that owns this HTMLTrackElement.\n         *\n         * @param {TextTrack~Kind} [options.kind='subtitles']\n         *        A valid text track kind.\n         *\n         * @param {TextTrack~Mode} [options.mode='disabled']\n         *        A valid text track mode.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this TextTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {string} [options.srclang='']\n         *        A valid two character language code. An alternative, but deprioritized\n         *        version of `options.language`\n         *\n         * @param {string} [options.src]\n         *        A url to TextTrack cues.\n         *\n         * @param {boolean} [options.default]\n         *        If this track should default to on or off.\n         */\n        constructor(options = {}) {\n            super();\n            let readyState;\n            const track = new TextTrack(options);\n            this.kind = track.kind;\n            this.src = track.src;\n            this.srclang = track.language;\n            this.label = track.label;\n            this.default = track.default;\n            Object.defineProperties(this, {\n                /**\n                 * @memberof HTMLTrackElement\n                 * @member {HTMLTrackElement~ReadyState} readyState\n                 *         The current ready state of the track element.\n                 * @instance\n                 */\n                readyState: {\n                    get() {\n                        return readyState;\n                    }\n                },\n                /**\n                 * @memberof HTMLTrackElement\n                 * @member {TextTrack} track\n                 *         The underlying TextTrack object.\n                 * @instance\n                 *\n                 */\n                track: {\n                    get() {\n                        return track;\n                    }\n                }\n            });\n            readyState = HTMLTrackElement.NONE;\n\n            /**\n             * @listens TextTrack#loadeddata\n             * @fires HTMLTrackElement#load\n             */\n            track.addEventListener('loadeddata', () => {\n                readyState = HTMLTrackElement.LOADED;\n                this.trigger({\n                    type: 'load',\n                    target: this\n                });\n            });\n        }\n    }\n\n    /**\n     * @protected\n     */\n    HTMLTrackElement.prototype.allowedEvents_ = {\n        load: 'load'\n    };\n\n    /**\n     * The text track not loaded state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.NONE = 0;\n\n    /**\n     * The text track loading state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.LOADING = 1;\n\n    /**\n     * The text track loaded state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.LOADED = 2;\n\n    /**\n     * The text track failed to load state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.ERROR = 3;\n\n    /*\n   * This file contains all track properties that are used in\n   * player.js, tech.js, html5.js and possibly other techs in the future.\n   */\n\n    const NORMAL = {\n        audio: {\n            ListClass: AudioTrackList,\n            TrackClass: AudioTrack,\n            capitalName: 'Audio'\n        },\n        video: {\n            ListClass: VideoTrackList,\n            TrackClass: VideoTrack,\n            capitalName: 'Video'\n        },\n        text: {\n            ListClass: TextTrackList,\n            TrackClass: TextTrack,\n            capitalName: 'Text'\n        }\n    };\n    Object.keys(NORMAL).forEach(function (type) {\n        NORMAL[type].getterName = `${type}Tracks`;\n        NORMAL[type].privateName = `${type}Tracks_`;\n    });\n    const REMOTE = {\n        remoteText: {\n            ListClass: TextTrackList,\n            TrackClass: TextTrack,\n            capitalName: 'RemoteText',\n            getterName: 'remoteTextTracks',\n            privateName: 'remoteTextTracks_'\n        },\n        remoteTextEl: {\n            ListClass: HtmlTrackElementList,\n            TrackClass: HTMLTrackElement,\n            capitalName: 'RemoteTextTrackEls',\n            getterName: 'remoteTextTrackEls',\n            privateName: 'remoteTextTrackEls_'\n        }\n    };\n    const ALL = Object.assign({}, NORMAL, REMOTE);\n    REMOTE.names = Object.keys(REMOTE);\n    NORMAL.names = Object.keys(NORMAL);\n    ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n    var minDoc = {};\n\n    var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : {};\n    var doccy;\n    if (typeof document !== 'undefined') {\n        doccy = document;\n    } else {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n        if (!doccy) {\n            doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n        }\n    }\n    var document_1 = doccy;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n    /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n    var _objCreate = Object.create || function () {\n        function F() {}\n        return function (o) {\n            if (arguments.length !== 1) {\n                throw new Error('Object.create shim only accepts one parameter.');\n            }\n            F.prototype = o;\n            return new F();\n        };\n    }();\n\n    // Creates a new ParserError object from an errorData object. The errorData\n    // object should have default code and message properties. The default message\n    // property can be overriden by passing in a message parameter.\n    // See ParsingError.Errors below for acceptable errors.\n    function ParsingError(errorData, message) {\n        this.name = \"ParsingError\";\n        this.code = errorData.code;\n        this.message = message || errorData.message;\n    }\n    ParsingError.prototype = _objCreate(Error.prototype);\n    ParsingError.prototype.constructor = ParsingError;\n\n    // ParsingError metadata for acceptable ParsingErrors.\n    ParsingError.Errors = {\n        BadSignature: {\n            code: 0,\n            message: \"Malformed WebVTT signature.\"\n        },\n        BadTimeStamp: {\n            code: 1,\n            message: \"Malformed time stamp.\"\n        }\n    };\n\n    // Try to parse input as a time stamp.\n    function parseTimeStamp(input) {\n        function computeSeconds(h, m, s, f) {\n            return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n        }\n        var m = input.match(/^(\\d+):(\\d{1,2})(:\\d{1,2})?\\.(\\d{3})/);\n        if (!m) {\n            return null;\n        }\n        if (m[3]) {\n            // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n            return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n        } else if (m[1] > 59) {\n            // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n            // First position is hours as it's over 59.\n            return computeSeconds(m[1], m[2], 0, m[4]);\n        } else {\n            // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n            return computeSeconds(0, m[1], m[2], m[4]);\n        }\n    }\n\n    // A settings object holds key/value pairs and will ignore anything but the first\n    // assignment to a specific key.\n    function Settings() {\n        this.values = _objCreate(null);\n    }\n    Settings.prototype = {\n        // Only accept the first assignment to any key.\n        set: function (k, v) {\n            if (!this.get(k) && v !== \"\") {\n                this.values[k] = v;\n            }\n        },\n        // Return the value for a key, or a default value.\n        // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n        // a number of possible default values as properties where 'defaultKey' is\n        // the key of the property that will be chosen; otherwise it's assumed to be\n        // a single value.\n        get: function (k, dflt, defaultKey) {\n            if (defaultKey) {\n                return this.has(k) ? this.values[k] : dflt[defaultKey];\n            }\n            return this.has(k) ? this.values[k] : dflt;\n        },\n        // Check whether we have a value for a key.\n        has: function (k) {\n            return k in this.values;\n        },\n        // Accept a setting if its one of the given alternatives.\n        alt: function (k, v, a) {\n            for (var n = 0; n < a.length; ++n) {\n                if (v === a[n]) {\n                    this.set(k, v);\n                    break;\n                }\n            }\n        },\n        // Accept a setting if its a valid (signed) integer.\n        integer: function (k, v) {\n            if (/^-?\\d+$/.test(v)) {\n                // integer\n                this.set(k, parseInt(v, 10));\n            }\n        },\n        // Accept a setting if its a valid percentage.\n        percent: function (k, v) {\n            if (v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n                v = parseFloat(v);\n                if (v >= 0 && v <= 100) {\n                    this.set(k, v);\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    // Helper function to parse input into groups separated by 'groupDelim', and\n    // interprete each group as a key/value pair separated by 'keyValueDelim'.\n    function parseOptions(input, callback, keyValueDelim, groupDelim) {\n        var groups = groupDelim ? input.split(groupDelim) : [input];\n        for (var i in groups) {\n            if (typeof groups[i] !== \"string\") {\n                continue;\n            }\n            var kv = groups[i].split(keyValueDelim);\n            if (kv.length !== 2) {\n                continue;\n            }\n            var k = kv[0].trim();\n            var v = kv[1].trim();\n            callback(k, v);\n        }\n    }\n    function parseCue(input, cue, regionList) {\n        // Remember the original input if we need to throw an error.\n        var oInput = input;\n        // 4.1 WebVTT timestamp\n        function consumeTimeStamp() {\n            var ts = parseTimeStamp(input);\n            if (ts === null) {\n                throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\n            }\n            // Remove time stamp from input.\n            input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n            return ts;\n        }\n\n        // 4.4.2 WebVTT cue settings\n        function consumeCueSettings(input, cue) {\n            var settings = new Settings();\n            parseOptions(input, function (k, v) {\n                switch (k) {\n                    case \"region\":\n                        // Find the last region we parsed with the same region id.\n                        for (var i = regionList.length - 1; i >= 0; i--) {\n                            if (regionList[i].id === v) {\n                                settings.set(k, regionList[i].region);\n                                break;\n                            }\n                        }\n                        break;\n                    case \"vertical\":\n                        settings.alt(k, v, [\"rl\", \"lr\"]);\n                        break;\n                    case \"line\":\n                        var vals = v.split(\",\"),\n                            vals0 = vals[0];\n                        settings.integer(k, vals0);\n                        settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n                        settings.alt(k, vals0, [\"auto\"]);\n                        if (vals.length === 2) {\n                            settings.alt(\"lineAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n                        }\n                        break;\n                    case \"position\":\n                        vals = v.split(\",\");\n                        settings.percent(k, vals[0]);\n                        if (vals.length === 2) {\n                            settings.alt(\"positionAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n                        }\n                        break;\n                    case \"size\":\n                        settings.percent(k, v);\n                        break;\n                    case \"align\":\n                        settings.alt(k, v, [\"start\", \"center\", \"end\", \"left\", \"right\"]);\n                        break;\n                }\n            }, /:/, /\\s/);\n\n            // Apply default values for any missing fields.\n            cue.region = settings.get(\"region\", null);\n            cue.vertical = settings.get(\"vertical\", \"\");\n            try {\n                cue.line = settings.get(\"line\", \"auto\");\n            } catch (e) {}\n            cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n            cue.snapToLines = settings.get(\"snapToLines\", true);\n            cue.size = settings.get(\"size\", 100);\n            // Safari still uses the old middle value and won't accept center\n            try {\n                cue.align = settings.get(\"align\", \"center\");\n            } catch (e) {\n                cue.align = settings.get(\"align\", \"middle\");\n            }\n            try {\n                cue.position = settings.get(\"position\", \"auto\");\n            } catch (e) {\n                cue.position = settings.get(\"position\", {\n                    start: 0,\n                    left: 0,\n                    center: 50,\n                    middle: 50,\n                    end: 100,\n                    right: 100\n                }, cue.align);\n            }\n            cue.positionAlign = settings.get(\"positionAlign\", {\n                start: \"start\",\n                left: \"start\",\n                center: \"center\",\n                middle: \"center\",\n                end: \"end\",\n                right: \"end\"\n            }, cue.align);\n        }\n        function skipWhitespace() {\n            input = input.replace(/^\\s+/, \"\");\n        }\n\n        // 4.1 WebVTT cue timings.\n        skipWhitespace();\n        cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n        skipWhitespace();\n        if (input.substr(0, 3) !== \"-->\") {\n            // (3) next characters must match \"-->\"\n            throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n        }\n        input = input.substr(3);\n        skipWhitespace();\n        cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n        // 4.1 WebVTT cue settings list.\n        skipWhitespace();\n        consumeCueSettings(input, cue);\n    }\n\n    // When evaluating this file as part of a Webpack bundle for server\n    // side rendering, `document` is an empty object.\n    var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement(\"textarea\");\n    var TAG_NAME = {\n        c: \"span\",\n        i: \"i\",\n        b: \"b\",\n        u: \"u\",\n        ruby: \"ruby\",\n        rt: \"rt\",\n        v: \"span\",\n        lang: \"span\"\n    };\n\n    // 5.1 default text color\n    // 5.2 default text background color is equivalent to text color with bg_ prefix\n    var DEFAULT_COLOR_CLASS = {\n        white: 'rgba(255,255,255,1)',\n        lime: 'rgba(0,255,0,1)',\n        cyan: 'rgba(0,255,255,1)',\n        red: 'rgba(255,0,0,1)',\n        yellow: 'rgba(255,255,0,1)',\n        magenta: 'rgba(255,0,255,1)',\n        blue: 'rgba(0,0,255,1)',\n        black: 'rgba(0,0,0,1)'\n    };\n    var TAG_ANNOTATION = {\n        v: \"title\",\n        lang: \"lang\"\n    };\n    var NEEDS_PARENT = {\n        rt: \"ruby\"\n    };\n\n    // Parse content into a document fragment.\n    function parseContent(window, input) {\n        function nextToken() {\n            // Check for end-of-string.\n            if (!input) {\n                return null;\n            }\n\n            // Consume 'n' characters from the input.\n            function consume(result) {\n                input = input.substr(result.length);\n                return result;\n            }\n            var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n            // If there is some text before the next tag, return it, otherwise return\n            // the tag.\n            return consume(m[1] ? m[1] : m[2]);\n        }\n        function unescape(s) {\n            TEXTAREA_ELEMENT.innerHTML = s;\n            s = TEXTAREA_ELEMENT.textContent;\n            TEXTAREA_ELEMENT.textContent = \"\";\n            return s;\n        }\n        function shouldAdd(current, element) {\n            return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\n        }\n\n        // Create an element for this tag.\n        function createElement(type, annotation) {\n            var tagName = TAG_NAME[type];\n            if (!tagName) {\n                return null;\n            }\n            var element = window.document.createElement(tagName);\n            var name = TAG_ANNOTATION[type];\n            if (name && annotation) {\n                element[name] = annotation.trim();\n            }\n            return element;\n        }\n        var rootDiv = window.document.createElement(\"div\"),\n            current = rootDiv,\n            t,\n            tagStack = [];\n        while ((t = nextToken()) !== null) {\n            if (t[0] === '<') {\n                if (t[1] === \"/\") {\n                    // If the closing tag matches, move back up to the parent node.\n                    if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n                        tagStack.pop();\n                        current = current.parentNode;\n                    }\n                    // Otherwise just ignore the end tag.\n                    continue;\n                }\n                var ts = parseTimeStamp(t.substr(1, t.length - 2));\n                var node;\n                if (ts) {\n                    // Timestamps are lead nodes as well.\n                    node = window.document.createProcessingInstruction(\"timestamp\", ts);\n                    current.appendChild(node);\n                    continue;\n                }\n                var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n                // If we can't parse the tag, skip to the next tag.\n                if (!m) {\n                    continue;\n                }\n                // Try to construct an element, and ignore the tag if we couldn't.\n                node = createElement(m[1], m[3]);\n                if (!node) {\n                    continue;\n                }\n                // Determine if the tag should be added based on the context of where it\n                // is placed in the cuetext.\n                if (!shouldAdd(current, node)) {\n                    continue;\n                }\n                // Set the class list (as a list of classes, separated by space).\n                if (m[2]) {\n                    var classes = m[2].split('.');\n                    classes.forEach(function (cl) {\n                        var bgColor = /^bg_/.test(cl);\n                        // slice out `bg_` if it's a background color\n                        var colorName = bgColor ? cl.slice(3) : cl;\n                        if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {\n                            var propName = bgColor ? 'background-color' : 'color';\n                            var propValue = DEFAULT_COLOR_CLASS[colorName];\n                            node.style[propName] = propValue;\n                        }\n                    });\n                    node.className = classes.join(' ');\n                }\n                // Append the node to the current node, and enter the scope of the new\n                // node.\n                tagStack.push(m[1]);\n                current.appendChild(node);\n                current = node;\n                continue;\n            }\n\n            // Text nodes are leaf nodes.\n            current.appendChild(window.document.createTextNode(unescape(t)));\n        }\n        return rootDiv;\n    }\n\n    // This is a list of all the Unicode characters that have a strong\n    // right-to-left category. What this means is that these characters are\n    // written right-to-left for sure. It was generated by pulling all the strong\n    // right-to-left characters out of the Unicode data table. That table can\n    // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\n    var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n    function isStrongRTLChar(charCode) {\n        for (var i = 0; i < strongRTLRanges.length; i++) {\n            var currentRange = strongRTLRanges[i];\n            if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function determineBidi(cueDiv) {\n        var nodeStack = [],\n            text = \"\",\n            charCode;\n        if (!cueDiv || !cueDiv.childNodes) {\n            return \"ltr\";\n        }\n        function pushNodes(nodeStack, node) {\n            for (var i = node.childNodes.length - 1; i >= 0; i--) {\n                nodeStack.push(node.childNodes[i]);\n            }\n        }\n        function nextTextNode(nodeStack) {\n            if (!nodeStack || !nodeStack.length) {\n                return null;\n            }\n            var node = nodeStack.pop(),\n                text = node.textContent || node.innerText;\n            if (text) {\n                // TODO: This should match all unicode type B characters (paragraph\n                // separator characters). See issue #115.\n                var m = text.match(/^.*(\\n|\\r)/);\n                if (m) {\n                    nodeStack.length = 0;\n                    return m[0];\n                }\n                return text;\n            }\n            if (node.tagName === \"ruby\") {\n                return nextTextNode(nodeStack);\n            }\n            if (node.childNodes) {\n                pushNodes(nodeStack, node);\n                return nextTextNode(nodeStack);\n            }\n        }\n        pushNodes(nodeStack, cueDiv);\n        while (text = nextTextNode(nodeStack)) {\n            for (var i = 0; i < text.length; i++) {\n                charCode = text.charCodeAt(i);\n                if (isStrongRTLChar(charCode)) {\n                    return \"rtl\";\n                }\n            }\n        }\n        return \"ltr\";\n    }\n    function computeLinePos(cue) {\n        if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\n            return cue.line;\n        }\n        if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\n            return -1;\n        }\n        var track = cue.track,\n            trackList = track.textTrackList,\n            count = 0;\n        for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n            if (trackList[i].mode === \"showing\") {\n                count++;\n            }\n        }\n        return ++count * -1;\n    }\n    function StyleBox() {}\n\n    // Apply styles to a div. If there is no div passed then it defaults to the\n    // div on 'this'.\n    StyleBox.prototype.applyStyles = function (styles, div) {\n        div = div || this.div;\n        for (var prop in styles) {\n            if (styles.hasOwnProperty(prop)) {\n                div.style[prop] = styles[prop];\n            }\n        }\n    };\n    StyleBox.prototype.formatStyle = function (val, unit) {\n        return val === 0 ? 0 : val + unit;\n    };\n\n    // Constructs the computed display state of the cue (a div). Places the div\n    // into the overlay which should be a block level element (usually a div).\n    function CueStyleBox(window, cue, styleOptions) {\n        StyleBox.call(this);\n        this.cue = cue;\n\n        // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n        // have inline positioning and will function as the cue background box.\n        this.cueDiv = parseContent(window, cue.text);\n        var styles = {\n            color: \"rgba(255, 255, 255, 1)\",\n            backgroundColor: \"rgba(0, 0, 0, 0.8)\",\n            position: \"relative\",\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            display: \"inline\",\n            writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n            unicodeBidi: \"plaintext\"\n        };\n        this.applyStyles(styles, this.cueDiv);\n\n        // Create an absolutely positioned div that will be used to position the cue\n        // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n        // mirrors of them except middle instead of center on Safari.\n        this.div = window.document.createElement(\"div\");\n        styles = {\n            direction: determineBidi(this.cueDiv),\n            writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n            unicodeBidi: \"plaintext\",\n            textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n            font: styleOptions.font,\n            whiteSpace: \"pre-line\",\n            position: \"absolute\"\n        };\n        this.applyStyles(styles);\n        this.div.appendChild(this.cueDiv);\n\n        // Calculate the distance from the reference edge of the viewport to the text\n        // position of the cue box. The reference edge will be resolved later when\n        // the box orientation styles are applied.\n        var textPos = 0;\n        switch (cue.positionAlign) {\n            case \"start\":\n            case \"line-left\":\n                textPos = cue.position;\n                break;\n            case \"center\":\n                textPos = cue.position - cue.size / 2;\n                break;\n            case \"end\":\n            case \"line-right\":\n                textPos = cue.position - cue.size;\n                break;\n        }\n\n        // Horizontal box orientation; textPos is the distance from the left edge of the\n        // area to the left edge of the box and cue.size is the distance extending to\n        // the right from there.\n        if (cue.vertical === \"\") {\n            this.applyStyles({\n                left: this.formatStyle(textPos, \"%\"),\n                width: this.formatStyle(cue.size, \"%\")\n            });\n            // Vertical box orientation; textPos is the distance from the top edge of the\n            // area to the top edge of the box and cue.size is the height extending\n            // downwards from there.\n        } else {\n            this.applyStyles({\n                top: this.formatStyle(textPos, \"%\"),\n                height: this.formatStyle(cue.size, \"%\")\n            });\n        }\n        this.move = function (box) {\n            this.applyStyles({\n                top: this.formatStyle(box.top, \"px\"),\n                bottom: this.formatStyle(box.bottom, \"px\"),\n                left: this.formatStyle(box.left, \"px\"),\n                right: this.formatStyle(box.right, \"px\"),\n                height: this.formatStyle(box.height, \"px\"),\n                width: this.formatStyle(box.width, \"px\")\n            });\n        };\n    }\n    CueStyleBox.prototype = _objCreate(StyleBox.prototype);\n    CueStyleBox.prototype.constructor = CueStyleBox;\n\n    // Represents the co-ordinates of an Element in a way that we can easily\n    // compute things with such as if it overlaps or intersects with another Element.\n    // Can initialize it with either a StyleBox or another BoxPosition.\n    function BoxPosition(obj) {\n        // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n        // was passed in and we need to copy the results of 'getBoundingClientRect'\n        // as the object returned is readonly. All co-ordinate values are in reference\n        // to the viewport origin (top left).\n        var lh, height, width, top;\n        if (obj.div) {\n            height = obj.div.offsetHeight;\n            width = obj.div.offsetWidth;\n            top = obj.div.offsetTop;\n            var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\n            obj = obj.div.getBoundingClientRect();\n            // In certain cases the outter div will be slightly larger then the sum of\n            // the inner div's lines. This could be due to bold text, etc, on some platforms.\n            // In this case we should get the average line height and use that. This will\n            // result in the desired behaviour.\n            lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\n        }\n        this.left = obj.left;\n        this.right = obj.right;\n        this.top = obj.top || top;\n        this.height = obj.height || height;\n        this.bottom = obj.bottom || top + (obj.height || height);\n        this.width = obj.width || width;\n        this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n    }\n\n    // Move the box along a particular axis. Optionally pass in an amount to move\n    // the box. If no amount is passed then the default is the line height of the\n    // box.\n    BoxPosition.prototype.move = function (axis, toMove) {\n        toMove = toMove !== undefined ? toMove : this.lineHeight;\n        switch (axis) {\n            case \"+x\":\n                this.left += toMove;\n                this.right += toMove;\n                break;\n            case \"-x\":\n                this.left -= toMove;\n                this.right -= toMove;\n                break;\n            case \"+y\":\n                this.top += toMove;\n                this.bottom += toMove;\n                break;\n            case \"-y\":\n                this.top -= toMove;\n                this.bottom -= toMove;\n                break;\n        }\n    };\n\n    // Check if this box overlaps another box, b2.\n    BoxPosition.prototype.overlaps = function (b2) {\n        return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\n    };\n\n    // Check if this box overlaps any other boxes in boxes.\n    BoxPosition.prototype.overlapsAny = function (boxes) {\n        for (var i = 0; i < boxes.length; i++) {\n            if (this.overlaps(boxes[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    // Check if this box is within another box.\n    BoxPosition.prototype.within = function (container) {\n        return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\n    };\n\n    // Check if this box is entirely within the container or it is overlapping\n    // on the edge opposite of the axis direction passed. For example, if \"+x\" is\n    // passed and the box is overlapping on the left edge of the container, then\n    // return true.\n    BoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\n        switch (axis) {\n            case \"+x\":\n                return this.left < container.left;\n            case \"-x\":\n                return this.right > container.right;\n            case \"+y\":\n                return this.top < container.top;\n            case \"-y\":\n                return this.bottom > container.bottom;\n        }\n    };\n\n    // Find the percentage of the area that this box is overlapping with another\n    // box.\n    BoxPosition.prototype.intersectPercentage = function (b2) {\n        var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n            y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n            intersectArea = x * y;\n        return intersectArea / (this.height * this.width);\n    };\n\n    // Convert the positions from this box to CSS compatible positions using\n    // the reference container's positions. This has to be done because this\n    // box's positions are in reference to the viewport origin, whereas, CSS\n    // values are in referecne to their respective edges.\n    BoxPosition.prototype.toCSSCompatValues = function (reference) {\n        return {\n            top: this.top - reference.top,\n            bottom: reference.bottom - this.bottom,\n            left: this.left - reference.left,\n            right: reference.right - this.right,\n            height: this.height,\n            width: this.width\n        };\n    };\n\n    // Get an object that represents the box's position without anything extra.\n    // Can pass a StyleBox, HTMLElement, or another BoxPositon.\n    BoxPosition.getSimpleBoxPosition = function (obj) {\n        var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n        var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n        var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n        obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\n        var ret = {\n            left: obj.left,\n            right: obj.right,\n            top: obj.top || top,\n            height: obj.height || height,\n            bottom: obj.bottom || top + (obj.height || height),\n            width: obj.width || width\n        };\n        return ret;\n    };\n\n    // Move a StyleBox to its specified, or next best, position. The containerBox\n    // is the box that contains the StyleBox, such as a div. boxPositions are\n    // a list of other boxes that the styleBox can't overlap with.\n    function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n        // Find the best position for a cue box, b, on the video. The axis parameter\n        // is a list of axis, the order of which, it will move the box along. For example:\n        // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n        // direction. If it doesn't find a good position for it there it will then move\n        // it along the x axis in the negative direction.\n        function findBestPosition(b, axis) {\n            var bestPosition,\n                specifiedPosition = new BoxPosition(b),\n                percentage = 1; // Highest possible so the first thing we get is better.\n\n            for (var i = 0; i < axis.length; i++) {\n                while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\n                    b.move(axis[i]);\n                }\n                // We found a spot where we aren't overlapping anything. This is our\n                // best position.\n                if (b.within(containerBox)) {\n                    return b;\n                }\n                var p = b.intersectPercentage(containerBox);\n                // If we're outside the container box less then we were on our last try\n                // then remember this position as the best position.\n                if (percentage > p) {\n                    bestPosition = new BoxPosition(b);\n                    percentage = p;\n                }\n                // Reset the box position to the specified position.\n                b = new BoxPosition(specifiedPosition);\n            }\n            return bestPosition || specifiedPosition;\n        }\n        var boxPosition = new BoxPosition(styleBox),\n            cue = styleBox.cue,\n            linePos = computeLinePos(cue),\n            axis = [];\n\n        // If we have a line number to align the cue to.\n        if (cue.snapToLines) {\n            var size;\n            switch (cue.vertical) {\n                case \"\":\n                    axis = [\"+y\", \"-y\"];\n                    size = \"height\";\n                    break;\n                case \"rl\":\n                    axis = [\"+x\", \"-x\"];\n                    size = \"width\";\n                    break;\n                case \"lr\":\n                    axis = [\"-x\", \"+x\"];\n                    size = \"width\";\n                    break;\n            }\n            var step = boxPosition.lineHeight,\n                position = step * Math.round(linePos),\n                maxPosition = containerBox[size] + step,\n                initialAxis = axis[0];\n\n            // If the specified intial position is greater then the max position then\n            // clamp the box to the amount of steps it would take for the box to\n            // reach the max position.\n            if (Math.abs(position) > maxPosition) {\n                position = position < 0 ? -1 : 1;\n                position *= Math.ceil(maxPosition / step) * step;\n            }\n\n            // If computed line position returns negative then line numbers are\n            // relative to the bottom of the video instead of the top. Therefore, we\n            // need to increase our initial position by the length or width of the\n            // video, depending on the writing direction, and reverse our axis directions.\n            if (linePos < 0) {\n                position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n                axis = axis.reverse();\n            }\n\n            // Move the box to the specified position. This may not be its best\n            // position.\n            boxPosition.move(initialAxis, position);\n        } else {\n            // If we have a percentage line value for the cue.\n            var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\n            switch (cue.lineAlign) {\n                case \"center\":\n                    linePos -= calculatedPercentage / 2;\n                    break;\n                case \"end\":\n                    linePos -= calculatedPercentage;\n                    break;\n            }\n\n            // Apply initial line position to the cue box.\n            switch (cue.vertical) {\n                case \"\":\n                    styleBox.applyStyles({\n                        top: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n                case \"rl\":\n                    styleBox.applyStyles({\n                        left: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n                case \"lr\":\n                    styleBox.applyStyles({\n                        right: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n            }\n            axis = [\"+y\", \"-x\", \"+x\", \"-y\"];\n\n            // Get the box position again after we've applied the specified positioning\n            // to it.\n            boxPosition = new BoxPosition(styleBox);\n        }\n        var bestPosition = findBestPosition(boxPosition, axis);\n        styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n    }\n    function WebVTT$1() {\n        // Nothing\n    }\n\n    // Helper to allow strings to be decoded instead of the default binary utf8 data.\n    WebVTT$1.StringDecoder = function () {\n        return {\n            decode: function (data) {\n                if (!data) {\n                    return \"\";\n                }\n                if (typeof data !== \"string\") {\n                    throw new Error(\"Error - expected string data.\");\n                }\n                return decodeURIComponent(encodeURIComponent(data));\n            }\n        };\n    };\n    WebVTT$1.convertCueToDOMTree = function (window, cuetext) {\n        if (!window || !cuetext) {\n            return null;\n        }\n        return parseContent(window, cuetext);\n    };\n    var FONT_SIZE_PERCENT = 0.05;\n    var FONT_STYLE = \"sans-serif\";\n    var CUE_BACKGROUND_PADDING = \"1.5%\";\n\n    // Runs the processing model over the cues and regions passed to it.\n    // @param overlay A block level element (usually a div) that the computed cues\n    //                and regions will be placed into.\n    WebVTT$1.processCues = function (window, cues, overlay) {\n        if (!window || !cues || !overlay) {\n            return null;\n        }\n\n        // Remove all previous children.\n        while (overlay.firstChild) {\n            overlay.removeChild(overlay.firstChild);\n        }\n        var paddedOverlay = window.document.createElement(\"div\");\n        paddedOverlay.style.position = \"absolute\";\n        paddedOverlay.style.left = \"0\";\n        paddedOverlay.style.right = \"0\";\n        paddedOverlay.style.top = \"0\";\n        paddedOverlay.style.bottom = \"0\";\n        paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n        overlay.appendChild(paddedOverlay);\n\n        // Determine if we need to compute the display states of the cues. This could\n        // be the case if a cue's state has been changed since the last computation or\n        // if it has not been computed yet.\n        function shouldCompute(cues) {\n            for (var i = 0; i < cues.length; i++) {\n                if (cues[i].hasBeenReset || !cues[i].displayState) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // We don't need to recompute the cues' display states. Just reuse them.\n        if (!shouldCompute(cues)) {\n            for (var i = 0; i < cues.length; i++) {\n                paddedOverlay.appendChild(cues[i].displayState);\n            }\n            return;\n        }\n        var boxPositions = [],\n            containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n            fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n        var styleOptions = {\n            font: fontSize + \"px \" + FONT_STYLE\n        };\n        (function () {\n            var styleBox, cue;\n            for (var i = 0; i < cues.length; i++) {\n                cue = cues[i];\n\n                // Compute the intial position and styles of the cue div.\n                styleBox = new CueStyleBox(window, cue, styleOptions);\n                paddedOverlay.appendChild(styleBox.div);\n\n                // Move the cue div to it's correct line position.\n                moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n                // Remember the computed div so that we don't have to recompute it later\n                // if we don't have too.\n                cue.displayState = styleBox.div;\n                boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n            }\n        })();\n    };\n    WebVTT$1.Parser = function (window, vttjs, decoder) {\n        if (!decoder) {\n            decoder = vttjs;\n            vttjs = {};\n        }\n        if (!vttjs) {\n            vttjs = {};\n        }\n        this.window = window;\n        this.vttjs = vttjs;\n        this.state = \"INITIAL\";\n        this.buffer = \"\";\n        this.decoder = decoder || new TextDecoder(\"utf8\");\n        this.regionList = [];\n    };\n    WebVTT$1.Parser.prototype = {\n        // If the error is a ParsingError then report it to the consumer if\n        // possible. If it's not a ParsingError then throw it like normal.\n        reportOrThrowError: function (e) {\n            if (e instanceof ParsingError) {\n                this.onparsingerror && this.onparsingerror(e);\n            } else {\n                throw e;\n            }\n        },\n        parse: function (data) {\n            var self = this;\n\n            // If there is no data then we won't decode it, but will just try to parse\n            // whatever is in buffer already. This may occur in circumstances, for\n            // example when flush() is called.\n            if (data) {\n                // Try to decode the data that we received.\n                self.buffer += self.decoder.decode(data, {\n                    stream: true\n                });\n            }\n            function collectNextLine() {\n                var buffer = self.buffer;\n                var pos = 0;\n                while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n                    ++pos;\n                }\n                var line = buffer.substr(0, pos);\n                // Advance the buffer early in case we fail below.\n                if (buffer[pos] === '\\r') {\n                    ++pos;\n                }\n                if (buffer[pos] === '\\n') {\n                    ++pos;\n                }\n                self.buffer = buffer.substr(pos);\n                return line;\n            }\n\n            // 3.4 WebVTT region and WebVTT region settings syntax\n            function parseRegion(input) {\n                var settings = new Settings();\n                parseOptions(input, function (k, v) {\n                    switch (k) {\n                        case \"id\":\n                            settings.set(k, v);\n                            break;\n                        case \"width\":\n                            settings.percent(k, v);\n                            break;\n                        case \"lines\":\n                            settings.integer(k, v);\n                            break;\n                        case \"regionanchor\":\n                        case \"viewportanchor\":\n                            var xy = v.split(',');\n                            if (xy.length !== 2) {\n                                break;\n                            }\n                            // We have to make sure both x and y parse, so use a temporary\n                            // settings object here.\n                            var anchor = new Settings();\n                            anchor.percent(\"x\", xy[0]);\n                            anchor.percent(\"y\", xy[1]);\n                            if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n                                break;\n                            }\n                            settings.set(k + \"X\", anchor.get(\"x\"));\n                            settings.set(k + \"Y\", anchor.get(\"y\"));\n                            break;\n                        case \"scroll\":\n                            settings.alt(k, v, [\"up\"]);\n                            break;\n                    }\n                }, /=/, /\\s/);\n\n                // Create the region, using default values for any values that were not\n                // specified.\n                if (settings.has(\"id\")) {\n                    var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n                    region.width = settings.get(\"width\", 100);\n                    region.lines = settings.get(\"lines\", 3);\n                    region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n                    region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n                    region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n                    region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n                    region.scroll = settings.get(\"scroll\", \"\");\n                    // Register the region.\n                    self.onregion && self.onregion(region);\n                    // Remember the VTTRegion for later in case we parse any VTTCues that\n                    // reference it.\n                    self.regionList.push({\n                        id: settings.get(\"id\"),\n                        region: region\n                    });\n                }\n            }\n\n            // draft-pantos-http-live-streaming-20\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n            // 3.5 WebVTT\n            function parseTimestampMap(input) {\n                var settings = new Settings();\n                parseOptions(input, function (k, v) {\n                    switch (k) {\n                        case \"MPEGT\":\n                            settings.integer(k + 'S', v);\n                            break;\n                        case \"LOCA\":\n                            settings.set(k + 'L', parseTimeStamp(v));\n                            break;\n                    }\n                }, /[^\\d]:/, /,/);\n                self.ontimestampmap && self.ontimestampmap({\n                    \"MPEGTS\": settings.get(\"MPEGTS\"),\n                    \"LOCAL\": settings.get(\"LOCAL\")\n                });\n            }\n\n            // 3.2 WebVTT metadata header syntax\n            function parseHeader(input) {\n                if (input.match(/X-TIMESTAMP-MAP/)) {\n                    // This line contains HLS X-TIMESTAMP-MAP metadata\n                    parseOptions(input, function (k, v) {\n                        switch (k) {\n                            case \"X-TIMESTAMP-MAP\":\n                                parseTimestampMap(v);\n                                break;\n                        }\n                    }, /=/);\n                } else {\n                    parseOptions(input, function (k, v) {\n                        switch (k) {\n                            case \"Region\":\n                                // 3.3 WebVTT region metadata header syntax\n                                parseRegion(v);\n                                break;\n                        }\n                    }, /:/);\n                }\n            }\n\n            // 5.1 WebVTT file parsing.\n            try {\n                var line;\n                if (self.state === \"INITIAL\") {\n                    // We can't start parsing until we have the first line.\n                    if (!/\\r\\n|\\n/.test(self.buffer)) {\n                        return this;\n                    }\n                    line = collectNextLine();\n                    var m = line.match(/^WEBVTT([ \\t].*)?$/);\n                    if (!m || !m[0]) {\n                        throw new ParsingError(ParsingError.Errors.BadSignature);\n                    }\n                    self.state = \"HEADER\";\n                }\n                var alreadyCollectedLine = false;\n                while (self.buffer) {\n                    // We can't parse a line until we have the full line.\n                    if (!/\\r\\n|\\n/.test(self.buffer)) {\n                        return this;\n                    }\n                    if (!alreadyCollectedLine) {\n                        line = collectNextLine();\n                    } else {\n                        alreadyCollectedLine = false;\n                    }\n                    switch (self.state) {\n                        case \"HEADER\":\n                            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n                            if (/:/.test(line)) {\n                                parseHeader(line);\n                            } else if (!line) {\n                                // An empty line terminates the header and starts the body (cues).\n                                self.state = \"ID\";\n                            }\n                            continue;\n                        case \"NOTE\":\n                            // Ignore NOTE blocks.\n                            if (!line) {\n                                self.state = \"ID\";\n                            }\n                            continue;\n                        case \"ID\":\n                            // Check for the start of NOTE blocks.\n                            if (/^NOTE($|[ \\t])/.test(line)) {\n                                self.state = \"NOTE\";\n                                break;\n                            }\n                            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n                            if (!line) {\n                                continue;\n                            }\n                            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n                            // Safari still uses the old middle value and won't accept center\n                            try {\n                                self.cue.align = \"center\";\n                            } catch (e) {\n                                self.cue.align = \"middle\";\n                            }\n                            self.state = \"CUE\";\n                            // 30-39 - Check if self line contains an optional identifier or timing data.\n                            if (line.indexOf(\"-->\") === -1) {\n                                self.cue.id = line;\n                                continue;\n                            }\n                        // Process line as start of a cue.\n                        /*falls through*/\n                        case \"CUE\":\n                            // 40 - Collect cue timings and settings.\n                            try {\n                                parseCue(line, self.cue, self.regionList);\n                            } catch (e) {\n                                self.reportOrThrowError(e);\n                                // In case of an error ignore rest of the cue.\n                                self.cue = null;\n                                self.state = \"BADCUE\";\n                                continue;\n                            }\n                            self.state = \"CUETEXT\";\n                            continue;\n                        case \"CUETEXT\":\n                            var hasSubstring = line.indexOf(\"-->\") !== -1;\n                            // 34 - If we have an empty line then report the cue.\n                            // 35 - If we have the special substring '-->' then report the cue,\n                            // but do not collect the line as we need to process the current\n                            // one as a new cue.\n                            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                                // We are done parsing self cue.\n                                self.oncue && self.oncue(self.cue);\n                                self.cue = null;\n                                self.state = \"ID\";\n                                continue;\n                            }\n                            if (self.cue.text) {\n                                self.cue.text += \"\\n\";\n                            }\n                            self.cue.text += line.replace(/\\u2028/g, '\\n').replace(/u2029/g, '\\n');\n                            continue;\n                        case \"BADCUE\":\n                            // BADCUE\n                            // 54-62 - Collect and discard the remaining cue.\n                            if (!line) {\n                                self.state = \"ID\";\n                            }\n                            continue;\n                    }\n                }\n            } catch (e) {\n                self.reportOrThrowError(e);\n\n                // If we are currently parsing a cue, report what we have.\n                if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n                    self.oncue(self.cue);\n                }\n                self.cue = null;\n                // Enter BADWEBVTT state if header was not parsed correctly otherwise\n                // another exception occurred so enter BADCUE state.\n                self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n            }\n            return this;\n        },\n        flush: function () {\n            var self = this;\n            try {\n                // Finish decoding the stream.\n                self.buffer += self.decoder.decode();\n                // Synthesize the end of the current cue or region.\n                if (self.cue || self.state === \"HEADER\") {\n                    self.buffer += \"\\n\\n\";\n                    self.parse();\n                }\n                // If we've flushed, parsed, and we're still on the INITIAL state then\n                // that means we don't have enough of the stream to parse the first\n                // line.\n                if (self.state === \"INITIAL\") {\n                    throw new ParsingError(ParsingError.Errors.BadSignature);\n                }\n            } catch (e) {\n                self.reportOrThrowError(e);\n            }\n            self.onflush && self.onflush();\n            return this;\n        }\n    };\n    var vtt = WebVTT$1;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    var autoKeyword = \"auto\";\n    var directionSetting = {\n        \"\": 1,\n        \"lr\": 1,\n        \"rl\": 1\n    };\n    var alignSetting = {\n        \"start\": 1,\n        \"center\": 1,\n        \"end\": 1,\n        \"left\": 1,\n        \"right\": 1,\n        \"auto\": 1,\n        \"line-left\": 1,\n        \"line-right\": 1\n    };\n    function findDirectionSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var dir = directionSetting[value.toLowerCase()];\n        return dir ? value.toLowerCase() : false;\n    }\n    function findAlignSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var align = alignSetting[value.toLowerCase()];\n        return align ? value.toLowerCase() : false;\n    }\n    function VTTCue(startTime, endTime, text) {\n        /**\n         * Shim implementation specific properties. These properties are not in\n         * the spec.\n         */\n\n        // Lets us know when the VTTCue's data has changed in such a way that we need\n        // to recompute its display state. This lets us compute its display state\n        // lazily.\n        this.hasBeenReset = false;\n\n        /**\n         * VTTCue and TextTrackCue properties\n         * http://dev.w3.org/html5/webvtt/#vttcue-interface\n         */\n\n        var _id = \"\";\n        var _pauseOnExit = false;\n        var _startTime = startTime;\n        var _endTime = endTime;\n        var _text = text;\n        var _region = null;\n        var _vertical = \"\";\n        var _snapToLines = true;\n        var _line = \"auto\";\n        var _lineAlign = \"start\";\n        var _position = \"auto\";\n        var _positionAlign = \"auto\";\n        var _size = 100;\n        var _align = \"center\";\n        Object.defineProperties(this, {\n            \"id\": {\n                enumerable: true,\n                get: function () {\n                    return _id;\n                },\n                set: function (value) {\n                    _id = \"\" + value;\n                }\n            },\n            \"pauseOnExit\": {\n                enumerable: true,\n                get: function () {\n                    return _pauseOnExit;\n                },\n                set: function (value) {\n                    _pauseOnExit = !!value;\n                }\n            },\n            \"startTime\": {\n                enumerable: true,\n                get: function () {\n                    return _startTime;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"Start time must be set to a number.\");\n                    }\n                    _startTime = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"endTime\": {\n                enumerable: true,\n                get: function () {\n                    return _endTime;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"End time must be set to a number.\");\n                    }\n                    _endTime = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"text\": {\n                enumerable: true,\n                get: function () {\n                    return _text;\n                },\n                set: function (value) {\n                    _text = \"\" + value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"region\": {\n                enumerable: true,\n                get: function () {\n                    return _region;\n                },\n                set: function (value) {\n                    _region = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"vertical\": {\n                enumerable: true,\n                get: function () {\n                    return _vertical;\n                },\n                set: function (value) {\n                    var setting = findDirectionSetting(value);\n                    // Have to check for false because the setting an be an empty string.\n                    if (setting === false) {\n                        throw new SyntaxError(\"Vertical: an invalid or illegal direction string was specified.\");\n                    }\n                    _vertical = setting;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"snapToLines\": {\n                enumerable: true,\n                get: function () {\n                    return _snapToLines;\n                },\n                set: function (value) {\n                    _snapToLines = !!value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"line\": {\n                enumerable: true,\n                get: function () {\n                    return _line;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\" && value !== autoKeyword) {\n                        throw new SyntaxError(\"Line: an invalid number or illegal string was specified.\");\n                    }\n                    _line = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"lineAlign\": {\n                enumerable: true,\n                get: function () {\n                    return _lineAlign;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        console.warn(\"lineAlign: an invalid or illegal string was specified.\");\n                    } else {\n                        _lineAlign = setting;\n                        this.hasBeenReset = true;\n                    }\n                }\n            },\n            \"position\": {\n                enumerable: true,\n                get: function () {\n                    return _position;\n                },\n                set: function (value) {\n                    if (value < 0 || value > 100) {\n                        throw new Error(\"Position must be between 0 and 100.\");\n                    }\n                    _position = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"positionAlign\": {\n                enumerable: true,\n                get: function () {\n                    return _positionAlign;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        console.warn(\"positionAlign: an invalid or illegal string was specified.\");\n                    } else {\n                        _positionAlign = setting;\n                        this.hasBeenReset = true;\n                    }\n                }\n            },\n            \"size\": {\n                enumerable: true,\n                get: function () {\n                    return _size;\n                },\n                set: function (value) {\n                    if (value < 0 || value > 100) {\n                        throw new Error(\"Size must be between 0 and 100.\");\n                    }\n                    _size = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"align\": {\n                enumerable: true,\n                get: function () {\n                    return _align;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        throw new SyntaxError(\"align: an invalid or illegal alignment string was specified.\");\n                    }\n                    _align = setting;\n                    this.hasBeenReset = true;\n                }\n            }\n        });\n\n        /**\n         * Other <track> spec defined properties\n         */\n\n        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n        this.displayState = undefined;\n    }\n\n    /**\n     * VTTCue methods\n     */\n\n    VTTCue.prototype.getCueAsHTML = function () {\n        // Assume WebVTT.convertCueToDOMTree is on the global.\n        return WebVTT.convertCueToDOMTree(window, this.text);\n    };\n    var vttcue = VTTCue;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    var scrollSetting = {\n        \"\": true,\n        \"up\": true\n    };\n    function findScrollSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var scroll = scrollSetting[value.toLowerCase()];\n        return scroll ? value.toLowerCase() : false;\n    }\n    function isValidPercentValue(value) {\n        return typeof value === \"number\" && value >= 0 && value <= 100;\n    }\n\n    // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\n    function VTTRegion() {\n        var _width = 100;\n        var _lines = 3;\n        var _regionAnchorX = 0;\n        var _regionAnchorY = 100;\n        var _viewportAnchorX = 0;\n        var _viewportAnchorY = 100;\n        var _scroll = \"\";\n        Object.defineProperties(this, {\n            \"width\": {\n                enumerable: true,\n                get: function () {\n                    return _width;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"Width must be between 0 and 100.\");\n                    }\n                    _width = value;\n                }\n            },\n            \"lines\": {\n                enumerable: true,\n                get: function () {\n                    return _lines;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"Lines must be set to a number.\");\n                    }\n                    _lines = value;\n                }\n            },\n            \"regionAnchorY\": {\n                enumerable: true,\n                get: function () {\n                    return _regionAnchorY;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n                    }\n                    _regionAnchorY = value;\n                }\n            },\n            \"regionAnchorX\": {\n                enumerable: true,\n                get: function () {\n                    return _regionAnchorX;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n                    }\n                    _regionAnchorX = value;\n                }\n            },\n            \"viewportAnchorY\": {\n                enumerable: true,\n                get: function () {\n                    return _viewportAnchorY;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n                    }\n                    _viewportAnchorY = value;\n                }\n            },\n            \"viewportAnchorX\": {\n                enumerable: true,\n                get: function () {\n                    return _viewportAnchorX;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n                    }\n                    _viewportAnchorX = value;\n                }\n            },\n            \"scroll\": {\n                enumerable: true,\n                get: function () {\n                    return _scroll;\n                },\n                set: function (value) {\n                    var setting = findScrollSetting(value);\n                    // Have to check for false as an empty string is a legal value.\n                    if (setting === false) {\n                        console.warn(\"Scroll: an invalid or illegal string was specified.\");\n                    } else {\n                        _scroll = setting;\n                    }\n                }\n            }\n        });\n    }\n    var vttregion = VTTRegion;\n\n    var browserIndex = createCommonjsModule(function (module) {\n        /**\n         * Copyright 2013 vtt.js Contributors\n         *\n         * Licensed under the Apache License, Version 2.0 (the \"License\");\n         * you may not use this file except in compliance with the License.\n         * You may obtain a copy of the License at\n         *\n         *   http://www.apache.org/licenses/LICENSE-2.0\n         *\n         * Unless required by applicable law or agreed to in writing, software\n         * distributed under the License is distributed on an \"AS IS\" BASIS,\n         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         * See the License for the specific language governing permissions and\n         * limitations under the License.\n         */\n\n            // Default exports for Node. Export the extended versions of VTTCue and\n            // VTTRegion in Node since we likely want the capability to convert back and\n            // forth between JSON. If we don't then it's not that big of a deal since we're\n            // off browser.\n\n        var vttjs = module.exports = {\n                WebVTT: vtt,\n                VTTCue: vttcue,\n                VTTRegion: vttregion\n            };\n        window_1.vttjs = vttjs;\n        window_1.WebVTT = vttjs.WebVTT;\n        var cueShim = vttjs.VTTCue;\n        var regionShim = vttjs.VTTRegion;\n        var nativeVTTCue = window_1.VTTCue;\n        var nativeVTTRegion = window_1.VTTRegion;\n        vttjs.shim = function () {\n            window_1.VTTCue = cueShim;\n            window_1.VTTRegion = regionShim;\n        };\n        vttjs.restore = function () {\n            window_1.VTTCue = nativeVTTCue;\n            window_1.VTTRegion = nativeVTTRegion;\n        };\n        if (!window_1.VTTCue) {\n            vttjs.shim();\n        }\n    });\n    browserIndex.WebVTT;\n    browserIndex.VTTCue;\n    browserIndex.VTTRegion;\n\n    /**\n     * @file tech.js\n     */\n\n    /**\n     * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n     * that just contains the src url alone.\n     * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n     * `var SourceString = 'http://example.com/some-video.mp4';`\n     *\n     * @typedef {Object|string} SourceObject\n     *\n     * @property {string} src\n     *           The url to the source\n     *\n     * @property {string} type\n     *           The mime type of the source\n     */\n\n    /**\n     * A function used by {@link Tech} to create a new {@link TextTrack}.\n     *\n     * @private\n     *\n     * @param {Tech} self\n     *        An instance of the Tech class.\n     *\n     * @param {string} kind\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n     *\n     * @param {string} [label]\n     *        Label to identify the text track\n     *\n     * @param {string} [language]\n     *        Two letter language abbreviation\n     *\n     * @param {Object} [options={}]\n     *        An object with additional text track options\n     *\n     * @return {TextTrack}\n     *          The text track that was created.\n     */\n    function createTrackHelper(self, kind, label, language, options = {}) {\n        const tracks = self.textTracks();\n        options.kind = kind;\n        if (label) {\n            options.label = label;\n        }\n        if (language) {\n            options.language = language;\n        }\n        options.tech = self;\n        const track = new ALL.text.TrackClass(options);\n        tracks.addTrack(track);\n        return track;\n    }\n\n    /**\n     * This is the base class for media playback technology controllers, such as\n     * {@link HTML5}\n     *\n     * @extends Component\n     */\n    class Tech extends Component$1 {\n        /**\n         * Create an instance of this Tech.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        Callback function to call when the `HTML5` Tech is ready.\n         */\n        constructor(options = {}, ready = function () {}) {\n            // we don't want the tech to report user activity automatically.\n            // This is done manually in addControlsListeners\n            options.reportTouchActivity = false;\n            super(null, options, ready);\n            this.onDurationChange_ = e => this.onDurationChange(e);\n            this.trackProgress_ = e => this.trackProgress(e);\n            this.trackCurrentTime_ = e => this.trackCurrentTime(e);\n            this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);\n            this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);\n            this.queuedHanders_ = new Set();\n\n            // keep track of whether the current source has played at all to\n            // implement a very limited played()\n            this.hasStarted_ = false;\n            this.on('playing', function () {\n                this.hasStarted_ = true;\n            });\n            this.on('loadstart', function () {\n                this.hasStarted_ = false;\n            });\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                if (options && options[props.getterName]) {\n                    this[props.privateName] = options[props.getterName];\n                }\n            });\n\n            // Manually track progress in cases where the browser/tech doesn't report it.\n            if (!this.featuresProgressEvents) {\n                this.manualProgressOn();\n            }\n\n            // Manually track timeupdates in cases where the browser/tech doesn't report it.\n            if (!this.featuresTimeupdateEvents) {\n                this.manualTimeUpdatesOn();\n            }\n            ['Text', 'Audio', 'Video'].forEach(track => {\n                if (options[`native${track}Tracks`] === false) {\n                    this[`featuresNative${track}Tracks`] = false;\n                }\n            });\n            if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n                this.featuresNativeTextTracks = false;\n            } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n                this.featuresNativeTextTracks = true;\n            }\n            if (!this.featuresNativeTextTracks) {\n                this.emulateTextTracks();\n            }\n            this.preloadTextTracks = options.preloadTextTracks !== false;\n            this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n            this.initTrackListeners();\n\n            // Turn on component tap events only if not using native controls\n            if (!options.nativeControlsForTouch) {\n                this.emitTapEvents();\n            }\n            if (this.constructor) {\n                this.name_ = this.constructor.name || 'Unknown Tech';\n            }\n        }\n\n        /**\n         * A special function to trigger source set in a way that will allow player\n         * to re-trigger if the player or tech are not ready yet.\n         *\n         * @fires Tech#sourceset\n         * @param {string} src The source string at the time of the source changing.\n         */\n        triggerSourceset(src) {\n            if (!this.isReady_) {\n                // on initial ready we have to trigger source set\n                // 1ms after ready so that player can watch for it.\n                this.one('ready', () => this.setTimeout(() => this.triggerSourceset(src), 1));\n            }\n\n            /**\n             * Fired when the source is set on the tech causing the media element\n             * to reload.\n             *\n             * @see {@link Player#event:sourceset}\n             * @event Tech#sourceset\n             * @type {Event}\n             */\n            this.trigger({\n                src,\n                type: 'sourceset'\n            });\n        }\n\n        /* Fallbacks for unsupported event types\n    ================================================================================ */\n\n        /**\n         * Polyfill the `progress` event for browsers that don't support it natively.\n         *\n         * @see {@link Tech#trackProgress}\n         */\n        manualProgressOn() {\n            this.on('durationchange', this.onDurationChange_);\n            this.manualProgress = true;\n\n            // Trigger progress watching when a source begins loading\n            this.one('ready', this.trackProgress_);\n        }\n\n        /**\n         * Turn off the polyfill for `progress` events that was created in\n         * {@link Tech#manualProgressOn}\n         */\n        manualProgressOff() {\n            this.manualProgress = false;\n            this.stopTrackingProgress();\n            this.off('durationchange', this.onDurationChange_);\n        }\n\n        /**\n         * This is used to trigger a `progress` event when the buffered percent changes. It\n         * sets an interval function that will be called every 500 milliseconds to check if the\n         * buffer end percent has changed.\n         *\n         * > This function is called by {@link Tech#manualProgressOn}\n         *\n         * @param {Event} event\n         *        The `ready` event that caused this to run.\n         *\n         * @listens Tech#ready\n         * @fires Tech#progress\n         */\n        trackProgress(event) {\n            this.stopTrackingProgress();\n            this.progressInterval = this.setInterval(bind_(this, function () {\n                // Don't trigger unless buffered amount is greater than last time\n\n                const numBufferedPercent = this.bufferedPercent();\n                if (this.bufferedPercent_ !== numBufferedPercent) {\n                    /**\n                     * See {@link Player#progress}\n                     *\n                     * @event Tech#progress\n                     * @type {Event}\n                     */\n                    this.trigger('progress');\n                }\n                this.bufferedPercent_ = numBufferedPercent;\n                if (numBufferedPercent === 1) {\n                    this.stopTrackingProgress();\n                }\n            }), 500);\n        }\n\n        /**\n         * Update our internal duration on a `durationchange` event by calling\n         * {@link Tech#duration}.\n         *\n         * @param {Event} event\n         *        The `durationchange` event that caused this to run.\n         *\n         * @listens Tech#durationchange\n         */\n        onDurationChange(event) {\n            this.duration_ = this.duration();\n        }\n\n        /**\n         * Get and create a `TimeRange` object for buffering.\n         *\n         * @return { import('../utils/time').TimeRange }\n         *         The time range object that was created.\n         */\n        buffered() {\n            return createTimeRanges$1(0, 0);\n        }\n\n        /**\n         * Get the percentage of the current video that is currently buffered.\n         *\n         * @return {number}\n         *         A number from 0 to 1 that represents the decimal percentage of the\n         *         video that is buffered.\n         *\n         */\n        bufferedPercent() {\n            return bufferedPercent(this.buffered(), this.duration_);\n        }\n\n        /**\n         * Turn off the polyfill for `progress` events that was created in\n         * {@link Tech#manualProgressOn}\n         * Stop manually tracking progress events by clearing the interval that was set in\n         * {@link Tech#trackProgress}.\n         */\n        stopTrackingProgress() {\n            this.clearInterval(this.progressInterval);\n        }\n\n        /**\n         * Polyfill the `timeupdate` event for browsers that don't support it.\n         *\n         * @see {@link Tech#trackCurrentTime}\n         */\n        manualTimeUpdatesOn() {\n            this.manualTimeUpdates = true;\n            this.on('play', this.trackCurrentTime_);\n            this.on('pause', this.stopTrackingCurrentTime_);\n        }\n\n        /**\n         * Turn off the polyfill for `timeupdate` events that was created in\n         * {@link Tech#manualTimeUpdatesOn}\n         */\n        manualTimeUpdatesOff() {\n            this.manualTimeUpdates = false;\n            this.stopTrackingCurrentTime();\n            this.off('play', this.trackCurrentTime_);\n            this.off('pause', this.stopTrackingCurrentTime_);\n        }\n\n        /**\n         * Sets up an interval function to track current time and trigger `timeupdate` every\n         * 250 milliseconds.\n         *\n         * @listens Tech#play\n         * @triggers Tech#timeupdate\n         */\n        trackCurrentTime() {\n            if (this.currentTimeInterval) {\n                this.stopTrackingCurrentTime();\n            }\n            this.currentTimeInterval = this.setInterval(function () {\n                /**\n                 * Triggered at an interval of 250ms to indicated that time is passing in the video.\n                 *\n                 * @event Tech#timeupdate\n                 * @type {Event}\n                 */\n                this.trigger({\n                    type: 'timeupdate',\n                    target: this,\n                    manuallyTriggered: true\n                });\n\n                // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n            }, 250);\n        }\n\n        /**\n         * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n         * `timeupdate` event is no longer triggered.\n         *\n         * @listens {Tech#pause}\n         */\n        stopTrackingCurrentTime() {\n            this.clearInterval(this.currentTimeInterval);\n\n            // #1002 - if the video ends right before the next timeupdate would happen,\n            // the progress bar won't make it all the way to the end\n            this.trigger({\n                type: 'timeupdate',\n                target: this,\n                manuallyTriggered: true\n            });\n        }\n\n        /**\n         * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n         * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n         *\n         * @fires Component#dispose\n         */\n        dispose() {\n            // clear out all tracks because we can't reuse them between techs\n            this.clearTracks(NORMAL.names);\n\n            // Turn off any manual progress or timeupdate tracking\n            if (this.manualProgress) {\n                this.manualProgressOff();\n            }\n            if (this.manualTimeUpdates) {\n                this.manualTimeUpdatesOff();\n            }\n            super.dispose();\n        }\n\n        /**\n         * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n         *\n         * > Note: Techs without source handlers should call this between sources for `video`\n         *         & `audio` tracks. You don't want to use them between tracks!\n         *\n         * @param {string[]|string} types\n         *        TrackList names to clear, valid names are `video`, `audio`, and\n         *        `text`.\n         */\n        clearTracks(types) {\n            types = [].concat(types);\n            // clear out all tracks because we can't reuse them between techs\n            types.forEach(type => {\n                const list = this[`${type}Tracks`]() || [];\n                let i = list.length;\n                while (i--) {\n                    const track = list[i];\n                    if (type === 'text') {\n                        this.removeRemoteTextTrack(track);\n                    }\n                    list.removeTrack(track);\n                }\n            });\n        }\n\n        /**\n         * Remove any TextTracks added via addRemoteTextTrack that are\n         * flagged for automatic garbage collection\n         */\n        cleanupAutoTextTracks() {\n            const list = this.autoRemoteTextTracks_ || [];\n            let i = list.length;\n            while (i--) {\n                const track = list[i];\n                this.removeRemoteTextTrack(track);\n            }\n        }\n\n        /**\n         * Reset the tech, which will removes all sources and reset the internal readyState.\n         *\n         * @abstract\n         */\n        reset() {}\n\n        /**\n         * Get the value of `crossOrigin` from the tech.\n         *\n         * @abstract\n         *\n         * @see {Html5#crossOrigin}\n         */\n        crossOrigin() {}\n\n        /**\n         * Set the value of `crossOrigin` on the tech.\n         *\n         * @abstract\n         *\n         * @param {string} crossOrigin the crossOrigin value\n         * @see {Html5#setCrossOrigin}\n         */\n        setCrossOrigin() {}\n\n        /**\n         * Get or set an error on the Tech.\n         *\n         * @param {MediaError} [err]\n         *        Error to set on the Tech\n         *\n         * @return {MediaError|null}\n         *         The current error object on the tech, or null if there isn't one.\n         */\n        error(err) {\n            if (err !== undefined) {\n                this.error_ = new MediaError(err);\n                this.trigger('error');\n            }\n            return this.error_;\n        }\n\n        /**\n         * Returns the `TimeRange`s that have been played through for the current source.\n         *\n         * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n         *         It only checks whether the source has played at all or not.\n         *\n         * @return { import('../utils/time').TimeRange }\n         *         - A single time range if this video has played\n         *         - An empty set of ranges if not.\n         */\n        played() {\n            if (this.hasStarted_) {\n                return createTimeRanges$1(0, 0);\n            }\n            return createTimeRanges$1();\n        }\n\n        /**\n         * Start playback\n         *\n         * @abstract\n         *\n         * @see {Html5#play}\n         */\n        play() {}\n\n        /**\n         * Set whether we are scrubbing or not\n         *\n         * @abstract\n         * @param {boolean} _isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         *\n         * @see {Html5#setScrubbing}\n         */\n        setScrubbing(_isScrubbing) {}\n\n        /**\n         * Get whether we are scrubbing or not\n         *\n         * @abstract\n         *\n         * @see {Html5#scrubbing}\n         */\n        scrubbing() {}\n\n        /**\n         * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n         * previously called.\n         *\n         * @param {number} _seconds\n         *        Set the current time of the media to this.\n         * @fires Tech#timeupdate\n         */\n        setCurrentTime(_seconds) {\n            // improve the accuracy of manual timeupdates\n            if (this.manualTimeUpdates) {\n                /**\n                 * A manual `timeupdate` event.\n                 *\n                 * @event Tech#timeupdate\n                 * @type {Event}\n                 */\n                this.trigger({\n                    type: 'timeupdate',\n                    target: this,\n                    manuallyTriggered: true\n                });\n            }\n        }\n\n        /**\n         * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n         * {@link TextTrackList} events.\n         *\n         * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n         *\n         * @fires Tech#audiotrackchange\n         * @fires Tech#videotrackchange\n         * @fires Tech#texttrackchange\n         */\n        initTrackListeners() {\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n             *\n             * @event Tech#audiotrackchange\n             * @type {Event}\n             */\n\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n             *\n             * @event Tech#videotrackchange\n             * @type {Event}\n             */\n\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n             *\n             * @event Tech#texttrackchange\n             * @type {Event}\n             */\n            NORMAL.names.forEach(name => {\n                const props = NORMAL[name];\n                const trackListChanges = () => {\n                    this.trigger(`${name}trackchange`);\n                };\n                const tracks = this[props.getterName]();\n                tracks.addEventListener('removetrack', trackListChanges);\n                tracks.addEventListener('addtrack', trackListChanges);\n                this.on('dispose', () => {\n                    tracks.removeEventListener('removetrack', trackListChanges);\n                    tracks.removeEventListener('addtrack', trackListChanges);\n                });\n            });\n        }\n\n        /**\n         * Emulate TextTracks using vtt.js if necessary\n         *\n         * @fires Tech#vttjsloaded\n         * @fires Tech#vttjserror\n         */\n        addWebVttScript_() {\n            if (window.WebVTT) {\n                return;\n            }\n\n            // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n            // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n            // before inserting the WebVTT script\n            if (document.body.contains(this.el())) {\n                // load via require if available and vtt.js script location was not passed in\n                // as an option. novtt builds will turn the above require call into an empty object\n                // which will cause this if check to always fail.\n                if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {\n                    this.trigger('vttjsloaded');\n                    return;\n                }\n\n                // load vtt.js via the script location option or the cdn of no location was\n                // passed in\n                const script = document.createElement('script');\n                script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\n                script.onload = () => {\n                    /**\n                     * Fired when vtt.js is loaded.\n                     *\n                     * @event Tech#vttjsloaded\n                     * @type {Event}\n                     */\n                    this.trigger('vttjsloaded');\n                };\n                script.onerror = () => {\n                    /**\n                     * Fired when vtt.js was not loaded due to an error\n                     *\n                     * @event Tech#vttjsloaded\n                     * @type {Event}\n                     */\n                    this.trigger('vttjserror');\n                };\n                this.on('dispose', () => {\n                    script.onload = null;\n                    script.onerror = null;\n                });\n                // but have not loaded yet and we set it to true before the inject so that\n                // we don't overwrite the injected window.WebVTT if it loads right away\n                window.WebVTT = true;\n                this.el().parentNode.appendChild(script);\n            } else {\n                this.ready(this.addWebVttScript_);\n            }\n        }\n\n        /**\n         * Emulate texttracks\n         *\n         */\n        emulateTextTracks() {\n            const tracks = this.textTracks();\n            const remoteTracks = this.remoteTextTracks();\n            const handleAddTrack = e => tracks.addTrack(e.track);\n            const handleRemoveTrack = e => tracks.removeTrack(e.track);\n            remoteTracks.on('addtrack', handleAddTrack);\n            remoteTracks.on('removetrack', handleRemoveTrack);\n            this.addWebVttScript_();\n            const updateDisplay = () => this.trigger('texttrackchange');\n            const textTracksChanges = () => {\n                updateDisplay();\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n                    track.removeEventListener('cuechange', updateDisplay);\n                    if (track.mode === 'showing') {\n                        track.addEventListener('cuechange', updateDisplay);\n                    }\n                }\n            };\n            textTracksChanges();\n            tracks.addEventListener('change', textTracksChanges);\n            tracks.addEventListener('addtrack', textTracksChanges);\n            tracks.addEventListener('removetrack', textTracksChanges);\n            this.on('dispose', function () {\n                remoteTracks.off('addtrack', handleAddTrack);\n                remoteTracks.off('removetrack', handleRemoveTrack);\n                tracks.removeEventListener('change', textTracksChanges);\n                tracks.removeEventListener('addtrack', textTracksChanges);\n                tracks.removeEventListener('removetrack', textTracksChanges);\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n                    track.removeEventListener('cuechange', updateDisplay);\n                }\n            });\n        }\n\n        /**\n         * Create and returns a remote {@link TextTrack} object.\n         *\n         * @param {string} kind\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n         *\n         * @param {string} [label]\n         *        Label to identify the text track\n         *\n         * @param {string} [language]\n         *        Two letter language abbreviation\n         *\n         * @return {TextTrack}\n         *         The TextTrack that gets created.\n         */\n        addTextTrack(kind, label, language) {\n            if (!kind) {\n                throw new Error('TextTrack kind is required but was not provided');\n            }\n            return createTrackHelper(this, kind, label, language);\n        }\n\n        /**\n         * Create an emulated TextTrack for use by addRemoteTextTrack\n         *\n         * This is intended to be overridden by classes that inherit from\n         * Tech in order to create native or custom TextTracks.\n         *\n         * @param {Object} options\n         *        The object should contain the options to initialize the TextTrack with.\n         *\n         * @param {string} [options.kind]\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n         *\n         * @param {string} [options.label].\n         *        Label to identify the text track\n         *\n         * @param {string} [options.language]\n         *        Two letter language abbreviation.\n         *\n         * @return {HTMLTrackElement}\n         *         The track element that gets created.\n         */\n        createRemoteTextTrack(options) {\n            const track = merge$2(options, {\n                tech: this\n            });\n            return new REMOTE.remoteTextEl.TrackClass(track);\n        }\n\n        /**\n         * Creates a remote text track object and returns an html track element.\n         *\n         * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n         *\n         * @param {Object} options\n         *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n         *\n         * @param {boolean} [manualCleanup=false]\n         *        - When false: the TextTrack will be automatically removed from the video\n         *          element whenever the source changes\n         *        - When True: The TextTrack will have to be cleaned up manually\n         *\n         * @return {HTMLTrackElement}\n         *         An Html Track Element.\n         *\n         */\n        addRemoteTextTrack(options = {}, manualCleanup) {\n            const htmlTrackElement = this.createRemoteTextTrack(options);\n            if (typeof manualCleanup !== 'boolean') {\n                manualCleanup = false;\n            }\n\n            // store HTMLTrackElement and TextTrack to remote list\n            this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n            this.remoteTextTracks().addTrack(htmlTrackElement.track);\n            if (manualCleanup === false) {\n                // create the TextTrackList if it doesn't exist\n                this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Remove a remote text track from the remote `TextTrackList`.\n         *\n         * @param {TextTrack} track\n         *        `TextTrack` to remove from the `TextTrackList`\n         */\n        removeRemoteTextTrack(track) {\n            const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n            // remove HTMLTrackElement and TextTrack from remote list\n            this.remoteTextTrackEls().removeTrackElement_(trackElement);\n            this.remoteTextTracks().removeTrack(track);\n            this.autoRemoteTextTracks_.removeTrack(track);\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object}\n         *         An object with supported media playback quality metrics\n         *\n         * @abstract\n         */\n        getVideoPlaybackQuality() {\n            return {};\n        }\n\n        /**\n         * Attempt to create a floating video window always on top of other windows\n         * so that users may continue consuming media while they interact with other\n         * content sites, or applications on their device.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @return {Promise|undefined}\n         *         A promise with a Picture-in-Picture window if the browser supports\n         *         Promises (or one was passed in as an option). It returns undefined\n         *         otherwise.\n         *\n         * @abstract\n         */\n        requestPictureInPicture() {\n            return Promise.reject();\n        }\n\n        /**\n         * A method to check for the value of the 'disablePictureInPicture' <video> property.\n         * Defaults to true, as it should be considered disabled if the tech does not support pip\n         *\n         * @abstract\n         */\n        disablePictureInPicture() {\n            return true;\n        }\n\n        /**\n         * A method to set or unset the 'disablePictureInPicture' <video> property.\n         *\n         * @abstract\n         */\n        setDisablePictureInPicture() {}\n\n        /**\n         * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame\n         *\n         * @param {function} cb\n         * @return {number} request id\n         */\n        requestVideoFrameCallback(cb) {\n            const id = newGUID();\n            if (!this.isReady_ || this.paused()) {\n                this.queuedHanders_.add(id);\n                this.one('playing', () => {\n                    if (this.queuedHanders_.has(id)) {\n                        this.queuedHanders_.delete(id);\n                        cb();\n                    }\n                });\n            } else {\n                this.requestNamedAnimationFrame(id, cb);\n            }\n            return id;\n        }\n\n        /**\n         * A fallback implementation of cancelVideoFrameCallback\n         *\n         * @param {number} id id of callback to be cancelled\n         */\n        cancelVideoFrameCallback(id) {\n            if (this.queuedHanders_.has(id)) {\n                this.queuedHanders_.delete(id);\n            } else {\n                this.cancelNamedAnimationFrame(id);\n            }\n        }\n\n        /**\n         * A method to set a poster from a `Tech`.\n         *\n         * @abstract\n         */\n        setPoster() {}\n\n        /**\n         * A method to check for the presence of the 'playsinline' <video> attribute.\n         *\n         * @abstract\n         */\n        playsinline() {}\n\n        /**\n         * A method to set or unset the 'playsinline' <video> attribute.\n         *\n         * @abstract\n         */\n        setPlaysinline() {}\n\n        /**\n         * Attempt to force override of native audio tracks.\n         *\n         * @param {boolean} override - If set to true native audio will be overridden,\n         * otherwise native audio will potentially be used.\n         *\n         * @abstract\n         */\n        overrideNativeAudioTracks(override) {}\n\n        /**\n         * Attempt to force override of native video tracks.\n         *\n         * @param {boolean} override - If set to true native video will be overridden,\n         * otherwise native video will potentially be used.\n         *\n         * @abstract\n         */\n        overrideNativeVideoTracks(override) {}\n\n        /**\n         * Check if the tech can support the given mime-type.\n         *\n         * The base tech does not support any type, but source handlers might\n         * overwrite this.\n         *\n         * @param  {string} _type\n         *         The mimetype to check for support\n         *\n         * @return {string}\n         *         'probably', 'maybe', or empty string\n         *\n         * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n         *\n         * @abstract\n         */\n        canPlayType(_type) {\n            return '';\n        }\n\n        /**\n         * Check if the type is supported by this tech.\n         *\n         * The base tech does not support any type, but source handlers might\n         * overwrite this.\n         *\n         * @param {string} _type\n         *        The media type to check\n         * @return {string} Returns the native video element's response\n         */\n        static canPlayType(_type) {\n            return '';\n        }\n\n        /**\n         * Check if the tech can support the given source\n         *\n         * @param {Object} srcObj\n         *        The source object\n         * @param {Object} options\n         *        The options passed to the tech\n         * @return {string} 'probably', 'maybe', or '' (empty string)\n         */\n        static canPlaySource(srcObj, options) {\n            return Tech.canPlayType(srcObj.type);\n        }\n\n        /*\n     * Return whether the argument is a Tech or not.\n     * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n     *\n     * @param {Object} component\n     *        The item to check\n     *\n     * @return {boolean}\n     *         Whether it is a tech or not\n     *         - True if it is a tech\n     *         - False if it is not\n     */\n        static isTech(component) {\n            return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n        }\n\n        /**\n         * Registers a `Tech` into a shared list for videojs.\n         *\n         * @param {string} name\n         *        Name of the `Tech` to register.\n         *\n         * @param {Object} tech\n         *        The `Tech` class to register.\n         */\n        static registerTech(name, tech) {\n            if (!Tech.techs_) {\n                Tech.techs_ = {};\n            }\n            if (!Tech.isTech(tech)) {\n                throw new Error(`Tech ${name} must be a Tech`);\n            }\n            if (!Tech.canPlayType) {\n                throw new Error('Techs must have a static canPlayType method on them');\n            }\n            if (!Tech.canPlaySource) {\n                throw new Error('Techs must have a static canPlaySource method on them');\n            }\n            name = toTitleCase$1(name);\n            Tech.techs_[name] = tech;\n            Tech.techs_[toLowerCase(name)] = tech;\n            if (name !== 'Tech') {\n                // camel case the techName for use in techOrder\n                Tech.defaultTechOrder_.push(name);\n            }\n            return tech;\n        }\n\n        /**\n         * Get a `Tech` from the shared list by name.\n         *\n         * @param {string} name\n         *        `camelCase` or `TitleCase` name of the Tech to get\n         *\n         * @return {Tech|undefined}\n         *         The `Tech` or undefined if there was no tech with the name requested.\n         */\n        static getTech(name) {\n            if (!name) {\n                return;\n            }\n            if (Tech.techs_ && Tech.techs_[name]) {\n                return Tech.techs_[name];\n            }\n            name = toTitleCase$1(name);\n            if (window && window.videojs && window.videojs[name]) {\n                log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);\n                return window.videojs[name];\n            }\n        }\n    }\n\n    /**\n     * Get the {@link VideoTrackList}\n     *\n     * @returns {VideoTrackList}\n     * @method Tech.prototype.videoTracks\n     */\n\n    /**\n     * Get the {@link AudioTrackList}\n     *\n     * @returns {AudioTrackList}\n     * @method Tech.prototype.audioTracks\n     */\n\n    /**\n     * Get the {@link TextTrackList}\n     *\n     * @returns {TextTrackList}\n     * @method Tech.prototype.textTracks\n     */\n\n    /**\n     * Get the remote element {@link TextTrackList}\n     *\n     * @returns {TextTrackList}\n     * @method Tech.prototype.remoteTextTracks\n     */\n\n    /**\n     * Get the remote element {@link HtmlTrackElementList}\n     *\n     * @returns {HtmlTrackElementList}\n     * @method Tech.prototype.remoteTextTrackEls\n     */\n\n    ALL.names.forEach(function (name) {\n        const props = ALL[name];\n        Tech.prototype[props.getterName] = function () {\n            this[props.privateName] = this[props.privateName] || new props.ListClass();\n            return this[props.privateName];\n        };\n    });\n\n    /**\n     * List of associated text tracks\n     *\n     * @type {TextTrackList}\n     * @private\n     * @property Tech#textTracks_\n     */\n\n    /**\n     * List of associated audio tracks.\n     *\n     * @type {AudioTrackList}\n     * @private\n     * @property Tech#audioTracks_\n     */\n\n    /**\n     * List of associated video tracks.\n     *\n     * @type {VideoTrackList}\n     * @private\n     * @property Tech#videoTracks_\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports volume control.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresVolumeControl = true;\n\n    /**\n     * Boolean indicating whether the `Tech` supports muting volume.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresMuteControl = true;\n\n    /**\n     * Boolean indicating whether the `Tech` supports fullscreen resize control.\n     * Resizing plugins using request fullscreen reloads the plugin\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresFullscreenResize = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports changing the speed at which the video\n     * plays. Examples:\n     *   - Set player to play 2x (twice) as fast\n     *   - Set player to play 0.5x (half) as fast\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresPlaybackRate = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `progress` event.\n     * This will be used to determine if {@link Tech#manualProgressOn} should be called.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresProgressEvents = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `sourceset` event.\n     *\n     * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n     * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n     * a new source.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresSourceset = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `timeupdate` event.\n     * This will be used to determine if {@link Tech#manualTimeUpdates} should be called.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresTimeupdateEvents = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\n     * This will help us integrate with native `TextTrack`s if the browser supports them.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresNativeTextTracks = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports `requestVideoFrameCallback`.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresVideoFrameCallback = false;\n\n    /**\n     * A functional mixin for techs that want to use the Source Handler pattern.\n     * Source handlers are scripts for handling specific formats.\n     * The source handler pattern is used for adaptive formats (HLS, DASH) that\n     * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n     * Example: `Tech.withSourceHandlers.call(MyTech);`\n     *\n     * @param {Tech} _Tech\n     *        The tech to add source handler functions to.\n     *\n     * @mixes Tech~SourceHandlerAdditions\n     */\n    Tech.withSourceHandlers = function (_Tech) {\n        /**\n         * Register a source handler\n         *\n         * @param {Function} handler\n         *        The source handler class\n         *\n         * @param {number} [index]\n         *        Register it at the following index\n         */\n        _Tech.registerSourceHandler = function (handler, index) {\n            let handlers = _Tech.sourceHandlers;\n            if (!handlers) {\n                handlers = _Tech.sourceHandlers = [];\n            }\n            if (index === undefined) {\n                // add to the end of the list\n                index = handlers.length;\n            }\n            handlers.splice(index, 0, handler);\n        };\n\n        /**\n         * Check if the tech can support the given type. Also checks the\n         * Techs sourceHandlers.\n         *\n         * @param {string} type\n         *         The mimetype to check.\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        _Tech.canPlayType = function (type) {\n            const handlers = _Tech.sourceHandlers || [];\n            let can;\n            for (let i = 0; i < handlers.length; i++) {\n                can = handlers[i].canPlayType(type);\n                if (can) {\n                    return can;\n                }\n            }\n            return '';\n        };\n\n        /**\n         * Returns the first source handler that supports the source.\n         *\n         * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n         *\n         * @param {SourceObject} source\n         *        The source object\n         *\n         * @param {Object} options\n         *        The options passed to the tech\n         *\n         * @return {SourceHandler|null}\n         *          The first source handler that supports the source or null if\n         *          no SourceHandler supports the source\n         */\n        _Tech.selectSourceHandler = function (source, options) {\n            const handlers = _Tech.sourceHandlers || [];\n            let can;\n            for (let i = 0; i < handlers.length; i++) {\n                can = handlers[i].canHandleSource(source, options);\n                if (can) {\n                    return handlers[i];\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Check if the tech can support the given source.\n         *\n         * @param {SourceObject} srcObj\n         *        The source object\n         *\n         * @param {Object} options\n         *        The options passed to the tech\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        _Tech.canPlaySource = function (srcObj, options) {\n            const sh = _Tech.selectSourceHandler(srcObj, options);\n            if (sh) {\n                return sh.canHandleSource(srcObj, options);\n            }\n            return '';\n        };\n\n        /**\n         * When using a source handler, prefer its implementation of\n         * any function normally provided by the tech.\n         */\n        const deferrable = ['seekable', 'seeking', 'duration'];\n\n        /**\n         * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n         * function if it exists, with a fallback to the Techs seekable function.\n         *\n         * @method _Tech.seekable\n         */\n\n        /**\n         * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n         * function if it exists, otherwise it will fallback to the techs duration function.\n         *\n         * @method _Tech.duration\n         */\n\n        deferrable.forEach(function (fnName) {\n            const originalFn = this[fnName];\n            if (typeof originalFn !== 'function') {\n                return;\n            }\n            this[fnName] = function () {\n                if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n                    return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n                }\n                return originalFn.apply(this, arguments);\n            };\n        }, _Tech.prototype);\n\n        /**\n         * Create a function for setting the source using a source object\n         * and source handlers.\n         * Should never be called unless a source handler was found.\n         *\n         * @param {SourceObject} source\n         *        A source object with src and type keys\n         */\n        _Tech.prototype.setSource = function (source) {\n            let sh = _Tech.selectSourceHandler(source, this.options_);\n            if (!sh) {\n                // Fall back to a native source handler when unsupported sources are\n                // deliberately set\n                if (_Tech.nativeSourceHandler) {\n                    sh = _Tech.nativeSourceHandler;\n                } else {\n                    log$1.error('No source handler found for the current source.');\n                }\n            }\n\n            // Dispose any existing source handler\n            this.disposeSourceHandler();\n            this.off('dispose', this.disposeSourceHandler_);\n            if (sh !== _Tech.nativeSourceHandler) {\n                this.currentSource_ = source;\n            }\n            this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n            this.one('dispose', this.disposeSourceHandler_);\n        };\n\n        /**\n         * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n         *\n         * @listens Tech#dispose\n         */\n        _Tech.prototype.disposeSourceHandler = function () {\n            // if we have a source and get another one\n            // then we are loading something new\n            // than clear all of our current tracks\n            if (this.currentSource_) {\n                this.clearTracks(['audio', 'video']);\n                this.currentSource_ = null;\n            }\n\n            // always clean up auto-text tracks\n            this.cleanupAutoTextTracks();\n            if (this.sourceHandler_) {\n                if (this.sourceHandler_.dispose) {\n                    this.sourceHandler_.dispose();\n                }\n                this.sourceHandler_ = null;\n            }\n        };\n    };\n\n    // The base Tech class needs to be registered as a Component. It is the only\n    // Tech that can be registered as a Component.\n    Component$1.registerComponent('Tech', Tech);\n    Tech.registerTech('Tech', Tech);\n\n    /**\n     * A list of techs that should be added to techOrder on Players\n     *\n     * @private\n     */\n    Tech.defaultTechOrder_ = [];\n\n    /**\n     * @file middleware.js\n     * @module middleware\n     */\n    const middlewares = {};\n    const middlewareInstances = {};\n    const TERMINATOR = {};\n\n    /**\n     * A middleware object is a plain JavaScript object that has methods that\n     * match the {@link Tech} methods found in the lists of allowed\n     * {@link module:middleware.allowedGetters|getters},\n     * {@link module:middleware.allowedSetters|setters}, and\n     * {@link module:middleware.allowedMediators|mediators}.\n     *\n     * @typedef {Object} MiddlewareObject\n     */\n\n    /**\n     * A middleware factory function that should return a\n     * {@link module:middleware~MiddlewareObject|MiddlewareObject}.\n     *\n     * This factory will be called for each player when needed, with the player\n     * passed in as an argument.\n     *\n     * @callback MiddlewareFactory\n     * @param { import('../player').default } player\n     *        A Video.js player.\n     */\n\n    /**\n     * Define a middleware that the player should use by way of a factory function\n     * that returns a middleware object.\n     *\n     * @param  {string} type\n     *         The MIME type to match or `\"*\"` for all MIME types.\n     *\n     * @param  {MiddlewareFactory} middleware\n     *         A middleware factory function that will be executed for\n     *         matching types.\n     */\n    function use(type, middleware) {\n        middlewares[type] = middlewares[type] || [];\n        middlewares[type].push(middleware);\n    }\n\n    /**\n     * Asynchronously sets a source using middleware by recursing through any\n     * matching middlewares and calling `setSource` on each, passing along the\n     * previous returned value each time.\n     *\n     * @param  { import('../player').default } player\n     *         A {@link Player} instance.\n     *\n     * @param  {Tech~SourceObject} src\n     *         A source object.\n     *\n     * @param  {Function}\n     *         The next middleware to run.\n     */\n    function setSource(player, src, next) {\n        player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);\n    }\n\n    /**\n     * When the tech is set, passes the tech to each middleware's `setTech` method.\n     *\n     * @param {Object[]} middleware\n     *        An array of middleware instances.\n     *\n     * @param { import('../tech/tech').default } tech\n     *        A Video.js tech.\n     */\n    function setTech(middleware, tech) {\n        middleware.forEach(mw => mw.setTech && mw.setTech(tech));\n    }\n\n    /**\n     * Calls a getter on the tech first, through each middleware\n     * from right to left to the player.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @return {*}\n     *         The final value from the tech after middleware has intercepted it.\n     */\n    function get(middleware, tech, method) {\n        return middleware.reduceRight(middlewareIterator(method), tech[method]());\n    }\n\n    /**\n     * Takes the argument given to the player and calls the setter method on each\n     * middleware from left to right to the tech.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @param  {*} arg\n     *         The value to set on the tech.\n     *\n     * @return {*}\n     *         The return value of the `method` of the `tech`.\n     */\n    function set(middleware, tech, method, arg) {\n        return tech[method](middleware.reduce(middlewareIterator(method), arg));\n    }\n\n    /**\n     * Takes the argument given to the player and calls the `call` version of the\n     * method on each middleware from left to right.\n     *\n     * Then, call the passed in method on the tech and return the result unchanged\n     * back to the player, through middleware, this time from right to left.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @param  {*} arg\n     *         The value to set on the tech.\n     *\n     * @return {*}\n     *         The return value of the `method` of the `tech`, regardless of the\n     *         return values of middlewares.\n     */\n    function mediate(middleware, tech, method, arg = null) {\n        const callMethod = 'call' + toTitleCase$1(method);\n        const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n        const terminated = middlewareValue === TERMINATOR;\n        // deprecated. The `null` return value should instead return TERMINATOR to\n        // prevent confusion if a techs method actually returns null.\n        const returnValue = terminated ? null : tech[method](middlewareValue);\n        executeRight(middleware, method, returnValue, terminated);\n        return returnValue;\n    }\n\n    /**\n     * Enumeration of allowed getters where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedGetters = {\n        buffered: 1,\n        currentTime: 1,\n        duration: 1,\n        muted: 1,\n        played: 1,\n        paused: 1,\n        seekable: 1,\n        volume: 1,\n        ended: 1\n    };\n\n    /**\n     * Enumeration of allowed setters where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedSetters = {\n        setCurrentTime: 1,\n        setMuted: 1,\n        setVolume: 1\n    };\n\n    /**\n     * Enumeration of allowed mediators where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedMediators = {\n        play: 1,\n        pause: 1\n    };\n    function middlewareIterator(method) {\n        return (value, mw) => {\n            // if the previous middleware terminated, pass along the termination\n            if (value === TERMINATOR) {\n                return TERMINATOR;\n            }\n            if (mw[method]) {\n                return mw[method](value);\n            }\n            return value;\n        };\n    }\n    function executeRight(mws, method, value, terminated) {\n        for (let i = mws.length - 1; i >= 0; i--) {\n            const mw = mws[i];\n            if (mw[method]) {\n                mw[method](terminated, value);\n            }\n        }\n    }\n\n    /**\n     * Clear the middleware cache for a player.\n     *\n     * @param  { import('../player').default } player\n     *         A {@link Player} instance.\n     */\n    function clearCacheForPlayer(player) {\n        middlewareInstances[player.id()] = null;\n    }\n\n    /**\n     * {\n     *  [playerId]: [[mwFactory, mwInstance], ...]\n     * }\n     *\n     * @private\n     */\n    function getOrCreateFactory(player, mwFactory) {\n        const mws = middlewareInstances[player.id()];\n        let mw = null;\n        if (mws === undefined || mws === null) {\n            mw = mwFactory(player);\n            middlewareInstances[player.id()] = [[mwFactory, mw]];\n            return mw;\n        }\n        for (let i = 0; i < mws.length; i++) {\n            const [mwf, mwi] = mws[i];\n            if (mwf !== mwFactory) {\n                continue;\n            }\n            mw = mwi;\n        }\n        if (mw === null) {\n            mw = mwFactory(player);\n            mws.push([mwFactory, mw]);\n        }\n        return mw;\n    }\n    function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {\n        const [mwFactory, ...mwrest] = middleware;\n\n        // if mwFactory is a string, then we're at a fork in the road\n        if (typeof mwFactory === 'string') {\n            setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n            // if we have an mwFactory, call it with the player to get the mw,\n            // then call the mw's setSource method\n        } else if (mwFactory) {\n            const mw = getOrCreateFactory(player, mwFactory);\n\n            // if setSource isn't present, implicitly select this middleware\n            if (!mw.setSource) {\n                acc.push(mw);\n                return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n            }\n            mw.setSource(Object.assign({}, src), function (err, _src) {\n                // something happened, try the next middleware on the current level\n                // make sure to use the old src\n                if (err) {\n                    return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n                }\n\n                // we've succeeded, now we need to go deeper\n                acc.push(mw);\n\n                // if it's the same type, continue down the current chain\n                // otherwise, we want to go down the new chain\n                setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n            });\n        } else if (mwrest.length) {\n            setSourceHelper(src, mwrest, next, player, acc, lastRun);\n        } else if (lastRun) {\n            next(src, acc);\n        } else {\n            setSourceHelper(src, middlewares['*'], next, player, acc, true);\n        }\n    }\n\n    /**\n     * Mimetypes\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml\n     * @typedef Mimetypes~Kind\n     * @enum\n     */\n    const MimetypesKind = {\n        opus: 'video/ogg',\n        ogv: 'video/ogg',\n        mp4: 'video/mp4',\n        mov: 'video/mp4',\n        m4v: 'video/mp4',\n        mkv: 'video/x-matroska',\n        m4a: 'audio/mp4',\n        mp3: 'audio/mpeg',\n        aac: 'audio/aac',\n        caf: 'audio/x-caf',\n        flac: 'audio/flac',\n        oga: 'audio/ogg',\n        wav: 'audio/wav',\n        m3u8: 'application/x-mpegURL',\n        mpd: 'application/dash+xml',\n        jpg: 'image/jpeg',\n        jpeg: 'image/jpeg',\n        gif: 'image/gif',\n        png: 'image/png',\n        svg: 'image/svg+xml',\n        webp: 'image/webp'\n    };\n\n    /**\n     * Get the mimetype of a given src url if possible\n     *\n     * @param {string} src\n     *        The url to the src\n     *\n     * @return {string}\n     *         return the mimetype if it was known or empty string otherwise\n     */\n    const getMimetype = function (src = '') {\n        const ext = getFileExtension(src);\n        const mimetype = MimetypesKind[ext.toLowerCase()];\n        return mimetype || '';\n    };\n\n    /**\n     * Find the mime type of a given source string if possible. Uses the player\n     * source cache.\n     *\n     * @param { import('../player').default } player\n     *        The player object\n     *\n     * @param {string} src\n     *        The source string\n     *\n     * @return {string}\n     *         The type that was found\n     */\n    const findMimetype = (player, src) => {\n        if (!src) {\n            return '';\n        }\n\n        // 1. check for the type in the `source` cache\n        if (player.cache_.source.src === src && player.cache_.source.type) {\n            return player.cache_.source.type;\n        }\n\n        // 2. see if we have this source in our `currentSources` cache\n        const matchingSources = player.cache_.sources.filter(s => s.src === src);\n        if (matchingSources.length) {\n            return matchingSources[0].type;\n        }\n\n        // 3. look for the src url in source elements and use the type there\n        const sources = player.$$('source');\n        for (let i = 0; i < sources.length; i++) {\n            const s = sources[i];\n            if (s.type && s.src && s.src === src) {\n                return s.type;\n            }\n        }\n\n        // 4. finally fallback to our list of mime types based on src url extension\n        return getMimetype(src);\n    };\n\n    /**\n     * @module filter-source\n     */\n\n    /**\n     * Filter out single bad source objects or multiple source objects in an\n     * array. Also flattens nested source object arrays into a 1 dimensional\n     * array of source objects.\n     *\n     * @param {Tech~SourceObject|Tech~SourceObject[]} src\n     *        The src object to filter\n     *\n     * @return {Tech~SourceObject[]}\n     *         An array of sourceobjects containing only valid sources\n     *\n     * @private\n     */\n    const filterSource = function (src) {\n        // traverse array\n        if (Array.isArray(src)) {\n            let newsrc = [];\n            src.forEach(function (srcobj) {\n                srcobj = filterSource(srcobj);\n                if (Array.isArray(srcobj)) {\n                    newsrc = newsrc.concat(srcobj);\n                } else if (isObject$1(srcobj)) {\n                    newsrc.push(srcobj);\n                }\n            });\n            src = newsrc;\n        } else if (typeof src === 'string' && src.trim()) {\n            // convert string into object\n            src = [fixSource({\n                src\n            })];\n        } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n            // src is already valid\n            src = [fixSource(src)];\n        } else {\n            // invalid source, turn it into an empty array\n            src = [];\n        }\n        return src;\n    };\n\n    /**\n     * Checks src mimetype, adding it when possible\n     *\n     * @param {Tech~SourceObject} src\n     *        The src object to check\n     * @return {Tech~SourceObject}\n     *        src Object with known type\n     */\n    function fixSource(src) {\n        if (!src.type) {\n            const mimetype = getMimetype(src.src);\n            if (mimetype) {\n                src.type = mimetype;\n            }\n        }\n        return src;\n    }\n\n    var icons = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <defs>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-play\\\">\\n      <path d=\\\"M16 10v28l22-14z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-pause\\\">\\n      <path d=\\\"M12 38h8V10h-8v28zm16-28v28h8V10h-8z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-audio\\\">\\n      <path d=\\\"M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-captions\\\">\\n      <path d=\\\"M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-subtitles\\\">\\n      <path d=\\\"M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-fullscreen-enter\\\">\\n      <path d=\\\"M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-fullscreen-exit\\\">\\n      <path d=\\\"M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-play-circle\\\">\\n      <path d=\\\"M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-volume-mute\\\">\\n      <path d=\\\"M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-volume-low\\\">\\n      <path d=\\\"M14 18v12h8l10 10V8L22 18h-8z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-volume-medium\\\">\\n      <path d=\\\"M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-volume-high\\\">\\n      <path d=\\\"M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-spinner\\\">\\n      <path d=\\\"M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 24 24\\\" id=\\\"vjs-icon-hd\\\">\\n      <path d=\\\"M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-chapters\\\">\\n      <path d=\\\"M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 40 40\\\" id=\\\"vjs-icon-downloading\\\">\\n      <path d=\\\"M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-file-download\\\">\\n      <path d=\\\"M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-file-download-done\\\">\\n      <path d=\\\"M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-file-download-off\\\">\\n      <path d=\\\"M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-share\\\">\\n      <path d=\\\"M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-cog\\\">\\n      <path d=\\\"M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-square\\\">\\n      <path d=\\\"M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-circle\\\">\\n      <circle cx=\\\"24\\\" cy=\\\"24\\\" r=\\\"20\\\"></circle>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-circle-outline\\\">\\n      <path d=\\\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-circle-inner-circle\\\">\\n      <path d=\\\"M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-cancel\\\">\\n      <path d=\\\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-replay\\\">\\n      <path d=\\\"M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-repeat\\\">\\n      <path d=\\\"M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-replay-5\\\">\\n      <path d=\\\"M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-replay-10\\\">\\n      <path d=\\\"M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-replay-30\\\">\\n      <path d=\\\"M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-forward-5\\\">\\n      <path d=\\\"M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-forward-10\\\">\\n      <path d=\\\"M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 96 48 48\\\" id=\\\"vjs-icon-forward-30\\\">\\n      <path d=\\\"M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 512 512\\\" id=\\\"vjs-icon-audio-description\\\">\\n      <g fill-rule=\\\"evenodd\\\"><path d=\\\"M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57\\\"></path><path d=\\\"M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894\\\"></path><path d=\\\"M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894\\\"></path><path d=\\\"M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z\\\"></path></g>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-next-item\\\">\\n      <path d=\\\"M12 36l17-12-17-12v24zm20-24v24h4V12h-4z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-previous-item\\\">\\n      <path d=\\\"M12 12h4v24h-4zm7 12l17 12V12z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-shuffle\\\">\\n      <path d=\\\"M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-cast\\\">\\n      <path d=\\\"M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 48 48\\\" id=\\\"vjs-icon-picture-in-picture-enter\\\">\\n      <path d=\\\"M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 22 18\\\" id=\\\"vjs-icon-picture-in-picture-exit\\\">\\n      <path d=\\\"M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z\\\"></path>\\n      <path fill=\\\"none\\\" d=\\\"M-1-3h24v24H-1z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 1792 1792\\\" id=\\\"vjs-icon-facebook\\\">\\n      <path d=\\\"M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 1792 1792\\\" id=\\\"vjs-icon-linkedin\\\">\\n      <path d=\\\"M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 1792 1792\\\" id=\\\"vjs-icon-twitter\\\">\\n      <path d=\\\"M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 1792 1792\\\" id=\\\"vjs-icon-tumblr\\\">\\n      <path d=\\\"M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z\\\"></path>\\n    </symbol>\\n    <symbol viewBox=\\\"0 0 1792 1792\\\" id=\\\"vjs-icon-pinterest\\\">\\n      <path d=\\\"M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z\\\"></path>\\n    </symbol>\\n  </defs>\\n</svg>\";\n\n    /**\n     * @file loader.js\n     */\n\n    /**\n     * The `MediaLoader` is the `Component` that decides which playback technology to load\n     * when a player is initialized.\n     *\n     * @extends Component\n     */\n    class MediaLoader extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should attach to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function that is run when this component is ready.\n         */\n        constructor(player, options, ready) {\n            // MediaLoader has no element\n            const options_ = merge$2({\n                createEl: false\n            }, options);\n            super(player, options_, ready);\n\n            // If there are no sources when the player is initialized,\n            // load the first supported playback technology.\n\n            if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n                for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n                    const techName = toTitleCase$1(j[i]);\n                    let tech = Tech.getTech(techName);\n\n                    // Support old behavior of techs being registered as components.\n                    // Remove once that deprecated behavior is removed.\n                    if (!techName) {\n                        tech = Component$1.getComponent(techName);\n                    }\n\n                    // Check if the browser supports this technology\n                    if (tech && tech.isSupported()) {\n                        player.loadTech_(techName);\n                        break;\n                    }\n                }\n            } else {\n                // Loop through playback technologies (e.g. HTML5) and check for support.\n                // Then load the best source.\n                // A few assumptions here:\n                //   All playback technologies respect preload false.\n                player.src(options.playerOptions.sources);\n            }\n        }\n    }\n    Component$1.registerComponent('MediaLoader', MediaLoader);\n\n    /**\n     * @file clickable-component.js\n     */\n\n    /**\n     * Component which is clickable or keyboard actionable, but is not a\n     * native HTML button.\n     *\n     * @extends Component\n     */\n    class ClickableComponent extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of component options.\n         *\n         * @param  {function} [options.clickHandler]\n         *         The function to call when the button is clicked / activated\n         *\n         * @param  {string} [options.controlText]\n         *         The text to set on the button\n         *\n         * @param  {string} [options.className]\n         *         A class or space separated list of classes to add the component\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            if (this.options_.controlText) {\n                this.controlText(this.options_.controlText);\n            }\n            this.handleMouseOver_ = e => this.handleMouseOver(e);\n            this.handleMouseOut_ = e => this.handleMouseOut(e);\n            this.handleClick_ = e => this.handleClick(e);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.emitTapEvents();\n            this.enable();\n        }\n\n        /**\n         * Create the `ClickableComponent`s DOM element.\n         *\n         * @param {string} [tag=div]\n         *        The element's node type.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element.\n         *\n         * @param {Object} [attributes={}]\n         *        An object of attributes that should be set on the element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tag = 'div', props = {}, attributes = {}) {\n            props = Object.assign({\n                className: this.buildCSSClass(),\n                tabIndex: 0\n            }, props);\n            if (tag === 'button') {\n                log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);\n            }\n\n            // Add ARIA attributes for clickable element which is not a native HTML button\n            attributes = Object.assign({\n                role: 'button'\n            }, attributes);\n            this.tabIndex_ = props.tabIndex;\n            const el = createEl(tag, props, attributes);\n            if (!this.player_.options_.experimentalSvgIcons) {\n                el.appendChild(createEl('span', {\n                    className: 'vjs-icon-placeholder'\n                }, {\n                    'aria-hidden': true\n                }));\n            }\n            this.createControlTextEl(el);\n            return el;\n        }\n        dispose() {\n            // remove controlTextEl_ on dispose\n            this.controlTextEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Create a control text element on this `ClickableComponent`\n         *\n         * @param {Element} [el]\n         *        Parent element for the control text.\n         *\n         * @return {Element}\n         *         The control text element that gets created.\n         */\n        createControlTextEl(el) {\n            this.controlTextEl_ = createEl('span', {\n                className: 'vjs-control-text'\n            }, {\n                // let the screen reader user know that the text of the element may change\n                'aria-live': 'polite'\n            });\n            if (el) {\n                el.appendChild(this.controlTextEl_);\n            }\n            this.controlText(this.controlText_, el);\n            return this.controlTextEl_;\n        }\n\n        /**\n         * Get or set the localize text to use for the controls on the `ClickableComponent`.\n         *\n         * @param {string} [text]\n         *        Control text for element.\n         *\n         * @param {Element} [el=this.el()]\n         *        Element to set the title on.\n         *\n         * @return {string}\n         *         - The control text when getting\n         */\n        controlText(text, el = this.el()) {\n            if (text === undefined) {\n                return this.controlText_ || 'Need Text';\n            }\n            const localizedText = this.localize(text);\n\n            /** @protected */\n            this.controlText_ = text;\n            textContent(this.controlTextEl_, localizedText);\n            if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {\n                // Set title attribute if only an icon is shown\n                el.setAttribute('title', localizedText);\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-control vjs-button ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Enable this `ClickableComponent`\n         */\n        enable() {\n            if (!this.enabled_) {\n                this.enabled_ = true;\n                this.removeClass('vjs-disabled');\n                this.el_.setAttribute('aria-disabled', 'false');\n                if (typeof this.tabIndex_ !== 'undefined') {\n                    this.el_.setAttribute('tabIndex', this.tabIndex_);\n                }\n                this.on(['tap', 'click'], this.handleClick_);\n                this.on('keydown', this.handleKeyDown_);\n            }\n        }\n\n        /**\n         * Disable this `ClickableComponent`\n         */\n        disable() {\n            this.enabled_ = false;\n            this.addClass('vjs-disabled');\n            this.el_.setAttribute('aria-disabled', 'true');\n            if (typeof this.tabIndex_ !== 'undefined') {\n                this.el_.removeAttribute('tabIndex');\n            }\n            this.off('mouseover', this.handleMouseOver_);\n            this.off('mouseout', this.handleMouseOut_);\n            this.off(['tap', 'click'], this.handleClick_);\n            this.off('keydown', this.handleKeyDown_);\n        }\n\n        /**\n         * Handles language change in ClickableComponent for the player in components\n         *\n         *\n         */\n        handleLanguagechange() {\n            this.controlText(this.controlText_);\n        }\n\n        /**\n         * Event handler that is called when a `ClickableComponent` receives a\n         * `click` or `tap` event.\n         *\n         * @param {Event} event\n         *        The `tap` or `click` event that caused this function to be called.\n         *\n         * @listens tap\n         * @listens click\n         * @abstract\n         */\n        handleClick(event) {\n            if (this.options_.clickHandler) {\n                this.options_.clickHandler.call(this, arguments);\n            }\n        }\n\n        /**\n         * Event handler that is called when a `ClickableComponent` receives a\n         * `keydown` event.\n         *\n         * By default, if the key is Space or Enter, it will trigger a `click` event.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Support Space or Enter key operation to fire a click event. Also,\n            // prevent the event from propagating through the DOM and triggering\n            // Player hotkeys.\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.trigger('click');\n            } else {\n                // Pass keypress handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n    }\n    Component$1.registerComponent('ClickableComponent', ClickableComponent);\n\n    /**\n     * @file poster-image.js\n     */\n\n    /**\n     * A `ClickableComponent` that handles showing the poster image for the player.\n     *\n     * @extends ClickableComponent\n     */\n    class PosterImage extends ClickableComponent {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should attach to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update();\n            this.update_ = e => this.update(e);\n            player.on('posterchange', this.update_);\n        }\n\n        /**\n         * Clean up and dispose of the `PosterImage`.\n         */\n        dispose() {\n            this.player().off('posterchange', this.update_);\n            super.dispose();\n        }\n\n        /**\n         * Create the `PosterImage`s DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            // The el is an empty div to keep position in the DOM\n            // A picture and img el will be inserted when a source is set\n            return createEl('div', {\n                className: 'vjs-poster'\n            });\n        }\n\n        /**\n         * Get or set the `PosterImage`'s crossOrigin option.\n         *\n         * @param {string|null} [value]\n         *        The value to set the crossOrigin to. If an argument is\n         *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n         *\n         * @return {string|null}\n         *         - The current crossOrigin value of the `Player` when getting.\n         *         - undefined when setting\n         */\n        crossOrigin(value) {\n            // `null` can be set to unset a value\n            if (typeof value === 'undefined') {\n                if (this.$('img')) {\n                    // If the poster's element exists, give its value\n                    return this.$('img').crossOrigin;\n                } else if (this.player_.tech_ && this.player_.tech_.isReady_) {\n                    // If not but the tech is ready, query the tech\n                    return this.player_.crossOrigin();\n                }\n                // Otherwise check options as the  poster is usually set before the state of crossorigin\n                // can be retrieved by the getter\n                return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;\n            }\n            if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n                this.player_.log.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n                return;\n            }\n            if (this.$('img')) {\n                this.$('img').crossOrigin = value;\n            }\n            return;\n        }\n\n        /**\n         * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n         *\n         * @listens Player#posterchange\n         *\n         * @param {Event} [event]\n         *        The `Player#posterchange` event that triggered this function.\n         */\n        update(event) {\n            const url = this.player().poster();\n            this.setSrc(url);\n\n            // If there's no poster source we should display:none on this component\n            // so it's not still clickable or right-clickable\n            if (url) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n\n        /**\n         * Set the source of the `PosterImage` depending on the display method. (Re)creates\n         * the inner picture and img elementss when needed.\n         *\n         * @param {string} [url]\n         *        The URL to the source for the `PosterImage`. If not specified or falsy,\n         *        any source and ant inner picture/img are removed.\n         */\n        setSrc(url) {\n            if (!url) {\n                this.el_.textContent = '';\n                return;\n            }\n            if (!this.$('img')) {\n                this.el_.appendChild(createEl('picture', {\n                    className: 'vjs-poster',\n                    // Don't want poster to be tabbable.\n                    tabIndex: -1\n                }, {}, createEl('img', {\n                    loading: 'lazy',\n                    crossOrigin: this.crossOrigin()\n                }, {\n                    alt: ''\n                })));\n            }\n            this.$('img').src = url;\n        }\n\n        /**\n         * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n         * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n         *\n         * @listens tap\n         * @listens click\n         * @listens keydown\n         *\n         * @param {Event} event\n         +        The `click`, `tap` or `keydown` event that caused this function to be called.\n         */\n        handleClick(event) {\n            // We don't want a click to trigger playback when controls are disabled\n            if (!this.player_.controls()) {\n                return;\n            }\n            if (this.player_.tech(true)) {\n                this.player_.tech(true).focus();\n            }\n            if (this.player_.paused()) {\n                silencePromise(this.player_.play());\n            } else {\n                this.player_.pause();\n            }\n        }\n    }\n\n    /**\n     * Get or set the `PosterImage`'s crossorigin option. For the HTML5 player, this\n     * sets the `crossOrigin` property on the `<img>` tag to control the CORS\n     * behavior.\n     *\n     * @param {string|null} [value]\n     *        The value to set the `PosterImages`'s crossorigin to. If an argument is\n     *        given, must be one of `anonymous` or `use-credentials`.\n     *\n     * @return {string|null|undefined}\n     *         - The current crossorigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;\n    Component$1.registerComponent('PosterImage', PosterImage);\n\n    /**\n     * @file text-track-display.js\n     */\n    const darkGray = '#222';\n    const lightGray = '#ccc';\n    const fontMap = {\n        monospace: 'monospace',\n        sansSerif: 'sans-serif',\n        serif: 'serif',\n        monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n        monospaceSerif: '\"Courier New\", monospace',\n        proportionalSansSerif: 'sans-serif',\n        proportionalSerif: 'serif',\n        casual: '\"Comic Sans MS\", Impact, fantasy',\n        script: '\"Monotype Corsiva\", cursive',\n        smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n    };\n\n    /**\n     * Construct an rgba color from a given hex color code.\n     *\n     * @param {number} color\n     *        Hex number for color, like #f0e or #f604e2.\n     *\n     * @param {number} opacity\n     *        Value for opacity, 0.0 - 1.0.\n     *\n     * @return {string}\n     *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n     */\n    function constructColor(color, opacity) {\n        let hex;\n        if (color.length === 4) {\n            // color looks like \"#f0e\"\n            hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n        } else if (color.length === 7) {\n            // color looks like \"#f604e2\"\n            hex = color.slice(1);\n        } else {\n            throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n        }\n        return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n    }\n\n    /**\n     * Try to update the style of a DOM element. Some style changes will throw an error,\n     * particularly in IE8. Those should be noops.\n     *\n     * @param {Element} el\n     *        The DOM element to be styled.\n     *\n     * @param {string} style\n     *        The CSS property on the element that should be styled.\n     *\n     * @param {string} rule\n     *        The style rule that should be applied to the property.\n     *\n     * @private\n     */\n    function tryUpdateStyle(el, style, rule) {\n        try {\n            el.style[style] = rule;\n        } catch (e) {\n            // Satisfies linter.\n            return;\n        }\n    }\n\n    /**\n     * Converts the CSS top/right/bottom/left property numeric value to string in pixels.\n     *\n     * @param {number} position\n     *        The CSS top/right/bottom/left property value.\n     *\n     * @return {string}\n     *          The CSS property value that was created, like '10px'.\n     *\n     * @private\n     */\n    function getCSSPositionValue(position) {\n        return position ? `${position}px` : '';\n    }\n\n    /**\n     * The component for displaying text track cues.\n     *\n     * @extends Component\n     */\n    class TextTrackDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when `TextTrackDisplay` is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            const updateDisplayTextHandler = e => this.updateDisplay(e);\n            const updateDisplayHandler = e => {\n                this.updateDisplayOverlay();\n                this.updateDisplay(e);\n            };\n            player.on('loadstart', e => this.toggleDisplay(e));\n            player.on('texttrackchange', updateDisplayTextHandler);\n            player.on('loadedmetadata', e => {\n                this.updateDisplayOverlay();\n                this.preselectTrack(e);\n            });\n\n            // This used to be called during player init, but was causing an error\n            // if a track should show by default and the display hadn't loaded yet.\n            // Should probably be moved to an external track loader when we support\n            // tracks that don't need a display.\n            player.ready(bind_(this, function () {\n                if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n                    this.hide();\n                    return;\n                }\n                player.on('fullscreenchange', updateDisplayHandler);\n                player.on('playerresize', updateDisplayHandler);\n                const screenOrientation = window.screen.orientation || window;\n                const changeOrientationEvent = window.screen.orientation ? 'change' : 'orientationchange';\n                screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);\n                player.on('dispose', () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));\n                const tracks = this.options_.playerOptions.tracks || [];\n                for (let i = 0; i < tracks.length; i++) {\n                    this.player_.addRemoteTextTrack(tracks[i], true);\n                }\n                this.preselectTrack();\n            }));\n        }\n\n        /**\n         * Preselect a track following this precedence:\n         * - matches the previously selected {@link TextTrack}'s language and kind\n         * - matches the previously selected {@link TextTrack}'s language only\n         * - is the first default captions track\n         * - is the first default descriptions track\n         *\n         * @listens Player#loadstart\n         */\n        preselectTrack() {\n            const modes = {\n                captions: 1,\n                subtitles: 1\n            };\n            const trackList = this.player_.textTracks();\n            const userPref = this.player_.cache_.selectedLanguage;\n            let firstDesc;\n            let firstCaptions;\n            let preferredTrack;\n            for (let i = 0; i < trackList.length; i++) {\n                const track = trackList[i];\n                if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {\n                    // Always choose the track that matches both language and kind\n                    if (track.kind === userPref.kind) {\n                        preferredTrack = track;\n                        // or choose the first track that matches language\n                    } else if (!preferredTrack) {\n                        preferredTrack = track;\n                    }\n\n                    // clear everything if offTextTrackMenuItem was clicked\n                } else if (userPref && !userPref.enabled) {\n                    preferredTrack = null;\n                    firstDesc = null;\n                    firstCaptions = null;\n                } else if (track.default) {\n                    if (track.kind === 'descriptions' && !firstDesc) {\n                        firstDesc = track;\n                    } else if (track.kind in modes && !firstCaptions) {\n                        firstCaptions = track;\n                    }\n                }\n            }\n\n            // The preferredTrack matches the user preference and takes\n            // precedence over all the other tracks.\n            // So, display the preferredTrack before the first default track\n            // and the subtitles/captions track before the descriptions track\n            if (preferredTrack) {\n                preferredTrack.mode = 'showing';\n            } else if (firstCaptions) {\n                firstCaptions.mode = 'showing';\n            } else if (firstDesc) {\n                firstDesc.mode = 'showing';\n            }\n        }\n\n        /**\n         * Turn display of {@link TextTrack}'s from the current state into the other state.\n         * There are only two states:\n         * - 'shown'\n         * - 'hidden'\n         *\n         * @listens Player#loadstart\n         */\n        toggleDisplay() {\n            if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        }\n\n        /**\n         * Create the {@link Component}'s DOM element.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-text-track-display'\n            }, {\n                'translate': 'yes',\n                'aria-live': 'off',\n                'aria-atomic': 'true'\n            });\n        }\n\n        /**\n         * Clear all displayed {@link TextTrack}s.\n         */\n        clearDisplay() {\n            if (typeof window.WebVTT === 'function') {\n                window.WebVTT.processCues(window, [], this.el_);\n            }\n        }\n\n        /**\n         * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n         * a {@link Player#fullscreenchange} is fired.\n         *\n         * @listens Player#texttrackchange\n         * @listens Player#fullscreenchange\n         */\n        updateDisplay() {\n            const tracks = this.player_.textTracks();\n            const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;\n            this.clearDisplay();\n            if (allowMultipleShowingTracks) {\n                const showingTracks = [];\n                for (let i = 0; i < tracks.length; ++i) {\n                    const track = tracks[i];\n                    if (track.mode !== 'showing') {\n                        continue;\n                    }\n                    showingTracks.push(track);\n                }\n                this.updateForTrack(showingTracks);\n                return;\n            }\n\n            //  Track display prioritization model: if multiple tracks are 'showing',\n            //  display the first 'subtitles' or 'captions' track which is 'showing',\n            //  otherwise display the first 'descriptions' track which is 'showing'\n\n            let descriptionsTrack = null;\n            let captionsSubtitlesTrack = null;\n            let i = tracks.length;\n            while (i--) {\n                const track = tracks[i];\n                if (track.mode === 'showing') {\n                    if (track.kind === 'descriptions') {\n                        descriptionsTrack = track;\n                    } else {\n                        captionsSubtitlesTrack = track;\n                    }\n                }\n            }\n            if (captionsSubtitlesTrack) {\n                if (this.getAttribute('aria-live') !== 'off') {\n                    this.setAttribute('aria-live', 'off');\n                }\n                this.updateForTrack(captionsSubtitlesTrack);\n            } else if (descriptionsTrack) {\n                if (this.getAttribute('aria-live') !== 'assertive') {\n                    this.setAttribute('aria-live', 'assertive');\n                }\n                this.updateForTrack(descriptionsTrack);\n            }\n        }\n\n        /**\n         * Updates the displayed TextTrack to be sure it overlays the video when a either\n         * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.\n         */\n        updateDisplayOverlay() {\n            // inset-inline and inset-block are not supprted on old chrome, but these are\n            // only likely to be used on TV devices\n            if (!this.player_.videoHeight() || !window.CSS.supports('inset-inline: 10px')) {\n                return;\n            }\n            const playerWidth = this.player_.currentWidth();\n            const playerHeight = this.player_.currentHeight();\n            const playerAspectRatio = playerWidth / playerHeight;\n            const videoAspectRatio = this.player_.videoWidth() / this.player_.videoHeight();\n            let insetInlineMatch = 0;\n            let insetBlockMatch = 0;\n            if (Math.abs(playerAspectRatio - videoAspectRatio) > 0.1) {\n                if (playerAspectRatio > videoAspectRatio) {\n                    insetInlineMatch = Math.round((playerWidth - playerHeight * videoAspectRatio) / 2);\n                } else {\n                    insetBlockMatch = Math.round((playerHeight - playerWidth / videoAspectRatio) / 2);\n                }\n            }\n            tryUpdateStyle(this.el_, 'insetInline', getCSSPositionValue(insetInlineMatch));\n            tryUpdateStyle(this.el_, 'insetBlock', getCSSPositionValue(insetBlockMatch));\n        }\n\n        /**\n         * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.\n         *\n         * @param {TextTrack} track\n         *        Text track object containing active cues to style.\n         */\n        updateDisplayState(track) {\n            const overrides = this.player_.textTrackSettings.getValues();\n            const cues = track.activeCues;\n            let i = cues.length;\n            while (i--) {\n                const cue = cues[i];\n                if (!cue) {\n                    continue;\n                }\n                const cueDiv = cue.displayState;\n                if (overrides.color) {\n                    cueDiv.firstChild.style.color = overrides.color;\n                }\n                if (overrides.textOpacity) {\n                    tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n                }\n                if (overrides.backgroundColor) {\n                    cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n                }\n                if (overrides.backgroundOpacity) {\n                    tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n                }\n                if (overrides.windowColor) {\n                    if (overrides.windowOpacity) {\n                        tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n                    } else {\n                        cueDiv.style.backgroundColor = overrides.windowColor;\n                    }\n                }\n                if (overrides.edgeStyle) {\n                    if (overrides.edgeStyle === 'dropshadow') {\n                        cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'raised') {\n                        cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'depressed') {\n                        cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'uniform') {\n                        cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;\n                    }\n                }\n                if (overrides.fontPercent && overrides.fontPercent !== 1) {\n                    const fontSize = window.parseFloat(cueDiv.style.fontSize);\n                    cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n                    cueDiv.style.height = 'auto';\n                    cueDiv.style.top = 'auto';\n                }\n                if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n                    if (overrides.fontFamily === 'small-caps') {\n                        cueDiv.firstChild.style.fontVariant = 'small-caps';\n                    } else {\n                        cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n                    }\n                }\n            }\n        }\n\n        /**\n         * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\n         *\n         * @param {TextTrack|TextTrack[]} tracks\n         *        Text track object or text track array to be added to the list.\n         */\n        updateForTrack(tracks) {\n            if (!Array.isArray(tracks)) {\n                tracks = [tracks];\n            }\n            if (typeof window.WebVTT !== 'function' || tracks.every(track => {\n                return !track.activeCues;\n            })) {\n                return;\n            }\n            const cues = [];\n\n            // push all active track cues\n            for (let i = 0; i < tracks.length; ++i) {\n                const track = tracks[i];\n                for (let j = 0; j < track.activeCues.length; ++j) {\n                    cues.push(track.activeCues[j]);\n                }\n            }\n\n            // removes all cues before it processes new ones\n            window.WebVTT.processCues(window, cues, this.el_);\n\n            // add unique class to each language text track & add settings styling if necessary\n            for (let i = 0; i < tracks.length; ++i) {\n                const track = tracks[i];\n                for (let j = 0; j < track.activeCues.length; ++j) {\n                    const cueEl = track.activeCues[j].displayState;\n                    addClass(cueEl, 'vjs-text-track-cue', 'vjs-text-track-cue-' + (track.language ? track.language : i));\n                    if (track.language) {\n                        setAttribute(cueEl, 'lang', track.language);\n                    }\n                }\n                if (this.player_.textTrackSettings) {\n                    this.updateDisplayState(track);\n                }\n            }\n        }\n    }\n    Component$1.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n    /**\n     * @file loading-spinner.js\n     */\n\n    /**\n     * A loading spinner for use during waiting/loading events.\n     *\n     * @extends Component\n     */\n    class LoadingSpinner extends Component$1 {\n        /**\n         * Create the `LoadingSpinner`s DOM element.\n         *\n         * @return {Element}\n         *         The dom element that gets created.\n         */\n        createEl() {\n            const isAudio = this.player_.isAudio();\n            const playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n            const controlText = createEl('span', {\n                className: 'vjs-control-text',\n                textContent: this.localize('{1} is loading.', [playerType])\n            });\n            const el = super.createEl('div', {\n                className: 'vjs-loading-spinner',\n                dir: 'ltr'\n            });\n            el.appendChild(controlText);\n            return el;\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-control-text').textContent = this.localize('{1} is loading.', [this.player_.isAudio() ? 'Audio Player' : 'Video Player']);\n        }\n    }\n    Component$1.registerComponent('LoadingSpinner', LoadingSpinner);\n\n    /**\n     * @file button.js\n     */\n\n    /**\n     * Base class for all buttons.\n     *\n     * @extends ClickableComponent\n     */\n    class Button extends ClickableComponent {\n        /**\n         * Create the `Button`s DOM element.\n         *\n         * @param {string} [tag=\"button\"]\n         *        The element's node type. This argument is IGNORED: no matter what\n         *        is passed, it will always create a `button` element.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element.\n         *\n         * @param {Object} [attributes={}]\n         *        An object of attributes that should be set on the element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tag, props = {}, attributes = {}) {\n            tag = 'button';\n            props = Object.assign({\n                className: this.buildCSSClass()\n            }, props);\n\n            // Add attributes for button element\n            attributes = Object.assign({\n                // Necessary since the default button type is \"submit\"\n                type: 'button'\n            }, attributes);\n            const el = createEl(tag, props, attributes);\n            if (!this.player_.options_.experimentalSvgIcons) {\n                el.appendChild(createEl('span', {\n                    className: 'vjs-icon-placeholder'\n                }, {\n                    'aria-hidden': true\n                }));\n            }\n            this.createControlTextEl(el);\n            return el;\n        }\n\n        /**\n         * Add a child `Component` inside of this `Button`.\n         *\n         * @param {string|Component} child\n         *        The name or instance of a child to add.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of options that will get passed to children of\n         *        the child.\n         *\n         * @return {Component}\n         *         The `Component` that gets added as a child. When using a string the\n         *         `Component` will get created by this process.\n         *\n         * @deprecated since version 5\n         */\n        addChild(child, options = {}) {\n            const className = this.constructor.name;\n            log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);\n\n            // Avoid the error message generated by ClickableComponent's addChild method\n            return Component$1.prototype.addChild.call(this, child, options);\n        }\n\n        /**\n         * Enable the `Button` element so that it can be activated or clicked. Use this with\n         * {@link Button#disable}.\n         */\n        enable() {\n            super.enable();\n            this.el_.removeAttribute('disabled');\n        }\n\n        /**\n         * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n         * {@link Button#enable}.\n         */\n        disable() {\n            super.disable();\n            this.el_.setAttribute('disabled', 'disabled');\n        }\n\n        /**\n         * This gets called when a `Button` has focus and `keydown` is triggered via a key\n         * press.\n         *\n         * @param {KeyboardEvent} event\n         *        The event that caused this function to get called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Ignore Space or Enter key operation, which is handled by the browser for\n            // a button - though not for its super class, ClickableComponent. Also,\n            // prevent the event from propagating through the DOM and triggering Player\n            // hotkeys. We do not preventDefault here because we _want_ the browser to\n            // handle it.\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.stopPropagation();\n                return;\n            }\n\n            // Pass keypress handling up for unsupported keys\n            super.handleKeyDown(event);\n        }\n    }\n    Component$1.registerComponent('Button', Button);\n\n    /**\n     * @file big-play-button.js\n     */\n\n    /**\n     * The initial play button that shows before the video has played. The hiding of the\n     * `BigPlayButton` get done via CSS and `Player` states.\n     *\n     * @extends Button\n     */\n    class BigPlayButton extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.mouseused_ = false;\n            this.setIcon('play');\n            this.on('mousedown', e => this.handleMouseDown(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n         */\n        buildCSSClass() {\n            return 'vjs-big-play-button';\n        }\n\n        /**\n         * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n         * for more detailed information on what a click can be.\n         *\n         * @param {KeyboardEvent|MouseEvent|TouchEvent} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const playPromise = this.player_.play();\n\n            // exit early if clicked via the mouse\n            if (this.mouseused_ && 'clientX' in event && 'clientY' in event) {\n                silencePromise(playPromise);\n                if (this.player_.tech(true)) {\n                    this.player_.tech(true).focus();\n                }\n                return;\n            }\n            const cb = this.player_.getChild('controlBar');\n            const playToggle = cb && cb.getChild('playToggle');\n            if (!playToggle) {\n                this.player_.tech(true).focus();\n                return;\n            }\n            const playFocus = () => playToggle.focus();\n            if (isPromise(playPromise)) {\n                playPromise.then(playFocus, () => {});\n            } else {\n                this.setTimeout(playFocus, 1);\n            }\n        }\n\n        /**\n         * Event handler that is called when a `BigPlayButton` receives a\n         * `keydown` event.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            this.mouseused_ = false;\n            super.handleKeyDown(event);\n        }\n\n        /**\n         * Handle `mousedown` events on the `BigPlayButton`.\n         *\n         * @param {MouseEvent} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         */\n        handleMouseDown(event) {\n            this.mouseused_ = true;\n        }\n    }\n\n    /**\n     * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    BigPlayButton.prototype.controlText_ = 'Play Video';\n    Component$1.registerComponent('BigPlayButton', BigPlayButton);\n\n    /**\n     * @file close-button.js\n     */\n\n    /**\n     * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n     * it gets clicked.\n     *\n     * @extends Button\n     */\n    class CloseButton extends Button {\n        /**\n         * Creates an instance of the this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setIcon('cancel');\n            this.controlText(options && options.controlText || this.localize('Close'));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-close-button ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when a `CloseButton` gets clicked. See\n         * {@link ClickableComponent#handleClick} for more information on when\n         * this will be triggered\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         * @fires CloseButton#close\n         */\n        handleClick(event) {\n            /**\n             * Triggered when the a `CloseButton` is clicked.\n             *\n             * @event CloseButton#close\n             * @type {Event}\n             *\n             * @property {boolean} [bubbles=false]\n             *           set to false so that the close event does not\n             *           bubble up to parents if there is no listener\n             */\n            this.trigger({\n                type: 'close',\n                bubbles: false\n            });\n        }\n        /**\n         * Event handler that is called when a `CloseButton` receives a\n         * `keydown` event.\n         *\n         * By default, if the key is Esc, it will trigger a `click` event.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Esc button will trigger `click` event\n            if (keycode.isEventKey(event, 'Esc')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.trigger('click');\n            } else {\n                // Pass keypress handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n    }\n    Component$1.registerComponent('CloseButton', CloseButton);\n\n    /**\n     * @file play-toggle.js\n     */\n\n    /**\n     * Button to toggle between play and pause.\n     *\n     * @extends Button\n     */\n    class PlayToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n\n            // show or hide replay icon\n            options.replay = options.replay === undefined || options.replay;\n            this.setIcon('play');\n            this.on(player, 'play', e => this.handlePlay(e));\n            this.on(player, 'pause', e => this.handlePause(e));\n            if (options.replay) {\n                this.on(player, 'ended', e => this.handleEnded(e));\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-play-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when an `PlayToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (this.player_.paused()) {\n                silencePromise(this.player_.play());\n            } else {\n                this.player_.pause();\n            }\n        }\n\n        /**\n         * This gets called once after the video has ended and the user seeks so that\n         * we can change the replay button back to a play button.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#seeked\n         */\n        handleSeeked(event) {\n            this.removeClass('vjs-ended');\n            if (this.player_.paused()) {\n                this.handlePause(event);\n            } else {\n                this.handlePlay(event);\n            }\n        }\n\n        /**\n         * Add the vjs-playing class to the element so it can change appearance.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#play\n         */\n        handlePlay(event) {\n            this.removeClass('vjs-ended', 'vjs-paused');\n            this.addClass('vjs-playing');\n            // change the button text to \"Pause\"\n            this.setIcon('pause');\n            this.controlText('Pause');\n        }\n\n        /**\n         * Add the vjs-paused class to the element so it can change appearance.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#pause\n         */\n        handlePause(event) {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-paused');\n            // change the button text to \"Play\"\n            this.setIcon('play');\n            this.controlText('Play');\n        }\n\n        /**\n         * Add the vjs-ended class to the element so it can change appearance\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#ended\n         */\n        handleEnded(event) {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-ended');\n            // change the button text to \"Replay\"\n            this.setIcon('replay');\n            this.controlText('Replay');\n\n            // on the next seek remove the replay button\n            this.one(this.player_, 'seeked', e => this.handleSeeked(e));\n        }\n    }\n\n    /**\n     * The text that should display over the `PlayToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PlayToggle.prototype.controlText_ = 'Play';\n    Component$1.registerComponent('PlayToggle', PlayToggle);\n\n    /**\n     * @file time-display.js\n     */\n\n    /**\n     * Displays time information about the video\n     *\n     * @extends Component\n     */\n    class TimeDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, ['timeupdate', 'ended', 'seeking'], e => this.update(e));\n            this.updateTextNode_();\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const className = this.buildCSSClass();\n            const el = super.createEl('div', {\n                className: `${className} vjs-time-control vjs-control`\n            });\n            const span = createEl('span', {\n                className: 'vjs-control-text',\n                textContent: `${this.localize(this.labelText_)}\\u00a0`\n            }, {\n                role: 'presentation'\n            });\n            el.appendChild(span);\n            this.contentEl_ = createEl('span', {\n                className: `${className}-display`\n            }, {\n                // span elements have no implicit role, but some screen readers (notably VoiceOver)\n                // treat them as a break between items in the DOM when using arrow keys\n                // (or left-to-right swipes on iOS) to read contents of a page. Using\n                // role='presentation' causes VoiceOver to NOT treat this span as a break.\n                role: 'presentation'\n            });\n            el.appendChild(this.contentEl_);\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.textNode_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Updates the displayed time according to the `updateContent` function which is defined in the child class.\n         *\n         * @param {Event} [event]\n         *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.\n         */\n        update(event) {\n            if (!this.player_.options_.enableSmoothSeeking && event.type === 'seeking') {\n                return;\n            }\n            this.updateContent(event);\n        }\n\n        /**\n         * Updates the time display text node with a new time\n         *\n         * @param {number} [time=0] the time to update to\n         *\n         * @private\n         */\n        updateTextNode_(time = 0) {\n            time = formatTime(time);\n            if (this.formattedTime_ === time) {\n                return;\n            }\n            this.formattedTime_ = time;\n            this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', () => {\n                if (!this.contentEl_) {\n                    return;\n                }\n                let oldNode = this.textNode_;\n                if (oldNode && this.contentEl_.firstChild !== oldNode) {\n                    oldNode = null;\n                    log$1.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');\n                }\n                this.textNode_ = document.createTextNode(this.formattedTime_);\n                if (!this.textNode_) {\n                    return;\n                }\n                if (oldNode) {\n                    this.contentEl_.replaceChild(this.textNode_, oldNode);\n                } else {\n                    this.contentEl_.appendChild(this.textNode_);\n                }\n            });\n        }\n\n        /**\n         * To be filled out in the child class, should update the displayed time\n         * in accordance with the fact that the current time has changed.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate`  event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         */\n        updateContent(event) {}\n    }\n\n    /**\n     * The text that is added to the `TimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    TimeDisplay.prototype.labelText_ = 'Time';\n\n    /**\n     * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    TimeDisplay.prototype.controlText_ = 'Time';\n    Component$1.registerComponent('TimeDisplay', TimeDisplay);\n\n    /**\n     * @file current-time-display.js\n     */\n\n    /**\n     * Displays the current time\n     *\n     * @extends Component\n     */\n    class CurrentTimeDisplay extends TimeDisplay {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-current-time';\n        }\n\n        /**\n         * Update current time display\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` event that caused this function to run.\n         *\n         * @listens Player#timeupdate\n         */\n        updateContent(event) {\n            // Allows for smooth scrubbing, when player can't keep up.\n            let time;\n            if (this.player_.ended()) {\n                time = this.player_.duration();\n            } else {\n                time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n            }\n            this.updateTextNode_(time);\n        }\n    }\n\n    /**\n     * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    CurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n\n    /**\n     * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    CurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n    Component$1.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n    /**\n     * @file duration-display.js\n     */\n\n    /**\n     * Displays the duration\n     *\n     * @extends Component\n     */\n    class DurationDisplay extends TimeDisplay {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            const updateContent = e => this.updateContent(e);\n\n            // we do not want to/need to throttle duration changes,\n            // as they should always display the changed duration as\n            // it has changed\n            this.on(player, 'durationchange', updateContent);\n\n            // Listen to loadstart because the player duration is reset when a new media element is loaded,\n            // but the durationchange on the user agent will not fire.\n            // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n            this.on(player, 'loadstart', updateContent);\n\n            // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n            // listeners could have broken dependent applications/libraries. These\n            // can likely be removed for 7.0.\n            this.on(player, 'loadedmetadata', updateContent);\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-duration';\n        }\n\n        /**\n         * Update duration time display.\n         *\n         * @param {Event} [event]\n         *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n         *        this function to be called.\n         *\n         * @listens Player#durationchange\n         * @listens Player#timeupdate\n         * @listens Player#loadedmetadata\n         */\n        updateContent(event) {\n            const duration = this.player_.duration();\n            this.updateTextNode_(duration);\n        }\n    }\n\n    /**\n     * The text that is added to the `DurationDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    DurationDisplay.prototype.labelText_ = 'Duration';\n\n    /**\n     * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    DurationDisplay.prototype.controlText_ = 'Duration';\n    Component$1.registerComponent('DurationDisplay', DurationDisplay);\n\n    /**\n     * @file time-divider.js\n     */\n\n    /**\n     * The separator between the current time and duration.\n     * Can be hidden if it's not needed in the design.\n     *\n     * @extends Component\n     */\n    class TimeDivider extends Component$1 {\n        /**\n         * Create the component's DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-time-control vjs-time-divider'\n            }, {\n                // this element and its contents can be hidden from assistive techs since\n                // it is made extraneous by the announcement of the control text\n                // for the current time and duration displays\n                'aria-hidden': true\n            });\n            const div = super.createEl('div');\n            const span = super.createEl('span', {\n                textContent: '/'\n            });\n            div.appendChild(span);\n            el.appendChild(div);\n            return el;\n        }\n    }\n    Component$1.registerComponent('TimeDivider', TimeDivider);\n\n    /**\n     * @file remaining-time-display.js\n     */\n\n    /**\n     * Displays the time left in the video\n     *\n     * @extends Component\n     */\n    class RemainingTimeDisplay extends TimeDisplay {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, 'durationchange', e => this.updateContent(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-remaining-time';\n        }\n\n        /**\n         * Create the `Component`'s DOM element with the \"minus\" character prepend to the time\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl();\n            if (this.options_.displayNegative !== false) {\n                el.insertBefore(createEl('span', {}, {\n                    'aria-hidden': true\n                }, '-'), this.contentEl_);\n            }\n            return el;\n        }\n\n        /**\n         * Update remaining time display.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` or `durationchange` event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         * @listens Player#durationchange\n         */\n        updateContent(event) {\n            if (typeof this.player_.duration() !== 'number') {\n                return;\n            }\n            let time;\n\n            // @deprecated We should only use remainingTimeDisplay\n            // as of video.js 7\n            if (this.player_.ended()) {\n                time = 0;\n            } else if (this.player_.remainingTimeDisplay) {\n                time = this.player_.remainingTimeDisplay();\n            } else {\n                time = this.player_.remainingTime();\n            }\n            this.updateTextNode_(time);\n        }\n    }\n\n    /**\n     * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n\n    /**\n     * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n    Component$1.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n    /**\n     * @file live-display.js\n     */\n\n    // TODO - Future make it click to snap to live\n\n    /**\n     * Displays the live indicator when duration is Infinity.\n     *\n     * @extends Component\n     */\n    class LiveDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.updateShowing();\n            this.on(this.player(), 'durationchange', e => this.updateShowing(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-live-control vjs-control'\n            });\n            this.contentEl_ = createEl('div', {\n                className: 'vjs-live-display'\n            }, {\n                'aria-live': 'off'\n            });\n            this.contentEl_.appendChild(createEl('span', {\n                className: 'vjs-control-text',\n                textContent: `${this.localize('Stream Type')}\\u00a0`\n            }));\n            this.contentEl_.appendChild(document.createTextNode(this.localize('LIVE')));\n            el.appendChild(this.contentEl_);\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n         * it accordingly\n         *\n         * @param {Event} [event]\n         *        The {@link Player#durationchange} event that caused this function to run.\n         *\n         * @listens Player#durationchange\n         */\n        updateShowing(event) {\n            if (this.player().duration() === Infinity) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n    }\n    Component$1.registerComponent('LiveDisplay', LiveDisplay);\n\n    /**\n     * @file seek-to-live.js\n     */\n\n    /**\n     * Displays the live indicator when duration is Infinity.\n     *\n     * @extends Component\n     */\n    class SeekToLive extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.updateLiveEdgeStatus();\n            if (this.player_.liveTracker) {\n                this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);\n                this.on(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n            }\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('button', {\n                className: 'vjs-seek-to-live-control vjs-control'\n            });\n            this.setIcon('circle', el);\n            this.textEl_ = createEl('span', {\n                className: 'vjs-seek-to-live-text',\n                textContent: this.localize('LIVE')\n            }, {\n                'aria-hidden': 'true'\n            });\n            el.appendChild(this.textEl_);\n            return el;\n        }\n\n        /**\n         * Update the state of this button if we are at the live edge\n         * or not\n         */\n        updateLiveEdgeStatus() {\n            // default to live edge\n            if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {\n                this.setAttribute('aria-disabled', true);\n                this.addClass('vjs-at-live-edge');\n                this.controlText('Seek to live, currently playing live');\n            } else {\n                this.setAttribute('aria-disabled', false);\n                this.removeClass('vjs-at-live-edge');\n                this.controlText('Seek to live, currently behind live');\n            }\n        }\n\n        /**\n         * On click bring us as near to the live point as possible.\n         * This requires that we wait for the next `live-seekable-change`\n         * event which will happen every segment length seconds.\n         */\n        handleClick() {\n            this.player_.liveTracker.seekToLiveEdge();\n        }\n\n        /**\n         * Dispose of the element and stop tracking\n         */\n        dispose() {\n            if (this.player_.liveTracker) {\n                this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n            }\n            this.textEl_ = null;\n            super.dispose();\n        }\n    }\n    /**\n     * The text that should display over the `SeekToLive`s control. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';\n    Component$1.registerComponent('SeekToLive', SeekToLive);\n\n    /**\n     * @file num.js\n     * @module num\n     */\n\n    /**\n     * Keep a number between a min and a max value\n     *\n     * @param {number} number\n     *        The number to clamp\n     *\n     * @param {number} min\n     *        The minimum value\n     * @param {number} max\n     *        The maximum value\n     *\n     * @return {number}\n     *         the clamped number\n     */\n    function clamp(number, min, max) {\n        number = Number(number);\n        return Math.min(max, Math.max(min, isNaN(number) ? min : number));\n    }\n\n    var Num = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        clamp: clamp\n    });\n\n    /**\n     * @file slider.js\n     */\n\n    /**\n     * The base functionality for a slider. Can be vertical or horizontal.\n     * For instance the volume bar or the seek bar on a video is a slider.\n     *\n     * @extends Component\n     */\n    class Slider extends Component$1 {\n        /**\n         * Create an instance of this class\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleMouseDown_ = e => this.handleMouseDown(e);\n            this.handleMouseUp_ = e => this.handleMouseUp(e);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.handleClick_ = e => this.handleClick(e);\n            this.handleMouseMove_ = e => this.handleMouseMove(e);\n            this.update_ = e => this.update(e);\n\n            // Set property names to bar to match with the child Slider class is looking for\n            this.bar = this.getChild(this.options_.barName);\n\n            // Set a horizontal or vertical class on the slider depending on the slider type\n            this.vertical(!!this.options_.vertical);\n            this.enable();\n        }\n\n        /**\n         * Are controls are currently enabled for this slider or not.\n         *\n         * @return {boolean}\n         *         true if controls are enabled, false otherwise\n         */\n        enabled() {\n            return this.enabled_;\n        }\n\n        /**\n         * Enable controls for this slider if they are disabled\n         */\n        enable() {\n            if (this.enabled()) {\n                return;\n            }\n            this.on('mousedown', this.handleMouseDown_);\n            this.on('touchstart', this.handleMouseDown_);\n            this.on('keydown', this.handleKeyDown_);\n            this.on('click', this.handleClick_);\n\n            // TODO: deprecated, controlsvisible does not seem to be fired\n            this.on(this.player_, 'controlsvisible', this.update);\n            if (this.playerEvent) {\n                this.on(this.player_, this.playerEvent, this.update);\n            }\n            this.removeClass('disabled');\n            this.setAttribute('tabindex', 0);\n            this.enabled_ = true;\n        }\n\n        /**\n         * Disable controls for this slider if they are enabled\n         */\n        disable() {\n            if (!this.enabled()) {\n                return;\n            }\n            const doc = this.bar.el_.ownerDocument;\n            this.off('mousedown', this.handleMouseDown_);\n            this.off('touchstart', this.handleMouseDown_);\n            this.off('keydown', this.handleKeyDown_);\n            this.off('click', this.handleClick_);\n            this.off(this.player_, 'controlsvisible', this.update_);\n            this.off(doc, 'mousemove', this.handleMouseMove_);\n            this.off(doc, 'mouseup', this.handleMouseUp_);\n            this.off(doc, 'touchmove', this.handleMouseMove_);\n            this.off(doc, 'touchend', this.handleMouseUp_);\n            this.removeAttribute('tabindex');\n            this.addClass('disabled');\n            if (this.playerEvent) {\n                this.off(this.player_, this.playerEvent, this.update);\n            }\n            this.enabled_ = false;\n        }\n\n        /**\n         * Create the `Slider`s DOM element.\n         *\n         * @param {string} type\n         *        Type of element to create.\n         *\n         * @param {Object} [props={}]\n         *        List of properties in Object form.\n         *\n         * @param {Object} [attributes={}]\n         *        list of attributes in Object form.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(type, props = {}, attributes = {}) {\n            // Add the slider element class to all sub classes\n            props.className = props.className + ' vjs-slider';\n            props = Object.assign({\n                tabIndex: 0\n            }, props);\n            attributes = Object.assign({\n                'role': 'slider',\n                'aria-valuenow': 0,\n                'aria-valuemin': 0,\n                'aria-valuemax': 100\n            }, attributes);\n            return super.createEl(type, props, attributes);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `Slider`.\n         *\n         * @param {MouseEvent} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         * @fires Slider#slideractive\n         */\n        handleMouseDown(event) {\n            const doc = this.bar.el_.ownerDocument;\n            if (event.type === 'mousedown') {\n                event.preventDefault();\n            }\n            // Do not call preventDefault() on touchstart in Chrome\n            // to avoid console warnings. Use a 'touch-action: none' style\n            // instead to prevent unintended scrolling.\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            if (event.type === 'touchstart' && !IS_CHROME) {\n                event.preventDefault();\n            }\n            blockTextSelection();\n            this.addClass('vjs-sliding');\n            /**\n             * Triggered when the slider is in an active state\n             *\n             * @event Slider#slideractive\n             * @type {MouseEvent}\n             */\n            this.trigger('slideractive');\n            this.on(doc, 'mousemove', this.handleMouseMove_);\n            this.on(doc, 'mouseup', this.handleMouseUp_);\n            this.on(doc, 'touchmove', this.handleMouseMove_);\n            this.on(doc, 'touchend', this.handleMouseUp_);\n            this.handleMouseMove(event, true);\n        }\n\n        /**\n         * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n         * The `mousemove` and `touchmove` events will only only trigger this function during\n         * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n         * {@link Slider#handleMouseUp}.\n         *\n         * @param {MouseEvent} event\n         *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n         *        this function\n         * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.\n         *\n         * @listens mousemove\n         * @listens touchmove\n         */\n        handleMouseMove(event) {}\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `Slider`.\n         *\n         * @param {MouseEvent} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         * @fires Slider#sliderinactive\n         */\n        handleMouseUp(event) {\n            const doc = this.bar.el_.ownerDocument;\n            unblockTextSelection();\n            this.removeClass('vjs-sliding');\n            /**\n             * Triggered when the slider is no longer in an active state.\n             *\n             * @event Slider#sliderinactive\n             * @type {Event}\n             */\n            this.trigger('sliderinactive');\n            this.off(doc, 'mousemove', this.handleMouseMove_);\n            this.off(doc, 'mouseup', this.handleMouseUp_);\n            this.off(doc, 'touchmove', this.handleMouseMove_);\n            this.off(doc, 'touchend', this.handleMouseUp_);\n            this.update();\n        }\n\n        /**\n         * Update the progress bar of the `Slider`.\n         *\n         * @return {number}\n         *          The percentage of progress the progress bar represents as a\n         *          number from 0 to 1.\n         */\n        update() {\n            // In VolumeBar init we have a setTimeout for update that pops and update\n            // to the end of the execution stack. The player is destroyed before then\n            // update will cause an error\n            // If there's no bar...\n            if (!this.el_ || !this.bar) {\n                return;\n            }\n\n            // clamp progress between 0 and 1\n            // and only round to four decimal places, as we round to two below\n            const progress = this.getProgress();\n            if (progress === this.progress_) {\n                return progress;\n            }\n            this.progress_ = progress;\n            this.requestNamedAnimationFrame('Slider#update', () => {\n                // Set the new bar width or height\n                const sizeKey = this.vertical() ? 'height' : 'width';\n\n                // Convert to a percentage for css value\n                this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';\n            });\n            return progress;\n        }\n\n        /**\n         * Get the percentage of the bar that should be filled\n         * but clamped and rounded.\n         *\n         * @return {number}\n         *         percentage filled that the slider is\n         */\n        getProgress() {\n            return Number(clamp(this.getPercent(), 0, 1).toFixed(4));\n        }\n\n        /**\n         * Calculate distance for slider\n         *\n         * @param {Event} event\n         *        The event that caused this function to run.\n         *\n         * @return {number}\n         *         The current position of the Slider.\n         *         - position.x for vertical `Slider`s\n         *         - position.y for horizontal `Slider`s\n         */\n        calculateDistance(event) {\n            const position = getPointerPosition(this.el_, event);\n            if (this.vertical()) {\n                return position.y;\n            }\n            return position.x;\n        }\n\n        /**\n         * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down\n         * arrow keys. This function will only be called when the slider has focus. See\n         * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n         *\n         * @param {KeyboardEvent} event\n         *        the `keydown` event that caused this function to run.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Left and Down Arrows\n            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepBack();\n\n                // Up and Right Arrows\n            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepForward();\n            } else {\n                // Pass keydown handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Listener for click events on slider, used to prevent clicks\n         *   from bubbling up to parent elements like button menus.\n         *\n         * @param {Object} event\n         *        Event that caused this object to run\n         */\n        handleClick(event) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n\n        /**\n         * Get/set if slider is horizontal for vertical\n         *\n         * @param {boolean} [bool]\n         *        - true if slider is vertical,\n         *        - false is horizontal\n         *\n         * @return {boolean}\n         *         - true if slider is vertical, and getting\n         *         - false if the slider is horizontal, and getting\n         */\n        vertical(bool) {\n            if (bool === undefined) {\n                return this.vertical_ || false;\n            }\n            this.vertical_ = !!bool;\n            if (this.vertical_) {\n                this.addClass('vjs-slider-vertical');\n            } else {\n                this.addClass('vjs-slider-horizontal');\n            }\n        }\n    }\n    Component$1.registerComponent('Slider', Slider);\n\n    /**\n     * @file load-progress-bar.js\n     */\n\n        // get the percent width of a time compared to the total end\n    const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + '%';\n\n    /**\n     * Shows loading progress\n     *\n     * @extends Component\n     */\n    class LoadProgressBar extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.partEls_ = [];\n            this.on(player, 'progress', e => this.update(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-load-progress'\n            });\n            const wrapper = createEl('span', {\n                className: 'vjs-control-text'\n            });\n            const loadedText = createEl('span', {\n                textContent: this.localize('Loaded')\n            });\n            const separator = document.createTextNode(': ');\n            this.percentageEl_ = createEl('span', {\n                className: 'vjs-control-text-loaded-percentage',\n                textContent: '0%'\n            });\n            el.appendChild(wrapper);\n            wrapper.appendChild(loadedText);\n            wrapper.appendChild(separator);\n            wrapper.appendChild(this.percentageEl_);\n            return el;\n        }\n        dispose() {\n            this.partEls_ = null;\n            this.percentageEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Update progress bar\n         *\n         * @param {Event} [event]\n         *        The `progress` event that caused this function to run.\n         *\n         * @listens Player#progress\n         */\n        update(event) {\n            this.requestNamedAnimationFrame('LoadProgressBar#update', () => {\n                const liveTracker = this.player_.liveTracker;\n                const buffered = this.player_.buffered();\n                const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();\n                const bufferedEnd = this.player_.bufferedEnd();\n                const children = this.partEls_;\n                const percent = percentify(bufferedEnd, duration);\n                if (this.percent_ !== percent) {\n                    // update the width of the progress bar\n                    this.el_.style.width = percent;\n                    // update the control-text\n                    textContent(this.percentageEl_, percent);\n                    this.percent_ = percent;\n                }\n\n                // add child elements to represent the individual buffered time ranges\n                for (let i = 0; i < buffered.length; i++) {\n                    const start = buffered.start(i);\n                    const end = buffered.end(i);\n                    let part = children[i];\n                    if (!part) {\n                        part = this.el_.appendChild(createEl());\n                        children[i] = part;\n                    }\n\n                    //  only update if changed\n                    if (part.dataset.start === start && part.dataset.end === end) {\n                        continue;\n                    }\n                    part.dataset.start = start;\n                    part.dataset.end = end;\n\n                    // set the percent based on the width of the progress bar (bufferedEnd)\n                    part.style.left = percentify(start, bufferedEnd);\n                    part.style.width = percentify(end - start, bufferedEnd);\n                }\n\n                // remove unused buffered range elements\n                for (let i = children.length; i > buffered.length; i--) {\n                    this.el_.removeChild(children[i - 1]);\n                }\n                children.length = buffered.length;\n            });\n        }\n    }\n    Component$1.registerComponent('LoadProgressBar', LoadProgressBar);\n\n    /**\n     * @file time-tooltip.js\n     */\n\n    /**\n     * Time tooltips display a time above the progress bar.\n     *\n     * @extends Component\n     */\n    class TimeTooltip extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the time tooltip DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-time-tooltip'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Updates the position of the time tooltip relative to the `SeekBar`.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint, content) {\n            const tooltipRect = findPosition(this.el_);\n            const playerRect = getBoundingClientRect(this.player_.el());\n            const seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n            // do nothing if either rect isn't available\n            // for example, if the player isn't in the DOM for testing\n            if (!playerRect || !tooltipRect) {\n                return;\n            }\n\n            // This is the space left of the `seekBarPoint` available within the bounds\n            // of the player. We calculate any gap between the left edge of the player\n            // and the left edge of the `SeekBar` and add the number of pixels in the\n            // `SeekBar` before hitting the `seekBarPoint`\n            const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n            // This is the space right of the `seekBarPoint` available within the bounds\n            // of the player. We calculate the number of pixels from the `seekBarPoint`\n            // to the right edge of the `SeekBar` and add to that any gap between the\n            // right edge of the `SeekBar` and the player.\n            const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n            // This is the number of pixels by which the tooltip will need to be pulled\n            // further to the right to center it over the `seekBarPoint`.\n            let pullTooltipBy = tooltipRect.width / 2;\n\n            // Adjust the `pullTooltipBy` distance to the left or right depending on\n            // the results of the space calculations above.\n            if (spaceLeftOfPoint < pullTooltipBy) {\n                pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n            } else if (spaceRightOfPoint < pullTooltipBy) {\n                pullTooltipBy = spaceRightOfPoint;\n            }\n\n            // Due to the imprecision of decimal/ratio based calculations and varying\n            // rounding behaviors, there are cases where the spacing adjustment is off\n            // by a pixel or two. This adds insurance to these calculations.\n            if (pullTooltipBy < 0) {\n                pullTooltipBy = 0;\n            } else if (pullTooltipBy > tooltipRect.width) {\n                pullTooltipBy = tooltipRect.width;\n            }\n\n            // prevent small width fluctuations within 0.4px from\n            // changing the value below.\n            // This really helps for live to prevent the play\n            // progress time tooltip from jittering\n            pullTooltipBy = Math.round(pullTooltipBy);\n            this.el_.style.right = `-${pullTooltipBy}px`;\n            this.write(content);\n        }\n\n        /**\n         * Write the time to the tooltip DOM element.\n         *\n         * @param {string} content\n         *        The formatted time for the tooltip.\n         */\n        write(content) {\n            textContent(this.el_, content);\n        }\n\n        /**\n         * Updates the position of the time tooltip relative to the `SeekBar`.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         *\n         * @param {number} time\n         *        The time to update the tooltip to, not used during live playback\n         *\n         * @param {Function} cb\n         *        A function that will be called during the request animation frame\n         *        for tooltips that need to do additional animations from the default\n         */\n        updateTime(seekBarRect, seekBarPoint, time, cb) {\n            this.requestNamedAnimationFrame('TimeTooltip#updateTime', () => {\n                let content;\n                const duration = this.player_.duration();\n                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n                    const liveWindow = this.player_.liveTracker.liveWindow();\n                    const secondsBehind = liveWindow - seekBarPoint * liveWindow;\n                    content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);\n                } else {\n                    content = formatTime(time, duration);\n                }\n                this.update(seekBarRect, seekBarPoint, content);\n                if (cb) {\n                    cb();\n                }\n            });\n        }\n    }\n    Component$1.registerComponent('TimeTooltip', TimeTooltip);\n\n    /**\n     * @file play-progress-bar.js\n     */\n\n    /**\n     * Used by {@link SeekBar} to display media playback progress as part of the\n     * {@link ProgressControl}.\n     *\n     * @extends Component\n     */\n    class PlayProgressBar extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setIcon('circle');\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-play-progress vjs-slider-bar'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Enqueues updates to its own DOM as well as the DOM of its\n         * {@link TimeTooltip} child.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint) {\n            const timeTooltip = this.getChild('timeTooltip');\n            if (!timeTooltip) {\n                return;\n            }\n            const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n            timeTooltip.updateTime(seekBarRect, seekBarPoint, time);\n        }\n    }\n\n    /**\n     * Default options for {@link PlayProgressBar}.\n     *\n     * @type {Object}\n     * @private\n     */\n    PlayProgressBar.prototype.options_ = {\n        children: []\n    };\n\n    // Time tooltips should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        PlayProgressBar.prototype.options_.children.push('timeTooltip');\n    }\n    Component$1.registerComponent('PlayProgressBar', PlayProgressBar);\n\n    /**\n     * @file mouse-time-display.js\n     */\n\n    /**\n     * The {@link MouseTimeDisplay} component tracks mouse movement over the\n     * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n     * indicating the time which is represented by a given point in the\n     * {@link ProgressControl}.\n     *\n     * @extends Component\n     */\n    class MouseTimeDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-mouse-display'\n            });\n        }\n\n        /**\n         * Enqueues updates to its own DOM as well as the DOM of its\n         * {@link TimeTooltip} child.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint) {\n            const time = seekBarPoint * this.player_.duration();\n            this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, () => {\n                this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;\n            });\n        }\n    }\n\n    /**\n     * Default options for `MouseTimeDisplay`\n     *\n     * @type {Object}\n     * @private\n     */\n    MouseTimeDisplay.prototype.options_ = {\n        children: ['timeTooltip']\n    };\n    Component$1.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n    /**\n     * @file seek-bar.js\n     */\n\n        // The number of seconds the `step*` functions move the timeline.\n    const STEP_SECONDS = 5;\n\n    // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.\n    const PAGE_KEY_MULTIPLIER = 12;\n\n    /**\n     * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n     * as its `bar`.\n     *\n     * @extends Slider\n     */\n    class SeekBar extends Slider {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setEventHandlers_();\n        }\n\n        /**\n         * Sets the event handlers\n         *\n         * @private\n         */\n        setEventHandlers_() {\n            this.update_ = bind_(this, this.update);\n            this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);\n            this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n            if (this.player_.liveTracker) {\n                this.on(this.player_.liveTracker, 'liveedgechange', this.update);\n            }\n\n            // when playing, let's ensure we smoothly update the play progress bar\n            // via an interval\n            this.updateInterval = null;\n            this.enableIntervalHandler_ = e => this.enableInterval_(e);\n            this.disableIntervalHandler_ = e => this.disableInterval_(e);\n            this.on(this.player_, ['playing'], this.enableIntervalHandler_);\n            this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n            // we don't need to update the play progress if the document is hidden,\n            // also, this causes the CPU to spike and eventually crash the page on IE11.\n            if ('hidden' in document && 'visibilityState' in document) {\n                this.on(document, 'visibilitychange', this.toggleVisibility_);\n            }\n        }\n        toggleVisibility_(e) {\n            if (document.visibilityState === 'hidden') {\n                this.cancelNamedAnimationFrame('SeekBar#update');\n                this.cancelNamedAnimationFrame('Slider#update');\n                this.disableInterval_(e);\n            } else {\n                if (!this.player_.ended() && !this.player_.paused()) {\n                    this.enableInterval_();\n                }\n\n                // we just switched back to the page and someone may be looking, so, update ASAP\n                this.update();\n            }\n        }\n        enableInterval_() {\n            if (this.updateInterval) {\n                return;\n            }\n            this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);\n        }\n        disableInterval_(e) {\n            if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {\n                return;\n            }\n            if (!this.updateInterval) {\n                return;\n            }\n            this.clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-progress-holder'\n            }, {\n                'aria-label': this.localize('Progress Bar')\n            });\n        }\n\n        /**\n         * This function updates the play progress bar and accessibility\n         * attributes to whatever is passed in.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` or `ended` event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         *\n         * @return {number}\n         *          The current percent at a number from 0-1\n         */\n        update(event) {\n            // ignore updates while the tab is hidden\n            if (document.visibilityState === 'hidden') {\n                return;\n            }\n            const percent = super.update();\n            this.requestNamedAnimationFrame('SeekBar#update', () => {\n                const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();\n                const liveTracker = this.player_.liveTracker;\n                let duration = this.player_.duration();\n                if (liveTracker && liveTracker.isLive()) {\n                    duration = this.player_.liveTracker.liveCurrentTime();\n                }\n                if (this.percent_ !== percent) {\n                    // machine readable value of progress bar (percentage complete)\n                    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n                    this.percent_ = percent;\n                }\n                if (this.currentTime_ !== currentTime || this.duration_ !== duration) {\n                    // human readable value of progress bar (time complete)\n                    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n                    this.currentTime_ = currentTime;\n                    this.duration_ = duration;\n                }\n\n                // update the progress bar time tooltip with the current time\n                if (this.bar) {\n                    this.bar.update(getBoundingClientRect(this.el()), this.getProgress());\n                }\n            });\n            return percent;\n        }\n\n        /**\n         * Prevent liveThreshold from causing seeks to seem like they\n         * are not happening from a user perspective.\n         *\n         * @param {number} ct\n         *        current time to seek to\n         */\n        userSeek_(ct) {\n            if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n                this.player_.liveTracker.nextSeekedFromUser();\n            }\n            this.player_.currentTime(ct);\n        }\n\n        /**\n         * Get the value of current time but allows for smooth scrubbing,\n         * when player can't keep up.\n         *\n         * @return {number}\n         *         The current time value to display\n         *\n         * @private\n         */\n        getCurrentTime_() {\n            return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n        }\n\n        /**\n         * Get the percentage of media played so far.\n         *\n         * @return {number}\n         *         The percentage of media played so far (0 to 1).\n         */\n        getPercent() {\n            const currentTime = this.getCurrentTime_();\n            let percent;\n            const liveTracker = this.player_.liveTracker;\n            if (liveTracker && liveTracker.isLive()) {\n                percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();\n\n                // prevent the percent from changing at the live edge\n                if (liveTracker.atLiveEdge()) {\n                    percent = 1;\n                }\n            } else {\n                percent = currentTime / this.player_.duration();\n            }\n            return percent;\n        }\n\n        /**\n         * Handle mouse down on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mousedown` event that caused this to run.\n         *\n         * @listens mousedown\n         */\n        handleMouseDown(event) {\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n\n            // Stop event propagation to prevent double fire in progress-control.js\n            event.stopPropagation();\n            this.videoWasPlaying = !this.player_.paused();\n            this.player_.pause();\n            super.handleMouseDown(event);\n        }\n\n        /**\n         * Handle mouse move on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mousemove` event that caused this to run.\n         * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false\n         *\n         * @listens mousemove\n         */\n        handleMouseMove(event, mouseDown = false) {\n            if (!isSingleLeftClick(event) || isNaN(this.player_.duration())) {\n                return;\n            }\n            if (!mouseDown && !this.player_.scrubbing()) {\n                this.player_.scrubbing(true);\n            }\n            let newTime;\n            const distance = this.calculateDistance(event);\n            const liveTracker = this.player_.liveTracker;\n            if (!liveTracker || !liveTracker.isLive()) {\n                newTime = distance * this.player_.duration();\n\n                // Don't let video end while scrubbing.\n                if (newTime === this.player_.duration()) {\n                    newTime = newTime - 0.1;\n                }\n            } else {\n                if (distance >= 0.99) {\n                    liveTracker.seekToLiveEdge();\n                    return;\n                }\n                const seekableStart = liveTracker.seekableStart();\n                const seekableEnd = liveTracker.liveCurrentTime();\n                newTime = seekableStart + distance * liveTracker.liveWindow();\n\n                // Don't let video end while scrubbing.\n                if (newTime >= seekableEnd) {\n                    newTime = seekableEnd;\n                }\n\n                // Compensate for precision differences so that currentTime is not less\n                // than seekable start\n                if (newTime <= seekableStart) {\n                    newTime = seekableStart + 0.1;\n                }\n\n                // On android seekableEnd can be Infinity sometimes,\n                // this will cause newTime to be Infinity, which is\n                // not a valid currentTime.\n                if (newTime === Infinity) {\n                    return;\n                }\n            }\n\n            // Set new time (tell player to seek to new time)\n            this.userSeek_(newTime);\n            if (this.player_.options_.enableSmoothSeeking) {\n                this.update();\n            }\n        }\n        enable() {\n            super.enable();\n            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n            if (!mouseTimeDisplay) {\n                return;\n            }\n            mouseTimeDisplay.show();\n        }\n        disable() {\n            super.disable();\n            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n            if (!mouseTimeDisplay) {\n                return;\n            }\n            mouseTimeDisplay.hide();\n        }\n\n        /**\n         * Handle mouse up on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mouseup` event that caused this to run.\n         *\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            super.handleMouseUp(event);\n\n            // Stop event propagation to prevent double fire in progress-control.js\n            if (event) {\n                event.stopPropagation();\n            }\n            this.player_.scrubbing(false);\n\n            /**\n             * Trigger timeupdate because we're done seeking and the time has changed.\n             * This is particularly useful for if the player is paused to time the time displays.\n             *\n             * @event Tech#timeupdate\n             * @type {Event}\n             */\n            this.player_.trigger({\n                type: 'timeupdate',\n                target: this,\n                manuallyTriggered: true\n            });\n            if (this.videoWasPlaying) {\n                silencePromise(this.player_.play());\n            } else {\n                // We're done seeking and the time has changed.\n                // If the player is paused, make sure we display the correct time on the seek bar.\n                this.update_();\n            }\n        }\n\n        /**\n         * Move more quickly fast forward for keyboard-only users\n         */\n        stepForward() {\n            this.userSeek_(this.player_.currentTime() + STEP_SECONDS);\n        }\n\n        /**\n         * Move more quickly rewind for keyboard-only users\n         */\n        stepBack() {\n            this.userSeek_(this.player_.currentTime() - STEP_SECONDS);\n        }\n\n        /**\n         * Toggles the playback state of the player\n         * This gets called when enter or space is used on the seekbar\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called\n         *\n         */\n        handleAction(event) {\n            if (this.player_.paused()) {\n                this.player_.play();\n            } else {\n                this.player_.pause();\n            }\n        }\n\n        /**\n         * Called when this SeekBar has focus and a key gets pressed down.\n         * Supports the following keys:\n         *\n         *   Space or Enter key fire a click event\n         *   Home key moves to start of the timeline\n         *   End key moves to end of the timeline\n         *   Digit \"0\" through \"9\" keys move to 0%, 10% ... 80%, 90% of the timeline\n         *   PageDown key moves back a larger step than ArrowDown\n         *   PageUp key moves forward a large step\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            const liveTracker = this.player_.liveTracker;\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.handleAction(event);\n            } else if (keycode.isEventKey(event, 'Home')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(0);\n            } else if (keycode.isEventKey(event, 'End')) {\n                event.preventDefault();\n                event.stopPropagation();\n                if (liveTracker && liveTracker.isLive()) {\n                    this.userSeek_(liveTracker.liveCurrentTime());\n                } else {\n                    this.userSeek_(this.player_.duration());\n                }\n            } else if (/^[0-9]$/.test(keycode(event))) {\n                event.preventDefault();\n                event.stopPropagation();\n                const gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;\n                if (liveTracker && liveTracker.isLive()) {\n                    this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);\n                } else {\n                    this.userSeek_(this.player_.duration() * gotoFraction);\n                }\n            } else if (keycode.isEventKey(event, 'PgDn')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n            } else if (keycode.isEventKey(event, 'PgUp')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n            } else {\n                // Pass keydown handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n        dispose() {\n            this.disableInterval_();\n            this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n            if (this.player_.liveTracker) {\n                this.off(this.player_.liveTracker, 'liveedgechange', this.update);\n            }\n            this.off(this.player_, ['playing'], this.enableIntervalHandler_);\n            this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n            // we don't need to update the play progress if the document is hidden,\n            // also, this causes the CPU to spike and eventually crash the page on IE11.\n            if ('hidden' in document && 'visibilityState' in document) {\n                this.off(document, 'visibilitychange', this.toggleVisibility_);\n            }\n            super.dispose();\n        }\n    }\n\n    /**\n     * Default options for the `SeekBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    SeekBar.prototype.options_ = {\n        children: ['loadProgressBar', 'playProgressBar'],\n        barName: 'playProgressBar'\n    };\n\n    // MouseTimeDisplay tooltips should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n    }\n    Component$1.registerComponent('SeekBar', SeekBar);\n\n    /**\n     * @file progress-control.js\n     */\n\n    /**\n     * The Progress Control component contains the seek bar, load progress,\n     * and play progress.\n     *\n     * @extends Component\n     */\n    class ProgressControl extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n            this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);\n            this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n            this.handleMouseDownHandler_ = e => this.handleMouseDown(e);\n            this.enable();\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-progress-control vjs-control'\n            });\n        }\n\n        /**\n         * When the mouse moves over the `ProgressControl`, the pointer position\n         * gets passed down to the `MouseTimeDisplay` component.\n         *\n         * @param {Event} event\n         *        The `mousemove` event that caused this function to run.\n         *\n         * @listen mousemove\n         */\n        handleMouseMove(event) {\n            const seekBar = this.getChild('seekBar');\n            if (!seekBar) {\n                return;\n            }\n            const playProgressBar = seekBar.getChild('playProgressBar');\n            const mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n            if (!playProgressBar && !mouseTimeDisplay) {\n                return;\n            }\n            const seekBarEl = seekBar.el();\n            const seekBarRect = findPosition(seekBarEl);\n            let seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n            // The default skin has a gap on either side of the `SeekBar`. This means\n            // that it's possible to trigger this behavior outside the boundaries of\n            // the `SeekBar`. This ensures we stay within it at all times.\n            seekBarPoint = clamp(seekBarPoint, 0, 1);\n            if (mouseTimeDisplay) {\n                mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n            }\n            if (playProgressBar) {\n                playProgressBar.update(seekBarRect, seekBar.getProgress());\n            }\n        }\n\n        /**\n         * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n         *\n         * @method ProgressControl#throttledHandleMouseSeek\n         * @param {Event} event\n         *        The `mousemove` event that caused this function to run.\n         *\n         * @listen mousemove\n         * @listen touchmove\n         */\n\n        /**\n         * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousemove\n         * @listens touchmove\n         */\n        handleMouseSeek(event) {\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseMove(event);\n            }\n        }\n\n        /**\n         * Are controls are currently enabled for this progress control.\n         *\n         * @return {boolean}\n         *         true if controls are enabled, false otherwise\n         */\n        enabled() {\n            return this.enabled_;\n        }\n\n        /**\n         * Disable all controls on the progress control and its children\n         */\n        disable() {\n            this.children().forEach(child => child.disable && child.disable());\n            if (!this.enabled()) {\n                return;\n            }\n            this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n            this.off(this.el_, 'mousemove', this.handleMouseMove);\n            this.removeListenersAddedOnMousedownAndTouchstart();\n            this.addClass('disabled');\n            this.enabled_ = false;\n\n            // Restore normal playback state if controls are disabled while scrubbing\n            if (this.player_.scrubbing()) {\n                const seekBar = this.getChild('seekBar');\n                this.player_.scrubbing(false);\n                if (seekBar.videoWasPlaying) {\n                    silencePromise(this.player_.play());\n                }\n            }\n        }\n\n        /**\n         * Enable all controls on the progress control and its children\n         */\n        enable() {\n            this.children().forEach(child => child.enable && child.enable());\n            if (this.enabled()) {\n                return;\n            }\n            this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n            this.on(this.el_, 'mousemove', this.handleMouseMove);\n            this.removeClass('disabled');\n            this.enabled_ = true;\n        }\n\n        /**\n         * Cleanup listeners after the user finishes interacting with the progress controls\n         */\n        removeListenersAddedOnMousedownAndTouchstart() {\n            const doc = this.el_.ownerDocument;\n            this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n            this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n            this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.off(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseDown(event) {\n            const doc = this.el_.ownerDocument;\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseDown(event);\n            }\n            this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n            this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n            this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.on(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseUp(event);\n            }\n            this.removeListenersAddedOnMousedownAndTouchstart();\n        }\n    }\n\n    /**\n     * Default options for `ProgressControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    ProgressControl.prototype.options_ = {\n        children: ['seekBar']\n    };\n    Component$1.registerComponent('ProgressControl', ProgressControl);\n\n    /**\n     * @file picture-in-picture-toggle.js\n     */\n\n    /**\n     * Toggle Picture-in-Picture mode\n     *\n     * @extends Button\n     */\n    class PictureInPictureToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @listens Player#enterpictureinpicture\n         * @listens Player#leavepictureinpicture\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setIcon('picture-in-picture-enter');\n            this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], e => this.handlePictureInPictureChange(e));\n            this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], e => this.handlePictureInPictureEnabledChange(e));\n            this.on(player, ['loadedmetadata', 'audioonlymodechange', 'audiopostermodechange'], () => this.handlePictureInPictureAudioModeChange());\n\n            // TODO: Deactivate button on player emptied event.\n            this.disable();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Displays or hides the button depending on the audio mode detection.\n         * Exits picture-in-picture if it is enabled when switching to audio mode.\n         */\n        handlePictureInPictureAudioModeChange() {\n            // This audio detection will not detect HLS or DASH audio-only streams because there was no reliable way to detect them at the time\n            const isSourceAudio = this.player_.currentType().substring(0, 5) === 'audio';\n            const isAudioMode = isSourceAudio || this.player_.audioPosterMode() || this.player_.audioOnlyMode();\n            if (!isAudioMode) {\n                this.show();\n                return;\n            }\n            if (this.player_.isInPictureInPicture()) {\n                this.player_.exitPictureInPicture();\n            }\n            this.hide();\n        }\n\n        /**\n         * Enables or disables button based on availability of a Picture-In-Picture mode.\n         *\n         * Enabled if\n         * - `player.options().enableDocumentPictureInPicture` is true and\n         *   window.documentPictureInPicture is available; or\n         * - `player.disablePictureInPicture()` is false and\n         *   element.requestPictureInPicture is available\n         */\n        handlePictureInPictureEnabledChange() {\n            if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && 'documentPictureInPicture' in window) {\n                this.enable();\n            } else {\n                this.disable();\n            }\n        }\n\n        /**\n         * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be\n         *        called.\n         *\n         * @listens Player#enterpictureinpicture\n         * @listens Player#leavepictureinpicture\n         */\n        handlePictureInPictureChange(event) {\n            if (this.player_.isInPictureInPicture()) {\n                this.setIcon('picture-in-picture-exit');\n                this.controlText('Exit Picture-in-Picture');\n            } else {\n                this.setIcon('picture-in-picture-enter');\n                this.controlText('Picture-in-Picture');\n            }\n            this.handlePictureInPictureEnabledChange();\n        }\n\n        /**\n         * This gets called when an `PictureInPictureToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (!this.player_.isInPictureInPicture()) {\n                this.player_.requestPictureInPicture();\n            } else {\n                this.player_.exitPictureInPicture();\n            }\n        }\n\n        /**\n         * Show the `Component`s element if it is hidden by removing the\n         * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.\n         */\n        show() {\n            // Does not allow to display the pictureInPictureToggle in browsers that do not support the Picture-in-Picture API, e.g. Firefox.\n            if (typeof document.exitPictureInPicture !== 'function') {\n                return;\n            }\n            super.show();\n        }\n    }\n\n    /**\n     * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';\n    Component$1.registerComponent('PictureInPictureToggle', PictureInPictureToggle);\n\n    /**\n     * @file fullscreen-toggle.js\n     */\n\n    /**\n     * Toggle fullscreen video\n     *\n     * @extends Button\n     */\n    class FullscreenToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setIcon('fullscreen-enter');\n            this.on(player, 'fullscreenchange', e => this.handleFullscreenChange(e));\n            if (document[player.fsApi_.fullscreenEnabled] === false) {\n                this.disable();\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-fullscreen-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Handles fullscreenchange on the player and change control text accordingly.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#fullscreenchange} event that caused this function to be\n         *        called.\n         *\n         * @listens Player#fullscreenchange\n         */\n        handleFullscreenChange(event) {\n            if (this.player_.isFullscreen()) {\n                this.controlText('Exit Fullscreen');\n                this.setIcon('fullscreen-exit');\n            } else {\n                this.controlText('Fullscreen');\n                this.setIcon('fullscreen-enter');\n            }\n        }\n\n        /**\n         * This gets called when an `FullscreenToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (!this.player_.isFullscreen()) {\n                this.player_.requestFullscreen();\n            } else {\n                this.player_.exitFullscreen();\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    FullscreenToggle.prototype.controlText_ = 'Fullscreen';\n    Component$1.registerComponent('FullscreenToggle', FullscreenToggle);\n\n    /**\n     * Check if volume control is supported and if it isn't hide the\n     * `Component` that was passed  using the `vjs-hidden` class.\n     *\n     * @param { import('../../component').default } self\n     *        The component that should be hidden if volume is unsupported\n     *\n     * @param { import('../../player').default } player\n     *        A reference to the player\n     *\n     * @private\n     */\n    const checkVolumeSupport = function (self, player) {\n        // hide volume controls when they're not supported by the current tech\n        if (player.tech_ && !player.tech_.featuresVolumeControl) {\n            self.addClass('vjs-hidden');\n        }\n        self.on(player, 'loadstart', function () {\n            if (!player.tech_.featuresVolumeControl) {\n                self.addClass('vjs-hidden');\n            } else {\n                self.removeClass('vjs-hidden');\n            }\n        });\n    };\n\n    /**\n     * @file volume-level.js\n     */\n\n    /**\n     * Shows volume level\n     *\n     * @extends Component\n     */\n    class VolumeLevel extends Component$1 {\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-volume-level'\n            });\n            this.setIcon('circle', el);\n            el.appendChild(super.createEl('span', {\n                className: 'vjs-control-text'\n            }));\n            return el;\n        }\n    }\n    Component$1.registerComponent('VolumeLevel', VolumeLevel);\n\n    /**\n     * @file volume-level-tooltip.js\n     */\n\n    /**\n     * Volume level tooltips display a volume above or side by side the volume bar.\n     *\n     * @extends Component\n     */\n    class VolumeLevelTooltip extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the volume tooltip DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-volume-tooltip'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Updates the position of the tooltip relative to the `VolumeBar` and\n         * its content text.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         */\n        update(rangeBarRect, rangeBarPoint, vertical, content) {\n            if (!vertical) {\n                const tooltipRect = getBoundingClientRect(this.el_);\n                const playerRect = getBoundingClientRect(this.player_.el());\n                const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;\n                if (!playerRect || !tooltipRect) {\n                    return;\n                }\n                const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;\n                const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);\n                let pullTooltipBy = tooltipRect.width / 2;\n                if (spaceLeftOfPoint < pullTooltipBy) {\n                    pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n                } else if (spaceRightOfPoint < pullTooltipBy) {\n                    pullTooltipBy = spaceRightOfPoint;\n                }\n                if (pullTooltipBy < 0) {\n                    pullTooltipBy = 0;\n                } else if (pullTooltipBy > tooltipRect.width) {\n                    pullTooltipBy = tooltipRect.width;\n                }\n                this.el_.style.right = `-${pullTooltipBy}px`;\n            }\n            this.write(`${content}%`);\n        }\n\n        /**\n         * Write the volume to the tooltip DOM element.\n         *\n         * @param {string} content\n         *        The formatted volume for the tooltip.\n         */\n        write(content) {\n            textContent(this.el_, content);\n        }\n\n        /**\n         * Updates the position of the volume tooltip relative to the `VolumeBar`.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         * @param {number} volume\n         *        The volume level to update the tooltip to\n         *\n         * @param {Function} cb\n         *        A function that will be called during the request animation frame\n         *        for tooltips that need to do additional animations from the default\n         */\n        updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {\n            this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', () => {\n                this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));\n                if (cb) {\n                    cb();\n                }\n            });\n        }\n    }\n    Component$1.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);\n\n    /**\n     * @file mouse-volume-level-display.js\n     */\n\n    /**\n     * The {@link MouseVolumeLevelDisplay} component tracks mouse movement over the\n     * {@link VolumeControl}. It displays an indicator and a {@link VolumeLevelTooltip}\n     * indicating the volume level which is represented by a given point in the\n     * {@link VolumeBar}.\n     *\n     * @extends Component\n     */\n    class MouseVolumeLevelDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-mouse-display'\n            });\n        }\n\n        /**\n         * Enquires updates to its own DOM as well as the DOM of its\n         * {@link VolumeLevelTooltip} child.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         */\n        update(rangeBarRect, rangeBarPoint, vertical) {\n            const volume = 100 * rangeBarPoint;\n            this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {\n                if (vertical) {\n                    this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;\n                } else {\n                    this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;\n                }\n            });\n        }\n    }\n\n    /**\n     * Default options for `MouseVolumeLevelDisplay`\n     *\n     * @type {Object}\n     * @private\n     */\n    MouseVolumeLevelDisplay.prototype.options_ = {\n        children: ['volumeLevelTooltip']\n    };\n    Component$1.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);\n\n    /**\n     * @file volume-bar.js\n     */\n\n    /**\n     * The bar that contains the volume level and can be clicked on to adjust the level\n     *\n     * @extends Slider\n     */\n    class VolumeBar extends Slider {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on('slideractive', e => this.updateLastVolume_(e));\n            this.on(player, 'volumechange', e => this.updateARIAAttributes(e));\n            player.ready(() => this.updateARIAAttributes());\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-volume-bar vjs-slider-bar'\n            }, {\n                'aria-label': this.localize('Volume Level'),\n                'aria-live': 'polite'\n            });\n        }\n\n        /**\n         * Handle mouse down on volume bar\n         *\n         * @param {Event} event\n         *        The `mousedown` event that caused this to run.\n         *\n         * @listens mousedown\n         */\n        handleMouseDown(event) {\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n            super.handleMouseDown(event);\n        }\n\n        /**\n         * Handle movement events on the {@link VolumeMenuButton}.\n         *\n         * @param {Event} event\n         *        The event that caused this function to run.\n         *\n         * @listens mousemove\n         */\n        handleMouseMove(event) {\n            const mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');\n            if (mouseVolumeLevelDisplay) {\n                const volumeBarEl = this.el();\n                const volumeBarRect = getBoundingClientRect(volumeBarEl);\n                const vertical = this.vertical();\n                let volumeBarPoint = getPointerPosition(volumeBarEl, event);\n                volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;\n                // The default skin has a gap on either side of the `VolumeBar`. This means\n                // that it's possible to trigger this behavior outside the boundaries of\n                // the `VolumeBar`. This ensures we stay within it at all times.\n                volumeBarPoint = clamp(volumeBarPoint, 0, 1);\n                mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);\n            }\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n            this.checkMuted();\n            this.player_.volume(this.calculateDistance(event));\n        }\n\n        /**\n         * If the player is muted unmute it.\n         */\n        checkMuted() {\n            if (this.player_.muted()) {\n                this.player_.muted(false);\n            }\n        }\n\n        /**\n         * Get percent of volume level\n         *\n         * @return {number}\n         *         Volume level percent as a decimal number.\n         */\n        getPercent() {\n            if (this.player_.muted()) {\n                return 0;\n            }\n            return this.player_.volume();\n        }\n\n        /**\n         * Increase volume level for keyboard users\n         */\n        stepForward() {\n            this.checkMuted();\n            this.player_.volume(this.player_.volume() + 0.1);\n        }\n\n        /**\n         * Decrease volume level for keyboard users\n         */\n        stepBack() {\n            this.checkMuted();\n            this.player_.volume(this.player_.volume() - 0.1);\n        }\n\n        /**\n         * Update ARIA accessibility attributes\n         *\n         * @param {Event} [event]\n         *        The `volumechange` event that caused this function to run.\n         *\n         * @listens Player#volumechange\n         */\n        updateARIAAttributes(event) {\n            const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n            this.el_.setAttribute('aria-valuenow', ariaValue);\n            this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n        }\n\n        /**\n         * Returns the current value of the player volume as a percentage\n         *\n         * @private\n         */\n        volumeAsPercentage_() {\n            return Math.round(this.player_.volume() * 100);\n        }\n\n        /**\n         * When user starts dragging the VolumeBar, store the volume and listen for\n         * the end of the drag. When the drag ends, if the volume was set to zero,\n         * set lastVolume to the stored volume.\n         *\n         * @listens slideractive\n         * @private\n         */\n        updateLastVolume_() {\n            const volumeBeforeDrag = this.player_.volume();\n            this.one('sliderinactive', () => {\n                if (this.player_.volume() === 0) {\n                    this.player_.lastVolume_(volumeBeforeDrag);\n                }\n            });\n        }\n    }\n\n    /**\n     * Default options for the `VolumeBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumeBar.prototype.options_ = {\n        children: ['volumeLevel'],\n        barName: 'volumeLevel'\n    };\n\n    // MouseVolumeLevelDisplay tooltip should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');\n    }\n\n    /**\n     * Call the update event for this Slider when this event happens on the player.\n     *\n     * @type {string}\n     */\n    VolumeBar.prototype.playerEvent = 'volumechange';\n    Component$1.registerComponent('VolumeBar', VolumeBar);\n\n    /**\n     * @file volume-control.js\n     */\n\n    /**\n     * The component for controlling the volume level\n     *\n     * @extends Component\n     */\n    class VolumeControl extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.vertical = options.vertical || false;\n\n            // Pass the vertical option down to the VolumeBar if\n            // the VolumeBar is turned on.\n            if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n                options.volumeBar = options.volumeBar || {};\n                options.volumeBar.vertical = options.vertical;\n            }\n            super(player, options);\n\n            // hide this control if volume support is missing\n            checkVolumeSupport(this, player);\n            this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n            this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n            this.on('mousedown', e => this.handleMouseDown(e));\n            this.on('touchstart', e => this.handleMouseDown(e));\n            this.on('mousemove', e => this.handleMouseMove(e));\n\n            // while the slider is active (the mouse has been pressed down and\n            // is dragging) or in focus we do not want to hide the VolumeBar\n            this.on(this.volumeBar, ['focus', 'slideractive'], () => {\n                this.volumeBar.addClass('vjs-slider-active');\n                this.addClass('vjs-slider-active');\n                this.trigger('slideractive');\n            });\n            this.on(this.volumeBar, ['blur', 'sliderinactive'], () => {\n                this.volumeBar.removeClass('vjs-slider-active');\n                this.removeClass('vjs-slider-active');\n                this.trigger('sliderinactive');\n            });\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            let orientationClass = 'vjs-volume-horizontal';\n            if (this.options_.vertical) {\n                orientationClass = 'vjs-volume-vertical';\n            }\n            return super.createEl('div', {\n                className: `vjs-volume-control vjs-control ${orientationClass}`\n            });\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseDown(event) {\n            const doc = this.el_.ownerDocument;\n            this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n            this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n            this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.on(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            const doc = this.el_.ownerDocument;\n            this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n            this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n            this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.off(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseMove(event) {\n            this.volumeBar.handleMouseMove(event);\n        }\n    }\n\n    /**\n     * Default options for the `VolumeControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumeControl.prototype.options_ = {\n        children: ['volumeBar']\n    };\n    Component$1.registerComponent('VolumeControl', VolumeControl);\n\n    /**\n     * Check if muting volume is supported and if it isn't hide the mute toggle\n     * button.\n     *\n     * @param { import('../../component').default } self\n     *        A reference to the mute toggle button\n     *\n     * @param { import('../../player').default } player\n     *        A reference to the player\n     *\n     * @private\n     */\n    const checkMuteSupport = function (self, player) {\n        // hide mute toggle button if it's not supported by the current tech\n        if (player.tech_ && !player.tech_.featuresMuteControl) {\n            self.addClass('vjs-hidden');\n        }\n        self.on(player, 'loadstart', function () {\n            if (!player.tech_.featuresMuteControl) {\n                self.addClass('vjs-hidden');\n            } else {\n                self.removeClass('vjs-hidden');\n            }\n        });\n    };\n\n    /**\n     * @file mute-toggle.js\n     */\n\n    /**\n     * A button component for muting the audio.\n     *\n     * @extends Button\n     */\n    class MuteToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n\n            // hide this control if volume support is missing\n            checkMuteSupport(this, player);\n            this.on(player, ['loadstart', 'volumechange'], e => this.update(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-mute-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when an `MuteToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const vol = this.player_.volume();\n            const lastVolume = this.player_.lastVolume_();\n            if (vol === 0) {\n                const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n                this.player_.volume(volumeToSet);\n                this.player_.muted(false);\n            } else {\n                this.player_.muted(this.player_.muted() ? false : true);\n            }\n        }\n\n        /**\n         * Update the `MuteToggle` button based on the state of `volume` and `muted`\n         * on the player.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#loadstart} event if this function was called\n         *        through an event.\n         *\n         * @listens Player#loadstart\n         * @listens Player#volumechange\n         */\n        update(event) {\n            this.updateIcon_();\n            this.updateControlText_();\n        }\n\n        /**\n         * Update the appearance of the `MuteToggle` icon.\n         *\n         * Possible states (given `level` variable below):\n         * - 0: crossed out\n         * - 1: zero bars of volume\n         * - 2: one bar of volume\n         * - 3: two bars of volume\n         *\n         * @private\n         */\n        updateIcon_() {\n            const vol = this.player_.volume();\n            let level = 3;\n            this.setIcon('volume-high');\n\n            // in iOS when a player is loaded with muted attribute\n            // and volume is changed with a native mute button\n            // we want to make sure muted state is updated\n            if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {\n                this.player_.muted(this.player_.tech_.el_.muted);\n            }\n            if (vol === 0 || this.player_.muted()) {\n                this.setIcon('volume-mute');\n                level = 0;\n            } else if (vol < 0.33) {\n                this.setIcon('volume-low');\n                level = 1;\n            } else if (vol < 0.67) {\n                this.setIcon('volume-medium');\n                level = 2;\n            }\n            removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? ' ' : ''}vjs-vol-${i}`, ''));\n            addClass(this.el_, `vjs-vol-${level}`);\n        }\n\n        /**\n         * If `muted` has changed on the player, update the control text\n         * (`title` attribute on `vjs-mute-control` element and content of\n         * `vjs-control-text` element).\n         *\n         * @private\n         */\n        updateControlText_() {\n            const soundOff = this.player_.muted() || this.player_.volume() === 0;\n            const text = soundOff ? 'Unmute' : 'Mute';\n            if (this.controlText() !== text) {\n                this.controlText(text);\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `MuteToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    MuteToggle.prototype.controlText_ = 'Mute';\n    Component$1.registerComponent('MuteToggle', MuteToggle);\n\n    /**\n     * @file volume-control.js\n     */\n\n    /**\n     * A Component to contain the MuteToggle and VolumeControl so that\n     * they can work together.\n     *\n     * @extends Component\n     */\n    class VolumePanel extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            if (typeof options.inline !== 'undefined') {\n                options.inline = options.inline;\n            } else {\n                options.inline = true;\n            }\n\n            // pass the inline option down to the VolumeControl as vertical if\n            // the VolumeControl is on.\n            if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n                options.volumeControl = options.volumeControl || {};\n                options.volumeControl.vertical = !options.inline;\n            }\n            super(player, options);\n\n            // this handler is used by mouse handler methods below\n            this.handleKeyPressHandler_ = e => this.handleKeyPress(e);\n            this.on(player, ['loadstart'], e => this.volumePanelState_(e));\n            this.on(this.muteToggle, 'keyup', e => this.handleKeyPress(e));\n            this.on(this.volumeControl, 'keyup', e => this.handleVolumeControlKeyUp(e));\n            this.on('keydown', e => this.handleKeyPress(e));\n            this.on('mouseover', e => this.handleMouseOver(e));\n            this.on('mouseout', e => this.handleMouseOut(e));\n\n            // while the slider is active (the mouse has been pressed down and\n            // is dragging) we do not want to hide the VolumeBar\n            this.on(this.volumeControl, ['slideractive'], this.sliderActive_);\n            this.on(this.volumeControl, ['sliderinactive'], this.sliderInactive_);\n        }\n\n        /**\n         * Add vjs-slider-active class to the VolumePanel\n         *\n         * @listens VolumeControl#slideractive\n         * @private\n         */\n        sliderActive_() {\n            this.addClass('vjs-slider-active');\n        }\n\n        /**\n         * Removes vjs-slider-active class to the VolumePanel\n         *\n         * @listens VolumeControl#sliderinactive\n         * @private\n         */\n        sliderInactive_() {\n            this.removeClass('vjs-slider-active');\n        }\n\n        /**\n         * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n         * depending on MuteToggle and VolumeControl state\n         *\n         * @listens Player#loadstart\n         * @private\n         */\n        volumePanelState_() {\n            // hide volume panel if neither volume control or mute toggle\n            // are displayed\n            if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n                this.addClass('vjs-hidden');\n            }\n\n            // if only mute toggle is visible we don't want\n            // volume panel expanding when hovered or active\n            if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n                this.addClass('vjs-mute-toggle-only');\n            }\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            let orientationClass = 'vjs-volume-panel-horizontal';\n            if (!this.options_.inline) {\n                orientationClass = 'vjs-volume-panel-vertical';\n            }\n            return super.createEl('div', {\n                className: `vjs-volume-panel vjs-control ${orientationClass}`\n            });\n        }\n\n        /**\n         * Dispose of the `volume-panel` and all child components.\n         */\n        dispose() {\n            this.handleMouseOut();\n            super.dispose();\n        }\n\n        /**\n         * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes\n         * the volume panel and sets focus on `MuteToggle`.\n         *\n         * @param {Event} event\n         *        The `keyup` event that caused this function to be called.\n         *\n         * @listens keyup\n         */\n        handleVolumeControlKeyUp(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                this.muteToggle.focus();\n            }\n        }\n\n        /**\n         * This gets called when a `VolumePanel` gains hover via a `mouseover` event.\n         * Turns on listening for `mouseover` event. When they happen it\n         * calls `this.handleMouseOver`.\n         *\n         * @param {Event} event\n         *        The `mouseover` event that caused this function to be called.\n         *\n         * @listens mouseover\n         */\n        handleMouseOver(event) {\n            this.addClass('vjs-hover');\n            on(document, 'keyup', this.handleKeyPressHandler_);\n        }\n\n        /**\n         * This gets called when a `VolumePanel` gains hover via a `mouseout` event.\n         * Turns on listening for `mouseout` event. When they happen it\n         * calls `this.handleMouseOut`.\n         *\n         * @param {Event} event\n         *        The `mouseout` event that caused this function to be called.\n         *\n         * @listens mouseout\n         */\n        handleMouseOut(event) {\n            this.removeClass('vjs-hover');\n            off(document, 'keyup', this.handleKeyPressHandler_);\n        }\n\n        /**\n         * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,\n         * looking for ESC, which hides the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        The keypress that triggered this event.\n         *\n         * @listens keydown | keyup\n         */\n        handleKeyPress(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                this.handleMouseOut();\n            }\n        }\n    }\n\n    /**\n     * Default options for the `VolumeControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumePanel.prototype.options_ = {\n        children: ['muteToggle', 'volumeControl']\n    };\n    Component$1.registerComponent('VolumePanel', VolumePanel);\n\n    /**\n     * Button to skip forward a configurable amount of time\n     * through a video. Renders in the control bar.\n     *\n     * e.g. options: {controlBar: {skipButtons: forward: 5}}\n     *\n     * @extends Button\n     */\n    class SkipForward extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.validOptions = [5, 10, 30];\n            this.skipTime = this.getSkipForwardTime();\n            if (this.skipTime && this.validOptions.includes(this.skipTime)) {\n                this.setIcon(`forward-${this.skipTime}`);\n                this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime]));\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n        getSkipForwardTime() {\n            const playerOptions = this.options_.playerOptions;\n            return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;\n        }\n        buildCSSClass() {\n            return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * On click, skips forward in the duration/seekable range by a configurable amount of seconds.\n         * If the time left in the duration/seekable range is less than the configured 'skip forward' time,\n         * skips to end of duration/seekable range.\n         *\n         * Handle a click on a `SkipForward` button\n         *\n         * @param {EventTarget~Event} event\n         *        The `click` event that caused this function\n         *        to be called\n         */\n        handleClick(event) {\n            if (isNaN(this.player_.duration())) {\n                return;\n            }\n            const currentVideoTime = this.player_.currentTime();\n            const liveTracker = this.player_.liveTracker;\n            const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();\n            let newTime;\n            if (currentVideoTime + this.skipTime <= duration) {\n                newTime = currentVideoTime + this.skipTime;\n            } else {\n                newTime = duration;\n            }\n            this.player_.currentTime(newTime);\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime]));\n        }\n    }\n    SkipForward.prototype.controlText_ = 'Skip Forward';\n    Component$1.registerComponent('SkipForward', SkipForward);\n\n    /**\n     * Button to skip backward a configurable amount of time\n     * through a video. Renders in the control bar.\n     *\n     *  * e.g. options: {controlBar: {skipButtons: backward: 5}}\n     *\n     * @extends Button\n     */\n    class SkipBackward extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.validOptions = [5, 10, 30];\n            this.skipTime = this.getSkipBackwardTime();\n            if (this.skipTime && this.validOptions.includes(this.skipTime)) {\n                this.setIcon(`replay-${this.skipTime}`);\n                this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime]));\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n        getSkipBackwardTime() {\n            const playerOptions = this.options_.playerOptions;\n            return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;\n        }\n        buildCSSClass() {\n            return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * On click, skips backward in the video by a configurable amount of seconds.\n         * If the current time in the video is less than the configured 'skip backward' time,\n         * skips to beginning of video or seekable range.\n         *\n         * Handle a click on a `SkipBackward` button\n         *\n         * @param {EventTarget~Event} event\n         *        The `click` event that caused this function\n         *        to be called\n         */\n        handleClick(event) {\n            const currentVideoTime = this.player_.currentTime();\n            const liveTracker = this.player_.liveTracker;\n            const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();\n            let newTime;\n            if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) {\n                newTime = seekableStart;\n            } else if (currentVideoTime >= this.skipTime) {\n                newTime = currentVideoTime - this.skipTime;\n            } else {\n                newTime = 0;\n            }\n            this.player_.currentTime(newTime);\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime]));\n        }\n    }\n    SkipBackward.prototype.controlText_ = 'Skip Backward';\n    Component$1.registerComponent('SkipBackward', SkipBackward);\n\n    /**\n     * @file menu.js\n     */\n\n    /**\n     * The Menu component is used to build popup menus, including subtitle and\n     * captions selection menus.\n     *\n     * @extends Component\n     */\n    class Menu extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        the player that this component should attach to\n         *\n         * @param {Object} [options]\n         *        Object of option names and values\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            if (options) {\n                this.menuButton_ = options.menuButton;\n            }\n            this.focusedChild_ = -1;\n            this.on('keydown', e => this.handleKeyDown(e));\n\n            // All the menu item instances share the same blur handler provided by the menu container.\n            this.boundHandleBlur_ = e => this.handleBlur(e);\n            this.boundHandleTapClick_ = e => this.handleTapClick(e);\n        }\n\n        /**\n         * Add event listeners to the {@link MenuItem}.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem` to add listeners to.\n         *\n         */\n        addEventListenerForItem(component) {\n            if (!(component instanceof Component$1)) {\n                return;\n            }\n            this.on(component, 'blur', this.boundHandleBlur_);\n            this.on(component, ['tap', 'click'], this.boundHandleTapClick_);\n        }\n\n        /**\n         * Remove event listeners from the {@link MenuItem}.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem` to remove listeners.\n         *\n         */\n        removeEventListenerForItem(component) {\n            if (!(component instanceof Component$1)) {\n                return;\n            }\n            this.off(component, 'blur', this.boundHandleBlur_);\n            this.off(component, ['tap', 'click'], this.boundHandleTapClick_);\n        }\n\n        /**\n         * This method will be called indirectly when the component has been added\n         * before the component adds to the new menu instance by `addItem`.\n         * In this case, the original menu instance will remove the component\n         * by calling `removeChild`.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem`\n         */\n        removeChild(component) {\n            if (typeof component === 'string') {\n                component = this.getChild(component);\n            }\n            this.removeEventListenerForItem(component);\n            super.removeChild(component);\n        }\n\n        /**\n         * Add a {@link MenuItem} to the menu.\n         *\n         * @param {Object|string} component\n         *        The name or instance of the `MenuItem` to add.\n         *\n         */\n        addItem(component) {\n            const childComponent = this.addChild(component);\n            if (childComponent) {\n                this.addEventListenerForItem(childComponent);\n            }\n        }\n\n        /**\n         * Create the `Menu`s DOM element.\n         *\n         * @return {Element}\n         *         the element that was created\n         */\n        createEl() {\n            const contentElType = this.options_.contentElType || 'ul';\n            this.contentEl_ = createEl(contentElType, {\n                className: 'vjs-menu-content'\n            });\n            this.contentEl_.setAttribute('role', 'menu');\n            const el = super.createEl('div', {\n                append: this.contentEl_,\n                className: 'vjs-menu'\n            });\n            el.appendChild(this.contentEl_);\n\n            // Prevent clicks from bubbling up. Needed for Menu Buttons,\n            // where a click on the parent is significant\n            on(el, 'click', function (event) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            });\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.boundHandleBlur_ = null;\n            this.boundHandleTapClick_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Called when a `MenuItem` loses focus.\n         *\n         * @param {Event} event\n         *        The `blur` event that caused this function to be called.\n         *\n         * @listens blur\n         */\n        handleBlur(event) {\n            const relatedTarget = event.relatedTarget || document.activeElement;\n\n            // Close menu popup when a user clicks outside the menu\n            if (!this.children().some(element => {\n                return element.el() === relatedTarget;\n            })) {\n                const btn = this.menuButton_;\n                if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {\n                    btn.unpressButton();\n                }\n            }\n        }\n\n        /**\n         * Called when a `MenuItem` gets clicked or tapped.\n         *\n         * @param {Event} event\n         *        The `click` or `tap` event that caused this function to be called.\n         *\n         * @listens click,tap\n         */\n        handleTapClick(event) {\n            // Unpress the associated MenuButton, and move focus back to it\n            if (this.menuButton_) {\n                this.menuButton_.unpressButton();\n                const childComponents = this.children();\n                if (!Array.isArray(childComponents)) {\n                    return;\n                }\n                const foundComponent = childComponents.filter(component => component.el() === event.target)[0];\n                if (!foundComponent) {\n                    return;\n                }\n\n                // don't focus menu button if item is a caption settings item\n                // because focus will move elsewhere\n                if (foundComponent.name() !== 'CaptionSettingsMenuItem') {\n                    this.menuButton_.focus();\n                }\n            }\n        }\n\n        /**\n         * Handle a `keydown` event on this menu. This listener is added in the constructor.\n         *\n         * @param {KeyboardEvent} event\n         *        A `keydown` event that happened on the menu.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Left and Down Arrows\n            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepForward();\n\n                // Up and Right Arrows\n            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepBack();\n            }\n        }\n\n        /**\n         * Move to next (lower) menu item for keyboard users.\n         */\n        stepForward() {\n            let stepChild = 0;\n            if (this.focusedChild_ !== undefined) {\n                stepChild = this.focusedChild_ + 1;\n            }\n            this.focus(stepChild);\n        }\n\n        /**\n         * Move to previous (higher) menu item for keyboard users.\n         */\n        stepBack() {\n            let stepChild = 0;\n            if (this.focusedChild_ !== undefined) {\n                stepChild = this.focusedChild_ - 1;\n            }\n            this.focus(stepChild);\n        }\n\n        /**\n         * Set focus on a {@link MenuItem} in the `Menu`.\n         *\n         * @param {Object|string} [item=0]\n         *        Index of child item set focus on.\n         */\n        focus(item = 0) {\n            const children = this.children().slice();\n            const haveTitle = children.length && children[0].hasClass('vjs-menu-title');\n            if (haveTitle) {\n                children.shift();\n            }\n            if (children.length > 0) {\n                if (item < 0) {\n                    item = 0;\n                } else if (item >= children.length) {\n                    item = children.length - 1;\n                }\n                this.focusedChild_ = item;\n                children[item].el_.focus();\n            }\n        }\n    }\n    Component$1.registerComponent('Menu', Menu);\n\n    /**\n     * @file menu-button.js\n     */\n\n    /**\n     * A `MenuButton` class for any popup {@link Menu}.\n     *\n     * @extends Component\n     */\n    class MenuButton extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n            this.menuButton_ = new Button(player, options);\n            this.menuButton_.controlText(this.controlText_);\n            this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n            // Add buildCSSClass values to the button, not the wrapper\n            const buttonClass = Button.prototype.buildCSSClass();\n            this.menuButton_.el_.className = this.buildCSSClass() + ' ' + buttonClass;\n            this.menuButton_.removeClass('vjs-control');\n            this.addChild(this.menuButton_);\n            this.update();\n            this.enabled_ = true;\n            const handleClick = e => this.handleClick(e);\n            this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);\n            this.on(this.menuButton_, 'tap', handleClick);\n            this.on(this.menuButton_, 'click', handleClick);\n            this.on(this.menuButton_, 'keydown', e => this.handleKeyDown(e));\n            this.on(this.menuButton_, 'mouseenter', () => {\n                this.addClass('vjs-hover');\n                this.menu.show();\n                on(document, 'keyup', this.handleMenuKeyUp_);\n            });\n            this.on('mouseleave', e => this.handleMouseLeave(e));\n            this.on('keydown', e => this.handleSubmenuKeyDown(e));\n        }\n\n        /**\n         * Update the menu based on the current state of its items.\n         */\n        update() {\n            const menu = this.createMenu();\n            if (this.menu) {\n                this.menu.dispose();\n                this.removeChild(this.menu);\n            }\n            this.menu = menu;\n            this.addChild(menu);\n\n            /**\n             * Track the state of the menu button\n             *\n             * @type {Boolean}\n             * @private\n             */\n            this.buttonPressed_ = false;\n            this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n            if (this.items && this.items.length <= this.hideThreshold_) {\n                this.hide();\n                this.menu.contentEl_.removeAttribute('role');\n            } else {\n                this.show();\n                this.menu.contentEl_.setAttribute('role', 'menu');\n            }\n        }\n\n        /**\n         * Create the menu and add all items to it.\n         *\n         * @return {Menu}\n         *         The constructed menu\n         */\n        createMenu() {\n            const menu = new Menu(this.player_, {\n                menuButton: this\n            });\n\n            /**\n             * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n             * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n             * it here because every time we run `createMenu` we need to reset the value.\n             *\n             * @protected\n             * @type {Number}\n             */\n            this.hideThreshold_ = 0;\n\n            // Add a title list item to the top\n            if (this.options_.title) {\n                const titleEl = createEl('li', {\n                    className: 'vjs-menu-title',\n                    textContent: toTitleCase$1(this.options_.title),\n                    tabIndex: -1\n                });\n                const titleComponent = new Component$1(this.player_, {\n                    el: titleEl\n                });\n                menu.addItem(titleComponent);\n            }\n            this.items = this.createItems();\n            if (this.items) {\n                // Add menu items to the menu\n                for (let i = 0; i < this.items.length; i++) {\n                    menu.addItem(this.items[i]);\n                }\n            }\n            return menu;\n        }\n\n        /**\n         * Create the list of menu items. Specific to each subclass.\n         *\n         * @abstract\n         */\n        createItems() {}\n\n        /**\n         * Create the `MenuButtons`s DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildWrapperCSSClass()\n            }, {});\n        }\n\n        /**\n         * Overwrites the `setIcon` method from `Component`.\n         * In this case, we want the icon to be appended to the menuButton.\n         *\n         * @param {string} name\n         *         The icon name to be added.\n         */\n        setIcon(name) {\n            super.setIcon(name, this.menuButton_.el_);\n        }\n\n        /**\n         * Allow sub components to stack CSS class names for the wrapper element\n         *\n         * @return {string}\n         *         The constructed wrapper DOM `className`\n         */\n        buildWrapperCSSClass() {\n            let menuButtonClass = 'vjs-menu-button';\n\n            // If the inline option is passed, we want to use different styles altogether.\n            if (this.options_.inline === true) {\n                menuButtonClass += '-inline';\n            } else {\n                menuButtonClass += '-popup';\n            }\n\n            // TODO: Fix the CSS so that this isn't necessary\n            const buttonClass = Button.prototype.buildCSSClass();\n            return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            let menuButtonClass = 'vjs-menu-button';\n\n            // If the inline option is passed, we want to use different styles altogether.\n            if (this.options_.inline === true) {\n                menuButtonClass += '-inline';\n            } else {\n                menuButtonClass += '-popup';\n            }\n            return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Get or set the localized control text that will be used for accessibility.\n         *\n         * > NOTE: This will come from the internal `menuButton_` element.\n         *\n         * @param {string} [text]\n         *        Control text for element.\n         *\n         * @param {Element} [el=this.menuButton_.el()]\n         *        Element to set the title on.\n         *\n         * @return {string}\n         *         - The control text when getting\n         */\n        controlText(text, el = this.menuButton_.el()) {\n            return this.menuButton_.controlText(text, el);\n        }\n\n        /**\n         * Dispose of the `menu-button` and all child components.\n         */\n        dispose() {\n            this.handleMouseLeave();\n            super.dispose();\n        }\n\n        /**\n         * Handle a click on a `MenuButton`.\n         * See {@link ClickableComponent#handleClick} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (this.buttonPressed_) {\n                this.unpressButton();\n            } else {\n                this.pressButton();\n            }\n        }\n\n        /**\n         * Handle `mouseleave` for `MenuButton`.\n         *\n         * @param {Event} event\n         *        The `mouseleave` event that caused this function to be called.\n         *\n         * @listens mouseleave\n         */\n        handleMouseLeave(event) {\n            this.removeClass('vjs-hover');\n            off(document, 'keyup', this.handleMenuKeyUp_);\n        }\n\n        /**\n         * Set the focus to the actual button, not to this element\n         */\n        focus() {\n            this.menuButton_.focus();\n        }\n\n        /**\n         * Remove the focus from the actual button, not this element\n         */\n        blur() {\n            this.menuButton_.blur();\n        }\n\n        /**\n         * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n         * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Escape or Tab unpress the 'button'\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                if (this.buttonPressed_) {\n                    this.unpressButton();\n                }\n\n                // Don't preventDefault for Tab key - we still want to lose focus\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.preventDefault();\n                    // Set focus back to the menu button's button\n                    this.menuButton_.focus();\n                }\n                // Up Arrow or Down Arrow also 'press' the button to open the menu\n            } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {\n                if (!this.buttonPressed_) {\n                    event.preventDefault();\n                    this.pressButton();\n                }\n            }\n        }\n\n        /**\n         * Handle a `keyup` event on a `MenuButton`. The listener for this is added in\n         * the constructor.\n         *\n         * @param {Event} event\n         *        Key press event\n         *\n         * @listens keyup\n         */\n        handleMenuKeyUp(event) {\n            // Escape hides popup menu\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                this.removeClass('vjs-hover');\n            }\n        }\n\n        /**\n         * This method name now delegates to `handleSubmenuKeyDown`. This means\n         * anyone calling `handleSubmenuKeyPress` will not see their method calls\n         * stop working.\n         *\n         * @param {Event} event\n         *        The event that caused this function to be called.\n         */\n        handleSubmenuKeyPress(event) {\n            this.handleSubmenuKeyDown(event);\n        }\n\n        /**\n         * Handle a `keydown` event on a sub-menu. The listener for this is added in\n         * the constructor.\n         *\n         * @param {Event} event\n         *        Key press event\n         *\n         * @listens keydown\n         */\n        handleSubmenuKeyDown(event) {\n            // Escape or Tab unpress the 'button'\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                if (this.buttonPressed_) {\n                    this.unpressButton();\n                }\n                // Don't preventDefault for Tab key - we still want to lose focus\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.preventDefault();\n                    // Set focus back to the menu button's button\n                    this.menuButton_.focus();\n                }\n            }\n        }\n\n        /**\n         * Put the current `MenuButton` into a pressed state.\n         */\n        pressButton() {\n            if (this.enabled_) {\n                this.buttonPressed_ = true;\n                this.menu.show();\n                this.menu.lockShowing();\n                this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n                // set the focus into the submenu, except on iOS where it is resulting in\n                // undesired scrolling behavior when the player is in an iframe\n                if (IS_IOS && isInFrame()) {\n                    // Return early so that the menu isn't focused\n                    return;\n                }\n                this.menu.focus();\n            }\n        }\n\n        /**\n         * Take the current `MenuButton` out of a pressed state.\n         */\n        unpressButton() {\n            if (this.enabled_) {\n                this.buttonPressed_ = false;\n                this.menu.unlockShowing();\n                this.menu.hide();\n                this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n            }\n        }\n\n        /**\n         * Disable the `MenuButton`. Don't allow it to be clicked.\n         */\n        disable() {\n            this.unpressButton();\n            this.enabled_ = false;\n            this.addClass('vjs-disabled');\n            this.menuButton_.disable();\n        }\n\n        /**\n         * Enable the `MenuButton`. Allow it to be clicked.\n         */\n        enable() {\n            this.enabled_ = true;\n            this.removeClass('vjs-disabled');\n            this.menuButton_.enable();\n        }\n    }\n    Component$1.registerComponent('MenuButton', MenuButton);\n\n    /**\n     * @file track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific  track types (e.g. subtitles).\n     *\n     * @extends MenuButton\n     */\n    class TrackButton extends MenuButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const tracks = options.tracks;\n            super(player, options);\n            if (this.items.length <= 1) {\n                this.hide();\n            }\n            if (!tracks) {\n                return;\n            }\n            const updateHandler = bind_(this, this.update);\n            tracks.addEventListener('removetrack', updateHandler);\n            tracks.addEventListener('addtrack', updateHandler);\n            tracks.addEventListener('labelchange', updateHandler);\n            this.player_.on('ready', updateHandler);\n            this.player_.on('dispose', function () {\n                tracks.removeEventListener('removetrack', updateHandler);\n                tracks.removeEventListener('addtrack', updateHandler);\n                tracks.removeEventListener('labelchange', updateHandler);\n            });\n        }\n    }\n    Component$1.registerComponent('TrackButton', TrackButton);\n\n    /**\n     * @file menu-keys.js\n     */\n\n    /**\n     * All keys used for operation of a menu (`MenuButton`, `Menu`, and `MenuItem`)\n     * Note that 'Enter' and 'Space' are not included here (otherwise they would\n     * prevent the `MenuButton` and `MenuItem` from being keyboard-clickable)\n     *\n     * @typedef MenuKeys\n     * @array\n     */\n    const MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];\n\n    /**\n     * @file menu-item.js\n     */\n\n    /**\n     * The component for a menu item. `<li>`\n     *\n     * @extends ClickableComponent\n     */\n    class MenuItem extends ClickableComponent {\n        /**\n         * Creates an instance of the this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.selectable = options.selectable;\n            this.isSelected_ = options.selected || false;\n            this.multiSelectable = options.multiSelectable;\n            this.selected(this.isSelected_);\n            if (this.selectable) {\n                if (this.multiSelectable) {\n                    this.el_.setAttribute('role', 'menuitemcheckbox');\n                } else {\n                    this.el_.setAttribute('role', 'menuitemradio');\n                }\n            } else {\n                this.el_.setAttribute('role', 'menuitem');\n            }\n        }\n\n        /**\n         * Create the `MenuItem's DOM element\n         *\n         * @param {string} [type=li]\n         *        Element's node type, not actually used, always set to `li`.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element\n         *\n         * @param {Object} [attrs={}]\n         *        An object of attributes that should be set on the element\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(type, props, attrs) {\n            // The control is textual, not just an icon\n            this.nonIconControl = true;\n            const el = super.createEl('li', Object.assign({\n                className: 'vjs-menu-item',\n                tabIndex: -1\n            }, props), attrs);\n\n            // swap icon with menu item text.\n            const menuItemEl = createEl('span', {\n                className: 'vjs-menu-item-text',\n                textContent: this.localize(this.options_.label)\n            });\n\n            // If using SVG icons, the element with vjs-icon-placeholder will be added separately.\n            if (this.player_.options_.experimentalSvgIcons) {\n                el.appendChild(menuItemEl);\n            } else {\n                el.replaceChild(menuItemEl, el.querySelector('.vjs-icon-placeholder'));\n            }\n            return el;\n        }\n\n        /**\n         * Ignore keys which are used by the menu, but pass any other ones up. See\n         * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            if (!MenuKeys.some(key => keycode.isEventKey(event, key))) {\n                // Pass keydown handling up for unused keys\n                super.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Any click on a `MenuItem` puts it into the selected state.\n         * See {@link ClickableComponent#handleClick} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            this.selected(true);\n        }\n\n        /**\n         * Set the state for this menu item as selected or not.\n         *\n         * @param {boolean} selected\n         *        if the menu item is selected or not\n         */\n        selected(selected) {\n            if (this.selectable) {\n                if (selected) {\n                    this.addClass('vjs-selected');\n                    this.el_.setAttribute('aria-checked', 'true');\n                    // aria-checked isn't fully supported by browsers/screen readers,\n                    // so indicate selected state to screen reader in the control text.\n                    this.controlText(', selected');\n                    this.isSelected_ = true;\n                } else {\n                    this.removeClass('vjs-selected');\n                    this.el_.setAttribute('aria-checked', 'false');\n                    // Indicate un-selected state to screen reader\n                    this.controlText('');\n                    this.isSelected_ = false;\n                }\n            }\n        }\n    }\n    Component$1.registerComponent('MenuItem', MenuItem);\n\n    /**\n     * @file text-track-menu-item.js\n     */\n\n    /**\n     * The specific menu item type for selecting a language within a text track kind\n     *\n     * @extends MenuItem\n     */\n    class TextTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const tracks = player.textTracks();\n\n            // Modify options for parent MenuItem class's init.\n            options.label = track.label || track.language || 'Unknown';\n            options.selected = track.mode === 'showing';\n            super(player, options);\n            this.track = track;\n            // Determine the relevant kind(s) of tracks for this component and filter\n            // out empty kinds.\n            this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);\n            const changeHandler = (...args) => {\n                this.handleTracksChange.apply(this, args);\n            };\n            const selectedLanguageChangeHandler = (...args) => {\n                this.handleSelectedLanguageChange.apply(this, args);\n            };\n            player.on(['loadstart', 'texttrackchange'], changeHandler);\n            tracks.addEventListener('change', changeHandler);\n            tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n            this.on('dispose', function () {\n                player.off(['loadstart', 'texttrackchange'], changeHandler);\n                tracks.removeEventListener('change', changeHandler);\n                tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n            });\n\n            // iOS7 doesn't dispatch change events to TextTrackLists when an\n            // associated track's mode changes. Without something like\n            // Object.observe() (also not present on iOS7), it's not\n            // possible to detect changes to the mode attribute and polyfill\n            // the change event. As a poor substitute, we manually dispatch\n            // change events whenever the controls modify the mode.\n            if (tracks.onchange === undefined) {\n                let event;\n                this.on(['tap', 'click'], function () {\n                    if (typeof window.Event !== 'object') {\n                        // Android 2.3 throws an Illegal Constructor error for window.Event\n                        try {\n                            event = new window.Event('change');\n                        } catch (err) {\n                            // continue regardless of error\n                        }\n                    }\n                    if (!event) {\n                        event = document.createEvent('Event');\n                        event.initEvent('change', true, true);\n                    }\n                    tracks.dispatchEvent(event);\n                });\n            }\n\n            // set the default state based on current tracks\n            this.handleTracksChange();\n        }\n\n        /**\n         * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const referenceTrack = this.track;\n            const tracks = this.player_.textTracks();\n            super.handleClick(event);\n            if (!tracks) {\n                return;\n            }\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n\n                // If the track from the text tracks list is not of the right kind,\n                // skip it. We do not want to affect tracks of incompatible kind(s).\n                if (this.kinds.indexOf(track.kind) === -1) {\n                    continue;\n                }\n\n                // If this text track is the component's track and it is not showing,\n                // set it to showing.\n                if (track === referenceTrack) {\n                    if (track.mode !== 'showing') {\n                        track.mode = 'showing';\n                    }\n\n                    // If this text track is not the component's track and it is not\n                    // disabled, set it to disabled.\n                } else if (track.mode !== 'disabled') {\n                    track.mode = 'disabled';\n                }\n            }\n        }\n\n        /**\n         * Handle text track list change\n         *\n         * @param {Event} event\n         *        The `change` event that caused this function to be called.\n         *\n         * @listens TextTrackList#change\n         */\n        handleTracksChange(event) {\n            const shouldBeSelected = this.track.mode === 'showing';\n\n            // Prevent redundant selected() calls because they may cause\n            // screen readers to read the appended control text unnecessarily\n            if (shouldBeSelected !== this.isSelected_) {\n                this.selected(shouldBeSelected);\n            }\n        }\n        handleSelectedLanguageChange(event) {\n            if (this.track.mode === 'showing') {\n                const selectedLanguage = this.player_.cache_.selectedLanguage;\n\n                // Don't replace the kind of track across the same language\n                if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n                    return;\n                }\n                this.player_.cache_.selectedLanguage = {\n                    enabled: true,\n                    language: this.track.language,\n                    kind: this.track.kind\n                };\n            }\n        }\n        dispose() {\n            // remove reference to track object on dispose\n            this.track = null;\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n    /**\n     * @file off-text-track-menu-item.js\n     */\n\n    /**\n     * A special menu item for turning off a specific type of text track\n     *\n     * @extends TextTrackMenuItem\n     */\n    class OffTextTrackMenuItem extends TextTrackMenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            // Create pseudo track info\n            // Requires options['kind']\n            options.track = {\n                player,\n                // it is no longer necessary to store `kind` or `kinds` on the track itself\n                // since they are now stored in the `kinds` property of all instances of\n                // TextTrackMenuItem, but this will remain for backwards compatibility\n                kind: options.kind,\n                kinds: options.kinds,\n                default: false,\n                mode: 'disabled'\n            };\n            if (!options.kinds) {\n                options.kinds = [options.kind];\n            }\n            if (options.label) {\n                options.track.label = options.label;\n            } else {\n                options.track.label = options.kinds.join(' and ') + ' off';\n            }\n\n            // MenuItem is selectable\n            options.selectable = true;\n            // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n            options.multiSelectable = false;\n            super(player, options);\n        }\n\n        /**\n         * Handle text track change\n         *\n         * @param {Event} event\n         *        The event that caused this function to run\n         */\n        handleTracksChange(event) {\n            const tracks = this.player().textTracks();\n            let shouldBeSelected = true;\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n                    shouldBeSelected = false;\n                    break;\n                }\n            }\n\n            // Prevent redundant selected() calls because they may cause\n            // screen readers to read the appended control text unnecessarily\n            if (shouldBeSelected !== this.isSelected_) {\n                this.selected(shouldBeSelected);\n            }\n        }\n        handleSelectedLanguageChange(event) {\n            const tracks = this.player().textTracks();\n            let allHidden = true;\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n                    allHidden = false;\n                    break;\n                }\n            }\n            if (allHidden) {\n                this.player_.cache_.selectedLanguage = {\n                    enabled: false\n                };\n            }\n        }\n\n        /**\n         * Update control text and label on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.label);\n            super.handleLanguagechange();\n        }\n    }\n    Component$1.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n    /**\n     * @file text-track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific text track types (e.g. subtitles)\n     *\n     * @extends MenuButton\n     */\n    class TextTrackButton extends TrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.tracks = player.textTracks();\n            super(player, options);\n        }\n\n        /**\n         * Create a menu item for each text track\n         *\n         * @param {TextTrackMenuItem[]} [items=[]]\n         *        Existing array of items to use during creation\n         *\n         * @return {TextTrackMenuItem[]}\n         *         Array of menu items that were created\n         */\n        createItems(items = [], TrackMenuItem = TextTrackMenuItem) {\n            // Label is an override for the [track] off label\n            // USed to localise captions/subtitles\n            let label;\n            if (this.label_) {\n                label = `${this.label_} off`;\n            }\n            // Add an OFF menu item to turn all tracks off\n            items.push(new OffTextTrackMenuItem(this.player_, {\n                kinds: this.kinds_,\n                kind: this.kind_,\n                label\n            }));\n            this.hideThreshold_ += 1;\n            const tracks = this.player_.textTracks();\n            if (!Array.isArray(this.kinds_)) {\n                this.kinds_ = [this.kind_];\n            }\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n\n                // only add tracks that are of an appropriate kind and have a label\n                if (this.kinds_.indexOf(track.kind) > -1) {\n                    const item = new TrackMenuItem(this.player_, {\n                        track,\n                        kinds: this.kinds_,\n                        kind: this.kind_,\n                        // MenuItem is selectable\n                        selectable: true,\n                        // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n                        multiSelectable: false\n                    });\n                    item.addClass(`vjs-${track.kind}-menu-item`);\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    Component$1.registerComponent('TextTrackButton', TextTrackButton);\n\n    /**\n     * @file chapters-track-menu-item.js\n     */\n\n    /**\n     * The chapter track menu item\n     *\n     * @extends MenuItem\n     */\n    class ChaptersTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const cue = options.cue;\n            const currentTime = player.currentTime();\n\n            // Modify options for parent MenuItem class's init.\n            options.selectable = true;\n            options.multiSelectable = false;\n            options.label = cue.text;\n            options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n            super(player, options);\n            this.track = track;\n            this.cue = cue;\n        }\n\n        /**\n         * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick();\n            this.player_.currentTime(this.cue.startTime);\n        }\n    }\n    Component$1.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n    /**\n     * @file chapters-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting chapters\n     * Chapters act much differently than other text tracks\n     * Cues are navigation vs. other tracks of alternative languages\n     *\n     * @extends TextTrackButton\n     */\n    class ChaptersButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this function is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            this.setIcon('chapters');\n            this.selectCurrentItem_ = () => {\n                this.items.forEach(item => {\n                    item.selected(this.track_.activeCues[0] === item.cue);\n                });\n            };\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-chapters-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Update the menu based on the current state of its items.\n         *\n         * @param {Event} [event]\n         *        An event that triggered this function to run.\n         *\n         * @listens TextTrackList#addtrack\n         * @listens TextTrackList#removetrack\n         * @listens TextTrackList#change\n         */\n        update(event) {\n            if (event && event.track && event.track.kind !== 'chapters') {\n                return;\n            }\n            const track = this.findChaptersTrack();\n            if (track !== this.track_) {\n                this.setTrack(track);\n                super.update();\n            } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {\n                // Update the menu initially or if the number of cues has changed since set\n                super.update();\n            }\n        }\n\n        /**\n         * Set the currently selected track for the chapters button.\n         *\n         * @param {TextTrack} track\n         *        The new track to select. Nothing will change if this is the currently selected\n         *        track.\n         */\n        setTrack(track) {\n            if (this.track_ === track) {\n                return;\n            }\n            if (!this.updateHandler_) {\n                this.updateHandler_ = this.update.bind(this);\n            }\n\n            // here this.track_ refers to the old track instance\n            if (this.track_) {\n                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n                if (remoteTextTrackEl) {\n                    remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n                }\n                this.track_.removeEventListener('cuechange', this.selectCurrentItem_);\n                this.track_ = null;\n            }\n            this.track_ = track;\n\n            // here this.track_ refers to the new track instance\n            if (this.track_) {\n                this.track_.mode = 'hidden';\n                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n                if (remoteTextTrackEl) {\n                    remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n                }\n                this.track_.addEventListener('cuechange', this.selectCurrentItem_);\n            }\n        }\n\n        /**\n         * Find the track object that is currently in use by this ChaptersButton\n         *\n         * @return {TextTrack|undefined}\n         *         The current track or undefined if none was found.\n         */\n        findChaptersTrack() {\n            const tracks = this.player_.textTracks() || [];\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                // We will always choose the last track as our chaptersTrack\n                const track = tracks[i];\n                if (track.kind === this.kind_) {\n                    return track;\n                }\n            }\n        }\n\n        /**\n         * Get the caption for the ChaptersButton based on the track label. This will also\n         * use the current tracks localized kind as a fallback if a label does not exist.\n         *\n         * @return {string}\n         *         The tracks current label or the localized track kind.\n         */\n        getMenuCaption() {\n            if (this.track_ && this.track_.label) {\n                return this.track_.label;\n            }\n            return this.localize(toTitleCase$1(this.kind_));\n        }\n\n        /**\n         * Create menu from chapter track\n         *\n         * @return { import('../../menu/menu').default }\n         *         New menu for the chapter buttons\n         */\n        createMenu() {\n            this.options_.title = this.getMenuCaption();\n            return super.createMenu();\n        }\n\n        /**\n         * Create a menu item for each text track\n         *\n         * @return  { import('./text-track-menu-item').default[] }\n         *         Array of menu items\n         */\n        createItems() {\n            const items = [];\n            if (!this.track_) {\n                return items;\n            }\n            const cues = this.track_.cues;\n            if (!cues) {\n                return items;\n            }\n            for (let i = 0, l = cues.length; i < l; i++) {\n                const cue = cues[i];\n                const mi = new ChaptersTrackMenuItem(this.player_, {\n                    track: this.track_,\n                    cue\n                });\n                items.push(mi);\n            }\n            return items;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    ChaptersButton.prototype.kind_ = 'chapters';\n\n    /**\n     * The text that should display over the `ChaptersButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    ChaptersButton.prototype.controlText_ = 'Chapters';\n    Component$1.registerComponent('ChaptersButton', ChaptersButton);\n\n    /**\n     * @file descriptions-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting descriptions\n     *\n     * @extends TextTrackButton\n     */\n    class DescriptionsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            this.setIcon('audio-description');\n            const tracks = player.textTracks();\n            const changeHandler = bind_(this, this.handleTracksChange);\n            tracks.addEventListener('change', changeHandler);\n            this.on('dispose', function () {\n                tracks.removeEventListener('change', changeHandler);\n            });\n        }\n\n        /**\n         * Handle text track change\n         *\n         * @param {Event} event\n         *        The event that caused this function to run\n         *\n         * @listens TextTrackList#change\n         */\n        handleTracksChange(event) {\n            const tracks = this.player().textTracks();\n            let disabled = false;\n\n            // Check whether a track of a different kind is showing\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (track.kind !== this.kind_ && track.mode === 'showing') {\n                    disabled = true;\n                    break;\n                }\n            }\n\n            // If another track is showing, disable this menu button\n            if (disabled) {\n                this.disable();\n            } else {\n                this.enable();\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-descriptions-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    DescriptionsButton.prototype.kind_ = 'descriptions';\n\n    /**\n     * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    DescriptionsButton.prototype.controlText_ = 'Descriptions';\n    Component$1.registerComponent('DescriptionsButton', DescriptionsButton);\n\n    /**\n     * @file subtitles-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting subtitles\n     *\n     * @extends TextTrackButton\n     */\n    class SubtitlesButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            this.setIcon('subtitles');\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-subtitles-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    SubtitlesButton.prototype.kind_ = 'subtitles';\n\n    /**\n     * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    SubtitlesButton.prototype.controlText_ = 'Subtitles';\n    Component$1.registerComponent('SubtitlesButton', SubtitlesButton);\n\n    /**\n     * @file caption-settings-menu-item.js\n     */\n\n    /**\n     * The menu item for caption track settings menu\n     *\n     * @extends TextTrackMenuItem\n     */\n    class CaptionSettingsMenuItem extends TextTrackMenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            options.track = {\n                player,\n                kind: options.kind,\n                label: options.kind + ' settings',\n                selectable: false,\n                default: false,\n                mode: 'disabled'\n            };\n\n            // CaptionSettingsMenuItem has no concept of 'selected'\n            options.selectable = false;\n            options.name = 'CaptionSettingsMenuItem';\n            super(player, options);\n            this.addClass('vjs-texttrack-settings');\n            this.controlText(', opens ' + options.kind + ' settings dialog');\n        }\n\n        /**\n         * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            this.player().getChild('textTrackSettings').open();\n        }\n\n        /**\n         * Update control text and label on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.kind + ' settings');\n            super.handleLanguagechange();\n        }\n    }\n    Component$1.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n    /**\n     * @file captions-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting captions\n     *\n     * @extends TextTrackButton\n     */\n    class CaptionsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            this.setIcon('captions');\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-captions-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-captions-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create caption menu items\n         *\n         * @return {CaptionSettingsMenuItem[]}\n         *         The array of current menu items.\n         */\n        createItems() {\n            const items = [];\n            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n                items.push(new CaptionSettingsMenuItem(this.player_, {\n                    kind: this.kind_\n                }));\n                this.hideThreshold_ += 1;\n            }\n            return super.createItems(items);\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    CaptionsButton.prototype.kind_ = 'captions';\n\n    /**\n     * The text that should display over the `CaptionsButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    CaptionsButton.prototype.controlText_ = 'Captions';\n    Component$1.registerComponent('CaptionsButton', CaptionsButton);\n\n    /**\n     * @file subs-caps-menu-item.js\n     */\n\n    /**\n     * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n     * in the SubsCapsMenu.\n     *\n     * @extends TextTrackMenuItem\n     */\n    class SubsCapsMenuItem extends TextTrackMenuItem {\n        createEl(type, props, attrs) {\n            const el = super.createEl(type, props, attrs);\n            const parentSpan = el.querySelector('.vjs-menu-item-text');\n            if (this.options_.track.kind === 'captions') {\n                if (this.player_.options_.experimentalSvgIcons) {\n                    this.setIcon('captions', el);\n                } else {\n                    parentSpan.appendChild(createEl('span', {\n                        className: 'vjs-icon-placeholder'\n                    }, {\n                        'aria-hidden': true\n                    }));\n                }\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-control-text',\n                    // space added as the text will visually flow with the\n                    // label\n                    textContent: ` ${this.localize('Captions')}`\n                }));\n            }\n            return el;\n        }\n    }\n    Component$1.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n    /**\n     * @file sub-caps-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting captions and/or subtitles\n     *\n     * @extends TextTrackButton\n     */\n    class SubsCapsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n\n            // Although North America uses \"captions\" in most cases for\n            // \"captions and subtitles\" other locales use \"subtitles\"\n            this.label_ = 'subtitles';\n            this.setIcon('subtitles');\n            if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(this.player_.language_) > -1) {\n                this.label_ = 'captions';\n                this.setIcon('captions');\n            }\n            this.menuButton_.controlText(toTitleCase$1(this.label_));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-subs-caps-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create caption/subtitles menu items\n         *\n         * @return {CaptionSettingsMenuItem[]}\n         *         The array of current menu items.\n         */\n        createItems() {\n            let items = [];\n            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n                items.push(new CaptionSettingsMenuItem(this.player_, {\n                    kind: this.label_\n                }));\n                this.hideThreshold_ += 1;\n            }\n            items = super.createItems(items, SubsCapsMenuItem);\n            return items;\n        }\n    }\n\n    /**\n     * `kind`s of TextTrack to look for to associate it with this menu.\n     *\n     * @type {array}\n     * @private\n     */\n    SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n    /**\n     * The text that should display over the `SubsCapsButton`s controls.\n     *\n     *\n     * @type {string}\n     * @protected\n     */\n    SubsCapsButton.prototype.controlText_ = 'Subtitles';\n    Component$1.registerComponent('SubsCapsButton', SubsCapsButton);\n\n    /**\n     * @file audio-track-menu-item.js\n     */\n\n    /**\n     * An {@link AudioTrack} {@link MenuItem}\n     *\n     * @extends MenuItem\n     */\n    class AudioTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const tracks = player.audioTracks();\n\n            // Modify options for parent MenuItem class's init.\n            options.label = track.label || track.language || 'Unknown';\n            options.selected = track.enabled;\n            super(player, options);\n            this.track = track;\n            this.addClass(`vjs-${track.kind}-menu-item`);\n            const changeHandler = (...args) => {\n                this.handleTracksChange.apply(this, args);\n            };\n            tracks.addEventListener('change', changeHandler);\n            this.on('dispose', () => {\n                tracks.removeEventListener('change', changeHandler);\n            });\n        }\n        createEl(type, props, attrs) {\n            const el = super.createEl(type, props, attrs);\n            const parentSpan = el.querySelector('.vjs-menu-item-text');\n            if (['main-desc', 'description'].indexOf(this.options_.track.kind) >= 0) {\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-icon-placeholder'\n                }, {\n                    'aria-hidden': true\n                }));\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-control-text',\n                    textContent: ' ' + this.localize('Descriptions')\n                }));\n            }\n            return el;\n        }\n\n        /**\n         * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n         * for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick(event);\n\n            // the audio track list will automatically toggle other tracks\n            // off for us.\n            this.track.enabled = true;\n\n            // when native audio tracks are used, we want to make sure that other tracks are turned off\n            if (this.player_.tech_.featuresNativeAudioTracks) {\n                const tracks = this.player_.audioTracks();\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n\n                    // skip the current track since we enabled it above\n                    if (track === this.track) {\n                        continue;\n                    }\n                    track.enabled = track === this.track;\n                }\n            }\n        }\n\n        /**\n         * Handle any {@link AudioTrack} change.\n         *\n         * @param {Event} [event]\n         *        The {@link AudioTrackList#change} event that caused this to run.\n         *\n         * @listens AudioTrackList#change\n         */\n        handleTracksChange(event) {\n            this.selected(this.track.enabled);\n        }\n    }\n    Component$1.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n    /**\n     * @file audio-track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific {@link AudioTrack} types.\n     *\n     * @extends TrackButton\n     */\n    class AudioTrackButton extends TrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param {Player} player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.tracks = player.audioTracks();\n            super(player, options);\n            this.setIcon('audio');\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-audio-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-audio-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create a menu item for each audio track\n         *\n         * @param {AudioTrackMenuItem[]} [items=[]]\n         *        An array of existing menu items to use.\n         *\n         * @return {AudioTrackMenuItem[]}\n         *         An array of menu items\n         */\n        createItems(items = []) {\n            // if there's only one audio track, there no point in showing it\n            this.hideThreshold_ = 1;\n            const tracks = this.player_.audioTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n                items.push(new AudioTrackMenuItem(this.player_, {\n                    track,\n                    // MenuItem is selectable\n                    selectable: true,\n                    // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n                    multiSelectable: false\n                }));\n            }\n            return items;\n        }\n    }\n\n    /**\n     * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    AudioTrackButton.prototype.controlText_ = 'Audio Track';\n    Component$1.registerComponent('AudioTrackButton', AudioTrackButton);\n\n    /**\n     * @file playback-rate-menu-item.js\n     */\n\n    /**\n     * The specific menu item type for selecting a playback rate.\n     *\n     * @extends MenuItem\n     */\n    class PlaybackRateMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const label = options.rate;\n            const rate = parseFloat(label, 10);\n\n            // Modify options for parent MenuItem class's init.\n            options.label = label;\n            options.selected = rate === player.playbackRate();\n            options.selectable = true;\n            options.multiSelectable = false;\n            super(player, options);\n            this.label = label;\n            this.rate = rate;\n            this.on(player, 'ratechange', e => this.update(e));\n        }\n\n        /**\n         * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick();\n            this.player().playbackRate(this.rate);\n        }\n\n        /**\n         * Update the PlaybackRateMenuItem when the playbackrate changes.\n         *\n         * @param {Event} [event]\n         *        The `ratechange` event that caused this function to run.\n         *\n         * @listens Player#ratechange\n         */\n        update(event) {\n            this.selected(this.player().playbackRate() === this.rate);\n        }\n    }\n\n    /**\n     * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n     *\n     * @type {string}\n     * @private\n     */\n    PlaybackRateMenuItem.prototype.contentElType = 'button';\n    Component$1.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n    /**\n     * @file playback-rate-menu-button.js\n     */\n\n    /**\n     * The component for controlling the playback rate.\n     *\n     * @extends MenuButton\n     */\n    class PlaybackRateMenuButton extends MenuButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.menuButton_.el_.setAttribute('aria-describedby', this.labelElId_);\n            this.updateVisibility();\n            this.updateLabel();\n            this.on(player, 'loadstart', e => this.updateVisibility(e));\n            this.on(player, 'ratechange', e => this.updateLabel(e));\n            this.on(player, 'playbackrateschange', e => this.handlePlaybackRateschange(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl();\n            this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;\n            this.labelEl_ = createEl('div', {\n                className: 'vjs-playback-rate-value',\n                id: this.labelElId_,\n                textContent: '1x'\n            });\n            el.appendChild(this.labelEl_);\n            return el;\n        }\n        dispose() {\n            this.labelEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-playback-rate ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create the list of menu items. Specific to each subclass.\n         *\n         */\n        createItems() {\n            const rates = this.playbackRates();\n            const items = [];\n            for (let i = rates.length - 1; i >= 0; i--) {\n                items.push(new PlaybackRateMenuItem(this.player(), {\n                    rate: rates[i] + 'x'\n                }));\n            }\n            return items;\n        }\n\n        /**\n         * On playbackrateschange, update the menu to account for the new items.\n         *\n         * @listens Player#playbackrateschange\n         */\n        handlePlaybackRateschange(event) {\n            this.update();\n        }\n\n        /**\n         * Get possible playback rates\n         *\n         * @return {Array}\n         *         All possible playback rates\n         */\n        playbackRates() {\n            const player = this.player();\n            return player.playbackRates && player.playbackRates() || [];\n        }\n\n        /**\n         * Get whether playback rates is supported by the tech\n         * and an array of playback rates exists\n         *\n         * @return {boolean}\n         *         Whether changing playback rate is supported\n         */\n        playbackRateSupported() {\n            return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n        }\n\n        /**\n         * Hide playback rate controls when they're no playback rate options to select\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#loadstart\n         */\n        updateVisibility(event) {\n            if (this.playbackRateSupported()) {\n                this.removeClass('vjs-hidden');\n            } else {\n                this.addClass('vjs-hidden');\n            }\n        }\n\n        /**\n         * Update button label when rate changed\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#ratechange\n         */\n        updateLabel(event) {\n            if (this.playbackRateSupported()) {\n                this.labelEl_.textContent = this.player().playbackRate() + 'x';\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `PlaybackRateMenuButton`s controls.\n     *\n     * Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n    Component$1.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n    /**\n     * @file spacer.js\n     */\n\n    /**\n     * Just an empty spacer element that can be used as an append point for plugins, etc.\n     * Also can be used to create space between elements when necessary.\n     *\n     * @extends Component\n     */\n    class Spacer extends Component$1 {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-spacer ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl(tag = 'div', props = {}, attributes = {}) {\n            if (!props.className) {\n                props.className = this.buildCSSClass();\n            }\n            return super.createEl(tag, props, attributes);\n        }\n    }\n    Component$1.registerComponent('Spacer', Spacer);\n\n    /**\n     * @file custom-control-spacer.js\n     */\n\n    /**\n     * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n     *\n     * @extends Spacer\n     */\n    class CustomControlSpacer extends Spacer {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-custom-control-spacer ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildCSSClass(),\n                // No-flex/table-cell mode requires there be some content\n                // in the cell to fill the remaining space of the table.\n                textContent: '\\u00a0'\n            });\n        }\n    }\n    Component$1.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n    /**\n     * @file control-bar.js\n     */\n\n    /**\n     * Container of main controls.\n     *\n     * @extends Component\n     */\n    class ControlBar extends Component$1 {\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-control-bar',\n                dir: 'ltr'\n            });\n        }\n    }\n\n    /**\n     * Default options for `ControlBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    ControlBar.prototype.options_ = {\n        children: ['playToggle', 'skipBackward', 'skipForward', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'pictureInPictureToggle', 'fullscreenToggle']\n    };\n    Component$1.registerComponent('ControlBar', ControlBar);\n\n    /**\n     * @file error-display.js\n     */\n\n    /**\n     * A display that indicates an error has occurred. This means that the video\n     * is unplayable.\n     *\n     * @extends ModalDialog\n     */\n    class ErrorDisplay extends ModalDialog {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, 'error', e => {\n                this.close();\n                this.open(e);\n            });\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         *\n         * @deprecated Since version 5.\n         */\n        buildCSSClass() {\n            return `vjs-error-display ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Gets the localized error message based on the `Player`s error.\n         *\n         * @return {string}\n         *         The `Player`s error message localized or an empty string.\n         */\n        content() {\n            const error = this.player().error();\n            return error ? this.localize(error.message) : '';\n        }\n    }\n\n    /**\n     * The default options for an `ErrorDisplay`.\n     *\n     * @private\n     */\n    ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {\n        pauseOnOpen: false,\n        fillAlways: true,\n        temporary: false,\n        uncloseable: true\n    });\n    Component$1.registerComponent('ErrorDisplay', ErrorDisplay);\n\n    /**\n     * @file text-track-settings.js\n     */\n    const LOCAL_STORAGE_KEY$1 = 'vjs-text-track-settings';\n    const COLOR_BLACK = ['#000', 'Black'];\n    const COLOR_BLUE = ['#00F', 'Blue'];\n    const COLOR_CYAN = ['#0FF', 'Cyan'];\n    const COLOR_GREEN = ['#0F0', 'Green'];\n    const COLOR_MAGENTA = ['#F0F', 'Magenta'];\n    const COLOR_RED = ['#F00', 'Red'];\n    const COLOR_WHITE = ['#FFF', 'White'];\n    const COLOR_YELLOW = ['#FF0', 'Yellow'];\n    const OPACITY_OPAQUE = ['1', 'Opaque'];\n    const OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\n    const OPACITY_TRANS = ['0', 'Transparent'];\n\n    // Configuration for the various <select> elements in the DOM of this component.\n    //\n    // Possible keys include:\n    //\n    // `default`:\n    //   The default option index. Only needs to be provided if not zero.\n    // `parser`:\n    //   A function which is used to parse the value from the selected option in\n    //   a customized way.\n    // `selector`:\n    //   The selector used to find the associated <select> element.\n    const selectConfigs = {\n        backgroundColor: {\n            selector: '.vjs-bg-color > select',\n            id: 'captions-background-color-%s',\n            label: 'Color',\n            options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n        },\n        backgroundOpacity: {\n            selector: '.vjs-bg-opacity > select',\n            id: 'captions-background-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n        },\n        color: {\n            selector: '.vjs-text-color > select',\n            id: 'captions-foreground-color-%s',\n            label: 'Color',\n            options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n        },\n        edgeStyle: {\n            selector: '.vjs-edge-style > select',\n            id: '%s',\n            label: 'Text Edge Style',\n            options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Drop shadow']]\n        },\n        fontFamily: {\n            selector: '.vjs-font-family > select',\n            id: 'captions-font-family-%s',\n            label: 'Font Family',\n            options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n        },\n        fontPercent: {\n            selector: '.vjs-font-percent > select',\n            id: 'captions-font-size-%s',\n            label: 'Font Size',\n            options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n            default: 2,\n            parser: v => v === '1.00' ? null : Number(v)\n        },\n        textOpacity: {\n            selector: '.vjs-text-opacity > select',\n            id: 'captions-foreground-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_OPAQUE, OPACITY_SEMI]\n        },\n        // Options for this object are defined below.\n        windowColor: {\n            selector: '.vjs-window-color > select',\n            id: 'captions-window-color-%s',\n            label: 'Color'\n        },\n        // Options for this object are defined below.\n        windowOpacity: {\n            selector: '.vjs-window-opacity > select',\n            id: 'captions-window-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n        }\n    };\n    selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n    /**\n     * Get the actual value of an option.\n     *\n     * @param  {string} value\n     *         The value to get\n     *\n     * @param  {Function} [parser]\n     *         Optional function to adjust the value.\n     *\n     * @return {*}\n     *         - Will be `undefined` if no value exists\n     *         - Will be `undefined` if the given value is \"none\".\n     *         - Will be the actual value otherwise.\n     *\n     * @private\n     */\n    function parseOptionValue(value, parser) {\n        if (parser) {\n            value = parser(value);\n        }\n        if (value && value !== 'none') {\n            return value;\n        }\n    }\n\n    /**\n     * Gets the value of the selected <option> element within a <select> element.\n     *\n     * @param  {Element} el\n     *         the element to look in\n     *\n     * @param  {Function} [parser]\n     *         Optional function to adjust the value.\n     *\n     * @return {*}\n     *         - Will be `undefined` if no value exists\n     *         - Will be `undefined` if the given value is \"none\".\n     *         - Will be the actual value otherwise.\n     *\n     * @private\n     */\n    function getSelectedOptionValue(el, parser) {\n        const value = el.options[el.options.selectedIndex].value;\n        return parseOptionValue(value, parser);\n    }\n\n    /**\n     * Sets the selected <option> element within a <select> element based on a\n     * given value.\n     *\n     * @param {Element} el\n     *        The element to look in.\n     *\n     * @param {string} value\n     *        the property to look on.\n     *\n     * @param {Function} [parser]\n     *        Optional function to adjust the value before comparing.\n     *\n     * @private\n     */\n    function setSelectedOption(el, value, parser) {\n        if (!value) {\n            return;\n        }\n        for (let i = 0; i < el.options.length; i++) {\n            if (parseOptionValue(el.options[i].value, parser) === value) {\n                el.selectedIndex = i;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manipulate Text Tracks settings.\n     *\n     * @extends ModalDialog\n     */\n    class TextTrackSettings extends ModalDialog {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            options.temporary = false;\n            super(player, options);\n            this.updateDisplay = this.updateDisplay.bind(this);\n\n            // fill the modal and pretend we have opened it\n            this.fill();\n            this.hasBeenOpened_ = this.hasBeenFilled_ = true;\n            this.endDialog = createEl('p', {\n                className: 'vjs-control-text',\n                textContent: this.localize('End of dialog window.')\n            });\n            this.el().appendChild(this.endDialog);\n            this.setDefaults();\n\n            // Grab `persistTextTrackSettings` from the player options if not passed in child options\n            if (options.persistTextTrackSettings === undefined) {\n                this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;\n            }\n            this.on(this.$('.vjs-done-button'), 'click', () => {\n                this.saveSettings();\n                this.close();\n            });\n            this.on(this.$('.vjs-default-button'), 'click', () => {\n                this.setDefaults();\n                this.updateDisplay();\n            });\n            each(selectConfigs, config => {\n                this.on(this.$(config.selector), 'change', this.updateDisplay);\n            });\n            if (this.options_.persistTextTrackSettings) {\n                this.restoreSettings();\n            }\n        }\n        dispose() {\n            this.endDialog = null;\n            super.dispose();\n        }\n\n        /**\n         * Create a <select> element with configured options.\n         *\n         * @param {string} key\n         *        Configuration key to use during creation.\n         *\n         * @param {string} [legendId]\n         *        Id of associated <legend>.\n         *\n         * @param {string} [type=label]\n         *        Type of labelling element, `label` or `legend`\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElSelect_(key, legendId = '', type = 'label') {\n            const config = selectConfigs[key];\n            const id = config.id.replace('%s', this.id_);\n            const selectLabelledbyIds = [legendId, id].join(' ').trim();\n            const guid = `vjs_select_${newGUID()}`;\n            return [`<${type} id=\"${id}\"${type === 'label' ? ` for=\"${guid}\" class=\"vjs-label\"` : ''}>`, this.localize(config.label), `</${type}>`, `<select aria-labelledby=\"${selectLabelledbyIds}\" id=\"${guid}\">`].concat(config.options.map(o => {\n                const optionId = id + '-' + o[1].replace(/\\W+/g, '');\n                return [`<option id=\"${optionId}\" value=\"${o[0]}\" `, `aria-labelledby=\"${selectLabelledbyIds} ${optionId}\">`, this.localize(o[1]), '</option>'].join('');\n            })).concat('</select>').join('');\n        }\n\n        /**\n         * Create foreground color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElFgColor_() {\n            const legendId = `captions-text-legend-${this.id_}`;\n            return ['<fieldset class=\"vjs-fg vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Text'), '</legend>', '<span class=\"vjs-text-color\">', this.createElSelect_('color', legendId), '</span>', '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create background color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElBgColor_() {\n            const legendId = `captions-background-${this.id_}`;\n            return ['<fieldset class=\"vjs-bg vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Text Background'), '</legend>', '<span class=\"vjs-bg-color\">', this.createElSelect_('backgroundColor', legendId), '</span>', '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create window color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElWinColor_() {\n            const legendId = `captions-window-${this.id_}`;\n            return ['<fieldset class=\"vjs-window vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Caption Area Background'), '</legend>', '<span class=\"vjs-window-color\">', this.createElSelect_('windowColor', legendId), '</span>', '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create color elements for the component\n         *\n         * @return {Element}\n         *         The element that was created\n         *\n         * @private\n         */\n        createElColors_() {\n            return createEl('div', {\n                className: 'vjs-track-settings-colors',\n                innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n            });\n        }\n\n        /**\n         * Create font elements for the component\n         *\n         * @return {Element}\n         *         The element that was created.\n         *\n         * @private\n         */\n        createElFont_() {\n            return createEl('div', {\n                className: 'vjs-track-settings-font',\n                innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n            });\n        }\n\n        /**\n         * Create controls for the component\n         *\n         * @return {Element}\n         *         The element that was created.\n         *\n         * @private\n         */\n        createElControls_() {\n            const defaultsDescription = this.localize('restore all settings to the default values');\n            return createEl('div', {\n                className: 'vjs-track-settings-controls',\n                innerHTML: [`<button type=\"button\" class=\"vjs-default-button\" title=\"${defaultsDescription}\">`, this.localize('Reset'), `<span class=\"vjs-control-text\"> ${defaultsDescription}</span>`, '</button>', `<button type=\"button\" class=\"vjs-done-button\">${this.localize('Done')}</button>`].join('')\n            });\n        }\n        content() {\n            return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n        }\n        label() {\n            return this.localize('Caption Settings Dialog');\n        }\n        description() {\n            return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n        }\n        buildCSSClass() {\n            return super.buildCSSClass() + ' vjs-text-track-settings';\n        }\n\n        /**\n         * Gets an object of text track settings (or null).\n         *\n         * @return {Object}\n         *         An object with config values parsed from the DOM or localStorage.\n         */\n        getValues() {\n            return reduce(selectConfigs, (accum, config, key) => {\n                const value = getSelectedOptionValue(this.$(config.selector), config.parser);\n                if (value !== undefined) {\n                    accum[key] = value;\n                }\n                return accum;\n            }, {});\n        }\n\n        /**\n         * Sets text track settings from an object of values.\n         *\n         * @param {Object} values\n         *        An object with config values parsed from the DOM or localStorage.\n         */\n        setValues(values) {\n            each(selectConfigs, (config, key) => {\n                setSelectedOption(this.$(config.selector), values[key], config.parser);\n            });\n        }\n\n        /**\n         * Sets all `<select>` elements to their default values.\n         */\n        setDefaults() {\n            each(selectConfigs, config => {\n                const index = config.hasOwnProperty('default') ? config.default : 0;\n                this.$(config.selector).selectedIndex = index;\n            });\n        }\n\n        /**\n         * Restore texttrack settings from localStorage\n         */\n        restoreSettings() {\n            let values;\n            try {\n                values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));\n            } catch (err) {\n                log$1.warn(err);\n            }\n            if (values) {\n                this.setValues(values);\n            }\n        }\n\n        /**\n         * Save text track settings to localStorage\n         */\n        saveSettings() {\n            if (!this.options_.persistTextTrackSettings) {\n                return;\n            }\n            const values = this.getValues();\n            try {\n                if (Object.keys(values).length) {\n                    window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));\n                } else {\n                    window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);\n                }\n            } catch (err) {\n                log$1.warn(err);\n            }\n        }\n\n        /**\n         * Update display of text track settings\n         */\n        updateDisplay() {\n            const ttDisplay = this.player_.getChild('textTrackDisplay');\n            if (ttDisplay) {\n                ttDisplay.updateDisplay();\n            }\n        }\n\n        /**\n         * conditionally blur the element and refocus the captions button\n         *\n         * @private\n         */\n        conditionalBlur_() {\n            this.previouslyActiveEl_ = null;\n            const cb = this.player_.controlBar;\n            const subsCapsBtn = cb && cb.subsCapsButton;\n            const ccBtn = cb && cb.captionsButton;\n            if (subsCapsBtn) {\n                subsCapsBtn.focus();\n            } else if (ccBtn) {\n                ccBtn.focus();\n            }\n        }\n\n        /**\n         * Repopulate dialog with new localizations on languagechange\n         */\n        handleLanguagechange() {\n            this.fill();\n        }\n    }\n    Component$1.registerComponent('TextTrackSettings', TextTrackSettings);\n\n    /**\n     * @file resize-manager.js\n     */\n\n    /**\n     * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n     *\n     * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n     *\n     * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n     * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n     *\n     * @example <caption>How to disable the resize manager</caption>\n     * const player = videojs('#vid', {\n     *   resizeManager: false\n     * });\n     *\n     * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n     *\n     * @extends Component\n     */\n    class ResizeManager extends Component$1 {\n        /**\n         * Create the ResizeManager.\n         *\n         * @param {Object} player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of ResizeManager options.\n         *\n         * @param {Object} [options.ResizeObserver]\n         *        A polyfill for ResizeObserver can be passed in here.\n         *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n         */\n        constructor(player, options) {\n            let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;\n\n            // if `null` was passed, we want to disable the ResizeObserver\n            if (options.ResizeObserver === null) {\n                RESIZE_OBSERVER_AVAILABLE = false;\n            }\n\n            // Only create an element when ResizeObserver isn't available\n            const options_ = merge$2({\n                createEl: !RESIZE_OBSERVER_AVAILABLE,\n                reportTouchActivity: false\n            }, options);\n            super(player, options_);\n            this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;\n            this.loadListener_ = null;\n            this.resizeObserver_ = null;\n            this.debouncedHandler_ = debounce(() => {\n                this.resizeHandler();\n            }, 100, false, this);\n            if (RESIZE_OBSERVER_AVAILABLE) {\n                this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);\n                this.resizeObserver_.observe(player.el());\n            } else {\n                this.loadListener_ = () => {\n                    if (!this.el_ || !this.el_.contentWindow) {\n                        return;\n                    }\n                    const debouncedHandler_ = this.debouncedHandler_;\n                    let unloadListener_ = this.unloadListener_ = function () {\n                        off(this, 'resize', debouncedHandler_);\n                        off(this, 'unload', unloadListener_);\n                        unloadListener_ = null;\n                    };\n\n                    // safari and edge can unload the iframe before resizemanager dispose\n                    // we have to dispose of event handlers correctly before that happens\n                    on(this.el_.contentWindow, 'unload', unloadListener_);\n                    on(this.el_.contentWindow, 'resize', debouncedHandler_);\n                };\n                this.one('load', this.loadListener_);\n            }\n        }\n        createEl() {\n            return super.createEl('iframe', {\n                className: 'vjs-resize-manager',\n                tabIndex: -1,\n                title: this.localize('No content')\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n         *\n         * @fires Player#playerresize\n         */\n        resizeHandler() {\n            /**\n             * Called when the player size has changed\n             *\n             * @event Player#playerresize\n             * @type {Event}\n             */\n            // make sure player is still around to trigger\n            // prevents this from causing an error after dispose\n            if (!this.player_ || !this.player_.trigger) {\n                return;\n            }\n            this.player_.trigger('playerresize');\n        }\n        dispose() {\n            if (this.debouncedHandler_) {\n                this.debouncedHandler_.cancel();\n            }\n            if (this.resizeObserver_) {\n                if (this.player_.el()) {\n                    this.resizeObserver_.unobserve(this.player_.el());\n                }\n                this.resizeObserver_.disconnect();\n            }\n            if (this.loadListener_) {\n                this.off('load', this.loadListener_);\n            }\n            if (this.el_ && this.el_.contentWindow && this.unloadListener_) {\n                this.unloadListener_.call(this.el_.contentWindow);\n            }\n            this.ResizeObserver = null;\n            this.resizeObserver = null;\n            this.debouncedHandler_ = null;\n            this.loadListener_ = null;\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('ResizeManager', ResizeManager);\n\n    const defaults = {\n        trackingThreshold: 20,\n        liveTolerance: 15\n    };\n\n    /*\n    track when we are at the live edge, and other helpers for live playback */\n\n    /**\n     * A class for checking live current time and determining when the player\n     * is at or behind the live edge.\n     */\n    class LiveTracker extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {number} [options.trackingThreshold=20]\n         *        Number of seconds of live window (seekableEnd - seekableStart) that\n         *        media needs to have before the liveui will be shown.\n         *\n         * @param {number} [options.liveTolerance=15]\n         *        Number of seconds behind live that we have to be\n         *        before we will be considered non-live. Note that this will only\n         *        be used when playing at the live edge. This allows large seekable end\n         *        changes to not effect whether we are live or not.\n         */\n        constructor(player, options) {\n            // LiveTracker does not need an element\n            const options_ = merge$2(defaults, options, {\n                createEl: false\n            });\n            super(player, options_);\n            this.trackLiveHandler_ = () => this.trackLive_();\n            this.handlePlay_ = e => this.handlePlay(e);\n            this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);\n            this.handleSeeked_ = e => this.handleSeeked(e);\n            this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);\n            this.reset_();\n            this.on(this.player_, 'durationchange', e => this.handleDurationchange(e));\n            // we should try to toggle tracking on canplay as native playback engines, like Safari\n            // may not have the proper values for things like seekableEnd until then\n            this.on(this.player_, 'canplay', () => this.toggleTracking());\n        }\n\n        /**\n         * all the functionality for tracking when seek end changes\n         * and for tracking how far past seek end we should be\n         */\n        trackLive_() {\n            const seekable = this.player_.seekable();\n\n            // skip undefined seekable\n            if (!seekable || !seekable.length) {\n                return;\n            }\n            const newTime = Number(window.performance.now().toFixed(4));\n            const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;\n            this.lastTime_ = newTime;\n            this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;\n            const liveCurrentTime = this.liveCurrentTime();\n            const currentTime = this.player_.currentTime();\n\n            // we are behind live if any are true\n            // 1. the player is paused\n            // 2. the user seeked to a location 2 seconds away from live\n            // 3. the difference between live and current time is greater\n            //    liveTolerance which defaults to 15s\n            let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;\n\n            // we cannot be behind if\n            // 1. until we have not seen a timeupdate yet\n            // 2. liveCurrentTime is Infinity, which happens on Android and Native Safari\n            if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {\n                isBehind = false;\n            }\n            if (isBehind !== this.behindLiveEdge_) {\n                this.behindLiveEdge_ = isBehind;\n                this.trigger('liveedgechange');\n            }\n        }\n\n        /**\n         * handle a durationchange event on the player\n         * and start/stop tracking accordingly.\n         */\n        handleDurationchange() {\n            this.toggleTracking();\n        }\n\n        /**\n         * start/stop tracking\n         */\n        toggleTracking() {\n            if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {\n                if (this.player_.options_.liveui) {\n                    this.player_.addClass('vjs-liveui');\n                }\n                this.startTracking();\n            } else {\n                this.player_.removeClass('vjs-liveui');\n                this.stopTracking();\n            }\n        }\n\n        /**\n         * start tracking live playback\n         */\n        startTracking() {\n            if (this.isTracking()) {\n                return;\n            }\n\n            // If we haven't seen a timeupdate, we need to check whether playback\n            // began before this component started tracking. This can happen commonly\n            // when using autoplay.\n            if (!this.timeupdateSeen_) {\n                this.timeupdateSeen_ = this.player_.hasStarted();\n            }\n            this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);\n            this.trackLive_();\n            this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n            if (!this.timeupdateSeen_) {\n                this.one(this.player_, 'play', this.handlePlay_);\n                this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n            } else {\n                this.on(this.player_, 'seeked', this.handleSeeked_);\n            }\n        }\n\n        /**\n         * handle the first timeupdate on the player if it wasn't already playing\n         * when live tracker started tracking.\n         */\n        handleFirstTimeupdate() {\n            this.timeupdateSeen_ = true;\n            this.on(this.player_, 'seeked', this.handleSeeked_);\n        }\n\n        /**\n         * Keep track of what time a seek starts, and listen for seeked\n         * to find where a seek ends.\n         */\n        handleSeeked() {\n            const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());\n            this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;\n            this.nextSeekedFromUser_ = false;\n            this.trackLive_();\n        }\n\n        /**\n         * handle the first play on the player, and make sure that we seek\n         * right to the live edge.\n         */\n        handlePlay() {\n            this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);\n        }\n\n        /**\n         * Stop tracking, and set all internal variables to\n         * their initial value.\n         */\n        reset_() {\n            this.lastTime_ = -1;\n            this.pastSeekEnd_ = 0;\n            this.lastSeekEnd_ = -1;\n            this.behindLiveEdge_ = true;\n            this.timeupdateSeen_ = false;\n            this.seekedBehindLive_ = false;\n            this.nextSeekedFromUser_ = false;\n            this.clearInterval(this.trackingInterval_);\n            this.trackingInterval_ = null;\n            this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n            this.off(this.player_, 'seeked', this.handleSeeked_);\n            this.off(this.player_, 'play', this.handlePlay_);\n            this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n            this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);\n        }\n\n        /**\n         * The next seeked event is from the user. Meaning that any seek\n         * > 2s behind live will be considered behind live for real and\n         * liveTolerance will be ignored.\n         */\n        nextSeekedFromUser() {\n            this.nextSeekedFromUser_ = true;\n        }\n\n        /**\n         * stop tracking live playback\n         */\n        stopTracking() {\n            if (!this.isTracking()) {\n                return;\n            }\n            this.reset_();\n            this.trigger('liveedgechange');\n        }\n\n        /**\n         * A helper to get the player seekable end\n         * so that we don't have to null check everywhere\n         *\n         * @return {number}\n         *         The furthest seekable end or Infinity.\n         */\n        seekableEnd() {\n            const seekable = this.player_.seekable();\n            const seekableEnds = [];\n            let i = seekable ? seekable.length : 0;\n            while (i--) {\n                seekableEnds.push(seekable.end(i));\n            }\n\n            // grab the furthest seekable end after sorting, or if there are none\n            // default to Infinity\n            return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;\n        }\n\n        /**\n         * A helper to get the player seekable start\n         * so that we don't have to null check everywhere\n         *\n         * @return {number}\n         *         The earliest seekable start or 0.\n         */\n        seekableStart() {\n            const seekable = this.player_.seekable();\n            const seekableStarts = [];\n            let i = seekable ? seekable.length : 0;\n            while (i--) {\n                seekableStarts.push(seekable.start(i));\n            }\n\n            // grab the first seekable start after sorting, or if there are none\n            // default to 0\n            return seekableStarts.length ? seekableStarts.sort()[0] : 0;\n        }\n\n        /**\n         * Get the live time window aka\n         * the amount of time between seekable start and\n         * live current time.\n         *\n         * @return {number}\n         *         The amount of seconds that are seekable in\n         *         the live video.\n         */\n        liveWindow() {\n            const liveCurrentTime = this.liveCurrentTime();\n\n            // if liveCurrenTime is Infinity then we don't have a liveWindow at all\n            if (liveCurrentTime === Infinity) {\n                return 0;\n            }\n            return liveCurrentTime - this.seekableStart();\n        }\n\n        /**\n         * Determines if the player is live, only checks if this component\n         * is tracking live playback or not\n         *\n         * @return {boolean}\n         *         Whether liveTracker is tracking\n         */\n        isLive() {\n            return this.isTracking();\n        }\n\n        /**\n         * Determines if currentTime is at the live edge and won't fall behind\n         * on each seekableendchange\n         *\n         * @return {boolean}\n         *         Whether playback is at the live edge\n         */\n        atLiveEdge() {\n            return !this.behindLiveEdge();\n        }\n\n        /**\n         * get what we expect the live current time to be\n         *\n         * @return {number}\n         *         The expected live current time\n         */\n        liveCurrentTime() {\n            return this.pastSeekEnd() + this.seekableEnd();\n        }\n\n        /**\n         * The number of seconds that have occurred after seekable end\n         * changed. This will be reset to 0 once seekable end changes.\n         *\n         * @return {number}\n         *         Seconds past the current seekable end\n         */\n        pastSeekEnd() {\n            const seekableEnd = this.seekableEnd();\n            if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {\n                this.pastSeekEnd_ = 0;\n            }\n            this.lastSeekEnd_ = seekableEnd;\n            return this.pastSeekEnd_;\n        }\n\n        /**\n         * If we are currently behind the live edge, aka currentTime will be\n         * behind on a seekableendchange\n         *\n         * @return {boolean}\n         *         If we are behind the live edge\n         */\n        behindLiveEdge() {\n            return this.behindLiveEdge_;\n        }\n\n        /**\n         * Whether live tracker is currently tracking or not.\n         */\n        isTracking() {\n            return typeof this.trackingInterval_ === 'number';\n        }\n\n        /**\n         * Seek to the live edge if we are behind the live edge\n         */\n        seekToLiveEdge() {\n            this.seekedBehindLive_ = false;\n            if (this.atLiveEdge()) {\n                return;\n            }\n            this.nextSeekedFromUser_ = false;\n            this.player_.currentTime(this.liveCurrentTime());\n        }\n\n        /**\n         * Dispose of liveTracker\n         */\n        dispose() {\n            this.stopTracking();\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('LiveTracker', LiveTracker);\n\n    /**\n     * Displays an element over the player which contains an optional title and\n     * description for the current content.\n     *\n     * Much of the code for this component originated in the now obsolete\n     * videojs-dock plugin: https://github.com/brightcove/videojs-dock/\n     *\n     * @extends Component\n     */\n    class TitleBar extends Component$1 {\n        constructor(player, options) {\n            super(player, options);\n            this.on('statechanged', e => this.updateDom_());\n            this.updateDom_();\n        }\n\n        /**\n         * Create the `TitleBar`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            this.els = {\n                title: createEl('div', {\n                    className: 'vjs-title-bar-title',\n                    id: `vjs-title-bar-title-${newGUID()}`\n                }),\n                description: createEl('div', {\n                    className: 'vjs-title-bar-description',\n                    id: `vjs-title-bar-description-${newGUID()}`\n                })\n            };\n            return createEl('div', {\n                className: 'vjs-title-bar'\n            }, {}, values$1(this.els));\n        }\n\n        /**\n         * Updates the DOM based on the component's state object.\n         */\n        updateDom_() {\n            const tech = this.player_.tech_;\n            const techEl = tech && tech.el_;\n            const techAriaAttrs = {\n                title: 'aria-labelledby',\n                description: 'aria-describedby'\n            };\n            ['title', 'description'].forEach(k => {\n                const value = this.state[k];\n                const el = this.els[k];\n                const techAriaAttr = techAriaAttrs[k];\n                emptyEl(el);\n                if (value) {\n                    textContent(el, value);\n                }\n\n                // If there is a tech element available, update its ARIA attributes\n                // according to whether a title and/or description have been provided.\n                if (techEl) {\n                    techEl.removeAttribute(techAriaAttr);\n                    if (value) {\n                        techEl.setAttribute(techAriaAttr, el.id);\n                    }\n                }\n            });\n            if (this.state.title || this.state.description) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n\n        /**\n         * Update the contents of the title bar component with new title and\n         * description text.\n         *\n         * If both title and description are missing, the title bar will be hidden.\n         *\n         * If either title or description are present, the title bar will be visible.\n         *\n         * NOTE: Any previously set value will be preserved. To unset a previously\n         * set value, you must pass an empty string or null.\n         *\n         * For example:\n         *\n         * ```\n         * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'\n         * update({description: 'bar2'}) // title: 'foo', description: 'bar2'\n         * update({title: ''}) // title: '', description: 'bar2'\n         * update({title: 'foo', description: null}) // title: 'foo', description: null\n         * ```\n         *\n         * @param  {Object} [options={}]\n         *         An options object. When empty, the title bar will be hidden.\n         *\n         * @param  {string} [options.title]\n         *         A title to display in the title bar.\n         *\n         * @param  {string} [options.description]\n         *         A description to display in the title bar.\n         */\n        update(options) {\n            this.setState(options);\n        }\n\n        /**\n         * Dispose the component.\n         */\n        dispose() {\n            const tech = this.player_.tech_;\n            const techEl = tech && tech.el_;\n            if (techEl) {\n                techEl.removeAttribute('aria-labelledby');\n                techEl.removeAttribute('aria-describedby');\n            }\n            super.dispose();\n            this.els = null;\n        }\n    }\n    Component$1.registerComponent('TitleBar', TitleBar);\n\n    /**\n     * This function is used to fire a sourceset when there is something\n     * similar to `mediaEl.load()` being called. It will try to find the source via\n     * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n     * with the source that was found or empty string if we cannot know. If it cannot\n     * find a source then `sourceset` will not be fired.\n     *\n     * @param { import('./html5').default } tech\n     *        The tech object that sourceset was setup on\n     *\n     * @return {boolean}\n     *         returns false if the sourceset was not fired and true otherwise.\n     */\n    const sourcesetLoad = tech => {\n        const el = tech.el();\n\n        // if `el.src` is set, that source will be loaded.\n        if (el.hasAttribute('src')) {\n            tech.triggerSourceset(el.src);\n            return true;\n        }\n\n        /**\n         * Since there isn't a src property on the media element, source elements will be used for\n         * implementing the source selection algorithm. This happens asynchronously and\n         * for most cases were there is more than one source we cannot tell what source will\n         * be loaded, without re-implementing the source selection algorithm. At this time we are not\n         * going to do that. There are three special cases that we do handle here though:\n         *\n         * 1. If there are no sources, do not fire `sourceset`.\n         * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n         * 3. If there is more than one `<source>` but all of them have the same `src` url.\n         *    That will be our src.\n         */\n        const sources = tech.$$('source');\n        const srcUrls = [];\n        let src = '';\n\n        // if there are no sources, do not fire sourceset\n        if (!sources.length) {\n            return false;\n        }\n\n        // only count valid/non-duplicate source elements\n        for (let i = 0; i < sources.length; i++) {\n            const url = sources[i].src;\n            if (url && srcUrls.indexOf(url) === -1) {\n                srcUrls.push(url);\n            }\n        }\n\n        // there were no valid sources\n        if (!srcUrls.length) {\n            return false;\n        }\n\n        // there is only one valid source element url\n        // use that\n        if (srcUrls.length === 1) {\n            src = srcUrls[0];\n        }\n        tech.triggerSourceset(src);\n        return true;\n    };\n\n    /**\n     * our implementation of an `innerHTML` descriptor for browsers\n     * that do not have one.\n     */\n    const innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n        get() {\n            return this.cloneNode(true).innerHTML;\n        },\n        set(v) {\n            // make a dummy node to use innerHTML on\n            const dummy = document.createElement(this.nodeName.toLowerCase());\n\n            // set innerHTML to the value provided\n            dummy.innerHTML = v;\n\n            // make a document fragment to hold the nodes from dummy\n            const docFrag = document.createDocumentFragment();\n\n            // copy all of the nodes created by the innerHTML on dummy\n            // to the document fragment\n            while (dummy.childNodes.length) {\n                docFrag.appendChild(dummy.childNodes[0]);\n            }\n\n            // remove content\n            this.innerText = '';\n\n            // now we add all of that html in one by appending the\n            // document fragment. This is how innerHTML does it.\n            window.Element.prototype.appendChild.call(this, docFrag);\n\n            // then return the result that innerHTML's setter would\n            return this.innerHTML;\n        }\n    });\n\n    /**\n     * Get a property descriptor given a list of priorities and the\n     * property to get.\n     */\n    const getDescriptor = (priority, prop) => {\n        let descriptor = {};\n        for (let i = 0; i < priority.length; i++) {\n            descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n            if (descriptor && descriptor.set && descriptor.get) {\n                break;\n            }\n        }\n        descriptor.enumerable = true;\n        descriptor.configurable = true;\n        return descriptor;\n    };\n    const getInnerHTMLDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n\n    /**\n     * Patches browser internal functions so that we can tell synchronously\n     * if a `<source>` was appended to the media element. For some reason this\n     * causes a `sourceset` if the the media element is ready and has no source.\n     * This happens when:\n     * - The page has just loaded and the media element does not have a source.\n     * - The media element was emptied of all sources, then `load()` was called.\n     *\n     * It does this by patching the following functions/properties when they are supported:\n     *\n     * - `append()` - can be used to add a `<source>` element to the media element\n     * - `appendChild()` - can be used to add a `<source>` element to the media element\n     * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n     * - `innerHTML` -  can be used to add a `<source>` element to the media element\n     *\n     * @param {Html5} tech\n     *        The tech object that sourceset is being setup on.\n     */\n    const firstSourceWatch = function (tech) {\n        const el = tech.el();\n\n        // make sure firstSourceWatch isn't setup twice.\n        if (el.resetSourceWatch_) {\n            return;\n        }\n        const old = {};\n        const innerDescriptor = getInnerHTMLDescriptor(tech);\n        const appendWrapper = appendFn => (...args) => {\n            const retval = appendFn.apply(el, args);\n            sourcesetLoad(tech);\n            return retval;\n        };\n        ['append', 'appendChild', 'insertAdjacentHTML'].forEach(k => {\n            if (!el[k]) {\n                return;\n            }\n\n            // store the old function\n            old[k] = el[k];\n\n            // call the old function with a sourceset if a source\n            // was loaded\n            el[k] = appendWrapper(old[k]);\n        });\n        Object.defineProperty(el, 'innerHTML', merge$2(innerDescriptor, {\n            set: appendWrapper(innerDescriptor.set)\n        }));\n        el.resetSourceWatch_ = () => {\n            el.resetSourceWatch_ = null;\n            Object.keys(old).forEach(k => {\n                el[k] = old[k];\n            });\n            Object.defineProperty(el, 'innerHTML', innerDescriptor);\n        };\n\n        // on the first sourceset, we need to revert our changes\n        tech.one('sourceset', el.resetSourceWatch_);\n    };\n\n    /**\n     * our implementation of a `src` descriptor for browsers\n     * that do not have one\n     */\n    const srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n        get() {\n            if (this.hasAttribute('src')) {\n                return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));\n            }\n            return '';\n        },\n        set(v) {\n            window.Element.prototype.setAttribute.call(this, 'src', v);\n            return v;\n        }\n    });\n    const getSrcDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n\n    /**\n     * setup `sourceset` handling on the `Html5` tech. This function\n     * patches the following element properties/functions:\n     *\n     * - `src` - to determine when `src` is set\n     * - `setAttribute()` - to determine when `src` is set\n     * - `load()` - this re-triggers the source selection algorithm, and can\n     *              cause a sourceset.\n     *\n     * If there is no source when we are adding `sourceset` support or during a `load()`\n     * we also patch the functions listed in `firstSourceWatch`.\n     *\n     * @param {Html5} tech\n     *        The tech to patch\n     */\n    const setupSourceset = function (tech) {\n        if (!tech.featuresSourceset) {\n            return;\n        }\n        const el = tech.el();\n\n        // make sure sourceset isn't setup twice.\n        if (el.resetSourceset_) {\n            return;\n        }\n        const srcDescriptor = getSrcDescriptor(tech);\n        const oldSetAttribute = el.setAttribute;\n        const oldLoad = el.load;\n        Object.defineProperty(el, 'src', merge$2(srcDescriptor, {\n            set: v => {\n                const retval = srcDescriptor.set.call(el, v);\n\n                // we use the getter here to get the actual value set on src\n                tech.triggerSourceset(el.src);\n                return retval;\n            }\n        }));\n        el.setAttribute = (n, v) => {\n            const retval = oldSetAttribute.call(el, n, v);\n            if (/src/i.test(n)) {\n                tech.triggerSourceset(el.src);\n            }\n            return retval;\n        };\n        el.load = () => {\n            const retval = oldLoad.call(el);\n\n            // if load was called, but there was no source to fire\n            // sourceset on. We have to watch for a source append\n            // as that can trigger a `sourceset` when the media element\n            // has no source\n            if (!sourcesetLoad(tech)) {\n                tech.triggerSourceset('');\n                firstSourceWatch(tech);\n            }\n            return retval;\n        };\n        if (el.currentSrc) {\n            tech.triggerSourceset(el.currentSrc);\n        } else if (!sourcesetLoad(tech)) {\n            firstSourceWatch(tech);\n        }\n        el.resetSourceset_ = () => {\n            el.resetSourceset_ = null;\n            el.load = oldLoad;\n            el.setAttribute = oldSetAttribute;\n            Object.defineProperty(el, 'src', srcDescriptor);\n            if (el.resetSourceWatch_) {\n                el.resetSourceWatch_();\n            }\n        };\n    };\n\n    /**\n     * @file html5.js\n     */\n\n    /**\n     * HTML5 Media Controller - Wrapper for HTML5 Media API\n     *\n     * @mixes Tech~SourceHandlerAdditions\n     * @extends Tech\n     */\n    class Html5 extends Tech {\n        /**\n         * Create an instance of this Tech.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        Callback function to call when the `HTML5` Tech is ready.\n         */\n        constructor(options, ready) {\n            super(options, ready);\n            const source = options.source;\n            let crossoriginTracks = false;\n            this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === 'VIDEO';\n\n            // Set the source if one is provided\n            // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n            // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n            // anyway so the error gets fired.\n            if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n                this.setSource(source);\n            } else {\n                this.handleLateInit_(this.el_);\n            }\n\n            // setup sourceset after late sourceset/init\n            if (options.enableSourceset) {\n                this.setupSourcesetHandling_();\n            }\n            this.isScrubbing_ = false;\n            if (this.el_.hasChildNodes()) {\n                const nodes = this.el_.childNodes;\n                let nodesLength = nodes.length;\n                const removeNodes = [];\n                while (nodesLength--) {\n                    const node = nodes[nodesLength];\n                    const nodeName = node.nodeName.toLowerCase();\n                    if (nodeName === 'track') {\n                        if (!this.featuresNativeTextTracks) {\n                            // Empty video tag tracks so the built-in player doesn't use them also.\n                            // This may not be fast enough to stop HTML5 browsers from reading the tags\n                            // so we'll need to turn off any default tracks if we're manually doing\n                            // captions and subtitles. videoElement.textTracks\n                            removeNodes.push(node);\n                        } else {\n                            // store HTMLTrackElement and TextTrack to remote list\n                            this.remoteTextTrackEls().addTrackElement_(node);\n                            this.remoteTextTracks().addTrack(node.track);\n                            this.textTracks().addTrack(node.track);\n                            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n                                crossoriginTracks = true;\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < removeNodes.length; i++) {\n                    this.el_.removeChild(removeNodes[i]);\n                }\n            }\n            this.proxyNativeTracks_();\n            if (this.featuresNativeTextTracks && crossoriginTracks) {\n                log$1.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n' + 'This may prevent text tracks from loading.');\n            }\n\n            // prevent iOS Safari from disabling metadata text tracks during native playback\n            this.restoreMetadataTracksInIOSNativePlayer_();\n\n            // Determine if native controls should be used\n            // Our goal should be to get the custom controls on mobile solid everywhere\n            // so we can remove this all together. Right now this will block custom\n            // controls on touch enabled laptops like the Chrome Pixel\n            if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {\n                this.setControls(true);\n            }\n\n            // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n            // into a `fullscreenchange` event\n            this.proxyWebkitFullscreen_();\n            this.triggerReady();\n        }\n\n        /**\n         * Dispose of `HTML5` media element and remove all tracks.\n         */\n        dispose() {\n            if (this.el_ && this.el_.resetSourceset_) {\n                this.el_.resetSourceset_();\n            }\n            Html5.disposeMediaElement(this.el_);\n            this.options_ = null;\n\n            // tech will handle clearing of the emulated track list\n            super.dispose();\n        }\n\n        /**\n         * Modify the media element so that we can detect when\n         * the source is changed. Fires `sourceset` just after the source has changed\n         */\n        setupSourcesetHandling_() {\n            setupSourceset(this);\n        }\n\n        /**\n         * When a captions track is enabled in the iOS Safari native player, all other\n         * tracks are disabled (including metadata tracks), which nulls all of their\n         * associated cue points. This will restore metadata tracks to their pre-fullscreen\n         * state in those cases so that cue points are not needlessly lost.\n         *\n         * @private\n         */\n        restoreMetadataTracksInIOSNativePlayer_() {\n            const textTracks = this.textTracks();\n            let metadataTracksPreFullscreenState;\n\n            // captures a snapshot of every metadata track's current state\n            const takeMetadataTrackSnapshot = () => {\n                metadataTracksPreFullscreenState = [];\n                for (let i = 0; i < textTracks.length; i++) {\n                    const track = textTracks[i];\n                    if (track.kind === 'metadata') {\n                        metadataTracksPreFullscreenState.push({\n                            track,\n                            storedMode: track.mode\n                        });\n                    }\n                }\n            };\n\n            // snapshot each metadata track's initial state, and update the snapshot\n            // each time there is a track 'change' event\n            takeMetadataTrackSnapshot();\n            textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n            this.on('dispose', () => textTracks.removeEventListener('change', takeMetadataTrackSnapshot));\n            const restoreTrackMode = () => {\n                for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n                    const storedTrack = metadataTracksPreFullscreenState[i];\n                    if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n                        storedTrack.track.mode = storedTrack.storedMode;\n                    }\n                }\n                // we only want this handler to be executed on the first 'change' event\n                textTracks.removeEventListener('change', restoreTrackMode);\n            };\n\n            // when we enter fullscreen playback, stop updating the snapshot and\n            // restore all track modes to their pre-fullscreen state\n            this.on('webkitbeginfullscreen', () => {\n                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n                // remove the listener before adding it just in case it wasn't previously removed\n                textTracks.removeEventListener('change', restoreTrackMode);\n                textTracks.addEventListener('change', restoreTrackMode);\n            });\n\n            // start updating the snapshot again after leaving fullscreen\n            this.on('webkitendfullscreen', () => {\n                // remove the listener before adding it just in case it wasn't previously removed\n                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n                textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n                // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n                textTracks.removeEventListener('change', restoreTrackMode);\n            });\n        }\n\n        /**\n         * Attempt to force override of tracks for the given type\n         *\n         * @param {string} type - Track type to override, possible values include 'Audio',\n         * 'Video', and 'Text'.\n         * @param {boolean} override - If set to true native audio/video will be overridden,\n         * otherwise native audio/video will potentially be used.\n         * @private\n         */\n        overrideNative_(type, override) {\n            // If there is no behavioral change don't add/remove listeners\n            if (override !== this[`featuresNative${type}Tracks`]) {\n                return;\n            }\n            const lowerCaseType = type.toLowerCase();\n            if (this[`${lowerCaseType}TracksListeners_`]) {\n                Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach(eventName => {\n                    const elTracks = this.el()[`${lowerCaseType}Tracks`];\n                    elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);\n                });\n            }\n            this[`featuresNative${type}Tracks`] = !override;\n            this[`${lowerCaseType}TracksListeners_`] = null;\n            this.proxyNativeTracksForType_(lowerCaseType);\n        }\n\n        /**\n         * Attempt to force override of native audio tracks.\n         *\n         * @param {boolean} override - If set to true native audio will be overridden,\n         * otherwise native audio will potentially be used.\n         */\n        overrideNativeAudioTracks(override) {\n            this.overrideNative_('Audio', override);\n        }\n\n        /**\n         * Attempt to force override of native video tracks.\n         *\n         * @param {boolean} override - If set to true native video will be overridden,\n         * otherwise native video will potentially be used.\n         */\n        overrideNativeVideoTracks(override) {\n            this.overrideNative_('Video', override);\n        }\n\n        /**\n         * Proxy native track list events for the given type to our track\n         * lists if the browser we are playing in supports that type of track list.\n         *\n         * @param {string} name - Track type; values include 'audio', 'video', and 'text'\n         * @private\n         */\n        proxyNativeTracksForType_(name) {\n            const props = NORMAL[name];\n            const elTracks = this.el()[props.getterName];\n            const techTracks = this[props.getterName]();\n            if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {\n                return;\n            }\n            const listeners = {\n                change: e => {\n                    const event = {\n                        type: 'change',\n                        target: techTracks,\n                        currentTarget: techTracks,\n                        srcElement: techTracks\n                    };\n                    techTracks.trigger(event);\n\n                    // if we are a text track change event, we should also notify the\n                    // remote text track list. This can potentially cause a false positive\n                    // if we were to get a change event on a non-remote track and\n                    // we triggered the event on the remote text track list which doesn't\n                    // contain that track. However, best practices mean looping through the\n                    // list of tracks and searching for the appropriate mode value, so,\n                    // this shouldn't pose an issue\n                    if (name === 'text') {\n                        this[REMOTE.remoteText.getterName]().trigger(event);\n                    }\n                },\n                addtrack(e) {\n                    techTracks.addTrack(e.track);\n                },\n                removetrack(e) {\n                    techTracks.removeTrack(e.track);\n                }\n            };\n            const removeOldTracks = function () {\n                const removeTracks = [];\n                for (let i = 0; i < techTracks.length; i++) {\n                    let found = false;\n                    for (let j = 0; j < elTracks.length; j++) {\n                        if (elTracks[j] === techTracks[i]) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        removeTracks.push(techTracks[i]);\n                    }\n                }\n                while (removeTracks.length) {\n                    techTracks.removeTrack(removeTracks.shift());\n                }\n            };\n            this[props.getterName + 'Listeners_'] = listeners;\n            Object.keys(listeners).forEach(eventName => {\n                const listener = listeners[eventName];\n                elTracks.addEventListener(eventName, listener);\n                this.on('dispose', e => elTracks.removeEventListener(eventName, listener));\n            });\n\n            // Remove (native) tracks that are not used anymore\n            this.on('loadstart', removeOldTracks);\n            this.on('dispose', e => this.off('loadstart', removeOldTracks));\n        }\n\n        /**\n         * Proxy all native track list events to our track lists if the browser we are playing\n         * in supports that type of track list.\n         *\n         * @private\n         */\n        proxyNativeTracks_() {\n            NORMAL.names.forEach(name => {\n                this.proxyNativeTracksForType_(name);\n            });\n        }\n\n        /**\n         * Create the `Html5` Tech's DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            let el = this.options_.tag;\n\n            // Check if this browser supports moving the element into the box.\n            // On the iPhone video will break if you move the element,\n            // So we have to create a brand new element.\n            // If we ingested the player div, we do not need to move the media element.\n            if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n                // If the original tag is still there, clone and remove it.\n                if (el) {\n                    const clone = el.cloneNode(true);\n                    if (el.parentNode) {\n                        el.parentNode.insertBefore(clone, el);\n                    }\n                    Html5.disposeMediaElement(el);\n                    el = clone;\n                } else {\n                    el = document.createElement('video');\n\n                    // determine if native controls should be used\n                    const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n                    const attributes = merge$2({}, tagAttributes);\n                    if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n                        delete attributes.controls;\n                    }\n                    setAttributes(el, Object.assign(attributes, {\n                        id: this.options_.techId,\n                        class: 'vjs-tech'\n                    }));\n                }\n                el.playerId = this.options_.playerId;\n            }\n            if (typeof this.options_.preload !== 'undefined') {\n                setAttribute(el, 'preload', this.options_.preload);\n            }\n            if (this.options_.disablePictureInPicture !== undefined) {\n                el.disablePictureInPicture = this.options_.disablePictureInPicture;\n            }\n\n            // Update specific tag settings, in case they were overridden\n            // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n            // when iOS/Safari or other browsers attempt to autoplay.\n            const settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n            for (let i = 0; i < settingsAttrs.length; i++) {\n                const attr = settingsAttrs[i];\n                const value = this.options_[attr];\n                if (typeof value !== 'undefined') {\n                    if (value) {\n                        setAttribute(el, attr, attr);\n                    } else {\n                        removeAttribute(el, attr);\n                    }\n                    el[attr] = value;\n                }\n            }\n            return el;\n        }\n\n        /**\n         * This will be triggered if the loadstart event has already fired, before videojs was\n         * ready. Two known examples of when this can happen are:\n         * 1. If we're loading the playback object after it has started loading\n         * 2. The media is already playing the (often with autoplay on) then\n         *\n         * This function will fire another loadstart so that videojs can catchup.\n         *\n         * @fires Tech#loadstart\n         *\n         * @return {undefined}\n         *         returns nothing.\n         */\n        handleLateInit_(el) {\n            if (el.networkState === 0 || el.networkState === 3) {\n                // The video element hasn't started loading the source yet\n                // or didn't find a source\n                return;\n            }\n            if (el.readyState === 0) {\n                // NetworkState is set synchronously BUT loadstart is fired at the\n                // end of the current stack, usually before setInterval(fn, 0).\n                // So at this point we know loadstart may have already fired or is\n                // about to fire, and either way the player hasn't seen it yet.\n                // We don't want to fire loadstart prematurely here and cause a\n                // double loadstart so we'll wait and see if it happens between now\n                // and the next loop, and fire it if not.\n                // HOWEVER, we also want to make sure it fires before loadedmetadata\n                // which could also happen between now and the next loop, so we'll\n                // watch for that also.\n                let loadstartFired = false;\n                const setLoadstartFired = function () {\n                    loadstartFired = true;\n                };\n                this.on('loadstart', setLoadstartFired);\n                const triggerLoadstart = function () {\n                    // We did miss the original loadstart. Make sure the player\n                    // sees loadstart before loadedmetadata\n                    if (!loadstartFired) {\n                        this.trigger('loadstart');\n                    }\n                };\n                this.on('loadedmetadata', triggerLoadstart);\n                this.ready(function () {\n                    this.off('loadstart', setLoadstartFired);\n                    this.off('loadedmetadata', triggerLoadstart);\n                    if (!loadstartFired) {\n                        // We did miss the original native loadstart. Fire it now.\n                        this.trigger('loadstart');\n                    }\n                });\n                return;\n            }\n\n            // From here on we know that loadstart already fired and we missed it.\n            // The other readyState events aren't as much of a problem if we double\n            // them, so not going to go to as much trouble as loadstart to prevent\n            // that unless we find reason to.\n            const eventsToTrigger = ['loadstart'];\n\n            // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n            eventsToTrigger.push('loadedmetadata');\n\n            // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n            if (el.readyState >= 2) {\n                eventsToTrigger.push('loadeddata');\n            }\n\n            // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n            if (el.readyState >= 3) {\n                eventsToTrigger.push('canplay');\n            }\n\n            // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n            if (el.readyState >= 4) {\n                eventsToTrigger.push('canplaythrough');\n            }\n\n            // We still need to give the player time to add event listeners\n            this.ready(function () {\n                eventsToTrigger.forEach(function (type) {\n                    this.trigger(type);\n                }, this);\n            });\n        }\n\n        /**\n         * Set whether we are scrubbing or not.\n         * This is used to decide whether we should use `fastSeek` or not.\n         * `fastSeek` is used to provide trick play on Safari browsers.\n         *\n         * @param {boolean} isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         */\n        setScrubbing(isScrubbing) {\n            this.isScrubbing_ = isScrubbing;\n        }\n\n        /**\n         * Get whether we are scrubbing or not.\n         *\n         * @return {boolean} isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         */\n        scrubbing() {\n            return this.isScrubbing_;\n        }\n\n        /**\n         * Set current time for the `HTML5` tech.\n         *\n         * @param {number} seconds\n         *        Set the current time of the media to this.\n         */\n        setCurrentTime(seconds) {\n            try {\n                if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {\n                    this.el_.fastSeek(seconds);\n                } else {\n                    this.el_.currentTime = seconds;\n                }\n            } catch (e) {\n                log$1(e, 'Video is not ready. (Video.js)');\n                // this.warning(VideoJS.warnings.videoNotReady);\n            }\n        }\n\n        /**\n         * Get the current duration of the HTML5 media element.\n         *\n         * @return {number}\n         *         The duration of the media or 0 if there is no duration.\n         */\n        duration() {\n            // Android Chrome will report duration as Infinity for VOD HLS until after\n            // playback has started, which triggers the live display erroneously.\n            // Return NaN if playback has not started and trigger a durationupdate once\n            // the duration can be reliably known.\n            if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n                // Wait for the first `timeupdate` with currentTime > 0 - there may be\n                // several with 0\n                const checkProgress = () => {\n                    if (this.el_.currentTime > 0) {\n                        // Trigger durationchange for genuinely live video\n                        if (this.el_.duration === Infinity) {\n                            this.trigger('durationchange');\n                        }\n                        this.off('timeupdate', checkProgress);\n                    }\n                };\n                this.on('timeupdate', checkProgress);\n                return NaN;\n            }\n            return this.el_.duration || NaN;\n        }\n\n        /**\n         * Get the current width of the HTML5 media element.\n         *\n         * @return {number}\n         *         The width of the HTML5 media element.\n         */\n        width() {\n            return this.el_.offsetWidth;\n        }\n\n        /**\n         * Get the current height of the HTML5 media element.\n         *\n         * @return {number}\n         *         The height of the HTML5 media element.\n         */\n        height() {\n            return this.el_.offsetHeight;\n        }\n\n        /**\n         * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n         * `fullscreenchange` event.\n         *\n         * @private\n         * @fires fullscreenchange\n         * @listens webkitendfullscreen\n         * @listens webkitbeginfullscreen\n         * @listens webkitbeginfullscreen\n         */\n        proxyWebkitFullscreen_() {\n            if (!('webkitDisplayingFullscreen' in this.el_)) {\n                return;\n            }\n            const endFn = function () {\n                this.trigger('fullscreenchange', {\n                    isFullscreen: false\n                });\n                // Safari will sometimes set controls on the videoelement when existing fullscreen.\n                if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {\n                    this.el_.controls = false;\n                }\n            };\n            const beginFn = function () {\n                if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n                    this.one('webkitendfullscreen', endFn);\n                    this.trigger('fullscreenchange', {\n                        isFullscreen: true,\n                        // set a flag in case another tech triggers fullscreenchange\n                        nativeIOSFullscreen: true\n                    });\n                }\n            };\n            this.on('webkitbeginfullscreen', beginFn);\n            this.on('dispose', () => {\n                this.off('webkitbeginfullscreen', beginFn);\n                this.off('webkitendfullscreen', endFn);\n            });\n        }\n\n        /**\n         * Check if fullscreen is supported on the video el.\n         *\n         * @return {boolean}\n         *         - True if fullscreen is supported.\n         *         - False if fullscreen is not supported.\n         */\n        supportsFullScreen() {\n            return typeof this.el_.webkitEnterFullScreen === 'function';\n        }\n\n        /**\n         * Request that the `HTML5` Tech enter fullscreen.\n         */\n        enterFullScreen() {\n            const video = this.el_;\n            if (video.paused && video.networkState <= video.HAVE_METADATA) {\n                // attempt to prime the video element for programmatic access\n                // this isn't necessary on the desktop but shouldn't hurt\n                silencePromise(this.el_.play());\n\n                // playing and pausing synchronously during the transition to fullscreen\n                // can get iOS ~6.1 devices into a play/pause loop\n                this.setTimeout(function () {\n                    video.pause();\n                    try {\n                        video.webkitEnterFullScreen();\n                    } catch (e) {\n                        this.trigger('fullscreenerror', e);\n                    }\n                }, 0);\n            } else {\n                try {\n                    video.webkitEnterFullScreen();\n                } catch (e) {\n                    this.trigger('fullscreenerror', e);\n                }\n            }\n        }\n\n        /**\n         * Request that the `HTML5` Tech exit fullscreen.\n         */\n        exitFullScreen() {\n            if (!this.el_.webkitDisplayingFullscreen) {\n                this.trigger('fullscreenerror', new Error('The video is not fullscreen'));\n                return;\n            }\n            this.el_.webkitExitFullScreen();\n        }\n\n        /**\n         * Create a floating video window always on top of other windows so that users may\n         * continue consuming media while they interact with other content sites, or\n         * applications on their device.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @return {Promise}\n         *         A promise with a Picture-in-Picture window.\n         */\n        requestPictureInPicture() {\n            return this.el_.requestPictureInPicture();\n        }\n\n        /**\n         * Native requestVideoFrameCallback if supported by browser/tech, or fallback\n         * Don't use rVCF on Safari when DRM is playing, as it doesn't fire\n         * Needs to be checked later than the constructor\n         * This will be a false positive for clear sources loaded after a Fairplay source\n         *\n         * @param {function} cb function to call\n         * @return {number} id of request\n         */\n        requestVideoFrameCallback(cb) {\n            if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n                return this.el_.requestVideoFrameCallback(cb);\n            }\n            return super.requestVideoFrameCallback(cb);\n        }\n\n        /**\n         * Native or fallback requestVideoFrameCallback\n         *\n         * @param {number} id request id to cancel\n         */\n        cancelVideoFrameCallback(id) {\n            if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n                this.el_.cancelVideoFrameCallback(id);\n            } else {\n                super.cancelVideoFrameCallback(id);\n            }\n        }\n\n        /**\n         * A getter/setter for the `Html5` Tech's source object.\n         * > Note: Please use {@link Html5#setSource}\n         *\n         * @param {Tech~SourceObject} [src]\n         *        The source object you want to set on the `HTML5` techs element.\n         *\n         * @return {Tech~SourceObject|undefined}\n         *         - The current source object when a source is not passed in.\n         *         - undefined when setting\n         *\n         * @deprecated Since version 5.\n         */\n        src(src) {\n            if (src === undefined) {\n                return this.el_.src;\n            }\n\n            // Setting src through `src` instead of `setSrc` will be deprecated\n            this.setSrc(src);\n        }\n\n        /**\n         * Reset the tech by removing all sources and then calling\n         * {@link Html5.resetMediaElement}.\n         */\n        reset() {\n            Html5.resetMediaElement(this.el_);\n        }\n\n        /**\n         * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n         * the HTML5 media element.\n         *\n         * @return {Tech~SourceObject}\n         *         The current source object from the HTML5 tech. With a fallback to the\n         *         elements source.\n         */\n        currentSrc() {\n            if (this.currentSource_) {\n                return this.currentSource_.src;\n            }\n            return this.el_.currentSrc;\n        }\n\n        /**\n         * Set controls attribute for the HTML5 media Element.\n         *\n         * @param {string} val\n         *        Value to set the controls attribute to\n         */\n        setControls(val) {\n            this.el_.controls = !!val;\n        }\n\n        /**\n         * Create and returns a remote {@link TextTrack} object.\n         *\n         * @param {string} kind\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n         *\n         * @param {string} [label]\n         *        Label to identify the text track\n         *\n         * @param {string} [language]\n         *        Two letter language abbreviation\n         *\n         * @return {TextTrack}\n         *         The TextTrack that gets created.\n         */\n        addTextTrack(kind, label, language) {\n            if (!this.featuresNativeTextTracks) {\n                return super.addTextTrack(kind, label, language);\n            }\n            return this.el_.addTextTrack(kind, label, language);\n        }\n\n        /**\n         * Creates either native TextTrack or an emulated TextTrack depending\n         * on the value of `featuresNativeTextTracks`\n         *\n         * @param {Object} options\n         *        The object should contain the options to initialize the TextTrack with.\n         *\n         * @param {string} [options.kind]\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n         *\n         * @param {string} [options.label]\n         *        Label to identify the text track\n         *\n         * @param {string} [options.language]\n         *        Two letter language abbreviation.\n         *\n         * @param {boolean} [options.default]\n         *        Default this track to on.\n         *\n         * @param {string} [options.id]\n         *        The internal id to assign this track.\n         *\n         * @param {string} [options.src]\n         *        A source url for the track.\n         *\n         * @return {HTMLTrackElement}\n         *         The track element that gets created.\n         */\n        createRemoteTextTrack(options) {\n            if (!this.featuresNativeTextTracks) {\n                return super.createRemoteTextTrack(options);\n            }\n            const htmlTrackElement = document.createElement('track');\n            if (options.kind) {\n                htmlTrackElement.kind = options.kind;\n            }\n            if (options.label) {\n                htmlTrackElement.label = options.label;\n            }\n            if (options.language || options.srclang) {\n                htmlTrackElement.srclang = options.language || options.srclang;\n            }\n            if (options.default) {\n                htmlTrackElement.default = options.default;\n            }\n            if (options.id) {\n                htmlTrackElement.id = options.id;\n            }\n            if (options.src) {\n                htmlTrackElement.src = options.src;\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Creates a remote text track object and returns an html track element.\n         *\n         * @param {Object} options The object should contain values for\n         * kind, language, label, and src (location of the WebVTT file)\n         * @param {boolean} [manualCleanup=false] if set to true, the TextTrack\n         * will not be removed from the TextTrackList and HtmlTrackElementList\n         * after a source change\n         * @return {HTMLTrackElement} An Html Track Element.\n         * This can be an emulated {@link HTMLTrackElement} or a native one.\n         *\n         */\n        addRemoteTextTrack(options, manualCleanup) {\n            const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);\n            if (this.featuresNativeTextTracks) {\n                this.el().appendChild(htmlTrackElement);\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Remove remote `TextTrack` from `TextTrackList` object\n         *\n         * @param {TextTrack} track\n         *        `TextTrack` object to remove\n         */\n        removeRemoteTextTrack(track) {\n            super.removeRemoteTextTrack(track);\n            if (this.featuresNativeTextTracks) {\n                const tracks = this.$$('track');\n                let i = tracks.length;\n                while (i--) {\n                    if (track === tracks[i] || track === tracks[i].track) {\n                        this.el().removeChild(tracks[i]);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object}\n         *         An object with supported media playback quality metrics\n         */\n        getVideoPlaybackQuality() {\n            if (typeof this.el().getVideoPlaybackQuality === 'function') {\n                return this.el().getVideoPlaybackQuality();\n            }\n            const videoPlaybackQuality = {};\n            if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n                videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n                videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n            }\n            if (window.performance) {\n                videoPlaybackQuality.creationTime = window.performance.now();\n            }\n            return videoPlaybackQuality;\n        }\n    }\n\n    /* HTML5 Support Testing ---------------------------------------------------- */\n\n    /**\n     * Element for testing browser HTML5 media capabilities\n     *\n     * @type {Element}\n     * @constant\n     * @private\n     */\n    defineLazyProperty(Html5, 'TEST_VID', function () {\n        if (!isReal()) {\n            return;\n        }\n        const video = document.createElement('video');\n        const track = document.createElement('track');\n        track.kind = 'captions';\n        track.srclang = 'en';\n        track.label = 'English';\n        video.appendChild(track);\n        return video;\n    });\n\n    /**\n     * Check if HTML5 media is supported by this browser/device.\n     *\n     * @return {boolean}\n     *         - True if HTML5 media is supported.\n     *         - False if HTML5 media is not supported.\n     */\n    Html5.isSupported = function () {\n        // IE with no Media Player is a LIAR! (#984)\n        try {\n            Html5.TEST_VID.volume = 0.5;\n        } catch (e) {\n            return false;\n        }\n        return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n    };\n\n    /**\n     * Check if the tech can support the given type\n     *\n     * @param {string} type\n     *        The mimetype to check\n     * @return {string} 'probably', 'maybe', or '' (empty string)\n     */\n    Html5.canPlayType = function (type) {\n        return Html5.TEST_VID.canPlayType(type);\n    };\n\n    /**\n     * Check if the tech can support the given source\n     *\n     * @param {Object} srcObj\n     *        The source object\n     * @param {Object} options\n     *        The options passed to the tech\n     * @return {string} 'probably', 'maybe', or '' (empty string)\n     */\n    Html5.canPlaySource = function (srcObj, options) {\n        return Html5.canPlayType(srcObj.type);\n    };\n\n    /**\n     * Check if the volume can be changed in this browser/device.\n     * Volume cannot be changed in a lot of mobile devices.\n     * Specifically, it can't be changed from 1 on iOS.\n     *\n     * @return {boolean}\n     *         - True if volume can be controlled\n     *         - False otherwise\n     */\n    Html5.canControlVolume = function () {\n        // IE will error if Windows Media Player not installed #3315\n        try {\n            const volume = Html5.TEST_VID.volume;\n            Html5.TEST_VID.volume = volume / 2 + 0.1;\n            const canControl = volume !== Html5.TEST_VID.volume;\n\n            // With the introduction of iOS 15, there are cases where the volume is read as\n            // changed but reverts back to its original state at the start of the next tick.\n            // To determine whether volume can be controlled on iOS,\n            // a timeout is set and the volume is checked asynchronously.\n            // Since `features` doesn't currently work asynchronously, the value is manually set.\n            if (canControl && IS_IOS) {\n                window.setTimeout(() => {\n                    if (Html5 && Html5.prototype) {\n                        Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;\n                    }\n                });\n\n                // default iOS to false, which will be updated in the timeout above.\n                return false;\n            }\n            return canControl;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if the volume can be muted in this browser/device.\n     * Some devices, e.g. iOS, don't allow changing volume\n     * but permits muting/unmuting.\n     *\n     * @return {boolean}\n     *      - True if volume can be muted\n     *      - False otherwise\n     */\n    Html5.canMuteVolume = function () {\n        try {\n            const muted = Html5.TEST_VID.muted;\n\n            // in some versions of iOS muted property doesn't always\n            // work, so we want to set both property and attribute\n            Html5.TEST_VID.muted = !muted;\n            if (Html5.TEST_VID.muted) {\n                setAttribute(Html5.TEST_VID, 'muted', 'muted');\n            } else {\n                removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n            }\n            return muted !== Html5.TEST_VID.muted;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if the playback rate can be changed in this browser/device.\n     *\n     * @return {boolean}\n     *         - True if playback rate can be controlled\n     *         - False otherwise\n     */\n    Html5.canControlPlaybackRate = function () {\n        // Playback rate API is implemented in Android Chrome, but doesn't do anything\n        // https://github.com/videojs/video.js/issues/3180\n        if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n            return false;\n        }\n        // IE will error if Windows Media Player not installed #3315\n        try {\n            const playbackRate = Html5.TEST_VID.playbackRate;\n            Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n            return playbackRate !== Html5.TEST_VID.playbackRate;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if we can override a video/audio elements attributes, with\n     * Object.defineProperty.\n     *\n     * @return {boolean}\n     *         - True if builtin attributes can be overridden\n     *         - False otherwise\n     */\n    Html5.canOverrideAttributes = function () {\n        // if we cannot overwrite the src/innerHTML property, there is no support\n        // iOS 7 safari for instance cannot do this.\n        try {\n            const noop = () => {};\n            Object.defineProperty(document.createElement('video'), 'src', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('audio'), 'src', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('video'), 'innerHTML', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('audio'), 'innerHTML', {\n                get: noop,\n                set: noop\n            });\n        } catch (e) {\n            return false;\n        }\n        return true;\n    };\n\n    /**\n     * Check to see if native `TextTrack`s are supported by this browser/device.\n     *\n     * @return {boolean}\n     *         - True if native `TextTrack`s are supported.\n     *         - False otherwise\n     */\n    Html5.supportsNativeTextTracks = function () {\n        return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n    };\n\n    /**\n     * Check to see if native `VideoTrack`s are supported by this browser/device\n     *\n     * @return {boolean}\n     *        - True if native `VideoTrack`s are supported.\n     *        - False otherwise\n     */\n    Html5.supportsNativeVideoTracks = function () {\n        return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n    };\n\n    /**\n     * Check to see if native `AudioTrack`s are supported by this browser/device\n     *\n     * @return {boolean}\n     *        - True if native `AudioTrack`s are supported.\n     *        - False otherwise\n     */\n    Html5.supportsNativeAudioTracks = function () {\n        return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n    };\n\n    /**\n     * An array of events available on the Html5 tech.\n     *\n     * @private\n     * @type {Array}\n     */\n    Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n    /**\n     * Boolean indicating whether the `Tech` supports volume control.\n     *\n     * @type {boolean}\n     * @default {@link Html5.canControlVolume}\n     */\n    /**\n     * Boolean indicating whether the `Tech` supports muting volume.\n     *\n     * @type {boolean}\n     * @default {@link Html5.canMuteVolume}\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports changing the speed at which the media\n     * plays. Examples:\n     *   - Set player to play 2x (twice) as fast\n     *   - Set player to play 0.5x (half) as fast\n     *\n     * @type {boolean}\n     * @default {@link Html5.canControlPlaybackRate}\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `sourceset` event.\n     *\n     * @type {boolean}\n     * @default\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeTextTracks}\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeVideoTracks}\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeAudioTracks}\n     */\n    [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function ([key, fn]) {\n        defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);\n    });\n    Html5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the media element\n     * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n     * false there. Everywhere else this should be true.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n    // TODO: Previous comment: No longer appears to be used. Can probably be removed.\n    //       Is this true?\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n     * when going into fullscreen.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.featuresFullscreenResize = true;\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n     * If this is false, manual `progress` events will be triggered instead.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.featuresProgressEvents = true;\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n     * If this is false, manual `timeupdate` events will be triggered instead.\n     *\n     * @default\n     */\n    Html5.prototype.featuresTimeupdateEvents = true;\n\n    /**\n     * Whether the HTML5 el supports `requestVideoFrameCallback`\n     *\n     * @type {boolean}\n     */\n    Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);\n    Html5.disposeMediaElement = function (el) {\n        if (!el) {\n            return;\n        }\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n\n        // remove any child track or source nodes to prevent their loading\n        while (el.hasChildNodes()) {\n            el.removeChild(el.firstChild);\n        }\n\n        // remove any src reference. not setting `src=''` because that causes a warning\n        // in firefox\n        el.removeAttribute('src');\n\n        // force the media element to update its loading state by calling load()\n        // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n        if (typeof el.load === 'function') {\n            // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n            (function () {\n                try {\n                    el.load();\n                } catch (e) {\n                    // not supported\n                }\n            })();\n        }\n    };\n    Html5.resetMediaElement = function (el) {\n        if (!el) {\n            return;\n        }\n        const sources = el.querySelectorAll('source');\n        let i = sources.length;\n        while (i--) {\n            el.removeChild(sources[i]);\n        }\n\n        // remove any src reference.\n        // not setting `src=''` because that throws an error\n        el.removeAttribute('src');\n        if (typeof el.load === 'function') {\n            // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n            (function () {\n                try {\n                    el.load();\n                } catch (e) {\n                    // satisfy linter\n                }\n            })();\n        }\n    };\n\n    /* Native HTML5 element property wrapping ----------------------------------- */\n    // Wrap native boolean attributes with getters that check both property and attribute\n    // The list is as followed:\n    // muted, defaultMuted, autoplay, controls, loop, playsinline\n    [\n        /**\n         * Get the value of `muted` from the media element. `muted` indicates\n         * that the volume for the media should be set to silent. This does not actually change\n         * the `volume` attribute.\n         *\n         * @method Html5#muted\n         * @return {boolean}\n         *         - True if the value of `volume` should be ignored and the audio set to silent.\n         *         - False if the value of `volume` should be used.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n         */\n        'muted',\n        /**\n         * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n         * whether the media should start muted or not. Only changes the default state of the\n         * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n         * current state.\n         *\n         * @method Html5#defaultMuted\n         * @return {boolean}\n         *         - The value of `defaultMuted` from the media element.\n         *         - True indicates that the media should start muted.\n         *         - False indicates that the media should not start muted\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n         */\n        'defaultMuted',\n        /**\n         * Get the value of `autoplay` from the media element. `autoplay` indicates\n         * that the media should start to play as soon as the page is ready.\n         *\n         * @method Html5#autoplay\n         * @return {boolean}\n         *         - The value of `autoplay` from the media element.\n         *         - True indicates that the media should start as soon as the page loads.\n         *         - False indicates that the media should not start as soon as the page loads.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n         */\n        'autoplay',\n        /**\n         * Get the value of `controls` from the media element. `controls` indicates\n         * whether the native media controls should be shown or hidden.\n         *\n         * @method Html5#controls\n         * @return {boolean}\n         *         - The value of `controls` from the media element.\n         *         - True indicates that native controls should be showing.\n         *         - False indicates that native controls should be hidden.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n         */\n        'controls',\n        /**\n         * Get the value of `loop` from the media element. `loop` indicates\n         * that the media should return to the start of the media and continue playing once\n         * it reaches the end.\n         *\n         * @method Html5#loop\n         * @return {boolean}\n         *         - The value of `loop` from the media element.\n         *         - True indicates that playback should seek back to start once\n         *           the end of a media is reached.\n         *         - False indicates that playback should not loop back to the start when the\n         *           end of the media is reached.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n         */\n        'loop',\n        /**\n         * Get the value of `playsinline` from the media element. `playsinline` indicates\n         * to the browser that non-fullscreen playback is preferred when fullscreen\n         * playback is the native default, such as in iOS Safari.\n         *\n         * @method Html5#playsinline\n         * @return {boolean}\n         *         - The value of `playsinline` from the media element.\n         *         - True indicates that the media should play inline.\n         *         - False indicates that the media should not play inline.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        'playsinline'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop] || this.el_.hasAttribute(prop);\n        };\n    });\n\n    // Wrap native boolean attributes with setters that set both property and attribute\n    // The list is as followed:\n    // setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n    // setControls is special-cased above\n    [\n        /**\n         * Set the value of `muted` on the media element. `muted` indicates that the current\n         * audio level should be silent.\n         *\n         * @method Html5#setMuted\n         * @param {boolean} muted\n         *        - True if the audio should be set to silent\n         *        - False otherwise\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n         */\n        'muted',\n        /**\n         * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n         * audio level should be silent, but will only effect the muted level on initial playback..\n         *\n         * @method Html5.prototype.setDefaultMuted\n         * @param {boolean} defaultMuted\n         *        - True if the audio should be set to silent\n         *        - False otherwise\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n         */\n        'defaultMuted',\n        /**\n         * Set the value of `autoplay` on the media element. `autoplay` indicates\n         * that the media should start to play as soon as the page is ready.\n         *\n         * @method Html5#setAutoplay\n         * @param {boolean} autoplay\n         *         - True indicates that the media should start as soon as the page loads.\n         *         - False indicates that the media should not start as soon as the page loads.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n         */\n        'autoplay',\n        /**\n         * Set the value of `loop` on the media element. `loop` indicates\n         * that the media should return to the start of the media and continue playing once\n         * it reaches the end.\n         *\n         * @method Html5#setLoop\n         * @param {boolean} loop\n         *         - True indicates that playback should seek back to start once\n         *           the end of a media is reached.\n         *         - False indicates that playback should not loop back to the start when the\n         *           end of the media is reached.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n         */\n        'loop',\n        /**\n         * Set the value of `playsinline` from the media element. `playsinline` indicates\n         * to the browser that non-fullscreen playback is preferred when fullscreen\n         * playback is the native default, such as in iOS Safari.\n         *\n         * @method Html5#setPlaysinline\n         * @param {boolean} playsinline\n         *         - True indicates that the media should play inline.\n         *         - False indicates that the media should not play inline.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        'playsinline'].forEach(function (prop) {\n        Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n            this.el_[prop] = v;\n            if (v) {\n                this.el_.setAttribute(prop, prop);\n            } else {\n                this.el_.removeAttribute(prop);\n            }\n        };\n    });\n\n    // Wrap native properties with a getter\n    // The list is as followed\n    // paused, currentTime, buffered, volume, poster, preload, error, seeking\n    // seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture\n    // played, networkState, readyState, videoWidth, videoHeight, crossOrigin\n    [\n        /**\n         * Get the value of `paused` from the media element. `paused` indicates whether the media element\n         * is currently paused or not.\n         *\n         * @method Html5#paused\n         * @return {boolean}\n         *         The value of `paused` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n         */\n        'paused',\n        /**\n         * Get the value of `currentTime` from the media element. `currentTime` indicates\n         * the current second that the media is at in playback.\n         *\n         * @method Html5#currentTime\n         * @return {number}\n         *         The value of `currentTime` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n         */\n        'currentTime',\n        /**\n         * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n         * object that represents the parts of the media that are already downloaded and\n         * available for playback.\n         *\n         * @method Html5#buffered\n         * @return {TimeRange}\n         *         The value of `buffered` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n         */\n        'buffered',\n        /**\n         * Get the value of `volume` from the media element. `volume` indicates\n         * the current playback volume of audio for a media. `volume` will be a value from 0\n         * (silent) to 1 (loudest and default).\n         *\n         * @method Html5#volume\n         * @return {number}\n         *         The value of `volume` from the media element. Value will be between 0-1.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n         */\n        'volume',\n        /**\n         * Get the value of `poster` from the media element. `poster` indicates\n         * that the url of an image file that can/will be shown when no media data is available.\n         *\n         * @method Html5#poster\n         * @return {string}\n         *         The value of `poster` from the media element. Value will be a url to an\n         *         image.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n         */\n        'poster',\n        /**\n         * Get the value of `preload` from the media element. `preload` indicates\n         * what should download before the media is interacted with. It can have the following\n         * values:\n         * - none: nothing should be downloaded\n         * - metadata: poster and the first few frames of the media may be downloaded to get\n         *   media dimensions and other metadata\n         * - auto: allow the media and metadata for the media to be downloaded before\n         *    interaction\n         *\n         * @method Html5#preload\n         * @return {string}\n         *         The value of `preload` from the media element. Will be 'none', 'metadata',\n         *         or 'auto'.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n         */\n        'preload',\n        /**\n         * Get the value of the `error` from the media element. `error` indicates any\n         * MediaError that may have occurred during playback. If error returns null there is no\n         * current error.\n         *\n         * @method Html5#error\n         * @return {MediaError|null}\n         *         The value of `error` from the media element. Will be `MediaError` if there\n         *         is a current error and null otherwise.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n         */\n        'error',\n        /**\n         * Get the value of `seeking` from the media element. `seeking` indicates whether the\n         * media is currently seeking to a new position or not.\n         *\n         * @method Html5#seeking\n         * @return {boolean}\n         *         - The value of `seeking` from the media element.\n         *         - True indicates that the media is currently seeking to a new position.\n         *         - False indicates that the media is not seeking to a new position at this time.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n         */\n        'seeking',\n        /**\n         * Get the value of `seekable` from the media element. `seekable` returns a\n         * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n         *\n         * @method Html5#seekable\n         * @return {TimeRange}\n         *         The value of `seekable` from the media element. A `TimeRange` object\n         *         indicating the current ranges of time that can be seeked to.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n         */\n        'seekable',\n        /**\n         * Get the value of `ended` from the media element. `ended` indicates whether\n         * the media has reached the end or not.\n         *\n         * @method Html5#ended\n         * @return {boolean}\n         *         - The value of `ended` from the media element.\n         *         - True indicates that the media has ended.\n         *         - False indicates that the media has not ended.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n         */\n        'ended',\n        /**\n         * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n         * the rate at which the media is currently playing back. Examples:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5#playbackRate\n         * @return {number}\n         *         The value of `playbackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'playbackRate',\n        /**\n         * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n         * the rate at which the media is currently playing back. This value will not indicate the current\n         * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n         *\n         * Examples:\n         *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n         *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5.prototype.defaultPlaybackRate\n         * @return {number}\n         *         The value of `defaultPlaybackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'defaultPlaybackRate',\n        /**\n         * Get the value of 'disablePictureInPicture' from the video element.\n         *\n         * @method Html5#disablePictureInPicture\n         * @return {boolean} value\n         *         - The value of `disablePictureInPicture` from the video element.\n         *         - True indicates that the video can't be played in Picture-In-Picture mode\n         *         - False indicates that the video can be played in Picture-In-Picture mode\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n         */\n        'disablePictureInPicture',\n        /**\n         * Get the value of `played` from the media element. `played` returns a `TimeRange`\n         * object representing points in the media timeline that have been played.\n         *\n         * @method Html5#played\n         * @return {TimeRange}\n         *         The value of `played` from the media element. A `TimeRange` object indicating\n         *         the ranges of time that have been played.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n         */\n        'played',\n        /**\n         * Get the value of `networkState` from the media element. `networkState` indicates\n         * the current network state. It returns an enumeration from the following list:\n         * - 0: NETWORK_EMPTY\n         * - 1: NETWORK_IDLE\n         * - 2: NETWORK_LOADING\n         * - 3: NETWORK_NO_SOURCE\n         *\n         * @method Html5#networkState\n         * @return {number}\n         *         The value of `networkState` from the media element. This will be a number\n         *         from the list in the description.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n         */\n        'networkState',\n        /**\n         * Get the value of `readyState` from the media element. `readyState` indicates\n         * the current state of the media element. It returns an enumeration from the\n         * following list:\n         * - 0: HAVE_NOTHING\n         * - 1: HAVE_METADATA\n         * - 2: HAVE_CURRENT_DATA\n         * - 3: HAVE_FUTURE_DATA\n         * - 4: HAVE_ENOUGH_DATA\n         *\n         * @method Html5#readyState\n         * @return {number}\n         *         The value of `readyState` from the media element. This will be a number\n         *         from the list in the description.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n         */\n        'readyState',\n        /**\n         * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n         * the current width of the video in css pixels.\n         *\n         * @method Html5#videoWidth\n         * @return {number}\n         *         The value of `videoWidth` from the video element. This will be a number\n         *         in css pixels.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n         */\n        'videoWidth',\n        /**\n         * Get the value of `videoHeight` from the video element. `videoHeight` indicates\n         * the current height of the video in css pixels.\n         *\n         * @method Html5#videoHeight\n         * @return {number}\n         *         The value of `videoHeight` from the video element. This will be a number\n         *         in css pixels.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n         */\n        'videoHeight',\n        /**\n         * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates\n         * to the browser that should sent the cookies along with the requests for the\n         * different assets/playlists\n         *\n         * @method Html5#crossOrigin\n         * @return {string}\n         *         - anonymous indicates that the media should not sent cookies.\n         *         - use-credentials indicates that the media should sent cookies along the requests.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n         */\n        'crossOrigin'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop];\n        };\n    });\n\n    // Wrap native properties with a setter in this format:\n    // set + toTitleCase(name)\n    // The list is as follows:\n    // setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,\n    // setDisablePictureInPicture, setCrossOrigin\n    [\n        /**\n         * Set the value of `volume` on the media element. `volume` indicates the current\n         * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n         * so on.\n         *\n         * @method Html5#setVolume\n         * @param {number} percentAsDecimal\n         *        The volume percent as a decimal. Valid range is from 0-1.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n         */\n        'volume',\n        /**\n         * Set the value of `src` on the media element. `src` indicates the current\n         * {@link Tech~SourceObject} for the media.\n         *\n         * @method Html5#setSrc\n         * @param {Tech~SourceObject} src\n         *        The source object to set as the current source.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n         */\n        'src',\n        /**\n         * Set the value of `poster` on the media element. `poster` is the url to\n         * an image file that can/will be shown when no media data is available.\n         *\n         * @method Html5#setPoster\n         * @param {string} poster\n         *        The url to an image that should be used as the `poster` for the media\n         *        element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n         */\n        'poster',\n        /**\n         * Set the value of `preload` on the media element. `preload` indicates\n         * what should download before the media is interacted with. It can have the following\n         * values:\n         * - none: nothing should be downloaded\n         * - metadata: poster and the first few frames of the media may be downloaded to get\n         *   media dimensions and other metadata\n         * - auto: allow the media and metadata for the media to be downloaded before\n         *    interaction\n         *\n         * @method Html5#setPreload\n         * @param {string} preload\n         *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n         *         or 'auto'.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n         */\n        'preload',\n        /**\n         * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n         * the rate at which the media should play back. Examples:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5#setPlaybackRate\n         * @return {number}\n         *         The value of `playbackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'playbackRate',\n        /**\n         * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n         * the rate at which the media should play back upon initial startup. Changing this value\n         * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n         *\n         * Example Values:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5.prototype.setDefaultPlaybackRate\n         * @return {number}\n         *         The value of `defaultPlaybackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n         */\n        'defaultPlaybackRate',\n        /**\n         * Prevents the browser from suggesting a Picture-in-Picture context menu\n         * or to request Picture-in-Picture automatically in some cases.\n         *\n         * @method Html5#setDisablePictureInPicture\n         * @param {boolean} value\n         *         The true value will disable Picture-in-Picture mode.\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n         */\n        'disablePictureInPicture',\n        /**\n         * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates\n         * to the browser that should sent the cookies along with the requests for the\n         * different assets/playlists\n         *\n         * @method Html5#setCrossOrigin\n         * @param {string} crossOrigin\n         *         - anonymous indicates that the media should not sent cookies.\n         *         - use-credentials indicates that the media should sent cookies along the requests.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n         */\n        'crossOrigin'].forEach(function (prop) {\n        Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n            this.el_[prop] = v;\n        };\n    });\n\n    // wrap native functions with a function\n    // The list is as follows:\n    // pause, load, play\n    [\n        /**\n         * A wrapper around the media elements `pause` function. This will call the `HTML5`\n         * media elements `pause` function.\n         *\n         * @method Html5#pause\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n         */\n        'pause',\n        /**\n         * A wrapper around the media elements `load` function. This will call the `HTML5`s\n         * media element `load` function.\n         *\n         * @method Html5#load\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n         */\n        'load',\n        /**\n         * A wrapper around the media elements `play` function. This will call the `HTML5`s\n         * media element `play` function.\n         *\n         * @method Html5#play\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n         */\n        'play'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop]();\n        };\n    });\n    Tech.withSourceHandlers(Html5);\n\n    /**\n     * Native source handler for Html5, simply passes the source to the media element.\n     *\n     * @property {Tech~SourceObject} source\n     *        The source object\n     *\n     * @property {Html5} tech\n     *        The instance of the HTML5 tech.\n     */\n    Html5.nativeSourceHandler = {};\n\n    /**\n     * Check if the media element can play the given mime type.\n     *\n     * @param {string} type\n     *        The mimetype to check\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string)\n     */\n    Html5.nativeSourceHandler.canPlayType = function (type) {\n        // IE without MediaPlayer throws an error (#519)\n        try {\n            return Html5.TEST_VID.canPlayType(type);\n        } catch (e) {\n            return '';\n        }\n    };\n\n    /**\n     * Check if the media element can handle a source natively.\n     *\n     * @param {Tech~SourceObject} source\n     *         The source object\n     *\n     * @param {Object} [options]\n     *         Options to be passed to the tech.\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string).\n     */\n    Html5.nativeSourceHandler.canHandleSource = function (source, options) {\n        // If a type was provided we should rely on that\n        if (source.type) {\n            return Html5.nativeSourceHandler.canPlayType(source.type);\n\n            // If no type, fall back to checking 'video/[EXTENSION]'\n        } else if (source.src) {\n            const ext = getFileExtension(source.src);\n            return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);\n        }\n        return '';\n    };\n\n    /**\n     * Pass the source to the native media element.\n     *\n     * @param {Tech~SourceObject} source\n     *        The source object\n     *\n     * @param {Html5} tech\n     *        The instance of the Html5 tech\n     *\n     * @param {Object} [options]\n     *        The options to pass to the source\n     */\n    Html5.nativeSourceHandler.handleSource = function (source, tech, options) {\n        tech.setSrc(source.src);\n    };\n\n    /**\n     * A noop for the native dispose function, as cleanup is not needed.\n     */\n    Html5.nativeSourceHandler.dispose = function () {};\n\n    // Register the native source handler\n    Html5.registerSourceHandler(Html5.nativeSourceHandler);\n    Tech.registerTech('Html5', Html5);\n\n    /**\n     * @file player.js\n     */\n\n        // The following tech events are simply re-triggered\n        // on the player when they happen\n    const TECH_EVENTS_RETRIGGER = [\n            /**\n             * Fired while the user agent is downloading media data.\n             *\n             * @event Player#progress\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `progress` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechProgress_\n             * @fires Player#progress\n             * @listens Tech#progress\n             */\n            'progress',\n            /**\n             * Fires when the loading of an audio/video is aborted.\n             *\n             * @event Player#abort\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `abort` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechAbort_\n             * @fires Player#abort\n             * @listens Tech#abort\n             */\n            'abort',\n            /**\n             * Fires when the browser is intentionally not getting media data.\n             *\n             * @event Player#suspend\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechSuspend_\n             * @fires Player#suspend\n             * @listens Tech#suspend\n             */\n            'suspend',\n            /**\n             * Fires when the current playlist is empty.\n             *\n             * @event Player#emptied\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechEmptied_\n             * @fires Player#emptied\n             * @listens Tech#emptied\n             */\n            'emptied',\n            /**\n             * Fires when the browser is trying to get media data, but data is not available.\n             *\n             * @event Player#stalled\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechStalled_\n             * @fires Player#stalled\n             * @listens Tech#stalled\n             */\n            'stalled',\n            /**\n             * Fires when the browser has loaded meta data for the audio/video.\n             *\n             * @event Player#loadedmetadata\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechLoadedmetadata_\n             * @fires Player#loadedmetadata\n             * @listens Tech#loadedmetadata\n             */\n            'loadedmetadata',\n            /**\n             * Fires when the browser has loaded the current frame of the audio/video.\n             *\n             * @event Player#loadeddata\n             * @type {event}\n             */\n            /**\n             * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechLoaddeddata_\n             * @fires Player#loadeddata\n             * @listens Tech#loadeddata\n             */\n            'loadeddata',\n            /**\n             * Fires when the current playback position has changed.\n             *\n             * @event Player#timeupdate\n             * @type {event}\n             */\n            /**\n             * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechTimeUpdate_\n             * @fires Player#timeupdate\n             * @listens Tech#timeupdate\n             */\n            'timeupdate',\n            /**\n             * Fires when the video's intrinsic dimensions change\n             *\n             * @event Player#resize\n             * @type {event}\n             */\n            /**\n             * Retrigger the `resize` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechResize_\n             * @fires Player#resize\n             * @listens Tech#resize\n             */\n            'resize',\n            /**\n             * Fires when the volume has been changed\n             *\n             * @event Player#volumechange\n             * @type {event}\n             */\n            /**\n             * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechVolumechange_\n             * @fires Player#volumechange\n             * @listens Tech#volumechange\n             */\n            'volumechange',\n            /**\n             * Fires when the text track has been changed\n             *\n             * @event Player#texttrackchange\n             * @type {event}\n             */\n            /**\n             * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechTexttrackchange_\n             * @fires Player#texttrackchange\n             * @listens Tech#texttrackchange\n             */\n            'texttrackchange'];\n\n    // events to queue when playback rate is zero\n    // this is a hash for the sole purpose of mapping non-camel-cased event names\n    // to camel-cased function names\n    const TECH_EVENTS_QUEUE = {\n        canplay: 'CanPlay',\n        canplaythrough: 'CanPlayThrough',\n        playing: 'Playing',\n        seeked: 'Seeked'\n    };\n    const BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\n    const BREAKPOINT_CLASSES = {};\n\n    // grep: vjs-layout-tiny\n    // grep: vjs-layout-x-small\n    // grep: vjs-layout-small\n    // grep: vjs-layout-medium\n    // grep: vjs-layout-large\n    // grep: vjs-layout-x-large\n    // grep: vjs-layout-huge\n    BREAKPOINT_ORDER.forEach(k => {\n        const v = k.charAt(0) === 'x' ? `x-${k.substring(1)}` : k;\n        BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;\n    });\n    const DEFAULT_BREAKPOINTS = {\n        tiny: 210,\n        xsmall: 320,\n        small: 425,\n        medium: 768,\n        large: 1440,\n        xlarge: 2560,\n        huge: Infinity\n    };\n\n    /**\n     * An instance of the `Player` class is created when any of the Video.js setup methods\n     * are used to initialize a video.\n     *\n     * After an instance has been created it can be accessed globally in three ways:\n     * 1. By calling `videojs.getPlayer('example_video_1');`\n     * 2. By calling `videojs('example_video_1');` (not recommended)\n     * 2. By using it directly via `videojs.players.example_video_1;`\n     *\n     * @extends Component\n     * @global\n     */\n    class Player extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Element} tag\n         *        The original video DOM element used for configuring options.\n         *\n         * @param {Object} [options]\n         *        Object of option names and values.\n         *\n         * @param {Function} [ready]\n         *        Ready callback function.\n         */\n        constructor(tag, options, ready) {\n            // Make sure tag ID exists\n            // also here.. probably better\n            tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;\n\n            // Set Options\n            // The options argument overrides options set in the video tag\n            // which overrides globally set options.\n            // This latter part coincides with the load order\n            // (tag must exist before Player)\n            options = Object.assign(Player.getTagSettings(tag), options);\n\n            // Delay the initialization of children because we need to set up\n            // player properties first, and can't use `this` before `super()`\n            options.initChildren = false;\n\n            // Same with creating the element\n            options.createEl = false;\n\n            // don't auto mixin the evented mixin\n            options.evented = false;\n\n            // we don't want the player to report touch activity on itself\n            // see enableTouchActivity in Component\n            options.reportTouchActivity = false;\n\n            // If language is not set, get the closest lang attribute\n            if (!options.language) {\n                const closest = tag.closest('[lang]');\n                if (closest) {\n                    options.language = closest.getAttribute('lang');\n                }\n            }\n\n            // Run base component initializing with new options\n            super(null, options, ready);\n\n            // Create bound methods for document listeners.\n            this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);\n            this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);\n            this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);\n            this.boundApplyInitTime_ = e => this.applyInitTime_(e);\n            this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);\n            this.boundHandleTechClick_ = e => this.handleTechClick_(e);\n            this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);\n            this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);\n            this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);\n            this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);\n            this.boundHandleTechTap_ = e => this.handleTechTap_(e);\n\n            // default isFullscreen_ to false\n            this.isFullscreen_ = false;\n\n            // create logger\n            this.log = createLogger(this.id_);\n\n            // Hold our own reference to fullscreen api so it can be mocked in tests\n            this.fsApi_ = FullscreenApi;\n\n            // Tracks when a tech changes the poster\n            this.isPosterFromTech_ = false;\n\n            // Holds callback info that gets queued when playback rate is zero\n            // and a seek is happening\n            this.queuedCallbacks_ = [];\n\n            // Turn off API access because we're loading a new tech that might load asynchronously\n            this.isReady_ = false;\n\n            // Init state hasStarted_\n            this.hasStarted_ = false;\n\n            // Init state userActive_\n            this.userActive_ = false;\n\n            // Init debugEnabled_\n            this.debugEnabled_ = false;\n\n            // Init state audioOnlyMode_\n            this.audioOnlyMode_ = false;\n\n            // Init state audioPosterMode_\n            this.audioPosterMode_ = false;\n\n            // Init state audioOnlyCache_\n            this.audioOnlyCache_ = {\n                playerHeight: null,\n                hiddenChildren: []\n            };\n\n            // if the global option object was accidentally blown away by\n            // someone, bail early with an informative error\n            if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {\n                throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n            }\n\n            // Store the original tag used to set options\n            this.tag = tag;\n\n            // Store the tag attributes used to restore html5 element\n            this.tagAttributes = tag && getAttributes(tag);\n\n            // Update current language\n            this.language(this.options_.language);\n\n            // Update Supported Languages\n            if (options.languages) {\n                // Normalise player option languages to lowercase\n                const languagesToLower = {};\n                Object.getOwnPropertyNames(options.languages).forEach(function (name) {\n                    languagesToLower[name.toLowerCase()] = options.languages[name];\n                });\n                this.languages_ = languagesToLower;\n            } else {\n                this.languages_ = Player.prototype.options_.languages;\n            }\n            this.resetCache_();\n\n            // Set poster\n            /** @type string */\n            this.poster_ = options.poster || '';\n\n            // Set controls\n            /** @type {boolean} */\n            this.controls_ = !!options.controls;\n\n            // Original tag settings stored in options\n            // now remove immediately so native controls don't flash.\n            // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n            tag.controls = false;\n            tag.removeAttribute('controls');\n            this.changingSrc_ = false;\n            this.playCallbacks_ = [];\n            this.playTerminatedQueue_ = [];\n\n            // the attribute overrides the option\n            if (tag.hasAttribute('autoplay')) {\n                this.autoplay(true);\n            } else {\n                // otherwise use the setter to validate and\n                // set the correct value.\n                this.autoplay(this.options_.autoplay);\n            }\n\n            // check plugins\n            if (options.plugins) {\n                Object.keys(options.plugins).forEach(name => {\n                    if (typeof this[name] !== 'function') {\n                        throw new Error(`plugin \"${name}\" does not exist`);\n                    }\n                });\n            }\n\n            /*\n       * Store the internal state of scrubbing\n       *\n       * @private\n       * @return {Boolean} True if the user is scrubbing\n       */\n            this.scrubbing_ = false;\n            this.el_ = this.createEl();\n\n            // Make this an evented object and use `el_` as its event bus.\n            evented(this, {\n                eventBusKey: 'el_'\n            });\n\n            // listen to document and player fullscreenchange handlers so we receive those events\n            // before a user can receive them so we can update isFullscreen appropriately.\n            // make sure that we listen to fullscreenchange events before everything else to make sure that\n            // our isFullscreen method is updated properly for internal components as well as external.\n            if (this.fsApi_.requestFullscreen) {\n                on(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n                this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n            }\n            if (this.fluid_) {\n                this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n            }\n            // We also want to pass the original player options to each component and plugin\n            // as well so they don't need to reach back into the player for options later.\n            // We also need to do another copy of this.options_ so we don't end up with\n            // an infinite loop.\n            const playerOptionsCopy = merge$2(this.options_);\n\n            // Load plugins\n            if (options.plugins) {\n                Object.keys(options.plugins).forEach(name => {\n                    this[name](options.plugins[name]);\n                });\n            }\n\n            // Enable debug mode to fire debugon event for all plugins.\n            if (options.debug) {\n                this.debug(true);\n            }\n            this.options_.playerOptions = playerOptionsCopy;\n            this.middleware_ = [];\n            this.playbackRates(options.playbackRates);\n            if (options.experimentalSvgIcons) {\n                // Add SVG Sprite to the DOM\n                const parser = new window.DOMParser();\n                const parsedSVG = parser.parseFromString(icons, 'image/svg+xml');\n                const errorNode = parsedSVG.querySelector('parsererror');\n                if (errorNode) {\n                    log$1.warn('Failed to load SVG Icons. Falling back to Font Icons.');\n                    this.options_.experimentalSvgIcons = null;\n                } else {\n                    const sprite = parsedSVG.documentElement;\n                    sprite.style.display = 'none';\n                    this.el_.appendChild(sprite);\n                    this.addClass('vjs-svg-icons-enabled');\n                }\n            }\n            this.initChildren();\n\n            // Set isAudio based on whether or not an audio tag was used\n            this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n            // Update controls className. Can't do this when the controls are initially\n            // set because the element doesn't exist yet.\n            if (this.controls()) {\n                this.addClass('vjs-controls-enabled');\n            } else {\n                this.addClass('vjs-controls-disabled');\n            }\n\n            // Set ARIA label and region role depending on player type\n            this.el_.setAttribute('role', 'region');\n            if (this.isAudio()) {\n                this.el_.setAttribute('aria-label', this.localize('Audio Player'));\n            } else {\n                this.el_.setAttribute('aria-label', this.localize('Video Player'));\n            }\n            if (this.isAudio()) {\n                this.addClass('vjs-audio');\n            }\n\n            // TODO: Make this smarter. Toggle user state between touching/mousing\n            // using events, since devices can have both touch and mouse events.\n            // TODO: Make this check be performed again when the window switches between monitors\n            // (See https://github.com/videojs/video.js/issues/5683)\n            if (TOUCH_ENABLED) {\n                this.addClass('vjs-touch-enabled');\n            }\n\n            // iOS Safari has broken hover handling\n            if (!IS_IOS) {\n                this.addClass('vjs-workinghover');\n            }\n\n            // Make player easily findable by ID\n            Player.players[this.id_] = this;\n\n            // Add a major version class to aid css in plugins\n            const majorVersion = version$5.split('.')[0];\n            this.addClass(`vjs-v${majorVersion}`);\n\n            // When the player is first initialized, trigger activity so components\n            // like the control bar show themselves if needed\n            this.userActive(true);\n            this.reportUserActivity();\n            this.one('play', e => this.listenForUserActivity_(e));\n            this.on('keydown', e => this.handleKeyDown(e));\n            this.on('languagechange', e => this.handleLanguagechange(e));\n            this.breakpoints(this.options_.breakpoints);\n            this.responsive(this.options_.responsive);\n\n            // Calling both the audio mode methods after the player is fully\n            // setup to be able to listen to the events triggered by them\n            this.on('ready', () => {\n                // Calling the audioPosterMode method first so that\n                // the audioOnlyMode can take precedence when both options are set to true\n                this.audioPosterMode(this.options_.audioPosterMode);\n                this.audioOnlyMode(this.options_.audioOnlyMode);\n            });\n        }\n\n        /**\n         * Destroys the video player and does any necessary cleanup.\n         *\n         * This is especially helpful if you are dynamically adding and removing videos\n         * to/from the DOM.\n         *\n         * @fires Player#dispose\n         */\n        dispose() {\n            /**\n             * Called when the player is being disposed of.\n             *\n             * @event Player#dispose\n             * @type {Event}\n             */\n            this.trigger('dispose');\n            // prevent dispose from being called twice\n            this.off('dispose');\n\n            // Make sure all player-specific document listeners are unbound. This is\n            off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n            off(document, 'keydown', this.boundFullWindowOnEscKey_);\n            if (this.styleEl_ && this.styleEl_.parentNode) {\n                this.styleEl_.parentNode.removeChild(this.styleEl_);\n                this.styleEl_ = null;\n            }\n\n            // Kill reference to this player\n            Player.players[this.id_] = null;\n            if (this.tag && this.tag.player) {\n                this.tag.player = null;\n            }\n            if (this.el_ && this.el_.player) {\n                this.el_.player = null;\n            }\n            if (this.tech_) {\n                this.tech_.dispose();\n                this.isPosterFromTech_ = false;\n                this.poster_ = '';\n            }\n            if (this.playerElIngest_) {\n                this.playerElIngest_ = null;\n            }\n            if (this.tag) {\n                this.tag = null;\n            }\n            clearCacheForPlayer(this);\n\n            // remove all event handlers for track lists\n            // all tracks and track listeners are removed on\n            // tech dispose\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                const list = this[props.getterName]();\n\n                // if it is not a native list\n                // we have to manually remove event listeners\n                if (list && list.off) {\n                    list.off();\n                }\n            });\n\n            // the actual .el_ is removed here, or replaced if\n            super.dispose({\n                restoreEl: this.options_.restoreEl\n            });\n        }\n\n        /**\n         * Create the `Player`'s DOM element.\n         *\n         * @return {Element}\n         *         The DOM element that gets created.\n         */\n        createEl() {\n            let tag = this.tag;\n            let el;\n            let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n            const divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n            if (playerElIngest) {\n                el = this.el_ = tag.parentNode;\n            } else if (!divEmbed) {\n                el = this.el_ = super.createEl('div');\n            }\n\n            // Copy over all the attributes from the tag, including ID and class\n            // ID will now reference player box, not the video tag\n            const attrs = getAttributes(tag);\n            if (divEmbed) {\n                el = this.el_ = tag;\n                tag = this.tag = document.createElement('video');\n                while (el.children.length) {\n                    tag.appendChild(el.firstChild);\n                }\n                if (!hasClass(el, 'video-js')) {\n                    addClass(el, 'video-js');\n                }\n                el.appendChild(tag);\n                playerElIngest = this.playerElIngest_ = el;\n                // move properties over from our custom `video-js` element\n                // to our new `video` element. This will move things like\n                // `src` or `controls` that were set via js before the player\n                // was initialized.\n                Object.keys(el).forEach(k => {\n                    try {\n                        tag[k] = el[k];\n                    } catch (e) {\n                        // we got a a property like outerHTML which we can't actually copy, ignore it\n                    }\n                });\n            }\n\n            // set tabindex to -1 to remove the video element from the focus order\n            tag.setAttribute('tabindex', '-1');\n            attrs.tabindex = '-1';\n\n            // Workaround for #4583 on Chrome (on Windows) with JAWS.\n            // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n            // Note that we can't detect if JAWS is being used, but this ARIA attribute\n            // doesn't change behavior of Chrome if JAWS is not being used\n            if (IS_CHROME && IS_WINDOWS) {\n                tag.setAttribute('role', 'application');\n                attrs.role = 'application';\n            }\n\n            // Remove width/height attrs from tag so CSS can make it 100% width/height\n            tag.removeAttribute('width');\n            tag.removeAttribute('height');\n            if ('width' in attrs) {\n                delete attrs.width;\n            }\n            if ('height' in attrs) {\n                delete attrs.height;\n            }\n            Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n                // don't copy over the class attribute to the player element when we're in a div embed\n                // the class is already set up properly in the divEmbed case\n                // and we want to make sure that the `video-js` class doesn't get lost\n                if (!(divEmbed && attr === 'class')) {\n                    el.setAttribute(attr, attrs[attr]);\n                }\n                if (divEmbed) {\n                    tag.setAttribute(attr, attrs[attr]);\n                }\n            });\n\n            // Update tag id/class for use as HTML5 playback tech\n            // Might think we should do this after embedding in container so .vjs-tech class\n            // doesn't flash 100% width/height, but class only applies with .video-js parent\n            tag.playerId = tag.id;\n            tag.id += '_html5_api';\n            tag.className = 'vjs-tech';\n\n            // Make player findable on elements\n            tag.player = el.player = this;\n            // Default state of video is paused\n            this.addClass('vjs-paused');\n\n            // Add a style element in the player that we'll use to set the width/height\n            // of the player in a way that's still overridable by CSS, just like the\n            // video element\n            if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n                this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n                const defaultsStyleEl = $('.vjs-styles-defaults');\n                const head = $('head');\n                head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n            }\n            this.fill_ = false;\n            this.fluid_ = false;\n\n            // Pass in the width/height/aspectRatio options which will update the style el\n            this.width(this.options_.width);\n            this.height(this.options_.height);\n            this.fill(this.options_.fill);\n            this.fluid(this.options_.fluid);\n            this.aspectRatio(this.options_.aspectRatio);\n            // support both crossOrigin and crossorigin to reduce confusion and issues around the name\n            this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);\n\n            // Hide any links within the video/audio tag,\n            // because IE doesn't hide them completely from screen readers.\n            const links = tag.getElementsByTagName('a');\n            for (let i = 0; i < links.length; i++) {\n                const linkEl = links.item(i);\n                addClass(linkEl, 'vjs-hidden');\n                linkEl.setAttribute('hidden', 'hidden');\n            }\n\n            // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n            // keep track of the original for later so we can know if the source originally failed\n            tag.initNetworkState_ = tag.networkState;\n\n            // Wrap video tag in div (el/box) container\n            if (tag.parentNode && !playerElIngest) {\n                tag.parentNode.insertBefore(el, tag);\n            }\n\n            // insert the tag as the first child of the player element\n            // then manually add it to the children array so that this.addChild\n            // will work properly for other components\n            //\n            // Breaks iPhone, fixed in HTML5 setup.\n            prependTo(tag, el);\n            this.children_.unshift(tag);\n\n            // Set lang attr on player to ensure CSS :lang() in consistent with player\n            // if it's been set to something different to the doc\n            this.el_.setAttribute('lang', this.language_);\n            this.el_.setAttribute('translate', 'no');\n            this.el_ = el;\n            return el;\n        }\n\n        /**\n         * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this\n         * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n         * behavior.\n         *\n         * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n         *\n         * @param {string|null} [value]\n         *        The value to set the `Player`'s crossOrigin to. If an argument is\n         *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n         *\n         * @return {string|null|undefined}\n         *         - The current crossOrigin value of the `Player` when getting.\n         *         - undefined when setting\n         */\n        crossOrigin(value) {\n            // `null` can be set to unset a value\n            if (typeof value === 'undefined') {\n                return this.techGet_('crossOrigin');\n            }\n            if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n                log$1.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n                return;\n            }\n            this.techCall_('setCrossOrigin', value);\n            if (this.posterImage) {\n                this.posterImage.crossOrigin(value);\n            }\n            return;\n        }\n\n        /**\n         * A getter/setter for the `Player`'s width. Returns the player's configured value.\n         * To get the current width use `currentWidth()`.\n         *\n         * @param {number|string} [value]\n         *        CSS value to set the `Player`'s width to.\n         *\n         * @return {number|undefined}\n         *         - The current width of the `Player` when getting.\n         *         - Nothing when setting\n         */\n        width(value) {\n            return this.dimension('width', value);\n        }\n\n        /**\n         * A getter/setter for the `Player`'s height. Returns the player's configured value.\n         * To get the current height use `currentheight()`.\n         *\n         * @param {number|string} [value]\n         *        CSS value to set the `Player`'s height to.\n         *\n         * @return {number|undefined}\n         *         - The current height of the `Player` when getting.\n         *         - Nothing when setting\n         */\n        height(value) {\n            return this.dimension('height', value);\n        }\n\n        /**\n         * A getter/setter for the `Player`'s width & height.\n         *\n         * @param {string} dimension\n         *        This string can be:\n         *        - 'width'\n         *        - 'height'\n         *\n         * @param {number|string} [value]\n         *        Value for dimension specified in the first argument.\n         *\n         * @return {number}\n         *         The dimension arguments value when getting (width/height).\n         */\n        dimension(dimension, value) {\n            const privDimension = dimension + '_';\n            if (value === undefined) {\n                return this[privDimension] || 0;\n            }\n            if (value === '' || value === 'auto') {\n                // If an empty string is given, reset the dimension to be automatic\n                this[privDimension] = undefined;\n                this.updateStyleEl_();\n                return;\n            }\n            const parsedVal = parseFloat(value);\n            if (isNaN(parsedVal)) {\n                log$1.error(`Improper value \"${value}\" supplied for for ${dimension}`);\n                return;\n            }\n            this[privDimension] = parsedVal;\n            this.updateStyleEl_();\n        }\n\n        /**\n         * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n         *\n         * Turning this on will turn off fill mode.\n         *\n         * @param {boolean} [bool]\n         *        - A value of true adds the class.\n         *        - A value of false removes the class.\n         *        - No value will be a getter.\n         *\n         * @return {boolean|undefined}\n         *         - The value of fluid when getting.\n         *         - `undefined` when setting.\n         */\n        fluid(bool) {\n            if (bool === undefined) {\n                return !!this.fluid_;\n            }\n            this.fluid_ = !!bool;\n            if (isEvented(this)) {\n                this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n            }\n            if (bool) {\n                this.addClass('vjs-fluid');\n                this.fill(false);\n                addEventedCallback(this, () => {\n                    this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n                });\n            } else {\n                this.removeClass('vjs-fluid');\n            }\n            this.updateStyleEl_();\n        }\n\n        /**\n         * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\n         *\n         * Turning this on will turn off fluid mode.\n         *\n         * @param {boolean} [bool]\n         *        - A value of true adds the class.\n         *        - A value of false removes the class.\n         *        - No value will be a getter.\n         *\n         * @return {boolean|undefined}\n         *         - The value of fluid when getting.\n         *         - `undefined` when setting.\n         */\n        fill(bool) {\n            if (bool === undefined) {\n                return !!this.fill_;\n            }\n            this.fill_ = !!bool;\n            if (bool) {\n                this.addClass('vjs-fill');\n                this.fluid(false);\n            } else {\n                this.removeClass('vjs-fill');\n            }\n        }\n\n        /**\n         * Get/Set the aspect ratio\n         *\n         * @param {string} [ratio]\n         *        Aspect ratio for player\n         *\n         * @return {string|undefined}\n         *         returns the current aspect ratio when getting\n         */\n\n        /**\n         * A getter/setter for the `Player`'s aspect ratio.\n         *\n         * @param {string} [ratio]\n         *        The value to set the `Player`'s aspect ratio to.\n         *\n         * @return {string|undefined}\n         *         - The current aspect ratio of the `Player` when getting.\n         *         - undefined when setting\n         */\n        aspectRatio(ratio) {\n            if (ratio === undefined) {\n                return this.aspectRatio_;\n            }\n\n            // Check for width:height format\n            if (!/^\\d+\\:\\d+$/.test(ratio)) {\n                throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n            }\n            this.aspectRatio_ = ratio;\n\n            // We're assuming if you set an aspect ratio you want fluid mode,\n            // because in fixed mode you could calculate width and height yourself.\n            this.fluid(true);\n            this.updateStyleEl_();\n        }\n\n        /**\n         * Update styles of the `Player` element (height, width and aspect ratio).\n         *\n         * @private\n         * @listens Tech#loadedmetadata\n         */\n        updateStyleEl_() {\n            if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n                const width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n                const height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n                const techEl = this.tech_ && this.tech_.el();\n                if (techEl) {\n                    if (width >= 0) {\n                        techEl.width = width;\n                    }\n                    if (height >= 0) {\n                        techEl.height = height;\n                    }\n                }\n                return;\n            }\n            let width;\n            let height;\n            let aspectRatio;\n            let idClass;\n\n            // The aspect ratio is either used directly or to calculate width and height.\n            if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n                // Use any aspectRatio that's been specifically set\n                aspectRatio = this.aspectRatio_;\n            } else if (this.videoWidth() > 0) {\n                // Otherwise try to get the aspect ratio from the video metadata\n                aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n            } else {\n                // Or use a default. The video element's is 2:1, but 16:9 is more common.\n                aspectRatio = '16:9';\n            }\n\n            // Get the ratio as a decimal we can use to calculate dimensions\n            const ratioParts = aspectRatio.split(':');\n            const ratioMultiplier = ratioParts[1] / ratioParts[0];\n            if (this.width_ !== undefined) {\n                // Use any width that's been specifically set\n                width = this.width_;\n            } else if (this.height_ !== undefined) {\n                // Or calculate the width from the aspect ratio if a height has been set\n                width = this.height_ / ratioMultiplier;\n            } else {\n                // Or use the video's metadata, or use the video el's default of 300\n                width = this.videoWidth() || 300;\n            }\n            if (this.height_ !== undefined) {\n                // Use any height that's been specifically set\n                height = this.height_;\n            } else {\n                // Otherwise calculate the height from the ratio and the width\n                height = width * ratioMultiplier;\n            }\n\n            // Ensure the CSS class is valid by starting with an alpha character\n            if (/^[^a-zA-Z]/.test(this.id())) {\n                idClass = 'dimensions-' + this.id();\n            } else {\n                idClass = this.id() + '-dimensions';\n            }\n\n            // Ensure the right class is still on the player for the style element\n            this.addClass(idClass);\n            setTextContent(this.styleEl_, `\n      .${idClass} {\n        width: ${width}px;\n        height: ${height}px;\n      }\n\n      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${ratioMultiplier * 100}%;\n      }\n    `);\n        }\n\n        /**\n         * Load/Create an instance of playback {@link Tech} including element\n         * and API methods. Then append the `Tech` element in `Player` as a child.\n         *\n         * @param {string} techName\n         *        name of the playback technology\n         *\n         * @param {string} source\n         *        video source\n         *\n         * @private\n         */\n        loadTech_(techName, source) {\n            // Pause and remove current playback technology\n            if (this.tech_) {\n                this.unloadTech_();\n            }\n            const titleTechName = toTitleCase$1(techName);\n            const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n            // get rid of the HTML5 video tag as soon as we are using another tech\n            if (titleTechName !== 'Html5' && this.tag) {\n                Tech.getTech('Html5').disposeMediaElement(this.tag);\n                this.tag.player = null;\n                this.tag = null;\n            }\n            this.techName_ = titleTechName;\n\n            // Turn off API access because we're loading a new tech that might load asynchronously\n            this.isReady_ = false;\n            let autoplay = this.autoplay();\n\n            // if autoplay is a string (or `true` with normalizeAutoplay: true) we pass false to the tech\n            // because the player is going to handle autoplay on `loadstart`\n            if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {\n                autoplay = false;\n            }\n\n            // Grab tech-specific options from player options and add source and parent element to use.\n            const techOptions = {\n                source,\n                autoplay,\n                'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n                'playerId': this.id(),\n                'techId': `${this.id()}_${camelTechName}_api`,\n                'playsinline': this.options_.playsinline,\n                'preload': this.options_.preload,\n                'loop': this.options_.loop,\n                'disablePictureInPicture': this.options_.disablePictureInPicture,\n                'muted': this.options_.muted,\n                'poster': this.poster(),\n                'language': this.language(),\n                'playerElIngest': this.playerElIngest_ || false,\n                'vtt.js': this.options_['vtt.js'],\n                'canOverridePoster': !!this.options_.techCanOverridePoster,\n                'enableSourceset': this.options_.enableSourceset\n            };\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                techOptions[props.getterName] = this[props.privateName];\n            });\n            Object.assign(techOptions, this.options_[titleTechName]);\n            Object.assign(techOptions, this.options_[camelTechName]);\n            Object.assign(techOptions, this.options_[techName.toLowerCase()]);\n            if (this.tag) {\n                techOptions.tag = this.tag;\n            }\n            if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n                techOptions.startTime = this.cache_.currentTime;\n            }\n\n            // Initialize tech instance\n            const TechClass = Tech.getTech(techName);\n            if (!TechClass) {\n                throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);\n            }\n            this.tech_ = new TechClass(techOptions);\n\n            // player.triggerReady is always async, so don't need this to be async\n            this.tech_.ready(bind_(this, this.handleTechReady_), true);\n            textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n            // Listen to all HTML5-defined events and trigger them on the player\n            TECH_EVENTS_RETRIGGER.forEach(event => {\n                this.on(this.tech_, event, e => this[`handleTech${toTitleCase$1(event)}_`](e));\n            });\n            Object.keys(TECH_EVENTS_QUEUE).forEach(event => {\n                this.on(this.tech_, event, eventObj => {\n                    if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {\n                        this.queuedCallbacks_.push({\n                            callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),\n                            event: eventObj\n                        });\n                        return;\n                    }\n                    this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);\n                });\n            });\n            this.on(this.tech_, 'loadstart', e => this.handleTechLoadStart_(e));\n            this.on(this.tech_, 'sourceset', e => this.handleTechSourceset_(e));\n            this.on(this.tech_, 'waiting', e => this.handleTechWaiting_(e));\n            this.on(this.tech_, 'ended', e => this.handleTechEnded_(e));\n            this.on(this.tech_, 'seeking', e => this.handleTechSeeking_(e));\n            this.on(this.tech_, 'play', e => this.handleTechPlay_(e));\n            this.on(this.tech_, 'pause', e => this.handleTechPause_(e));\n            this.on(this.tech_, 'durationchange', e => this.handleTechDurationChange_(e));\n            this.on(this.tech_, 'fullscreenchange', (e, data) => this.handleTechFullscreenChange_(e, data));\n            this.on(this.tech_, 'fullscreenerror', (e, err) => this.handleTechFullscreenError_(e, err));\n            this.on(this.tech_, 'enterpictureinpicture', e => this.handleTechEnterPictureInPicture_(e));\n            this.on(this.tech_, 'leavepictureinpicture', e => this.handleTechLeavePictureInPicture_(e));\n            this.on(this.tech_, 'error', e => this.handleTechError_(e));\n            this.on(this.tech_, 'posterchange', e => this.handleTechPosterChange_(e));\n            this.on(this.tech_, 'textdata', e => this.handleTechTextData_(e));\n            this.on(this.tech_, 'ratechange', e => this.handleTechRateChange_(e));\n            this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);\n            this.usingNativeControls(this.techGet_('controls'));\n            if (this.controls() && !this.usingNativeControls()) {\n                this.addTechControlsListeners_();\n            }\n\n            // Add the tech element in the DOM if it was not already there\n            // Make sure to not insert the original video element if using Html5\n            if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n                prependTo(this.tech_.el(), this.el());\n            }\n\n            // Get rid of the original video tag reference after the first tech is loaded\n            if (this.tag) {\n                this.tag.player = null;\n                this.tag = null;\n            }\n        }\n\n        /**\n         * Unload and dispose of the current playback {@link Tech}.\n         *\n         * @private\n         */\n        unloadTech_() {\n            // Save the current text tracks so that we can reuse the same text tracks with the next tech\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                this[props.privateName] = this[props.getterName]();\n            });\n            this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n            this.isReady_ = false;\n            this.tech_.dispose();\n            this.tech_ = false;\n            if (this.isPosterFromTech_) {\n                this.poster_ = '';\n                this.trigger('posterchange');\n            }\n            this.isPosterFromTech_ = false;\n        }\n\n        /**\n         * Return a reference to the current {@link Tech}.\n         * It will print a warning by default about the danger of using the tech directly\n         * but any argument that is passed in will silence the warning.\n         *\n         * @param {*} [safety]\n         *        Anything passed in to silence the warning\n         *\n         * @return {Tech}\n         *         The Tech\n         */\n        tech(safety) {\n            if (safety === undefined) {\n                log$1.warn('Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\\n');\n            }\n            return this.tech_;\n        }\n\n        /**\n         * An object that contains Video.js version.\n         *\n         * @typedef {Object} PlayerVersion\n         *\n         * @property {string} 'video.js' - Video.js version\n         */\n\n        /**\n         * Returns an object with Video.js version.\n         *\n         * @return {PlayerVersion}\n         *          An object with Video.js version.\n         */\n        version() {\n            return {\n                'video.js': version$5\n            };\n        }\n\n        /**\n         * Set up click and touch listeners for the playback element\n         *\n         * - On desktops: a click on the video itself will toggle playback\n         * - On mobile devices: a click on the video toggles controls\n         *   which is done by toggling the user state between active and\n         *   inactive\n         * - A tap can signal that a user has become active or has become inactive\n         *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n         *   quick tap should hide them again (signaling the user is in an inactive\n         *   viewing state)\n         * - In addition to this, we still want the user to be considered inactive after\n         *   a few seconds of inactivity.\n         *\n         * > Note: the only part of iOS interaction we can't mimic with this setup\n         * is a touch and hold on the video element counting as activity in order to\n         * keep the controls showing, but that shouldn't be an issue. A touch and hold\n         * on any controls will still keep the user active\n         *\n         * @private\n         */\n        addTechControlsListeners_() {\n            // Make sure to remove all the previous listeners in case we are called multiple times.\n            this.removeTechControlsListeners_();\n            this.on(this.tech_, 'click', this.boundHandleTechClick_);\n            this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n\n            // If the controls were hidden we don't want that to change without a tap event\n            // so we'll check if the controls were already showing before reporting user\n            // activity\n            this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n            this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n            this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n\n            // The tap listener needs to come after the touchend listener because the tap\n            // listener cancels out any reportedUserActivity when setting userActive(false)\n            this.on(this.tech_, 'tap', this.boundHandleTechTap_);\n        }\n\n        /**\n         * Remove the listeners used for click and tap controls. This is needed for\n         * toggling to controls disabled, where a tap/touch should do nothing.\n         *\n         * @private\n         */\n        removeTechControlsListeners_() {\n            // We don't want to just use `this.off()` because there might be other needed\n            // listeners added by techs that extend this.\n            this.off(this.tech_, 'tap', this.boundHandleTechTap_);\n            this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n            this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n            this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n            this.off(this.tech_, 'click', this.boundHandleTechClick_);\n            this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n        }\n\n        /**\n         * Player waits for the tech to be ready\n         *\n         * @private\n         */\n        handleTechReady_() {\n            this.triggerReady();\n\n            // Keep the same volume as before\n            if (this.cache_.volume) {\n                this.techCall_('setVolume', this.cache_.volume);\n            }\n\n            // Look if the tech found a higher resolution poster while loading\n            this.handleTechPosterChange_();\n\n            // Update the duration if available\n            this.handleTechDurationChange_();\n        }\n\n        /**\n         * Retrigger the `loadstart` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#loadstart\n         * @listens Tech#loadstart\n         * @private\n         */\n        handleTechLoadStart_() {\n            // TODO: Update to use `emptied` event instead. See #1277.\n\n            this.removeClass('vjs-ended', 'vjs-seeking');\n\n            // reset the error state\n            this.error(null);\n\n            // Update the duration\n            this.handleTechDurationChange_();\n            if (!this.paused()) {\n                /**\n                 * Fired when the user agent begins looking for media data\n                 *\n                 * @event Player#loadstart\n                 * @type {Event}\n                 */\n                this.trigger('loadstart');\n            } else {\n                // reset the hasStarted state\n                this.hasStarted(false);\n                this.trigger('loadstart');\n            }\n\n            // autoplay happens after loadstart for the browser,\n            // so we mimic that behavior\n            this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());\n        }\n\n        /**\n         * Handle autoplay string values, rather than the typical boolean\n         * values that should be handled by the tech. Note that this is not\n         * part of any specification. Valid values and what they do can be\n         * found on the autoplay getter at Player#autoplay()\n         */\n        manualAutoplay_(type) {\n            if (!this.tech_ || typeof type !== 'string') {\n                return;\n            }\n\n            // Save original muted() value, set muted to true, and attempt to play().\n            // On promise rejection, restore muted from saved value\n            const resolveMuted = () => {\n                const previouslyMuted = this.muted();\n                this.muted(true);\n                const restoreMuted = () => {\n                    this.muted(previouslyMuted);\n                };\n\n                // restore muted on play terminatation\n                this.playTerminatedQueue_.push(restoreMuted);\n                const mutedPromise = this.play();\n                if (!isPromise(mutedPromise)) {\n                    return;\n                }\n                return mutedPromise.catch(err => {\n                    restoreMuted();\n                    throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ''}`);\n                });\n            };\n            let promise;\n\n            // if muted defaults to true\n            // the only thing we can do is call play\n            if (type === 'any' && !this.muted()) {\n                promise = this.play();\n                if (isPromise(promise)) {\n                    promise = promise.catch(resolveMuted);\n                }\n            } else if (type === 'muted' && !this.muted()) {\n                promise = resolveMuted();\n            } else {\n                promise = this.play();\n            }\n            if (!isPromise(promise)) {\n                return;\n            }\n            return promise.then(() => {\n                this.trigger({\n                    type: 'autoplay-success',\n                    autoplay: type\n                });\n            }).catch(() => {\n                this.trigger({\n                    type: 'autoplay-failure',\n                    autoplay: type\n                });\n            });\n        }\n\n        /**\n         * Update the internal source caches so that we return the correct source from\n         * `src()`, `currentSource()`, and `currentSources()`.\n         *\n         * > Note: `currentSources` will not be updated if the source that is passed in exists\n         *         in the current `currentSources` cache.\n         *\n         *\n         * @param {Tech~SourceObject} srcObj\n         *        A string or object source to update our caches to.\n         */\n        updateSourceCaches_(srcObj = '') {\n            let src = srcObj;\n            let type = '';\n            if (typeof src !== 'string') {\n                src = srcObj.src;\n                type = srcObj.type;\n            }\n\n            // make sure all the caches are set to default values\n            // to prevent null checking\n            this.cache_.source = this.cache_.source || {};\n            this.cache_.sources = this.cache_.sources || [];\n\n            // try to get the type of the src that was passed in\n            if (src && !type) {\n                type = findMimetype(this, src);\n            }\n\n            // update `currentSource` cache always\n            this.cache_.source = merge$2({}, srcObj, {\n                src,\n                type\n            });\n            const matchingSources = this.cache_.sources.filter(s => s.src && s.src === src);\n            const sourceElSources = [];\n            const sourceEls = this.$$('source');\n            const matchingSourceEls = [];\n            for (let i = 0; i < sourceEls.length; i++) {\n                const sourceObj = getAttributes(sourceEls[i]);\n                sourceElSources.push(sourceObj);\n                if (sourceObj.src && sourceObj.src === src) {\n                    matchingSourceEls.push(sourceObj.src);\n                }\n            }\n\n            // if we have matching source els but not matching sources\n            // the current source cache is not up to date\n            if (matchingSourceEls.length && !matchingSources.length) {\n                this.cache_.sources = sourceElSources;\n                // if we don't have matching source or source els set the\n                // sources cache to the `currentSource` cache\n            } else if (!matchingSources.length) {\n                this.cache_.sources = [this.cache_.source];\n            }\n\n            // update the tech `src` cache\n            this.cache_.src = src;\n        }\n\n        /**\n         * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n         * causing the media element to reload.\n         *\n         * It will fire for the initial source and each subsequent source.\n         * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n         *\n         * The event object for this event contains a `src` property that will contain the source\n         * that was available when the event was triggered. This is generally only necessary if Video.js\n         * is switching techs while the source was being changed.\n         *\n         * It is also fired when `load` is called on the player (or media element)\n         * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n         * says that the resource selection algorithm needs to be aborted and restarted.\n         * In this case, it is very likely that the `src` property will be set to the\n         * empty string `\"\"` to indicate we do not know what the source will be but\n         * that it is changing.\n         *\n         * *This event is currently still experimental and may change in minor releases.*\n         * __To use this, pass `enableSourceset` option to the player.__\n         *\n         * @event Player#sourceset\n         * @type {Event}\n         * @prop {string} src\n         *                The source url available when the `sourceset` was triggered.\n         *                It will be an empty string if we cannot know what the source is\n         *                but know that the source will change.\n         */\n        /**\n         * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#sourceset\n         * @listens Tech#sourceset\n         * @private\n         */\n        handleTechSourceset_(event) {\n            // only update the source cache when the source\n            // was not updated using the player api\n            if (!this.changingSrc_) {\n                let updateSourceCaches = src => this.updateSourceCaches_(src);\n                const playerSrc = this.currentSource().src;\n                const eventSrc = event.src;\n\n                // if we have a playerSrc that is not a blob, and a tech src that is a blob\n                if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\n                    // if both the tech source and the player source were updated we assume\n                    // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\n                    if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\n                        updateSourceCaches = () => {};\n                    }\n                }\n\n                // update the source to the initial source right away\n                // in some cases this will be empty string\n                updateSourceCaches(eventSrc);\n\n                // if the `sourceset` `src` was an empty string\n                // wait for a `loadstart` to update the cache to `currentSrc`.\n                // If a sourceset happens before a `loadstart`, we reset the state\n                if (!event.src) {\n                    this.tech_.any(['sourceset', 'loadstart'], e => {\n                        // if a sourceset happens before a `loadstart` there\n                        // is nothing to do as this `handleTechSourceset_`\n                        // will be called again and this will be handled there.\n                        if (e.type === 'sourceset') {\n                            return;\n                        }\n                        const techSrc = this.techGet_('currentSrc');\n                        this.lastSource_.tech = techSrc;\n                        this.updateSourceCaches_(techSrc);\n                    });\n                }\n            }\n            this.lastSource_ = {\n                player: this.currentSource().src,\n                tech: event.src\n            };\n            this.trigger({\n                src: event.src,\n                type: 'sourceset'\n            });\n        }\n\n        /**\n         * Add/remove the vjs-has-started class\n         *\n         *\n         * @param {boolean} request\n         *        - true: adds the class\n         *        - false: remove the class\n         *\n         * @return {boolean}\n         *         the boolean value of hasStarted_\n         */\n        hasStarted(request) {\n            if (request === undefined) {\n                // act as getter, if we have no request to change\n                return this.hasStarted_;\n            }\n            if (request === this.hasStarted_) {\n                return;\n            }\n            this.hasStarted_ = request;\n            if (this.hasStarted_) {\n                this.addClass('vjs-has-started');\n            } else {\n                this.removeClass('vjs-has-started');\n            }\n        }\n\n        /**\n         * Fired whenever the media begins or resumes playback\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n         * @fires Player#play\n         * @listens Tech#play\n         * @private\n         */\n        handleTechPlay_() {\n            this.removeClass('vjs-ended', 'vjs-paused');\n            this.addClass('vjs-playing');\n\n            // hide the poster when the user hits play\n            this.hasStarted(true);\n            /**\n             * Triggered whenever an {@link Tech#play} event happens. Indicates that\n             * playback has started or resumed.\n             *\n             * @event Player#play\n             * @type {Event}\n             */\n            this.trigger('play');\n        }\n\n        /**\n         * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n         *\n         * If there were any events queued while the playback rate was zero, fire\n         * those events now.\n         *\n         * @private\n         * @method Player#handleTechRateChange_\n         * @fires Player#ratechange\n         * @listens Tech#ratechange\n         */\n        handleTechRateChange_() {\n            if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n                this.queuedCallbacks_.forEach(queued => queued.callback(queued.event));\n                this.queuedCallbacks_ = [];\n            }\n            this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n            /**\n             * Fires when the playing speed of the audio/video is changed\n             *\n             * @event Player#ratechange\n             * @type {event}\n             */\n            this.trigger('ratechange');\n        }\n\n        /**\n         * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#waiting\n         * @listens Tech#waiting\n         * @private\n         */\n        handleTechWaiting_() {\n            this.addClass('vjs-waiting');\n            /**\n             * A readyState change on the DOM element has caused playback to stop.\n             *\n             * @event Player#waiting\n             * @type {Event}\n             */\n            this.trigger('waiting');\n\n            // Browsers may emit a timeupdate event after a waiting event. In order to prevent\n            // premature removal of the waiting class, wait for the time to change.\n            const timeWhenWaiting = this.currentTime();\n            const timeUpdateListener = () => {\n                if (timeWhenWaiting !== this.currentTime()) {\n                    this.removeClass('vjs-waiting');\n                    this.off('timeupdate', timeUpdateListener);\n                }\n            };\n            this.on('timeupdate', timeUpdateListener);\n        }\n\n        /**\n         * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n         * > Note: This is not consistent between browsers. See #1351\n         *\n         * @fires Player#canplay\n         * @listens Tech#canplay\n         * @private\n         */\n        handleTechCanPlay_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media has a readyState of HAVE_FUTURE_DATA or greater.\n             *\n             * @event Player#canplay\n             * @type {Event}\n             */\n            this.trigger('canplay');\n        }\n\n        /**\n         * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#canplaythrough\n         * @listens Tech#canplaythrough\n         * @private\n         */\n        handleTechCanPlayThrough_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n             * entire media file can be played without buffering.\n             *\n             * @event Player#canplaythrough\n             * @type {Event}\n             */\n            this.trigger('canplaythrough');\n        }\n\n        /**\n         * Retrigger the `playing` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#playing\n         * @listens Tech#playing\n         * @private\n         */\n        handleTechPlaying_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media is no longer blocked from playback, and has started playing.\n             *\n             * @event Player#playing\n             * @type {Event}\n             */\n            this.trigger('playing');\n        }\n\n        /**\n         * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#seeking\n         * @listens Tech#seeking\n         * @private\n         */\n        handleTechSeeking_() {\n            this.addClass('vjs-seeking');\n            /**\n             * Fired whenever the player is jumping to a new time\n             *\n             * @event Player#seeking\n             * @type {Event}\n             */\n            this.trigger('seeking');\n        }\n\n        /**\n         * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#seeked\n         * @listens Tech#seeked\n         * @private\n         */\n        handleTechSeeked_() {\n            this.removeClass('vjs-seeking', 'vjs-ended');\n            /**\n             * Fired when the player has finished jumping to a new time\n             *\n             * @event Player#seeked\n             * @type {Event}\n             */\n            this.trigger('seeked');\n        }\n\n        /**\n         * Retrigger the `pause` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#pause\n         * @listens Tech#pause\n         * @private\n         */\n        handleTechPause_() {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-paused');\n            /**\n             * Fired whenever the media has been paused\n             *\n             * @event Player#pause\n             * @type {Event}\n             */\n            this.trigger('pause');\n        }\n\n        /**\n         * Retrigger the `ended` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#ended\n         * @listens Tech#ended\n         * @private\n         */\n        handleTechEnded_() {\n            this.addClass('vjs-ended');\n            this.removeClass('vjs-waiting');\n            if (this.options_.loop) {\n                this.currentTime(0);\n                this.play();\n            } else if (!this.paused()) {\n                this.pause();\n            }\n\n            /**\n             * Fired when the end of the media resource is reached (currentTime == duration)\n             *\n             * @event Player#ended\n             * @type {Event}\n             */\n            this.trigger('ended');\n        }\n\n        /**\n         * Fired when the duration of the media resource is first known or changed\n         *\n         * @listens Tech#durationchange\n         * @private\n         */\n        handleTechDurationChange_() {\n            this.duration(this.techGet_('duration'));\n        }\n\n        /**\n         * Handle a click on the media element to play/pause\n         *\n         * @param {Event} event\n         *        the event that caused this function to trigger\n         *\n         * @listens Tech#click\n         * @private\n         */\n        handleTechClick_(event) {\n            // When controls are disabled a click should not toggle playback because\n            // the click is considered a control\n            if (!this.controls_) {\n                return;\n            }\n            if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {\n                if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {\n                    this.options_.userActions.click.call(this, event);\n                } else if (this.paused()) {\n                    silencePromise(this.play());\n                } else {\n                    this.pause();\n                }\n            }\n        }\n\n        /**\n         * Handle a double-click on the media element to enter/exit fullscreen\n         *\n         * @param {Event} event\n         *        the event that caused this function to trigger\n         *\n         * @listens Tech#dblclick\n         * @private\n         */\n        handleTechDoubleClick_(event) {\n            if (!this.controls_) {\n                return;\n            }\n\n            // we do not want to toggle fullscreen state\n            // when double-clicking inside a control bar or a modal\n            const inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), el => el.contains(event.target));\n            if (!inAllowedEls) {\n                /*\n         * options.userActions.doubleClick\n         *\n         * If `undefined` or `true`, double-click toggles fullscreen if controls are present\n         * Set to `false` to disable double-click handling\n         * Set to a function to substitute an external double-click handler\n         */\n                if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {\n                    if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {\n                        this.options_.userActions.doubleClick.call(this, event);\n                    } else if (this.isFullscreen()) {\n                        this.exitFullscreen();\n                    } else {\n                        this.requestFullscreen();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Handle a tap on the media element. It will toggle the user\n         * activity state, which hides and shows the controls.\n         *\n         * @listens Tech#tap\n         * @private\n         */\n        handleTechTap_() {\n            this.userActive(!this.userActive());\n        }\n\n        /**\n         * Handle touch to start\n         *\n         * @listens Tech#touchstart\n         * @private\n         */\n        handleTechTouchStart_() {\n            this.userWasActive = this.userActive();\n        }\n\n        /**\n         * Handle touch to move\n         *\n         * @listens Tech#touchmove\n         * @private\n         */\n        handleTechTouchMove_() {\n            if (this.userWasActive) {\n                this.reportUserActivity();\n            }\n        }\n\n        /**\n         * Handle touch to end\n         *\n         * @param {Event} event\n         *        the touchend event that triggered\n         *        this function\n         *\n         * @listens Tech#touchend\n         * @private\n         */\n        handleTechTouchEnd_(event) {\n            // Stop the mouse events from also happening\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * @private\n         */\n        toggleFullscreenClass_() {\n            if (this.isFullscreen()) {\n                this.addClass('vjs-fullscreen');\n            } else {\n                this.removeClass('vjs-fullscreen');\n            }\n        }\n\n        /**\n         * when the document fschange event triggers it calls this\n         */\n        documentFullscreenChange_(e) {\n            const targetPlayer = e.target.player;\n\n            // if another player was fullscreen\n            // do a null check for targetPlayer because older firefox's would put document as e.target\n            if (targetPlayer && targetPlayer !== this) {\n                return;\n            }\n            const el = this.el();\n            let isFs = document[this.fsApi_.fullscreenElement] === el;\n            if (!isFs && el.matches) {\n                isFs = el.matches(':' + this.fsApi_.fullscreen);\n            }\n            this.isFullscreen(isFs);\n        }\n\n        /**\n         * Handle Tech Fullscreen Change\n         *\n         * @param {Event} event\n         *        the fullscreenchange event that triggered this function\n         *\n         * @param {Object} data\n         *        the data that was sent with the event\n         *\n         * @private\n         * @listens Tech#fullscreenchange\n         * @fires Player#fullscreenchange\n         */\n        handleTechFullscreenChange_(event, data) {\n            if (data) {\n                if (data.nativeIOSFullscreen) {\n                    this.addClass('vjs-ios-native-fs');\n                    this.tech_.one('webkitendfullscreen', () => {\n                        this.removeClass('vjs-ios-native-fs');\n                    });\n                }\n                this.isFullscreen(data.isFullscreen);\n            }\n        }\n        handleTechFullscreenError_(event, err) {\n            this.trigger('fullscreenerror', err);\n        }\n\n        /**\n         * @private\n         */\n        togglePictureInPictureClass_() {\n            if (this.isInPictureInPicture()) {\n                this.addClass('vjs-picture-in-picture');\n            } else {\n                this.removeClass('vjs-picture-in-picture');\n            }\n        }\n\n        /**\n         * Handle Tech Enter Picture-in-Picture.\n         *\n         * @param {Event} event\n         *        the enterpictureinpicture event that triggered this function\n         *\n         * @private\n         * @listens Tech#enterpictureinpicture\n         */\n        handleTechEnterPictureInPicture_(event) {\n            this.isInPictureInPicture(true);\n        }\n\n        /**\n         * Handle Tech Leave Picture-in-Picture.\n         *\n         * @param {Event} event\n         *        the leavepictureinpicture event that triggered this function\n         *\n         * @private\n         * @listens Tech#leavepictureinpicture\n         */\n        handleTechLeavePictureInPicture_(event) {\n            this.isInPictureInPicture(false);\n        }\n\n        /**\n         * Fires when an error occurred during the loading of an audio/video.\n         *\n         * @private\n         * @listens Tech#error\n         */\n        handleTechError_() {\n            const error = this.tech_.error();\n            if (error) {\n                this.error(error);\n            }\n        }\n\n        /**\n         * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#textdata\n         * @listens Tech#textdata\n         * @private\n         */\n        handleTechTextData_() {\n            let data = null;\n            if (arguments.length > 1) {\n                data = arguments[1];\n            }\n\n            /**\n             * Fires when we get a textdata event from tech\n             *\n             * @event Player#textdata\n             * @type {Event}\n             */\n            this.trigger('textdata', data);\n        }\n\n        /**\n         * Get object for cached values.\n         *\n         * @return {Object}\n         *         get the current object cache\n         */\n        getCache() {\n            return this.cache_;\n        }\n\n        /**\n         * Resets the internal cache object.\n         *\n         * Using this function outside the player constructor or reset method may\n         * have unintended side-effects.\n         *\n         * @private\n         */\n        resetCache_() {\n            this.cache_ = {\n                // Right now, the currentTime is not _really_ cached because it is always\n                // retrieved from the tech (see: currentTime). However, for completeness,\n                // we set it to zero here to ensure that if we do start actually caching\n                // it, we reset it along with everything else.\n                currentTime: 0,\n                initTime: 0,\n                inactivityTimeout: this.options_.inactivityTimeout,\n                duration: NaN,\n                lastVolume: 1,\n                lastPlaybackRate: this.defaultPlaybackRate(),\n                media: null,\n                src: '',\n                source: {},\n                sources: [],\n                playbackRates: [],\n                volume: 1\n            };\n        }\n\n        /**\n         * Pass values to the playback tech\n         *\n         * @param {string} [method]\n         *        the method to call\n         *\n         * @param {Object} [arg]\n         *        the argument to pass\n         *\n         * @private\n         */\n        techCall_(method, arg) {\n            // If it's not ready yet, call method when it is\n\n            this.ready(function () {\n                if (method in allowedSetters) {\n                    return set(this.middleware_, this.tech_, method, arg);\n                } else if (method in allowedMediators) {\n                    return mediate(this.middleware_, this.tech_, method, arg);\n                }\n                try {\n                    if (this.tech_) {\n                        this.tech_[method](arg);\n                    }\n                } catch (e) {\n                    log$1(e);\n                    throw e;\n                }\n            }, true);\n        }\n\n        /**\n         * Mediate attempt to call playback tech method\n         * and return the value of the method called.\n         *\n         * @param {string} method\n         *        Tech method\n         *\n         * @return {*}\n         *         Value returned by the tech method called, undefined if tech\n         *         is not ready or tech method is not present\n         *\n         * @private\n         */\n        techGet_(method) {\n            if (!this.tech_ || !this.tech_.isReady_) {\n                return;\n            }\n            if (method in allowedGetters) {\n                return get(this.middleware_, this.tech_, method);\n            } else if (method in allowedMediators) {\n                return mediate(this.middleware_, this.tech_, method);\n            }\n\n            // Log error when playback tech object is present but method\n            // is undefined or unavailable\n            try {\n                return this.tech_[method]();\n            } catch (e) {\n                // When building additional tech libs, an expected method may not be defined yet\n                if (this.tech_[method] === undefined) {\n                    log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);\n                    throw e;\n                }\n\n                // When a method isn't available on the object it throws a TypeError\n                if (e.name === 'TypeError') {\n                    log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);\n                    this.tech_.isReady_ = false;\n                    throw e;\n                }\n\n                // If error unknown, just log and throw\n                log$1(e);\n                throw e;\n            }\n        }\n\n        /**\n         * Attempt to begin playback at the first opportunity.\n         *\n         * @return {Promise|undefined}\n         *         Returns a promise if the browser supports Promises (or one\n         *         was passed in as an option). This promise will be resolved on\n         *         the return value of play. If this is undefined it will fulfill the\n         *         promise chain otherwise the promise chain will be fulfilled when\n         *         the promise from play is fulfilled.\n         */\n        play() {\n            return new Promise(resolve => {\n                this.play_(resolve);\n            });\n        }\n\n        /**\n         * The actual logic for play, takes a callback that will be resolved on the\n         * return value of play. This allows us to resolve to the play promise if there\n         * is one on modern browsers.\n         *\n         * @private\n         * @param {Function} [callback]\n         *        The callback that should be called when the techs play is actually called\n         */\n        play_(callback = silencePromise) {\n            this.playCallbacks_.push(callback);\n            const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));\n            const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);\n\n            // treat calls to play_ somewhat like the `one` event function\n            if (this.waitToPlay_) {\n                this.off(['ready', 'loadstart'], this.waitToPlay_);\n                this.waitToPlay_ = null;\n            }\n\n            // if the player/tech is not ready or the src itself is not ready\n            // queue up a call to play on `ready` or `loadstart`\n            if (!this.isReady_ || !isSrcReady) {\n                this.waitToPlay_ = e => {\n                    this.play_();\n                };\n                this.one(['ready', 'loadstart'], this.waitToPlay_);\n\n                // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod\n                // in that case, we need to prime the video element by calling load so it'll be ready in time\n                if (!isSrcReady && isSafariOrIOS) {\n                    this.load();\n                }\n                return;\n            }\n\n            // If the player/tech is ready and we have a source, we can attempt playback.\n            const val = this.techGet_('play');\n\n            // For native playback, reset the progress bar if we get a play call from a replay.\n            const isNativeReplay = isSafariOrIOS && this.hasClass('vjs-ended');\n            if (isNativeReplay) {\n                this.resetProgressBar_();\n            }\n            // play was terminated if the returned value is null\n            if (val === null) {\n                this.runPlayTerminatedQueue_();\n            } else {\n                this.runPlayCallbacks_(val);\n            }\n        }\n\n        /**\n         * These functions will be run when if play is terminated. If play\n         * runPlayCallbacks_ is run these function will not be run. This allows us\n         * to differentiate between a terminated play and an actual call to play.\n         */\n        runPlayTerminatedQueue_() {\n            const queue = this.playTerminatedQueue_.slice(0);\n            this.playTerminatedQueue_ = [];\n            queue.forEach(function (q) {\n                q();\n            });\n        }\n\n        /**\n         * When a callback to play is delayed we have to run these\n         * callbacks when play is actually called on the tech. This function\n         * runs the callbacks that were delayed and accepts the return value\n         * from the tech.\n         *\n         * @param {undefined|Promise} val\n         *        The return value from the tech.\n         */\n        runPlayCallbacks_(val) {\n            const callbacks = this.playCallbacks_.slice(0);\n            this.playCallbacks_ = [];\n            // clear play terminatedQueue since we finished a real play\n            this.playTerminatedQueue_ = [];\n            callbacks.forEach(function (cb) {\n                cb(val);\n            });\n        }\n\n        /**\n         * Pause the video playback\n         */\n        pause() {\n            this.techCall_('pause');\n        }\n\n        /**\n         * Check if the player is paused or has yet to play\n         *\n         * @return {boolean}\n         *         - false: if the media is currently playing\n         *         - true: if media is not currently playing\n         */\n        paused() {\n            // The initial state of paused should be true (in Safari it's actually false)\n            return this.techGet_('paused') === false ? false : true;\n        }\n\n        /**\n         * Get a TimeRange object representing the current ranges of time that the user\n         * has played.\n         *\n         * @return { import('./utils/time').TimeRange }\n         *         A time range object that represents all the increments of time that have\n         *         been played.\n         */\n        played() {\n            return this.techGet_('played') || createTimeRanges$1(0, 0);\n        }\n\n        /**\n         * Sets or returns whether or not the user is \"scrubbing\". Scrubbing is\n         * when the user has clicked the progress bar handle and is\n         * dragging it along the progress bar.\n         *\n         * @param {boolean} [isScrubbing]\n         *        whether the user is or is not scrubbing\n         *\n         * @return {boolean|undefined}\n         *         - The value of scrubbing when getting\n         *         - Nothing when setting\n         */\n        scrubbing(isScrubbing) {\n            if (typeof isScrubbing === 'undefined') {\n                return this.scrubbing_;\n            }\n            this.scrubbing_ = !!isScrubbing;\n            this.techCall_('setScrubbing', this.scrubbing_);\n            if (isScrubbing) {\n                this.addClass('vjs-scrubbing');\n            } else {\n                this.removeClass('vjs-scrubbing');\n            }\n        }\n\n        /**\n         * Get or set the current time (in seconds)\n         *\n         * @param {number|string} [seconds]\n         *        The time to seek to in seconds\n         *\n         * @return {number|undefined}\n         *         - the current time in seconds when getting\n         *         - Nothing when setting\n         */\n        currentTime(seconds) {\n            if (seconds === undefined) {\n                // cache last currentTime and return. default to 0 seconds\n                //\n                // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n                // currentTime when scrubbing, but may not provide much performance benefit after all.\n                // Should be tested. Also something has to read the actual current time or the cache will\n                // never get updated.\n                this.cache_.currentTime = this.techGet_('currentTime') || 0;\n                return this.cache_.currentTime;\n            }\n            if (seconds < 0) {\n                seconds = 0;\n            }\n            if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {\n                this.cache_.initTime = seconds;\n                this.off('canplay', this.boundApplyInitTime_);\n                this.one('canplay', this.boundApplyInitTime_);\n                return;\n            }\n            this.techCall_('setCurrentTime', seconds);\n            this.cache_.initTime = 0;\n            if (isFinite(seconds)) {\n                this.cache_.currentTime = Number(seconds);\n            }\n        }\n\n        /**\n         * Apply the value of initTime stored in cache as currentTime.\n         *\n         * @private\n         */\n        applyInitTime_() {\n            this.currentTime(this.cache_.initTime);\n        }\n\n        /**\n         * Normally gets the length in time of the video in seconds;\n         * in all but the rarest use cases an argument will NOT be passed to the method\n         *\n         * > **NOTE**: The video must have started loading before the duration can be\n         * known, and depending on preload behaviour may not be known until the video starts\n         * playing.\n         *\n         * @fires Player#durationchange\n         *\n         * @param {number} [seconds]\n         *        The duration of the video to set in seconds\n         *\n         * @return {number|undefined}\n         *         - The duration of the video in seconds when getting\n         *         - Nothing when setting\n         */\n        duration(seconds) {\n            if (seconds === undefined) {\n                // return NaN if the duration is not known\n                return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n            }\n            seconds = parseFloat(seconds);\n\n            // Standardize on Infinity for signaling video is live\n            if (seconds < 0) {\n                seconds = Infinity;\n            }\n            if (seconds !== this.cache_.duration) {\n                // Cache the last set value for optimized scrubbing\n                this.cache_.duration = seconds;\n                if (seconds === Infinity) {\n                    this.addClass('vjs-live');\n                } else {\n                    this.removeClass('vjs-live');\n                }\n                if (!isNaN(seconds)) {\n                    // Do not fire durationchange unless the duration value is known.\n                    // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n\n                    /**\n                     * @event Player#durationchange\n                     * @type {Event}\n                     */\n                    this.trigger('durationchange');\n                }\n            }\n        }\n\n        /**\n         * Calculates how much time is left in the video. Not part\n         * of the native video API.\n         *\n         * @return {number}\n         *         The time remaining in seconds\n         */\n        remainingTime() {\n            return this.duration() - this.currentTime();\n        }\n\n        /**\n         * A remaining time function that is intended to be used when\n         * the time is to be displayed directly to the user.\n         *\n         * @return {number}\n         *         The rounded time remaining in seconds\n         */\n        remainingTimeDisplay() {\n            return Math.floor(this.duration()) - Math.floor(this.currentTime());\n        }\n\n        //\n        // Kind of like an array of portions of the video that have been downloaded.\n\n        /**\n         * Get a TimeRange object with an array of the times of the video\n         * that have been downloaded. If you just want the percent of the\n         * video that's been downloaded, use bufferedPercent.\n         *\n         * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n         *\n         * @return { import('./utils/time').TimeRange }\n         *         A mock {@link TimeRanges} object (following HTML spec)\n         */\n        buffered() {\n            let buffered = this.techGet_('buffered');\n            if (!buffered || !buffered.length) {\n                buffered = createTimeRanges$1(0, 0);\n            }\n            return buffered;\n        }\n\n        /**\n         * Get the TimeRanges of the media that are currently available\n         * for seeking to.\n         *\n         * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}\n         *\n         * @return { import('./utils/time').TimeRange }\n         *         A mock {@link TimeRanges} object (following HTML spec)\n         */\n        seekable() {\n            let seekable = this.techGet_('seekable');\n            if (!seekable || !seekable.length) {\n                seekable = createTimeRanges$1(0, 0);\n            }\n            return seekable;\n        }\n\n        /**\n         * Returns whether the player is in the \"seeking\" state.\n         *\n         * @return {boolean} True if the player is in the seeking state, false if not.\n         */\n        seeking() {\n            return this.techGet_('seeking');\n        }\n\n        /**\n         * Returns whether the player is in the \"ended\" state.\n         *\n         * @return {boolean} True if the player is in the ended state, false if not.\n         */\n        ended() {\n            return this.techGet_('ended');\n        }\n\n        /**\n         * Returns the current state of network activity for the element, from\n         * the codes in the list below.\n         * - NETWORK_EMPTY (numeric value 0)\n         *   The element has not yet been initialised. All attributes are in\n         *   their initial states.\n         * - NETWORK_IDLE (numeric value 1)\n         *   The element's resource selection algorithm is active and has\n         *   selected a resource, but it is not actually using the network at\n         *   this time.\n         * - NETWORK_LOADING (numeric value 2)\n         *   The user agent is actively trying to download data.\n         * - NETWORK_NO_SOURCE (numeric value 3)\n         *   The element's resource selection algorithm is active, but it has\n         *   not yet found a resource to use.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n         * @return {number} the current network activity state\n         */\n        networkState() {\n            return this.techGet_('networkState');\n        }\n\n        /**\n         * Returns a value that expresses the current state of the element\n         * with respect to rendering the current playback position, from the\n         * codes in the list below.\n         * - HAVE_NOTHING (numeric value 0)\n         *   No information regarding the media resource is available.\n         * - HAVE_METADATA (numeric value 1)\n         *   Enough of the resource has been obtained that the duration of the\n         *   resource is available.\n         * - HAVE_CURRENT_DATA (numeric value 2)\n         *   Data for the immediate current playback position is available.\n         * - HAVE_FUTURE_DATA (numeric value 3)\n         *   Data for the immediate current playback position is available, as\n         *   well as enough data for the user agent to advance the current\n         *   playback position in the direction of playback.\n         * - HAVE_ENOUGH_DATA (numeric value 4)\n         *   The user agent estimates that enough data is available for\n         *   playback to proceed uninterrupted.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n         * @return {number} the current playback rendering state\n         */\n        readyState() {\n            return this.techGet_('readyState');\n        }\n\n        /**\n         * Get the percent (as a decimal) of the video that's been downloaded.\n         * This method is not a part of the native HTML video API.\n         *\n         * @return {number}\n         *         A decimal between 0 and 1 representing the percent\n         *         that is buffered 0 being 0% and 1 being 100%\n         */\n        bufferedPercent() {\n            return bufferedPercent(this.buffered(), this.duration());\n        }\n\n        /**\n         * Get the ending time of the last buffered time range\n         * This is used in the progress bar to encapsulate all time ranges.\n         *\n         * @return {number}\n         *         The end of the last buffered time range\n         */\n        bufferedEnd() {\n            const buffered = this.buffered();\n            const duration = this.duration();\n            let end = buffered.end(buffered.length - 1);\n            if (end > duration) {\n                end = duration;\n            }\n            return end;\n        }\n\n        /**\n         * Get or set the current volume of the media\n         *\n         * @param  {number} [percentAsDecimal]\n         *         The new volume as a decimal percent:\n         *         - 0 is muted/0%/off\n         *         - 1.0 is 100%/full\n         *         - 0.5 is half volume or 50%\n         *\n         * @return {number|undefined}\n         *         The current volume as a percent when getting\n         */\n        volume(percentAsDecimal) {\n            let vol;\n            if (percentAsDecimal !== undefined) {\n                // Force value to between 0 and 1\n                vol = Math.max(0, Math.min(1, percentAsDecimal));\n                this.cache_.volume = vol;\n                this.techCall_('setVolume', vol);\n                if (vol > 0) {\n                    this.lastVolume_(vol);\n                }\n                return;\n            }\n\n            // Default to 1 when returning current volume.\n            vol = parseFloat(this.techGet_('volume'));\n            return isNaN(vol) ? 1 : vol;\n        }\n\n        /**\n         * Get the current muted state, or turn mute on or off\n         *\n         * @param {boolean} [muted]\n         *        - true to mute\n         *        - false to unmute\n         *\n         * @return {boolean|undefined}\n         *         - true if mute is on and getting\n         *         - false if mute is off and getting\n         *         - nothing if setting\n         */\n        muted(muted) {\n            if (muted !== undefined) {\n                this.techCall_('setMuted', muted);\n                return;\n            }\n            return this.techGet_('muted') || false;\n        }\n\n        /**\n         * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n         * indicates the state of muted on initial playback.\n         *\n         * ```js\n         *   var myPlayer = videojs('some-player-id');\n         *\n         *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n         *\n         *   // get, should be false\n         *   console.log(myPlayer.defaultMuted());\n         *   // set to true\n         *   myPlayer.defaultMuted(true);\n         *   // get should be true\n         *   console.log(myPlayer.defaultMuted());\n         * ```\n         *\n         * @param {boolean} [defaultMuted]\n         *        - true to mute\n         *        - false to unmute\n         *\n         * @return {boolean|undefined}\n         *         - true if defaultMuted is on and getting\n         *         - false if defaultMuted is off and getting\n         *         - Nothing when setting\n         */\n        defaultMuted(defaultMuted) {\n            if (defaultMuted !== undefined) {\n                this.techCall_('setDefaultMuted', defaultMuted);\n            }\n            return this.techGet_('defaultMuted') || false;\n        }\n\n        /**\n         * Get the last volume, or set it\n         *\n         * @param  {number} [percentAsDecimal]\n         *         The new last volume as a decimal percent:\n         *         - 0 is muted/0%/off\n         *         - 1.0 is 100%/full\n         *         - 0.5 is half volume or 50%\n         *\n         * @return {number|undefined}\n         *         - The current value of lastVolume as a percent when getting\n         *         - Nothing when setting\n         *\n         * @private\n         */\n        lastVolume_(percentAsDecimal) {\n            if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n                this.cache_.lastVolume = percentAsDecimal;\n                return;\n            }\n            return this.cache_.lastVolume;\n        }\n\n        /**\n         * Check if current tech can support native fullscreen\n         * (e.g. with built in controls like iOS)\n         *\n         * @return {boolean}\n         *         if native fullscreen is supported\n         */\n        supportsFullScreen() {\n            return this.techGet_('supportsFullScreen') || false;\n        }\n\n        /**\n         * Check if the player is in fullscreen mode or tell the player that it\n         * is or is not in fullscreen mode.\n         *\n         * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n         * property and instead document.fullscreenElement is used. But isFullscreen is\n         * still a valuable property for internal player workings.\n         *\n         * @param  {boolean} [isFS]\n         *         Set the players current fullscreen state\n         *\n         * @return {boolean|undefined}\n         *         - true if fullscreen is on and getting\n         *         - false if fullscreen is off and getting\n         *         - Nothing when setting\n         */\n        isFullscreen(isFS) {\n            if (isFS !== undefined) {\n                const oldValue = this.isFullscreen_;\n                this.isFullscreen_ = Boolean(isFS);\n\n                // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange\n                // this is the only place where we trigger fullscreenchange events for older browsers\n                // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well\n                if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {\n                    /**\n                     * @event Player#fullscreenchange\n                     * @type {Event}\n                     */\n                    this.trigger('fullscreenchange');\n                }\n                this.toggleFullscreenClass_();\n                return;\n            }\n            return this.isFullscreen_;\n        }\n\n        /**\n         * Increase the size of the video to full screen\n         * In some browsers, full screen is not supported natively, so it enters\n         * \"full window mode\", where the video fills the browser window.\n         * In browsers and devices that support native full screen, sometimes the\n         * browser's default controls will be shown, and not the Video.js custom skin.\n         * This includes most mobile devices (iOS, Android) and older versions of\n         * Safari.\n         *\n         * @param  {Object} [fullscreenOptions]\n         *         Override the player fullscreen options\n         *\n         * @fires Player#fullscreenchange\n         */\n        requestFullscreen(fullscreenOptions) {\n            if (this.isInPictureInPicture()) {\n                this.exitPictureInPicture();\n            }\n            const self = this;\n            return new Promise((resolve, reject) => {\n                function offHandler() {\n                    self.off('fullscreenerror', errorHandler);\n                    self.off('fullscreenchange', changeHandler);\n                }\n                function changeHandler() {\n                    offHandler();\n                    resolve();\n                }\n                function errorHandler(e, err) {\n                    offHandler();\n                    reject(err);\n                }\n                self.one('fullscreenchange', changeHandler);\n                self.one('fullscreenerror', errorHandler);\n                const promise = self.requestFullscreenHelper_(fullscreenOptions);\n                if (promise) {\n                    promise.then(offHandler, offHandler);\n                    promise.then(resolve, reject);\n                }\n            });\n        }\n        requestFullscreenHelper_(fullscreenOptions) {\n            let fsOptions;\n\n            // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.\n            // Use defaults or player configured option unless passed directly to this method.\n            if (!this.fsApi_.prefixed) {\n                fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};\n                if (fullscreenOptions !== undefined) {\n                    fsOptions = fullscreenOptions;\n                }\n            }\n\n            // This method works as follows:\n            // 1. if a fullscreen api is available, use it\n            //   1. call requestFullscreen with potential options\n            //   2. if we got a promise from above, use it to update isFullscreen()\n            // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.\n            //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.\n            // 3. otherwise, use \"fullWindow\" mode\n            if (this.fsApi_.requestFullscreen) {\n                const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);\n\n                // Even on browsers with promise support this may not return a promise\n                if (promise) {\n                    promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));\n                }\n                return promise;\n            } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n                // we can't take the video.js controls fullscreen but we can go fullscreen\n                // with native controls\n                this.techCall_('enterFullScreen');\n            } else {\n                // fullscreen isn't supported so we'll just stretch the video element to\n                // fill the viewport\n                this.enterFullWindow();\n            }\n        }\n\n        /**\n         * Return the video to its normal size after having been in full screen mode\n         *\n         * @fires Player#fullscreenchange\n         */\n        exitFullscreen() {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                function offHandler() {\n                    self.off('fullscreenerror', errorHandler);\n                    self.off('fullscreenchange', changeHandler);\n                }\n                function changeHandler() {\n                    offHandler();\n                    resolve();\n                }\n                function errorHandler(e, err) {\n                    offHandler();\n                    reject(err);\n                }\n                self.one('fullscreenchange', changeHandler);\n                self.one('fullscreenerror', errorHandler);\n                const promise = self.exitFullscreenHelper_();\n                if (promise) {\n                    promise.then(offHandler, offHandler);\n                    // map the promise to our resolve/reject methods\n                    promise.then(resolve, reject);\n                }\n            });\n        }\n        exitFullscreenHelper_() {\n            if (this.fsApi_.requestFullscreen) {\n                const promise = document[this.fsApi_.exitFullscreen]();\n\n                // Even on browsers with promise support this may not return a promise\n                if (promise) {\n                    // we're splitting the promise here, so, we want to catch the\n                    // potential error so that this chain doesn't have unhandled errors\n                    silencePromise(promise.then(() => this.isFullscreen(false)));\n                }\n                return promise;\n            } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n                this.techCall_('exitFullScreen');\n            } else {\n                this.exitFullWindow();\n            }\n        }\n\n        /**\n         * When fullscreen isn't supported we can stretch the\n         * video container to as wide as the browser will let us.\n         *\n         * @fires Player#enterFullWindow\n         */\n        enterFullWindow() {\n            this.isFullscreen(true);\n            this.isFullWindow = true;\n\n            // Storing original doc overflow value to return to when fullscreen is off\n            this.docOrigOverflow = document.documentElement.style.overflow;\n\n            // Add listener for esc key to exit fullscreen\n            on(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n            // Hide any scroll bars\n            document.documentElement.style.overflow = 'hidden';\n\n            // Apply fullscreen styles\n            addClass(document.body, 'vjs-full-window');\n\n            /**\n             * @event Player#enterFullWindow\n             * @type {Event}\n             */\n            this.trigger('enterFullWindow');\n        }\n\n        /**\n         * Check for call to either exit full window or\n         * full screen on ESC key\n         *\n         * @param {string} event\n         *        Event to check for key press\n         */\n        fullWindowOnEscKey(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                if (this.isFullscreen() === true) {\n                    if (!this.isFullWindow) {\n                        this.exitFullscreen();\n                    } else {\n                        this.exitFullWindow();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Exit full window\n         *\n         * @fires Player#exitFullWindow\n         */\n        exitFullWindow() {\n            this.isFullscreen(false);\n            this.isFullWindow = false;\n            off(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n            // Unhide scroll bars.\n            document.documentElement.style.overflow = this.docOrigOverflow;\n\n            // Remove fullscreen styles\n            removeClass(document.body, 'vjs-full-window');\n\n            // Resize the box, controller, and poster to original sizes\n            // this.positionAll();\n            /**\n             * @event Player#exitFullWindow\n             * @type {Event}\n             */\n            this.trigger('exitFullWindow');\n        }\n\n        /**\n         * Get or set disable Picture-in-Picture mode.\n         *\n         * @param {boolean} [value]\n         *                  - true will disable Picture-in-Picture mode\n         *                  - false will enable Picture-in-Picture mode\n         */\n        disablePictureInPicture(value) {\n            if (value === undefined) {\n                return this.techGet_('disablePictureInPicture');\n            }\n            this.techCall_('setDisablePictureInPicture', value);\n            this.options_.disablePictureInPicture = value;\n            this.trigger('disablepictureinpicturechanged');\n        }\n\n        /**\n         * Check if the player is in Picture-in-Picture mode or tell the player that it\n         * is or is not in Picture-in-Picture mode.\n         *\n         * @param  {boolean} [isPiP]\n         *         Set the players current Picture-in-Picture state\n         *\n         * @return {boolean|undefined}\n         *         - true if Picture-in-Picture is on and getting\n         *         - false if Picture-in-Picture is off and getting\n         *         - nothing if setting\n         */\n        isInPictureInPicture(isPiP) {\n            if (isPiP !== undefined) {\n                this.isInPictureInPicture_ = !!isPiP;\n                this.togglePictureInPictureClass_();\n                return;\n            }\n            return !!this.isInPictureInPicture_;\n        }\n\n        /**\n         * Create a floating video window always on top of other windows so that users may\n         * continue consuming media while they interact with other content sites, or\n         * applications on their device.\n         *\n         * This can use document picture-in-picture or element picture in picture\n         *\n         * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser\n         * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser\n         *\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}\n         * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}\n         *\n         * @fires Player#enterpictureinpicture\n         *\n         * @return {Promise}\n         *         A promise with a Picture-in-Picture window.\n         */\n        requestPictureInPicture() {\n            if (this.options_.enableDocumentPictureInPicture && window.documentPictureInPicture) {\n                const pipContainer = document.createElement(this.el().tagName);\n                pipContainer.classList = this.el().classList;\n                pipContainer.classList.add('vjs-pip-container');\n                if (this.posterImage) {\n                    pipContainer.appendChild(this.posterImage.el().cloneNode(true));\n                }\n                if (this.titleBar) {\n                    pipContainer.appendChild(this.titleBar.el().cloneNode(true));\n                }\n                pipContainer.appendChild(createEl('p', {\n                    className: 'vjs-pip-text'\n                }, {}, this.localize('Playing in picture-in-picture')));\n                return window.documentPictureInPicture.requestWindow({\n                    // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629\n                    width: this.videoWidth(),\n                    height: this.videoHeight()\n                }).then(pipWindow => {\n                    copyStyleSheetsToWindow(pipWindow);\n                    this.el_.parentNode.insertBefore(pipContainer, this.el_);\n                    pipWindow.document.body.appendChild(this.el_);\n                    pipWindow.document.body.classList.add('vjs-pip-window');\n                    this.player_.isInPictureInPicture(true);\n                    this.player_.trigger('enterpictureinpicture');\n\n                    // Listen for the PiP closing event to move the video back.\n                    pipWindow.addEventListener('pagehide', event => {\n                        const pipVideo = event.target.querySelector('.video-js');\n                        pipContainer.parentNode.replaceChild(pipVideo, pipContainer);\n                        this.player_.isInPictureInPicture(false);\n                        this.player_.trigger('leavepictureinpicture');\n                    });\n                    return pipWindow;\n                });\n            }\n            if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {\n                /**\n                 * This event fires when the player enters picture in picture mode\n                 *\n                 * @event Player#enterpictureinpicture\n                 * @type {Event}\n                 */\n                return this.techGet_('requestPictureInPicture');\n            }\n            return Promise.reject('No PiP mode is available');\n        }\n\n        /**\n         * Exit Picture-in-Picture mode.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @fires Player#leavepictureinpicture\n         *\n         * @return {Promise}\n         *         A promise.\n         */\n        exitPictureInPicture() {\n            if (window.documentPictureInPicture && window.documentPictureInPicture.window) {\n                // With documentPictureInPicture, Player#leavepictureinpicture is fired in the pagehide handler\n                window.documentPictureInPicture.window.close();\n                return Promise.resolve();\n            }\n            if ('pictureInPictureEnabled' in document) {\n                /**\n                 * This event fires when the player leaves picture in picture mode\n                 *\n                 * @event Player#leavepictureinpicture\n                 * @type {Event}\n                 */\n                return document.exitPictureInPicture();\n            }\n        }\n\n        /**\n         * Called when this Player has focus and a key gets pressed down, or when\n         * any Component of this player receives a key press that it doesn't handle.\n         * This allows player-wide hotkeys (either as defined below, or optionally\n         * by an external function).\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            const {\n                userActions\n            } = this.options_;\n\n            // Bail out if hotkeys are not configured.\n            if (!userActions || !userActions.hotkeys) {\n                return;\n            }\n\n            // Function that determines whether or not to exclude an element from\n            // hotkeys handling.\n            const excludeElement = el => {\n                const tagName = el.tagName.toLowerCase();\n\n                // The first and easiest test is for `contenteditable` elements.\n                if (el.isContentEditable) {\n                    return true;\n                }\n\n                // Inputs matching these types will still trigger hotkey handling as\n                // they are not text inputs.\n                const allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];\n                if (tagName === 'input') {\n                    return allowedInputTypes.indexOf(el.type) === -1;\n                }\n\n                // The final test is by tag name. These tags will be excluded entirely.\n                const excludedTags = ['textarea'];\n                return excludedTags.indexOf(tagName) !== -1;\n            };\n\n            // Bail out if the user is focused on an interactive form element.\n            if (excludeElement(this.el_.ownerDocument.activeElement)) {\n                return;\n            }\n            if (typeof userActions.hotkeys === 'function') {\n                userActions.hotkeys.call(this, event);\n            } else {\n                this.handleHotkeys(event);\n            }\n        }\n\n        /**\n         * Called when this Player receives a hotkey keydown event.\n         * Supported player-wide hotkeys are:\n         *\n         *   f          - toggle fullscreen\n         *   m          - toggle mute\n         *   k or Space - toggle play/pause\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         */\n        handleHotkeys(event) {\n            const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};\n\n            // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set\n            const {\n                fullscreenKey = keydownEvent => keycode.isEventKey(keydownEvent, 'f'),\n                muteKey = keydownEvent => keycode.isEventKey(keydownEvent, 'm'),\n                playPauseKey = keydownEvent => keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space')\n            } = hotkeys;\n            if (fullscreenKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const FSToggle = Component$1.getComponent('FullscreenToggle');\n                if (document[this.fsApi_.fullscreenEnabled] !== false) {\n                    FSToggle.prototype.handleClick.call(this, event);\n                }\n            } else if (muteKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const MuteToggle = Component$1.getComponent('MuteToggle');\n                MuteToggle.prototype.handleClick.call(this, event);\n            } else if (playPauseKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const PlayToggle = Component$1.getComponent('PlayToggle');\n                PlayToggle.prototype.handleClick.call(this, event);\n            }\n        }\n\n        /**\n         * Check whether the player can play a given mimetype\n         *\n         * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n         *\n         * @param {string} type\n         *        The mimetype to check\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        canPlayType(type) {\n            let can;\n\n            // Loop through each playback technology in the options order\n            for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {\n                const techName = j[i];\n                let tech = Tech.getTech(techName);\n\n                // Support old behavior of techs being registered as components.\n                // Remove once that deprecated behavior is removed.\n                if (!tech) {\n                    tech = Component$1.getComponent(techName);\n                }\n\n                // Check if the current tech is defined before continuing\n                if (!tech) {\n                    log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n                    continue;\n                }\n\n                // Check if the browser supports this technology\n                if (tech.isSupported()) {\n                    can = tech.canPlayType(type);\n                    if (can) {\n                        return can;\n                    }\n                }\n            }\n            return '';\n        }\n\n        /**\n         * Select source based on tech-order or source-order\n         * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n         * defaults to tech-order selection\n         *\n         * @param {Array} sources\n         *        The sources for a media asset\n         *\n         * @return {Object|boolean}\n         *         Object of source and tech order or false\n         */\n        selectSource(sources) {\n            // Get only the techs specified in `techOrder` that exist and are supported by the\n            // current platform\n            const techs = this.options_.techOrder.map(techName => {\n                return [techName, Tech.getTech(techName)];\n            }).filter(([techName, tech]) => {\n                // Check if the current tech is defined before continuing\n                if (tech) {\n                    // Check if the browser supports this technology\n                    return tech.isSupported();\n                }\n                log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n                return false;\n            });\n\n            // Iterate over each `innerArray` element once per `outerArray` element and execute\n            // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n            // that value.\n            const findFirstPassingTechSourcePair = function (outerArray, innerArray, tester) {\n                let found;\n                outerArray.some(outerChoice => {\n                    return innerArray.some(innerChoice => {\n                        found = tester(outerChoice, innerChoice);\n                        if (found) {\n                            return true;\n                        }\n                    });\n                });\n                return found;\n            };\n            let foundSourceAndTech;\n            const flip = fn => (a, b) => fn(b, a);\n            const finder = ([techName, tech], source) => {\n                if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {\n                    return {\n                        source,\n                        tech: techName\n                    };\n                }\n            };\n\n            // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n            // to select from them based on their priority.\n            if (this.options_.sourceOrder) {\n                // Source-first ordering\n                foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n            } else {\n                // Tech-first ordering\n                foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n            }\n            return foundSourceAndTech || false;\n        }\n\n        /**\n         * Executes source setting and getting logic\n         *\n         * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n         *        A SourceObject, an array of SourceObjects, or a string referencing\n         *        a URL to a media source. It is _highly recommended_ that an object\n         *        or array of objects is used here, so that source selection\n         *        algorithms can take the `type` into account.\n         *\n         *        If not provided, this method acts as a getter.\n         * @param {boolean} [isRetry]\n         *        Indicates whether this is being called internally as a result of a retry\n         *\n         * @return {string|undefined}\n         *         If the `source` argument is missing, returns the current source\n         *         URL. Otherwise, returns nothing/undefined.\n         */\n        handleSrc_(source, isRetry) {\n            // getter usage\n            if (typeof source === 'undefined') {\n                return this.cache_.src || '';\n            }\n\n            // Reset retry behavior for new source\n            if (this.resetRetryOnError_) {\n                this.resetRetryOnError_();\n            }\n\n            // filter out invalid sources and turn our source into\n            // an array of source objects\n            const sources = filterSource(source);\n\n            // if a source was passed in then it is invalid because\n            // it was filtered to a zero length Array. So we have to\n            // show an error\n            if (!sources.length) {\n                this.setTimeout(function () {\n                    this.error({\n                        code: 4,\n                        message: this.options_.notSupportedMessage\n                    });\n                }, 0);\n                return;\n            }\n\n            // initial sources\n            this.changingSrc_ = true;\n\n            // Only update the cached source list if we are not retrying a new source after error,\n            // since in that case we want to include the failed source(s) in the cache\n            if (!isRetry) {\n                this.cache_.sources = sources;\n            }\n            this.updateSourceCaches_(sources[0]);\n\n            // middlewareSource is the source after it has been changed by middleware\n            setSource(this, sources[0], (middlewareSource, mws) => {\n                this.middleware_ = mws;\n\n                // since sourceSet is async we have to update the cache again after we select a source since\n                // the source that is selected could be out of order from the cache update above this callback.\n                if (!isRetry) {\n                    this.cache_.sources = sources;\n                }\n                this.updateSourceCaches_(middlewareSource);\n                const err = this.src_(middlewareSource);\n                if (err) {\n                    if (sources.length > 1) {\n                        return this.handleSrc_(sources.slice(1));\n                    }\n                    this.changingSrc_ = false;\n\n                    // We need to wrap this in a timeout to give folks a chance to add error event handlers\n                    this.setTimeout(function () {\n                        this.error({\n                            code: 4,\n                            message: this.options_.notSupportedMessage\n                        });\n                    }, 0);\n\n                    // we could not find an appropriate tech, but let's still notify the delegate that this is it\n                    // this needs a better comment about why this is needed\n                    this.triggerReady();\n                    return;\n                }\n                setTech(mws, this.tech_);\n            });\n\n            // Try another available source if this one fails before playback.\n            if (sources.length > 1) {\n                const retry = () => {\n                    // Remove the error modal\n                    this.error(null);\n                    this.handleSrc_(sources.slice(1), true);\n                };\n                const stopListeningForErrors = () => {\n                    this.off('error', retry);\n                };\n                this.one('error', retry);\n                this.one('playing', stopListeningForErrors);\n                this.resetRetryOnError_ = () => {\n                    this.off('error', retry);\n                    this.off('playing', stopListeningForErrors);\n                };\n            }\n        }\n\n        /**\n         * Get or set the video source.\n         *\n         * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n         *        A SourceObject, an array of SourceObjects, or a string referencing\n         *        a URL to a media source. It is _highly recommended_ that an object\n         *        or array of objects is used here, so that source selection\n         *        algorithms can take the `type` into account.\n         *\n         *        If not provided, this method acts as a getter.\n         *\n         * @return {string|undefined}\n         *         If the `source` argument is missing, returns the current source\n         *         URL. Otherwise, returns nothing/undefined.\n         */\n        src(source) {\n            return this.handleSrc_(source, false);\n        }\n\n        /**\n         * Set the source object on the tech, returns a boolean that indicates whether\n         * there is a tech that can play the source or not\n         *\n         * @param {Tech~SourceObject} source\n         *        The source object to set on the Tech\n         *\n         * @return {boolean}\n         *         - True if there is no Tech to playback this source\n         *         - False otherwise\n         *\n         * @private\n         */\n        src_(source) {\n            const sourceTech = this.selectSource([source]);\n            if (!sourceTech) {\n                return true;\n            }\n            if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n                this.changingSrc_ = true;\n                // load this technology with the chosen source\n                this.loadTech_(sourceTech.tech, sourceTech.source);\n                this.tech_.ready(() => {\n                    this.changingSrc_ = false;\n                });\n                return false;\n            }\n\n            // wait until the tech is ready to set the source\n            // and set it synchronously if possible (#2326)\n            this.ready(function () {\n                // The setSource tech method was added with source handlers\n                // so older techs won't support it\n                // We need to check the direct prototype for the case where subclasses\n                // of the tech do not support source handlers\n                if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n                    this.techCall_('setSource', source);\n                } else {\n                    this.techCall_('src', source.src);\n                }\n                this.changingSrc_ = false;\n            }, true);\n            return false;\n        }\n\n        /**\n         * Begin loading the src data.\n         */\n        load() {\n            // Workaround to use the load method with the VHS.\n            // Does not cover the case when the load method is called directly from the mediaElement.\n            if (this.tech_ && this.tech_.vhs) {\n                this.src(this.currentSource());\n                return;\n            }\n            this.techCall_('load');\n        }\n\n        /**\n         * Reset the player. Loads the first tech in the techOrder,\n         * removes all the text tracks in the existing `tech`,\n         * and calls `reset` on the `tech`.\n         */\n        reset() {\n            if (this.paused()) {\n                this.doReset_();\n            } else {\n                const playPromise = this.play();\n                silencePromise(playPromise.then(() => this.doReset_()));\n            }\n        }\n        doReset_() {\n            if (this.tech_) {\n                this.tech_.clearTracks('text');\n            }\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-paused');\n            this.resetCache_();\n            this.poster('');\n            this.loadTech_(this.options_.techOrder[0], null);\n            this.techCall_('reset');\n            this.resetControlBarUI_();\n            this.error(null);\n            if (this.titleBar) {\n                this.titleBar.update({\n                    title: undefined,\n                    description: undefined\n                });\n            }\n            if (isEvented(this)) {\n                this.trigger('playerreset');\n            }\n        }\n\n        /**\n         * Reset Control Bar's UI by calling sub-methods that reset\n         * all of Control Bar's components\n         */\n        resetControlBarUI_() {\n            this.resetProgressBar_();\n            this.resetPlaybackRate_();\n            this.resetVolumeBar_();\n        }\n\n        /**\n         * Reset tech's progress so progress bar is reset in the UI\n         */\n        resetProgressBar_() {\n            this.currentTime(0);\n            const {\n                currentTimeDisplay,\n                durationDisplay,\n                progressControl,\n                remainingTimeDisplay\n            } = this.controlBar || {};\n            const {\n                seekBar\n            } = progressControl || {};\n            if (currentTimeDisplay) {\n                currentTimeDisplay.updateContent();\n            }\n            if (durationDisplay) {\n                durationDisplay.updateContent();\n            }\n            if (remainingTimeDisplay) {\n                remainingTimeDisplay.updateContent();\n            }\n            if (seekBar) {\n                seekBar.update();\n                if (seekBar.loadProgressBar) {\n                    seekBar.loadProgressBar.update();\n                }\n            }\n        }\n\n        /**\n         * Reset Playback ratio\n         */\n        resetPlaybackRate_() {\n            this.playbackRate(this.defaultPlaybackRate());\n            this.handleTechRateChange_();\n        }\n\n        /**\n         * Reset Volume bar\n         */\n        resetVolumeBar_() {\n            this.volume(1.0);\n            this.trigger('volumechange');\n        }\n\n        /**\n         * Returns all of the current source objects.\n         *\n         * @return {Tech~SourceObject[]}\n         *         The current source objects\n         */\n        currentSources() {\n            const source = this.currentSource();\n            const sources = [];\n\n            // assume `{}` or `{ src }`\n            if (Object.keys(source).length !== 0) {\n                sources.push(source);\n            }\n            return this.cache_.sources || sources;\n        }\n\n        /**\n         * Returns the current source object.\n         *\n         * @return {Tech~SourceObject}\n         *         The current source object\n         */\n        currentSource() {\n            return this.cache_.source || {};\n        }\n\n        /**\n         * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n         * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\n         *\n         * @return {string}\n         *         The current source\n         */\n        currentSrc() {\n            return this.currentSource() && this.currentSource().src || '';\n        }\n\n        /**\n         * Get the current source type e.g. video/mp4\n         * This can allow you rebuild the current source object so that you could load the same\n         * source and tech later\n         *\n         * @return {string}\n         *         The source MIME type\n         */\n        currentType() {\n            return this.currentSource() && this.currentSource().type || '';\n        }\n\n        /**\n         * Get or set the preload attribute\n         *\n         * @param {'none'|'auto'|'metadata'} [value]\n         *        Preload mode to pass to tech\n         *\n         * @return {string|undefined}\n         *         - The preload attribute value when getting\n         *         - Nothing when setting\n         */\n        preload(value) {\n            if (value !== undefined) {\n                this.techCall_('setPreload', value);\n                this.options_.preload = value;\n                return;\n            }\n            return this.techGet_('preload');\n        }\n\n        /**\n         * Get or set the autoplay option. When this is a boolean it will\n         * modify the attribute on the tech. When this is a string the attribute on\n         * the tech will be removed and `Player` will handle autoplay on loadstarts.\n         *\n         * @param {boolean|'play'|'muted'|'any'} [value]\n         *        - true: autoplay using the browser behavior\n         *        - false: do not autoplay\n         *        - 'play': call play() on every loadstart\n         *        - 'muted': call muted() then play() on every loadstart\n         *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n         *        - *: values other than those listed here will be set `autoplay` to true\n         *\n         * @return {boolean|string|undefined}\n         *         - The current value of autoplay when getting\n         *         - Nothing when setting\n         */\n        autoplay(value) {\n            // getter usage\n            if (value === undefined) {\n                return this.options_.autoplay || false;\n            }\n            let techAutoplay;\n\n            // if the value is a valid string set it to that, or normalize `true` to 'play', if need be\n            if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {\n                this.options_.autoplay = value;\n                this.manualAutoplay_(typeof value === 'string' ? value : 'play');\n                techAutoplay = false;\n\n                // any falsy value sets autoplay to false in the browser,\n                // lets do the same\n            } else if (!value) {\n                this.options_.autoplay = false;\n\n                // any other value (ie truthy) sets autoplay to true\n            } else {\n                this.options_.autoplay = true;\n            }\n            techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;\n\n            // if we don't have a tech then we do not queue up\n            // a setAutoplay call on tech ready. We do this because the\n            // autoplay option will be passed in the constructor and we\n            // do not need to set it twice\n            if (this.tech_) {\n                this.techCall_('setAutoplay', techAutoplay);\n            }\n        }\n\n        /**\n         * Set or unset the playsinline attribute.\n         * Playsinline tells the browser that non-fullscreen playback is preferred.\n         *\n         * @param {boolean} [value]\n         *        - true means that we should try to play inline by default\n         *        - false means that we should use the browser's default playback mode,\n         *          which in most cases is inline. iOS Safari is a notable exception\n         *          and plays fullscreen by default.\n         *\n         * @return {string|undefined}\n         *         - the current value of playsinline\n         *         - Nothing when setting\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        playsinline(value) {\n            if (value !== undefined) {\n                this.techCall_('setPlaysinline', value);\n                this.options_.playsinline = value;\n            }\n            return this.techGet_('playsinline');\n        }\n\n        /**\n         * Get or set the loop attribute on the video element.\n         *\n         * @param {boolean} [value]\n         *        - true means that we should loop the video\n         *        - false means that we should not loop the video\n         *\n         * @return {boolean|undefined}\n         *         - The current value of loop when getting\n         *         - Nothing when setting\n         */\n        loop(value) {\n            if (value !== undefined) {\n                this.techCall_('setLoop', value);\n                this.options_.loop = value;\n                return;\n            }\n            return this.techGet_('loop');\n        }\n\n        /**\n         * Get or set the poster image source url\n         *\n         * @fires Player#posterchange\n         *\n         * @param {string} [src]\n         *        Poster image source URL\n         *\n         * @return {string|undefined}\n         *         - The current value of poster when getting\n         *         - Nothing when setting\n         */\n        poster(src) {\n            if (src === undefined) {\n                return this.poster_;\n            }\n\n            // The correct way to remove a poster is to set as an empty string\n            // other falsey values will throw errors\n            if (!src) {\n                src = '';\n            }\n            if (src === this.poster_) {\n                return;\n            }\n\n            // update the internal poster variable\n            this.poster_ = src;\n\n            // update the tech's poster\n            this.techCall_('setPoster', src);\n            this.isPosterFromTech_ = false;\n\n            // alert components that the poster has been set\n            /**\n             * This event fires when the poster image is changed on the player.\n             *\n             * @event Player#posterchange\n             * @type {Event}\n             */\n            this.trigger('posterchange');\n        }\n\n        /**\n         * Some techs (e.g. YouTube) can provide a poster source in an\n         * asynchronous way. We want the poster component to use this\n         * poster source so that it covers up the tech's controls.\n         * (YouTube's play button). However we only want to use this\n         * source if the player user hasn't set a poster through\n         * the normal APIs.\n         *\n         * @fires Player#posterchange\n         * @listens Tech#posterchange\n         * @private\n         */\n        handleTechPosterChange_() {\n            if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n                const newPoster = this.tech_.poster() || '';\n                if (newPoster !== this.poster_) {\n                    this.poster_ = newPoster;\n                    this.isPosterFromTech_ = true;\n\n                    // Let components know the poster has changed\n                    this.trigger('posterchange');\n                }\n            }\n        }\n\n        /**\n         * Get or set whether or not the controls are showing.\n         *\n         * @fires Player#controlsenabled\n         *\n         * @param {boolean} [bool]\n         *        - true to turn controls on\n         *        - false to turn controls off\n         *\n         * @return {boolean|undefined}\n         *         - The current value of controls when getting\n         *         - Nothing when setting\n         */\n        controls(bool) {\n            if (bool === undefined) {\n                return !!this.controls_;\n            }\n            bool = !!bool;\n\n            // Don't trigger a change event unless it actually changed\n            if (this.controls_ === bool) {\n                return;\n            }\n            this.controls_ = bool;\n            if (this.usingNativeControls()) {\n                this.techCall_('setControls', bool);\n            }\n            if (this.controls_) {\n                this.removeClass('vjs-controls-disabled');\n                this.addClass('vjs-controls-enabled');\n                /**\n                 * @event Player#controlsenabled\n                 * @type {Event}\n                 */\n                this.trigger('controlsenabled');\n                if (!this.usingNativeControls()) {\n                    this.addTechControlsListeners_();\n                }\n            } else {\n                this.removeClass('vjs-controls-enabled');\n                this.addClass('vjs-controls-disabled');\n                /**\n                 * @event Player#controlsdisabled\n                 * @type {Event}\n                 */\n                this.trigger('controlsdisabled');\n                if (!this.usingNativeControls()) {\n                    this.removeTechControlsListeners_();\n                }\n            }\n        }\n\n        /**\n         * Toggle native controls on/off. Native controls are the controls built into\n         * devices (e.g. default iPhone controls) or other techs\n         * (e.g. Vimeo Controls)\n         * **This should only be set by the current tech, because only the tech knows\n         * if it can support native controls**\n         *\n         * @fires Player#usingnativecontrols\n         * @fires Player#usingcustomcontrols\n         *\n         * @param {boolean} [bool]\n         *        - true to turn native controls on\n         *        - false to turn native controls off\n         *\n         * @return {boolean|undefined}\n         *         - The current value of native controls when getting\n         *         - Nothing when setting\n         */\n        usingNativeControls(bool) {\n            if (bool === undefined) {\n                return !!this.usingNativeControls_;\n            }\n            bool = !!bool;\n\n            // Don't trigger a change event unless it actually changed\n            if (this.usingNativeControls_ === bool) {\n                return;\n            }\n            this.usingNativeControls_ = bool;\n            if (this.usingNativeControls_) {\n                this.addClass('vjs-using-native-controls');\n\n                /**\n                 * player is using the native device controls\n                 *\n                 * @event Player#usingnativecontrols\n                 * @type {Event}\n                 */\n                this.trigger('usingnativecontrols');\n            } else {\n                this.removeClass('vjs-using-native-controls');\n\n                /**\n                 * player is using the custom HTML controls\n                 *\n                 * @event Player#usingcustomcontrols\n                 * @type {Event}\n                 */\n                this.trigger('usingcustomcontrols');\n            }\n        }\n\n        /**\n         * Set or get the current MediaError\n         *\n         * @fires Player#error\n         *\n         * @param  {MediaError|string|number} [err]\n         *         A MediaError or a string/number to be turned\n         *         into a MediaError\n         *\n         * @return {MediaError|null|undefined}\n         *         - The current MediaError when getting (or null)\n         *         - Nothing when setting\n         */\n        error(err) {\n            if (err === undefined) {\n                return this.error_ || null;\n            }\n\n            // allow hooks to modify error object\n            hooks('beforeerror').forEach(hookFunction => {\n                const newErr = hookFunction(this, err);\n                if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {\n                    this.log.error('please return a value that MediaError expects in beforeerror hooks');\n                    return;\n                }\n                err = newErr;\n            });\n\n            // Suppress the first error message for no compatible source until\n            // user interaction\n            if (this.options_.suppressNotSupportedError && err && err.code === 4) {\n                const triggerSuppressedError = function () {\n                    this.error(err);\n                };\n                this.options_.suppressNotSupportedError = false;\n                this.any(['click', 'touchstart'], triggerSuppressedError);\n                this.one('loadstart', function () {\n                    this.off(['click', 'touchstart'], triggerSuppressedError);\n                });\n                return;\n            }\n\n            // restoring to default\n            if (err === null) {\n                this.error_ = null;\n                this.removeClass('vjs-error');\n                if (this.errorDisplay) {\n                    this.errorDisplay.close();\n                }\n                return;\n            }\n            this.error_ = new MediaError(err);\n\n            // add the vjs-error classname to the player\n            this.addClass('vjs-error');\n\n            // log the name of the error type and any message\n            // IE11 logs \"[object object]\" and required you to expand message to see error object\n            log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);\n\n            /**\n             * @event Player#error\n             * @type {Event}\n             */\n            this.trigger('error');\n\n            // notify hooks of the per player error\n            hooks('error').forEach(hookFunction => hookFunction(this, this.error_));\n            return;\n        }\n\n        /**\n         * Report user activity\n         *\n         * @param {Object} event\n         *        Event object\n         */\n        reportUserActivity(event) {\n            this.userActivity_ = true;\n        }\n\n        /**\n         * Get/set if user is active\n         *\n         * @fires Player#useractive\n         * @fires Player#userinactive\n         *\n         * @param {boolean} [bool]\n         *        - true if the user is active\n         *        - false if the user is inactive\n         *\n         * @return {boolean|undefined}\n         *         - The current value of userActive when getting\n         *         - Nothing when setting\n         */\n        userActive(bool) {\n            if (bool === undefined) {\n                return this.userActive_;\n            }\n            bool = !!bool;\n            if (bool === this.userActive_) {\n                return;\n            }\n            this.userActive_ = bool;\n            if (this.userActive_) {\n                this.userActivity_ = true;\n                this.removeClass('vjs-user-inactive');\n                this.addClass('vjs-user-active');\n                /**\n                 * @event Player#useractive\n                 * @type {Event}\n                 */\n                this.trigger('useractive');\n                return;\n            }\n\n            // Chrome/Safari/IE have bugs where when you change the cursor it can\n            // trigger a mousemove event. This causes an issue when you're hiding\n            // the cursor when the user is inactive, and a mousemove signals user\n            // activity. Making it impossible to go into inactive mode. Specifically\n            // this happens in fullscreen when we really need to hide the cursor.\n            //\n            // When this gets resolved in ALL browsers it can be removed\n            // https://code.google.com/p/chromium/issues/detail?id=103041\n            if (this.tech_) {\n                this.tech_.one('mousemove', function (e) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                });\n            }\n            this.userActivity_ = false;\n            this.removeClass('vjs-user-active');\n            this.addClass('vjs-user-inactive');\n            /**\n             * @event Player#userinactive\n             * @type {Event}\n             */\n            this.trigger('userinactive');\n        }\n\n        /**\n         * Listen for user activity based on timeout value\n         *\n         * @private\n         */\n        listenForUserActivity_() {\n            let mouseInProgress;\n            let lastMoveX;\n            let lastMoveY;\n            const handleActivity = bind_(this, this.reportUserActivity);\n            const handleMouseMove = function (e) {\n                // #1068 - Prevent mousemove spamming\n                // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n                if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n                    lastMoveX = e.screenX;\n                    lastMoveY = e.screenY;\n                    handleActivity();\n                }\n            };\n            const handleMouseDown = function () {\n                handleActivity();\n                // For as long as the they are touching the device or have their mouse down,\n                // we consider them active even if they're not moving their finger or mouse.\n                // So we want to continue to update that they are active\n                this.clearInterval(mouseInProgress);\n                // Setting userActivity=true now and setting the interval to the same time\n                // as the activityCheck interval (250) should ensure we never miss the\n                // next activityCheck\n                mouseInProgress = this.setInterval(handleActivity, 250);\n            };\n            const handleMouseUpAndMouseLeave = function (event) {\n                handleActivity();\n                // Stop the interval that maintains activity if the mouse/touch is down\n                this.clearInterval(mouseInProgress);\n            };\n\n            // Any mouse movement will be considered user activity\n            this.on('mousedown', handleMouseDown);\n            this.on('mousemove', handleMouseMove);\n            this.on('mouseup', handleMouseUpAndMouseLeave);\n            this.on('mouseleave', handleMouseUpAndMouseLeave);\n            const controlBar = this.getChild('controlBar');\n\n            // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)\n            // controlBar would no longer be hidden by default timeout.\n            if (controlBar && !IS_IOS && !IS_ANDROID) {\n                controlBar.on('mouseenter', function (event) {\n                    if (this.player().options_.inactivityTimeout !== 0) {\n                        this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;\n                    }\n                    this.player().options_.inactivityTimeout = 0;\n                });\n                controlBar.on('mouseleave', function (event) {\n                    this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;\n                });\n            }\n\n            // Listen for keyboard navigation\n            // Shouldn't need to use inProgress interval because of key repeat\n            this.on('keydown', handleActivity);\n            this.on('keyup', handleActivity);\n\n            // Run an interval every 250 milliseconds instead of stuffing everything into\n            // the mousemove/touchmove function itself, to prevent performance degradation.\n            // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n            // then gets picked up by this loop\n            // http://ejohn.org/blog/learning-from-twitter/\n            let inactivityTimeout;\n\n            /** @this Player */\n            const activityCheck = function () {\n                // Check to see if mouse/touch activity has happened\n                if (!this.userActivity_) {\n                    return;\n                }\n\n                // Reset the activity tracker\n                this.userActivity_ = false;\n\n                // If the user state was inactive, set the state to active\n                this.userActive(true);\n\n                // Clear any existing inactivity timeout to start the timer over\n                this.clearTimeout(inactivityTimeout);\n                const timeout = this.options_.inactivityTimeout;\n                if (timeout <= 0) {\n                    return;\n                }\n\n                // In <timeout> milliseconds, if no more activity has occurred the\n                // user will be considered inactive\n                inactivityTimeout = this.setTimeout(function () {\n                    // Protect against the case where the inactivityTimeout can trigger just\n                    // before the next user activity is picked up by the activity check loop\n                    // causing a flicker\n                    if (!this.userActivity_) {\n                        this.userActive(false);\n                    }\n                }, timeout);\n            };\n            this.setInterval(activityCheck, 250);\n        }\n\n        /**\n         * Gets or sets the current playback rate. A playback rate of\n         * 1.0 represents normal speed and 0.5 would indicate half-speed\n         * playback, for instance.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n         *\n         * @param {number} [rate]\n         *       New playback rate to set.\n         *\n         * @return {number|undefined}\n         *         - The current playback rate when getting or 1.0\n         *         - Nothing when setting\n         */\n        playbackRate(rate) {\n            if (rate !== undefined) {\n                // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n                // that is registered above\n                this.techCall_('setPlaybackRate', rate);\n                return;\n            }\n            if (this.tech_ && this.tech_.featuresPlaybackRate) {\n                return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n            }\n            return 1.0;\n        }\n\n        /**\n         * Gets or sets the current default playback rate. A default playback rate of\n         * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n         * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\n         * not the current playbackRate.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n         *\n         * @param {number} [rate]\n         *       New default playback rate to set.\n         *\n         * @return {number|undefined}\n         *         - The default playback rate when getting or 1.0\n         *         - Nothing when setting\n         */\n        defaultPlaybackRate(rate) {\n            if (rate !== undefined) {\n                return this.techCall_('setDefaultPlaybackRate', rate);\n            }\n            if (this.tech_ && this.tech_.featuresPlaybackRate) {\n                return this.techGet_('defaultPlaybackRate');\n            }\n            return 1.0;\n        }\n\n        /**\n         * Gets or sets the audio flag\n         *\n         * @param {boolean} [bool]\n         *        - true signals that this is an audio player\n         *        - false signals that this is not an audio player\n         *\n         * @return {boolean|undefined}\n         *         - The current value of isAudio when getting\n         *         - Nothing when setting\n         */\n        isAudio(bool) {\n            if (bool !== undefined) {\n                this.isAudio_ = !!bool;\n                return;\n            }\n            return !!this.isAudio_;\n        }\n        enableAudioOnlyUI_() {\n            // Update styling immediately to show the control bar so we can get its height\n            this.addClass('vjs-audio-only-mode');\n            const playerChildren = this.children();\n            const controlBar = this.getChild('ControlBar');\n            const controlBarHeight = controlBar && controlBar.currentHeight();\n\n            // Hide all player components except the control bar. Control bar components\n            // needed only for video are hidden with CSS\n            playerChildren.forEach(child => {\n                if (child === controlBar) {\n                    return;\n                }\n                if (child.el_ && !child.hasClass('vjs-hidden')) {\n                    child.hide();\n                    this.audioOnlyCache_.hiddenChildren.push(child);\n                }\n            });\n            this.audioOnlyCache_.playerHeight = this.currentHeight();\n\n            // Set the player height the same as the control bar\n            this.height(controlBarHeight);\n            this.trigger('audioonlymodechange');\n        }\n        disableAudioOnlyUI_() {\n            this.removeClass('vjs-audio-only-mode');\n\n            // Show player components that were previously hidden\n            this.audioOnlyCache_.hiddenChildren.forEach(child => child.show());\n\n            // Reset player height\n            this.height(this.audioOnlyCache_.playerHeight);\n            this.trigger('audioonlymodechange');\n        }\n\n        /**\n         * Get the current audioOnlyMode state or set audioOnlyMode to true or false.\n         *\n         * Setting this to `true` will hide all player components except the control bar,\n         * as well as control bar components needed only for video.\n         *\n         * @param {boolean} [value]\n         *         The value to set audioOnlyMode to.\n         *\n         * @return {Promise|boolean}\n         *        A Promise is returned when setting the state, and a boolean when getting\n         *        the present state\n         */\n        audioOnlyMode(value) {\n            if (typeof value !== 'boolean' || value === this.audioOnlyMode_) {\n                return this.audioOnlyMode_;\n            }\n            this.audioOnlyMode_ = value;\n\n            // Enable Audio Only Mode\n            if (value) {\n                const exitPromises = [];\n\n                // Fullscreen and PiP are not supported in audioOnlyMode, so exit if we need to.\n                if (this.isInPictureInPicture()) {\n                    exitPromises.push(this.exitPictureInPicture());\n                }\n                if (this.isFullscreen()) {\n                    exitPromises.push(this.exitFullscreen());\n                }\n                if (this.audioPosterMode()) {\n                    exitPromises.push(this.audioPosterMode(false));\n                }\n                return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());\n            }\n\n            // Disable Audio Only Mode\n            return Promise.resolve().then(() => this.disableAudioOnlyUI_());\n        }\n        enablePosterModeUI_() {\n            // Hide the video element and show the poster image to enable posterModeUI\n            const tech = this.tech_ && this.tech_;\n            tech.hide();\n            this.addClass('vjs-audio-poster-mode');\n            this.trigger('audiopostermodechange');\n        }\n        disablePosterModeUI_() {\n            // Show the video element and hide the poster image to disable posterModeUI\n            const tech = this.tech_ && this.tech_;\n            tech.show();\n            this.removeClass('vjs-audio-poster-mode');\n            this.trigger('audiopostermodechange');\n        }\n\n        /**\n         * Get the current audioPosterMode state or set audioPosterMode to true or false\n         *\n         * @param {boolean} [value]\n         *         The value to set audioPosterMode to.\n         *\n         * @return {Promise|boolean}\n         *         A Promise is returned when setting the state, and a boolean when getting\n         *        the present state\n         */\n        audioPosterMode(value) {\n            if (typeof value !== 'boolean' || value === this.audioPosterMode_) {\n                return this.audioPosterMode_;\n            }\n            this.audioPosterMode_ = value;\n            if (value) {\n                if (this.audioOnlyMode()) {\n                    const audioOnlyModePromise = this.audioOnlyMode(false);\n                    return audioOnlyModePromise.then(() => {\n                        // enable audio poster mode after audio only mode is disabled\n                        this.enablePosterModeUI_();\n                    });\n                }\n                return Promise.resolve().then(() => {\n                    // enable audio poster mode\n                    this.enablePosterModeUI_();\n                });\n            }\n            return Promise.resolve().then(() => {\n                // disable audio poster mode\n                this.disablePosterModeUI_();\n            });\n        }\n\n        /**\n         * A helper method for adding a {@link TextTrack} to our\n         * {@link TextTrackList}.\n         *\n         * In addition to the W3C settings we allow adding additional info through options.\n         *\n         * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n         *\n         * @param {string} [kind]\n         *        the kind of TextTrack you are adding\n         *\n         * @param {string} [label]\n         *        the label to give the TextTrack label\n         *\n         * @param {string} [language]\n         *        the language to set on the TextTrack\n         *\n         * @return {TextTrack|undefined}\n         *         the TextTrack that was added or undefined\n         *         if there is no tech\n         */\n        addTextTrack(kind, label, language) {\n            if (this.tech_) {\n                return this.tech_.addTextTrack(kind, label, language);\n            }\n        }\n\n        /**\n         * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.\n         *\n         * @param {Object} options\n         *        Options to pass to {@link HTMLTrackElement} during creation. See\n         *        {@link HTMLTrackElement} for object properties that you should use.\n         *\n         * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed\n         *                                        from the TextTrackList and HtmlTrackElementList\n         *                                        after a source change\n         *\n         * @return { import('./tracks/html-track-element').default }\n         *         the HTMLTrackElement that was created and added\n         *         to the HtmlTrackElementList and the remote\n         *         TextTrackList\n         *\n         */\n        addRemoteTextTrack(options, manualCleanup) {\n            if (this.tech_) {\n                return this.tech_.addRemoteTextTrack(options, manualCleanup);\n            }\n        }\n\n        /**\n         * Remove a remote {@link TextTrack} from the respective\n         * {@link TextTrackList} and {@link HtmlTrackElementList}.\n         *\n         * @param {Object} track\n         *        Remote {@link TextTrack} to remove\n         *\n         * @return {undefined}\n         *         does not return anything\n         */\n        removeRemoteTextTrack(obj = {}) {\n            let {\n                track\n            } = obj;\n            if (!track) {\n                track = obj;\n            }\n\n            // destructure the input into an object with a track argument, defaulting to arguments[0]\n            // default the whole argument to an empty object if nothing was passed in\n\n            if (this.tech_) {\n                return this.tech_.removeRemoteTextTrack(track);\n            }\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object|undefined}\n         *         An object with supported media playback quality metrics or undefined if there\n         *         is no tech or the tech does not support it.\n         */\n        getVideoPlaybackQuality() {\n            return this.techGet_('getVideoPlaybackQuality');\n        }\n\n        /**\n         * Get video width\n         *\n         * @return {number}\n         *         current video width\n         */\n        videoWidth() {\n            return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n        }\n\n        /**\n         * Get video height\n         *\n         * @return {number}\n         *         current video height\n         */\n        videoHeight() {\n            return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n        }\n\n        /**\n         * Set or get the player's language code.\n         *\n         * Changing the language will trigger\n         * [languagechange]{@link Player#event:languagechange}\n         * which Components can use to update control text.\n         * ClickableComponent will update its control text by default on\n         * [languagechange]{@link Player#event:languagechange}.\n         *\n         * @fires Player#languagechange\n         *\n         * @param {string} [code]\n         *        the language code to set the player to\n         *\n         * @return {string|undefined}\n         *         - The current language code when getting\n         *         - Nothing when setting\n         */\n        language(code) {\n            if (code === undefined) {\n                return this.language_;\n            }\n            if (this.language_ !== String(code).toLowerCase()) {\n                this.language_ = String(code).toLowerCase();\n\n                // during first init, it's possible some things won't be evented\n                if (isEvented(this)) {\n                    /**\n                     * fires when the player language change\n                     *\n                     * @event Player#languagechange\n                     * @type {Event}\n                     */\n                    this.trigger('languagechange');\n                }\n            }\n        }\n\n        /**\n         * Get the player's language dictionary\n         * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n         * Languages specified directly in the player options have precedence\n         *\n         * @return {Array}\n         *         An array of of supported languages\n         */\n        languages() {\n            return merge$2(Player.prototype.options_.languages, this.languages_);\n        }\n\n        /**\n         * returns a JavaScript object representing the current track\n         * information. **DOES not return it as JSON**\n         *\n         * @return {Object}\n         *         Object representing the current of track info\n         */\n        toJSON() {\n            const options = merge$2(this.options_);\n            const tracks = options.tracks;\n            options.tracks = [];\n            for (let i = 0; i < tracks.length; i++) {\n                let track = tracks[i];\n\n                // deep merge tracks and null out player so no circular references\n                track = merge$2(track);\n                track.player = undefined;\n                options.tracks[i] = track;\n            }\n            return options;\n        }\n\n        /**\n         * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n         * component) that immediately overlays the player with arbitrary\n         * content and removes itself when closed.\n         *\n         * @param {string|Function|Element|Array|null} content\n         *        Same as {@link ModalDialog#content}'s param of the same name.\n         *        The most straight-forward usage is to provide a string or DOM\n         *        element.\n         *\n         * @param {Object} [options]\n         *        Extra options which will be passed on to the {@link ModalDialog}.\n         *\n         * @return {ModalDialog}\n         *         the {@link ModalDialog} that was created\n         */\n        createModal(content, options) {\n            options = options || {};\n            options.content = content || '';\n            const modal = new ModalDialog(this, options);\n            this.addChild(modal);\n            modal.on('dispose', () => {\n                this.removeChild(modal);\n            });\n            modal.open();\n            return modal;\n        }\n\n        /**\n         * Change breakpoint classes when the player resizes.\n         *\n         * @private\n         */\n        updateCurrentBreakpoint_() {\n            if (!this.responsive()) {\n                return;\n            }\n            const currentBreakpoint = this.currentBreakpoint();\n            const currentWidth = this.currentWidth();\n            for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {\n                const candidateBreakpoint = BREAKPOINT_ORDER[i];\n                const maxWidth = this.breakpoints_[candidateBreakpoint];\n                if (currentWidth <= maxWidth) {\n                    // The current breakpoint did not change, nothing to do.\n                    if (currentBreakpoint === candidateBreakpoint) {\n                        return;\n                    }\n\n                    // Only remove a class if there is a current breakpoint.\n                    if (currentBreakpoint) {\n                        this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\n                    }\n                    this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\n                    this.breakpoint_ = candidateBreakpoint;\n                    break;\n                }\n            }\n        }\n\n        /**\n         * Removes the current breakpoint.\n         *\n         * @private\n         */\n        removeCurrentBreakpoint_() {\n            const className = this.currentBreakpointClass();\n            this.breakpoint_ = '';\n            if (className) {\n                this.removeClass(className);\n            }\n        }\n\n        /**\n         * Get or set breakpoints on the player.\n         *\n         * Calling this method with an object or `true` will remove any previous\n         * custom breakpoints and start from the defaults again.\n         *\n         * @param  {Object|boolean} [breakpoints]\n         *         If an object is given, it can be used to provide custom\n         *         breakpoints. If `true` is given, will set default breakpoints.\n         *         If this argument is not given, will simply return the current\n         *         breakpoints.\n         *\n         * @param  {number} [breakpoints.tiny]\n         *         The maximum width for the \"vjs-layout-tiny\" class.\n         *\n         * @param  {number} [breakpoints.xsmall]\n         *         The maximum width for the \"vjs-layout-x-small\" class.\n         *\n         * @param  {number} [breakpoints.small]\n         *         The maximum width for the \"vjs-layout-small\" class.\n         *\n         * @param  {number} [breakpoints.medium]\n         *         The maximum width for the \"vjs-layout-medium\" class.\n         *\n         * @param  {number} [breakpoints.large]\n         *         The maximum width for the \"vjs-layout-large\" class.\n         *\n         * @param  {number} [breakpoints.xlarge]\n         *         The maximum width for the \"vjs-layout-x-large\" class.\n         *\n         * @param  {number} [breakpoints.huge]\n         *         The maximum width for the \"vjs-layout-huge\" class.\n         *\n         * @return {Object}\n         *         An object mapping breakpoint names to maximum width values.\n         */\n        breakpoints(breakpoints) {\n            // Used as a getter.\n            if (breakpoints === undefined) {\n                return Object.assign(this.breakpoints_);\n            }\n            this.breakpoint_ = '';\n            this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);\n\n            // When breakpoint definitions change, we need to update the currently\n            // selected breakpoint.\n            this.updateCurrentBreakpoint_();\n\n            // Clone the breakpoints before returning.\n            return Object.assign(this.breakpoints_);\n        }\n\n        /**\n         * Get or set a flag indicating whether or not this player should adjust\n         * its UI based on its dimensions.\n         *\n         * @param  {boolean} [value]\n         *         Should be `true` if the player should adjust its UI based on its\n         *         dimensions; otherwise, should be `false`.\n         *\n         * @return {boolean|undefined}\n         *         Will be `true` if this player should adjust its UI based on its\n         *         dimensions; otherwise, will be `false`.\n         *         Nothing if setting\n         */\n        responsive(value) {\n            // Used as a getter.\n            if (value === undefined) {\n                return this.responsive_;\n            }\n            value = Boolean(value);\n            const current = this.responsive_;\n\n            // Nothing changed.\n            if (value === current) {\n                return;\n            }\n\n            // The value actually changed, set it.\n            this.responsive_ = value;\n\n            // Start listening for breakpoints and set the initial breakpoint if the\n            // player is now responsive.\n            if (value) {\n                this.on('playerresize', this.boundUpdateCurrentBreakpoint_);\n                this.updateCurrentBreakpoint_();\n\n                // Stop listening for breakpoints if the player is no longer responsive.\n            } else {\n                this.off('playerresize', this.boundUpdateCurrentBreakpoint_);\n                this.removeCurrentBreakpoint_();\n            }\n            return value;\n        }\n\n        /**\n         * Get current breakpoint name, if any.\n         *\n         * @return {string}\n         *         If there is currently a breakpoint set, returns a the key from the\n         *         breakpoints object matching it. Otherwise, returns an empty string.\n         */\n        currentBreakpoint() {\n            return this.breakpoint_;\n        }\n\n        /**\n         * Get the current breakpoint class name.\n         *\n         * @return {string}\n         *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\n         *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\n         *         there is no current breakpoint.\n         */\n        currentBreakpointClass() {\n            return BREAKPOINT_CLASSES[this.breakpoint_] || '';\n        }\n\n        /**\n         * An object that describes a single piece of media.\n         *\n         * Properties that are not part of this type description will be retained; so,\n         * this can be viewed as a generic metadata storage mechanism as well.\n         *\n         * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}\n         * @typedef  {Object} Player~MediaObject\n         *\n         * @property {string} [album]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {string} [artist]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {Object[]} [artwork]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API. If not specified, will be populated via the `poster`, if\n         *           available.\n         *\n         * @property {string} [poster]\n         *           URL to an image that will display before playback.\n         *\n         * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]\n         *           A single source object, an array of source objects, or a string\n         *           referencing a URL to a media source. It is _highly recommended_\n         *           that an object or array of objects is used here, so that source\n         *           selection algorithms can take the `type` into account.\n         *\n         * @property {string} [title]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {Object[]} [textTracks]\n         *           An array of objects to be used to create text tracks, following\n         *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.\n         *           For ease of removal, these will be created as \"remote\" text\n         *           tracks and set to automatically clean up on source changes.\n         *\n         *           These objects may have properties like `src`, `kind`, `label`,\n         *           and `language`, see {@link Tech#createRemoteTextTrack}.\n         */\n\n        /**\n         * Populate the player using a {@link Player~MediaObject|MediaObject}.\n         *\n         * @param  {Player~MediaObject} media\n         *         A media object.\n         *\n         * @param  {Function} ready\n         *         A callback to be called when the player is ready.\n         */\n        loadMedia(media, ready) {\n            if (!media || typeof media !== 'object') {\n                return;\n            }\n            const crossOrigin = this.crossOrigin();\n            this.reset();\n\n            // Clone the media object so it cannot be mutated from outside.\n            this.cache_.media = merge$2(media);\n            const {\n                artist,\n                artwork,\n                description,\n                poster,\n                src,\n                textTracks,\n                title\n            } = this.cache_.media;\n\n            // If `artwork` is not given, create it using `poster`.\n            if (!artwork && poster) {\n                this.cache_.media.artwork = [{\n                    src: poster,\n                    type: getMimetype(poster)\n                }];\n            }\n            if (crossOrigin) {\n                this.crossOrigin(crossOrigin);\n            }\n            if (src) {\n                this.src(src);\n            }\n            if (poster) {\n                this.poster(poster);\n            }\n            if (Array.isArray(textTracks)) {\n                textTracks.forEach(tt => this.addRemoteTextTrack(tt, false));\n            }\n            if (this.titleBar) {\n                this.titleBar.update({\n                    title,\n                    description: description || artist || ''\n                });\n            }\n            this.ready(ready);\n        }\n\n        /**\n         * Get a clone of the current {@link Player~MediaObject} for this player.\n         *\n         * If the `loadMedia` method has not been used, will attempt to return a\n         * {@link Player~MediaObject} based on the current state of the player.\n         *\n         * @return {Player~MediaObject}\n         */\n        getMedia() {\n            if (!this.cache_.media) {\n                const poster = this.poster();\n                const src = this.currentSources();\n                const textTracks = Array.prototype.map.call(this.remoteTextTracks(), tt => ({\n                    kind: tt.kind,\n                    label: tt.label,\n                    language: tt.language,\n                    src: tt.src\n                }));\n                const media = {\n                    src,\n                    textTracks\n                };\n                if (poster) {\n                    media.poster = poster;\n                    media.artwork = [{\n                        src: media.poster,\n                        type: getMimetype(media.poster)\n                    }];\n                }\n                return media;\n            }\n            return merge$2(this.cache_.media);\n        }\n\n        /**\n         * Gets tag settings\n         *\n         * @param {Element} tag\n         *        The player tag\n         *\n         * @return {Object}\n         *         An object containing all of the settings\n         *         for a player tag\n         */\n        static getTagSettings(tag) {\n            const baseOptions = {\n                sources: [],\n                tracks: []\n            };\n            const tagOptions = getAttributes(tag);\n            const dataSetup = tagOptions['data-setup'];\n            if (hasClass(tag, 'vjs-fill')) {\n                tagOptions.fill = true;\n            }\n            if (hasClass(tag, 'vjs-fluid')) {\n                tagOptions.fluid = true;\n            }\n\n            // Check if data-setup attr exists.\n            if (dataSetup !== null) {\n                // Parse options JSON\n                // If empty string, make it a parsable json object.\n                const [err, data] = tuple(dataSetup || '{}');\n                if (err) {\n                    log$1.error(err);\n                }\n                Object.assign(tagOptions, data);\n            }\n            Object.assign(baseOptions, tagOptions);\n\n            // Get tag children settings\n            if (tag.hasChildNodes()) {\n                const children = tag.childNodes;\n                for (let i = 0, j = children.length; i < j; i++) {\n                    const child = children[i];\n                    // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n                    const childName = child.nodeName.toLowerCase();\n                    if (childName === 'source') {\n                        baseOptions.sources.push(getAttributes(child));\n                    } else if (childName === 'track') {\n                        baseOptions.tracks.push(getAttributes(child));\n                    }\n                }\n            }\n            return baseOptions;\n        }\n\n        /**\n         * Set debug mode to enable/disable logs at info level.\n         *\n         * @param {boolean} enabled\n         * @fires Player#debugon\n         * @fires Player#debugoff\n         * @return {boolean|undefined}\n         */\n        debug(enabled) {\n            if (enabled === undefined) {\n                return this.debugEnabled_;\n            }\n            if (enabled) {\n                this.trigger('debugon');\n                this.previousLogLevel_ = this.log.level;\n                this.log.level('debug');\n                this.debugEnabled_ = true;\n            } else {\n                this.trigger('debugoff');\n                this.log.level(this.previousLogLevel_);\n                this.previousLogLevel_ = undefined;\n                this.debugEnabled_ = false;\n            }\n        }\n\n        /**\n         * Set or get current playback rates.\n         * Takes an array and updates the playback rates menu with the new items.\n         * Pass in an empty array to hide the menu.\n         * Values other than arrays are ignored.\n         *\n         * @fires Player#playbackrateschange\n         * @param {number[]} newRates\n         *                   The new rates that the playback rates menu should update to.\n         *                   An empty array will hide the menu\n         * @return {number[]} When used as a getter will return the current playback rates\n         */\n        playbackRates(newRates) {\n            if (newRates === undefined) {\n                return this.cache_.playbackRates;\n            }\n\n            // ignore any value that isn't an array\n            if (!Array.isArray(newRates)) {\n                return;\n            }\n\n            // ignore any arrays that don't only contain numbers\n            if (!newRates.every(rate => typeof rate === 'number')) {\n                return;\n            }\n            this.cache_.playbackRates = newRates;\n\n            /**\n             * fires when the playback rates in a player are changed\n             *\n             * @event Player#playbackrateschange\n             * @type {Event}\n             */\n            this.trigger('playbackrateschange');\n        }\n    }\n\n    /**\n     * Get the {@link VideoTrackList}\n     *\n     * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n     *\n     * @return {VideoTrackList}\n     *         the current video track list\n     *\n     * @method Player.prototype.videoTracks\n     */\n\n    /**\n     * Get the {@link AudioTrackList}\n     *\n     * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n     *\n     * @return {AudioTrackList}\n     *         the current audio track list\n     *\n     * @method Player.prototype.audioTracks\n     */\n\n    /**\n     * Get the {@link TextTrackList}\n     *\n     * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n     *\n     * @return {TextTrackList}\n     *         the current text track list\n     *\n     * @method Player.prototype.textTracks\n     */\n\n    /**\n     * Get the remote {@link TextTrackList}\n     *\n     * @return {TextTrackList}\n     *         The current remote text track list\n     *\n     * @method Player.prototype.remoteTextTracks\n     */\n\n    /**\n     * Get the remote {@link HtmlTrackElementList} tracks.\n     *\n     * @return {HtmlTrackElementList}\n     *         The current remote text track element list\n     *\n     * @method Player.prototype.remoteTextTrackEls\n     */\n\n    ALL.names.forEach(function (name) {\n        const props = ALL[name];\n        Player.prototype[props.getterName] = function () {\n            if (this.tech_) {\n                return this.tech_[props.getterName]();\n            }\n\n            // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n            // these will be passed to the tech during loading\n            this[props.privateName] = this[props.privateName] || new props.ListClass();\n            return this[props.privateName];\n        };\n    });\n\n    /**\n     * Get or set the `Player`'s crossorigin option. For the HTML5 player, this\n     * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n     * behavior.\n     *\n     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n     *\n     * @param {string} [value]\n     *        The value to set the `Player`'s crossorigin to. If an argument is\n     *        given, must be one of `anonymous` or `use-credentials`.\n     *\n     * @return {string|undefined}\n     *         - The current crossorigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    Player.prototype.crossorigin = Player.prototype.crossOrigin;\n\n    /**\n     * Global enumeration of players.\n     *\n     * The keys are the player IDs and the values are either the {@link Player}\n     * instance or `null` for disposed players.\n     *\n     * @type {Object}\n     */\n    Player.players = {};\n    const navigator = window.navigator;\n\n    /*\n   * Player instance options, surfaced using options\n   * options = Player.prototype.options_\n   * Make changes in options, not here.\n   *\n   * @type {Object}\n   * @private\n   */\n    Player.prototype.options_ = {\n        // Default order of fallback technology\n        techOrder: Tech.defaultTechOrder_,\n        html5: {},\n        // enable sourceset by default\n        enableSourceset: true,\n        // default inactivity timeout\n        inactivityTimeout: 2000,\n        // default playback rates\n        playbackRates: [],\n        // Add playback rate selection by adding rates\n        // 'playbackRates': [0.5, 1, 1.5, 2],\n        liveui: false,\n        // Included control sets\n        children: ['mediaLoader', 'posterImage', 'titleBar', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\n        language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n        // locales and their language translations\n        languages: {},\n        // Default message to show when a video cannot be played.\n        notSupportedMessage: 'No compatible source was found for this media.',\n        normalizeAutoplay: false,\n        fullscreen: {\n            options: {\n                navigationUI: 'hide'\n            }\n        },\n        breakpoints: {},\n        responsive: false,\n        audioOnlyMode: false,\n        audioPosterMode: false,\n        // Default smooth seeking to false\n        enableSmoothSeeking: false\n    };\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n        Player.prototype[`handleTech${toTitleCase$1(event)}_`] = function () {\n            return this.trigger(event);\n        };\n    });\n\n    /**\n     * Fired when the player has initial duration and dimension information\n     *\n     * @event Player#loadedmetadata\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the player has downloaded data at the current playback position\n     *\n     * @event Player#loadeddata\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the current playback position has changed *\n     * During playback this is fired every 15-250 milliseconds, depending on the\n     * playback technology in use.\n     *\n     * @event Player#timeupdate\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the volume changes\n     *\n     * @event Player#volumechange\n     * @type {Event}\n     */\n\n    /**\n     * Reports whether or not a player has a plugin available.\n     *\n     * This does not report whether or not the plugin has ever been initialized\n     * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n     *\n     * @method Player#hasPlugin\n     * @param  {string}  name\n     *         The name of a plugin.\n     *\n     * @return {boolean}\n     *         Whether or not this player has the requested plugin available.\n     */\n\n    /**\n     * Reports whether or not a player is using a plugin by name.\n     *\n     * For basic plugins, this only reports whether the plugin has _ever_ been\n     * initialized on this player.\n     *\n     * @method Player#usingPlugin\n     * @param  {string} name\n     *         The name of a plugin.\n     *\n     * @return {boolean}\n     *         Whether or not this player is using the requested plugin.\n     */\n\n    Component$1.registerComponent('Player', Player);\n\n    /**\n     * @file plugin.js\n     */\n\n    /**\n     * The base plugin name.\n     *\n     * @private\n     * @constant\n     * @type {string}\n     */\n    const BASE_PLUGIN_NAME = 'plugin';\n\n    /**\n     * The key on which a player's active plugins cache is stored.\n     *\n     * @private\n     * @constant\n     * @type     {string}\n     */\n    const PLUGIN_CACHE_KEY = 'activePlugins_';\n\n    /**\n     * Stores registered plugins in a private space.\n     *\n     * @private\n     * @type    {Object}\n     */\n    const pluginStorage = {};\n\n    /**\n     * Reports whether or not a plugin has been registered.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of a plugin.\n     *\n     * @return {boolean}\n     *          Whether or not the plugin has been registered.\n     */\n    const pluginExists = name => pluginStorage.hasOwnProperty(name);\n\n    /**\n     * Get a single registered plugin by name.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of a plugin.\n     *\n     * @return {typeof Plugin|Function|undefined}\n     *          The plugin (or undefined).\n     */\n    const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;\n\n    /**\n     * Marks a plugin as \"active\" on a player.\n     *\n     * Also, ensures that the player has an object for tracking active plugins.\n     *\n     * @private\n     * @param   {Player} player\n     *          A Video.js player instance.\n     *\n     * @param   {string} name\n     *          The name of a plugin.\n     */\n    const markPluginAsActive = (player, name) => {\n        player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n        player[PLUGIN_CACHE_KEY][name] = true;\n    };\n\n    /**\n     * Triggers a pair of plugin setup events.\n     *\n     * @private\n     * @param  {Player} player\n     *         A Video.js player instance.\n     *\n     * @param  {PluginEventHash} hash\n     *         A plugin event hash.\n     *\n     * @param  {boolean} [before]\n     *         If true, prefixes the event name with \"before\". In other words,\n     *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n     */\n    const triggerSetupEvent = (player, hash, before) => {\n        const eventName = (before ? 'before' : '') + 'pluginsetup';\n        player.trigger(eventName, hash);\n        player.trigger(eventName + ':' + hash.name, hash);\n    };\n\n    /**\n     * Takes a basic plugin function and returns a wrapper function which marks\n     * on the player that the plugin has been activated.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of the plugin.\n     *\n     * @param   {Function} plugin\n     *          The basic plugin.\n     *\n     * @return {Function}\n     *          A wrapper function for the given plugin.\n     */\n    const createBasicPlugin = function (name, plugin) {\n        const basicPluginWrapper = function () {\n            // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n            // regardless, but we want the hash to be consistent with the hash provided\n            // for advanced plugins.\n            //\n            // The only potentially counter-intuitive thing here is the `instance` in\n            // the \"pluginsetup\" event is the value returned by the `plugin` function.\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance: null\n            }, true);\n            const instance = plugin.apply(this, arguments);\n            markPluginAsActive(this, name);\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance\n            });\n            return instance;\n        };\n        Object.keys(plugin).forEach(function (prop) {\n            basicPluginWrapper[prop] = plugin[prop];\n        });\n        return basicPluginWrapper;\n    };\n\n    /**\n     * Takes a plugin sub-class and returns a factory function for generating\n     * instances of it.\n     *\n     * This factory function will replace itself with an instance of the requested\n     * sub-class of Plugin.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of the plugin.\n     *\n     * @param   {Plugin} PluginSubClass\n     *          The advanced plugin.\n     *\n     * @return {Function}\n     */\n    const createPluginFactory = (name, PluginSubClass) => {\n        // Add a `name` property to the plugin prototype so that each plugin can\n        // refer to itself by name.\n        PluginSubClass.prototype.name = name;\n        return function (...args) {\n            triggerSetupEvent(this, {\n                name,\n                plugin: PluginSubClass,\n                instance: null\n            }, true);\n            const instance = new PluginSubClass(...[this, ...args]);\n\n            // The plugin is replaced by a function that returns the current instance.\n            this[name] = () => instance;\n            triggerSetupEvent(this, instance.getEventHash());\n            return instance;\n        };\n    };\n\n    /**\n     * Parent class for all advanced plugins.\n     *\n     * @mixes   module:evented~EventedMixin\n     * @mixes   module:stateful~StatefulMixin\n     * @fires   Player#beforepluginsetup\n     * @fires   Player#beforepluginsetup:$name\n     * @fires   Player#pluginsetup\n     * @fires   Player#pluginsetup:$name\n     * @listens Player#dispose\n     * @throws  {Error}\n     *          If attempting to instantiate the base {@link Plugin} class\n     *          directly instead of via a sub-class.\n     */\n    class Plugin {\n        /**\n         * Creates an instance of this class.\n         *\n         * Sub-classes should call `super` to ensure plugins are properly initialized.\n         *\n         * @param {Player} player\n         *        A Video.js player instance.\n         */\n        constructor(player) {\n            if (this.constructor === Plugin) {\n                throw new Error('Plugin must be sub-classed; not directly instantiated.');\n            }\n            this.player = player;\n            if (!this.log) {\n                this.log = this.player.log.createLogger(this.name);\n            }\n\n            // Make this object evented, but remove the added `trigger` method so we\n            // use the prototype version instead.\n            evented(this);\n            delete this.trigger;\n            stateful(this, this.constructor.defaultState);\n            markPluginAsActive(player, this.name);\n\n            // Auto-bind the dispose method so we can use it as a listener and unbind\n            // it later easily.\n            this.dispose = this.dispose.bind(this);\n\n            // If the player is disposed, dispose the plugin.\n            player.on('dispose', this.dispose);\n        }\n\n        /**\n         * Get the version of the plugin that was set on <pluginName>.VERSION\n         */\n        version() {\n            return this.constructor.VERSION;\n        }\n\n        /**\n         * Each event triggered by plugins includes a hash of additional data with\n         * conventional properties.\n         *\n         * This returns that object or mutates an existing hash.\n         *\n         * @param   {Object} [hash={}]\n         *          An object to be used as event an event hash.\n         *\n         * @return {PluginEventHash}\n         *          An event hash object with provided properties mixed-in.\n         */\n        getEventHash(hash = {}) {\n            hash.name = this.name;\n            hash.plugin = this.constructor;\n            hash.instance = this;\n            return hash;\n        }\n\n        /**\n         * Triggers an event on the plugin object and overrides\n         * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n         *\n         * @param   {string|Object} event\n         *          An event type or an object with a type property.\n         *\n         * @param   {Object} [hash={}]\n         *          Additional data hash to merge with a\n         *          {@link PluginEventHash|PluginEventHash}.\n         *\n         * @return {boolean}\n         *          Whether or not default was prevented.\n         */\n        trigger(event, hash = {}) {\n            return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n        }\n\n        /**\n         * Handles \"statechanged\" events on the plugin. No-op by default, override by\n         * subclassing.\n         *\n         * @abstract\n         * @param    {Event} e\n         *           An event object provided by a \"statechanged\" event.\n         *\n         * @param    {Object} e.changes\n         *           An object describing changes that occurred with the \"statechanged\"\n         *           event.\n         */\n        handleStateChanged(e) {}\n\n        /**\n         * Disposes a plugin.\n         *\n         * Subclasses can override this if they want, but for the sake of safety,\n         * it's probably best to subscribe the \"dispose\" event.\n         *\n         * @fires Plugin#dispose\n         */\n        dispose() {\n            const {\n                name,\n                player\n            } = this;\n\n            /**\n             * Signals that a advanced plugin is about to be disposed.\n             *\n             * @event Plugin#dispose\n             * @type  {Event}\n             */\n            this.trigger('dispose');\n            this.off();\n            player.off('dispose', this.dispose);\n\n            // Eliminate any possible sources of leaking memory by clearing up\n            // references between the player and the plugin instance and nulling out\n            // the plugin's state and replacing methods with a function that throws.\n            player[PLUGIN_CACHE_KEY][name] = false;\n            this.player = this.state = null;\n\n            // Finally, replace the plugin name on the player with a new factory\n            // function, so that the plugin is ready to be set up again.\n            player[name] = createPluginFactory(name, pluginStorage[name]);\n        }\n\n        /**\n         * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n         *\n         * @param   {string|Function} plugin\n         *          If a string, matches the name of a plugin. If a function, will be\n         *          tested directly.\n         *\n         * @return {boolean}\n         *          Whether or not a plugin is a basic plugin.\n         */\n        static isBasic(plugin) {\n            const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n            return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n        }\n\n        /**\n         * Register a Video.js plugin.\n         *\n         * @param   {string} name\n         *          The name of the plugin to be registered. Must be a string and\n         *          must not match an existing plugin or a method on the `Player`\n         *          prototype.\n         *\n         * @param   {typeof Plugin|Function} plugin\n         *          A sub-class of `Plugin` or a function for basic plugins.\n         *\n         * @return {typeof Plugin|Function}\n         *          For advanced plugins, a factory function for that plugin. For\n         *          basic plugins, a wrapper function that initializes the plugin.\n         */\n        static registerPlugin(name, plugin) {\n            if (typeof name !== 'string') {\n                throw new Error(`Illegal plugin name, \"${name}\", must be a string, was ${typeof name}.`);\n            }\n            if (pluginExists(name)) {\n                log$1.warn(`A plugin named \"${name}\" already exists. You may want to avoid re-registering plugins!`);\n            } else if (Player.prototype.hasOwnProperty(name)) {\n                throw new Error(`Illegal plugin name, \"${name}\", cannot share a name with an existing player method!`);\n            }\n            if (typeof plugin !== 'function') {\n                throw new Error(`Illegal plugin for \"${name}\", must be a function, was ${typeof plugin}.`);\n            }\n            pluginStorage[name] = plugin;\n\n            // Add a player prototype method for all sub-classed plugins (but not for\n            // the base Plugin class).\n            if (name !== BASE_PLUGIN_NAME) {\n                if (Plugin.isBasic(plugin)) {\n                    Player.prototype[name] = createBasicPlugin(name, plugin);\n                } else {\n                    Player.prototype[name] = createPluginFactory(name, plugin);\n                }\n            }\n            return plugin;\n        }\n\n        /**\n         * De-register a Video.js plugin.\n         *\n         * @param  {string} name\n         *         The name of the plugin to be de-registered. Must be a string that\n         *         matches an existing plugin.\n         *\n         * @throws {Error}\n         *         If an attempt is made to de-register the base plugin.\n         */\n        static deregisterPlugin(name) {\n            if (name === BASE_PLUGIN_NAME) {\n                throw new Error('Cannot de-register base plugin.');\n            }\n            if (pluginExists(name)) {\n                delete pluginStorage[name];\n                delete Player.prototype[name];\n            }\n        }\n\n        /**\n         * Gets an object containing multiple Video.js plugins.\n         *\n         * @param   {Array} [names]\n         *          If provided, should be an array of plugin names. Defaults to _all_\n         *          plugin names.\n         *\n         * @return {Object|undefined}\n         *          An object containing plugin(s) associated with their name(s) or\n         *          `undefined` if no matching plugins exist).\n         */\n        static getPlugins(names = Object.keys(pluginStorage)) {\n            let result;\n            names.forEach(name => {\n                const plugin = getPlugin(name);\n                if (plugin) {\n                    result = result || {};\n                    result[name] = plugin;\n                }\n            });\n            return result;\n        }\n\n        /**\n         * Gets a plugin's version, if available\n         *\n         * @param   {string} name\n         *          The name of a plugin.\n         *\n         * @return {string}\n         *          The plugin's version or an empty string.\n         */\n        static getPluginVersion(name) {\n            const plugin = getPlugin(name);\n            return plugin && plugin.VERSION || '';\n        }\n    }\n\n    /**\n     * Gets a plugin by name if it exists.\n     *\n     * @static\n     * @method   getPlugin\n     * @memberOf Plugin\n     * @param    {string} name\n     *           The name of a plugin.\n     *\n     * @returns  {typeof Plugin|Function|undefined}\n     *           The plugin (or `undefined`).\n     */\n    Plugin.getPlugin = getPlugin;\n\n    /**\n     * The name of the base plugin class as it is registered.\n     *\n     * @type {string}\n     */\n    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n    /**\n     * Documented in player.js\n     *\n     * @ignore\n     */\n    Player.prototype.usingPlugin = function (name) {\n        return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n    };\n\n    /**\n     * Documented in player.js\n     *\n     * @ignore\n     */\n    Player.prototype.hasPlugin = function (name) {\n        return !!pluginExists(name);\n    };\n\n    /**\n     * Signals that a plugin is about to be set up on a player.\n     *\n     * @event    Player#beforepluginsetup\n     * @type     {PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin is about to be set up on a player - by name. The name\n     * is the name of the plugin.\n     *\n     * @event    Player#beforepluginsetup:$name\n     * @type     {PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin has just been set up on a player.\n     *\n     * @event    Player#pluginsetup\n     * @type     {PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin has just been set up on a player - by name. The name\n     * is the name of the plugin.\n     *\n     * @event    Player#pluginsetup:$name\n     * @type     {PluginEventHash}\n     */\n\n    /**\n     * @typedef  {Object} PluginEventHash\n     *\n     * @property {string} instance\n     *           For basic plugins, the return value of the plugin function. For\n     *           advanced plugins, the plugin instance on which the event is fired.\n     *\n     * @property {string} name\n     *           The name of the plugin.\n     *\n     * @property {string} plugin\n     *           For basic plugins, the plugin function. For advanced plugins, the\n     *           plugin class/constructor.\n     */\n\n    /**\n     * @file deprecate.js\n     * @module deprecate\n     */\n\n    /**\n     * Decorate a function with a deprecation message the first time it is called.\n     *\n     * @param  {string}   message\n     *         A deprecation message to log the first time the returned function\n     *         is called.\n     *\n     * @param  {Function} fn\n     *         The function to be deprecated.\n     *\n     * @return {Function}\n     *         A wrapper function that will log a deprecation warning the first\n     *         time it is called. The return value will be the return value of\n     *         the wrapped function.\n     */\n    function deprecate(message, fn) {\n        let warned = false;\n        return function (...args) {\n            if (!warned) {\n                log$1.warn(message);\n            }\n            warned = true;\n            return fn.apply(this, args);\n        };\n    }\n\n    /**\n     * Internal function used to mark a function as deprecated in the next major\n     * version with consistent messaging.\n     *\n     * @param  {number}   major   The major version where it will be removed\n     * @param  {string}   oldName The old function name\n     * @param  {string}   newName The new function name\n     * @param  {Function} fn      The function to deprecate\n     * @return {Function}         The decorated function\n     */\n    function deprecateForMajor(major, oldName, newName, fn) {\n        return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);\n    }\n\n    /**\n     * @file video.js\n     * @module videojs\n     */\n\n    /**\n     * Normalize an `id` value by trimming off a leading `#`\n     *\n     * @private\n     * @param   {string} id\n     *          A string, maybe with a leading `#`.\n     *\n     * @return {string}\n     *          The string, without any leading `#`.\n     */\n    const normalizeId = id => id.indexOf('#') === 0 ? id.slice(1) : id;\n\n    /**\n     * A callback that is called when a component is ready. Does not have any\n     * parameters and any callback value will be ignored. See: {@link Component~ReadyCallback}\n     *\n     * @callback ReadyCallback\n     */\n\n    /**\n     * The `videojs()` function doubles as the main function for users to create a\n     * {@link Player} instance as well as the main library namespace.\n     *\n     * It can also be used as a getter for a pre-existing {@link Player} instance.\n     * However, we _strongly_ recommend using `videojs.getPlayer()` for this\n     * purpose because it avoids any potential for unintended initialization.\n     *\n     * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n     * of our JSDoc template, we cannot properly document this as both a function\n     * and a namespace, so its function signature is documented here.\n     *\n     * #### Arguments\n     * ##### id\n     * string|Element, **required**\n     *\n     * Video element or video element ID.\n     *\n     * ##### options\n     * Object, optional\n     *\n     * Options object for providing settings.\n     * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n     *\n     * ##### ready\n     * {@link Component~ReadyCallback}, optional\n     *\n     * A function to be called when the {@link Player} and {@link Tech} are ready.\n     *\n     * #### Return Value\n     *\n     * The `videojs()` function returns a {@link Player} instance.\n     *\n     * @namespace\n     *\n     * @borrows AudioTrack as AudioTrack\n     * @borrows Component.getComponent as getComponent\n     * @borrows module:events.on as on\n     * @borrows module:events.one as one\n     * @borrows module:events.off as off\n     * @borrows module:events.trigger as trigger\n     * @borrows EventTarget as EventTarget\n     * @borrows module:middleware.use as use\n     * @borrows Player.players as players\n     * @borrows Plugin.registerPlugin as registerPlugin\n     * @borrows Plugin.deregisterPlugin as deregisterPlugin\n     * @borrows Plugin.getPlugins as getPlugins\n     * @borrows Plugin.getPlugin as getPlugin\n     * @borrows Plugin.getPluginVersion as getPluginVersion\n     * @borrows Tech.getTech as getTech\n     * @borrows Tech.registerTech as registerTech\n     * @borrows TextTrack as TextTrack\n     * @borrows VideoTrack as VideoTrack\n     *\n     * @param  {string|Element} id\n     *         Video element or video element ID.\n     *\n     * @param  {Object} [options]\n     *         Options object for providing settings.\n     *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n     *\n     * @param  {ReadyCallback} [ready]\n     *         A function to be called when the {@link Player} and {@link Tech} are\n     *         ready.\n     *\n     * @return {Player}\n     *         The `videojs()` function returns a {@link Player|Player} instance.\n     */\n    function videojs(id, options, ready) {\n        let player = videojs.getPlayer(id);\n        if (player) {\n            if (options) {\n                log$1.warn(`Player \"${id}\" is already initialised. Options will not be applied.`);\n            }\n            if (ready) {\n                player.ready(ready);\n            }\n            return player;\n        }\n        const el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n        if (!isEl(el)) {\n            throw new TypeError('The element or ID supplied is not valid. (videojs)');\n        }\n\n        // document.body.contains(el) will only check if el is contained within that one document.\n        // This causes problems for elements in iframes.\n        // Instead, use the element's ownerDocument instead of the global document.\n        // This will make sure that the element is indeed in the dom of that document.\n        // Additionally, check that the document in question has a default view.\n        // If the document is no longer attached to the dom, the defaultView of the document will be null.\n        // If element is inside Shadow DOM (e.g. is part of a Custom element), ownerDocument.body\n        // always returns false. Instead, use the Shadow DOM root.\n        const inShadowDom = 'getRootNode' in el ? el.getRootNode() instanceof window.ShadowRoot : false;\n        const rootNode = inShadowDom ? el.getRootNode() : el.ownerDocument.body;\n        if (!el.ownerDocument.defaultView || !rootNode.contains(el)) {\n            log$1.warn('The element supplied is not included in the DOM');\n        }\n        options = options || {};\n\n        // Store a copy of the el before modification, if it is to be restored in destroy()\n        // If div ingest, store the parent div\n        if (options.restoreEl === true) {\n            options.restoreEl = (el.parentNode && el.parentNode.hasAttribute('data-vjs-player') ? el.parentNode : el).cloneNode(true);\n        }\n        hooks('beforesetup').forEach(hookFunction => {\n            const opts = hookFunction(el, merge$2(options));\n            if (!isObject$1(opts) || Array.isArray(opts)) {\n                log$1.error('please return an object in beforesetup hooks');\n                return;\n            }\n            options = merge$2(options, opts);\n        });\n\n        // We get the current \"Player\" component here in case an integration has\n        // replaced it with a custom player.\n        const PlayerComponent = Component$1.getComponent('Player');\n        player = new PlayerComponent(el, options, ready);\n        hooks('setup').forEach(hookFunction => hookFunction(player));\n        return player;\n    }\n    videojs.hooks_ = hooks_;\n    videojs.hooks = hooks;\n    videojs.hook = hook;\n    videojs.hookOnce = hookOnce;\n    videojs.removeHook = removeHook;\n\n    // Add default styles\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n        let style = $('.vjs-styles-defaults');\n        if (!style) {\n            style = createStyleElement('vjs-styles-defaults');\n            const head = $('head');\n            if (head) {\n                head.insertBefore(style, head.firstChild);\n            }\n            setTextContent(style, `\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    `);\n        }\n    }\n\n    // Run Auto-load players\n    // You have to wait at least once in case this script is loaded after your\n    // video in the DOM (weird behavior only with minified version)\n    autoSetupTimeout(1, videojs);\n\n    /**\n     * Current Video.js version. Follows [semantic versioning](https://semver.org/).\n     *\n     * @type {string}\n     */\n    videojs.VERSION = version$5;\n\n    /**\n     * The global options object. These are the settings that take effect\n     * if no overrides are specified when the player is created.\n     *\n     * @type {Object}\n     */\n    videojs.options = Player.prototype.options_;\n\n    /**\n     * Get an object with the currently created players, keyed by player ID\n     *\n     * @return {Object}\n     *         The created players\n     */\n    videojs.getPlayers = () => Player.players;\n\n    /**\n     * Get a single player based on an ID or DOM element.\n     *\n     * This is useful if you want to check if an element or ID has an associated\n     * Video.js player, but not create one if it doesn't.\n     *\n     * @param   {string|Element} id\n     *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n     *          or a string matching the `id` of such an element.\n     *\n     * @return {Player|undefined}\n     *          A player instance or `undefined` if there is no player instance\n     *          matching the argument.\n     */\n    videojs.getPlayer = id => {\n        const players = Player.players;\n        let tag;\n        if (typeof id === 'string') {\n            const nId = normalizeId(id);\n            const player = players[nId];\n            if (player) {\n                return player;\n            }\n            tag = $('#' + nId);\n        } else {\n            tag = id;\n        }\n        if (isEl(tag)) {\n            const {\n                player,\n                playerId\n            } = tag;\n\n            // Element may have a `player` property referring to an already created\n            // player instance. If so, return that.\n            if (player || players[playerId]) {\n                return player || players[playerId];\n            }\n        }\n    };\n\n    /**\n     * Returns an array of all current players.\n     *\n     * @return {Array}\n     *         An array of all players. The array will be in the order that\n     *         `Object.keys` provides, which could potentially vary between\n     *         JavaScript engines.\n     *\n     */\n    videojs.getAllPlayers = () =>\n        // Disposed players leave a key with a `null` value, so we need to make sure\n        // we filter those out.\n        Object.keys(Player.players).map(k => Player.players[k]).filter(Boolean);\n    videojs.players = Player.players;\n    videojs.getComponent = Component$1.getComponent;\n\n    /**\n     * Register a component so it can referred to by name. Used when adding to other\n     * components, either through addChild `component.addChild('myComponent')` or through\n     * default children options  `{ children: ['myComponent'] }`.\n     *\n     * > NOTE: You could also just initialize the component before adding.\n     * `component.addChild(new MyComponent());`\n     *\n     * @param {string} name\n     *        The class name of the component\n     *\n     * @param {typeof Component} comp\n     *        The component class\n     *\n     * @return {typeof Component}\n     *         The newly registered component\n     */\n    videojs.registerComponent = (name, comp) => {\n        if (Tech.isTech(comp)) {\n            log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);\n        }\n        return Component$1.registerComponent.call(Component$1, name, comp);\n    };\n    videojs.getTech = Tech.getTech;\n    videojs.registerTech = Tech.registerTech;\n    videojs.use = use;\n\n    /**\n     * An object that can be returned by a middleware to signify\n     * that the middleware is being terminated.\n     *\n     * @type {object}\n     * @property {object} middleware.TERMINATOR\n     */\n    Object.defineProperty(videojs, 'middleware', {\n        value: {},\n        writeable: false,\n        enumerable: true\n    });\n    Object.defineProperty(videojs.middleware, 'TERMINATOR', {\n        value: TERMINATOR,\n        writeable: false,\n        enumerable: true\n    });\n\n    /**\n     * A reference to the {@link module:browser|browser utility module} as an object.\n     *\n     * @type {Object}\n     * @see  {@link module:browser|browser}\n     */\n    videojs.browser = browser;\n\n    /**\n     * A reference to the {@link module:obj|obj utility module} as an object.\n     *\n     * @type {Object}\n     * @see  {@link module:obj|obj}\n     */\n    videojs.obj = Obj;\n\n    /**\n     * Deprecated reference to the {@link module:obj.merge|merge function}\n     *\n     * @type {Function}\n     * @see {@link module:obj.merge|merge}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.merge instead.\n     */\n    videojs.mergeOptions = deprecateForMajor(9, 'videojs.mergeOptions', 'videojs.obj.merge', merge$2);\n\n    /**\n     * Deprecated reference to the {@link module:obj.defineLazyProperty|defineLazyProperty function}\n     *\n     * @type {Function}\n     * @see {@link module:obj.defineLazyProperty|defineLazyProperty}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.defineLazyProperty instead.\n     */\n    videojs.defineLazyProperty = deprecateForMajor(9, 'videojs.defineLazyProperty', 'videojs.obj.defineLazyProperty', defineLazyProperty);\n\n    /**\n     * Deprecated reference to the {@link module:fn.bind_|fn.bind_ function}\n     *\n     * @type {Function}\n     * @see {@link module:fn.bind_|fn.bind_}\n     * @deprecated Deprecated and will be removed in 9.0. Please use native Function.prototype.bind instead.\n     */\n    videojs.bind = deprecateForMajor(9, 'videojs.bind', 'native Function.prototype.bind', bind_);\n    videojs.registerPlugin = Plugin.registerPlugin;\n    videojs.deregisterPlugin = Plugin.deregisterPlugin;\n\n    /**\n     * Deprecated method to register a plugin with Video.js\n     *\n     * @deprecated Deprecated and will be removed in 9.0. Use videojs.registerPlugin() instead.\n     *\n     * @param {string} name\n     *        The plugin name\n     *\n     * @param {typeof Plugin|Function} plugin\n     *         The plugin sub-class or function\n     *\n     * @return {typeof Plugin|Function}\n     */\n    videojs.plugin = (name, plugin) => {\n        log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n        return Plugin.registerPlugin(name, plugin);\n    };\n    videojs.getPlugins = Plugin.getPlugins;\n    videojs.getPlugin = Plugin.getPlugin;\n    videojs.getPluginVersion = Plugin.getPluginVersion;\n\n    /**\n     * Adding languages so that they're available to all players.\n     * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n     *\n     * @param {string} code\n     *        The language code or dictionary property\n     *\n     * @param {Object} data\n     *        The data values to be translated\n     *\n     * @return {Object}\n     *         The resulting language dictionary object\n     */\n    videojs.addLanguage = function (code, data) {\n        code = ('' + code).toLowerCase();\n        videojs.options.languages = merge$2(videojs.options.languages, {\n            [code]: data\n        });\n        return videojs.options.languages[code];\n    };\n\n    /**\n     * A reference to the {@link module:log|log utility module} as an object.\n     *\n     * @type {Function}\n     * @see  {@link module:log|log}\n     */\n    videojs.log = log$1;\n    videojs.createLogger = createLogger;\n\n    /**\n     * A reference to the {@link module:time|time utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:time|time}\n     */\n    videojs.time = Time;\n\n    /**\n     * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n     *\n     * @type {Function}\n     * @see {@link module:time.createTimeRanges|createTimeRanges}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n     */\n    videojs.createTimeRange = deprecateForMajor(9, 'videojs.createTimeRange', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n    /**\n     * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n     *\n     * @type {Function}\n     * @see {@link module:time.createTimeRanges|createTimeRanges}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n     */\n    videojs.createTimeRanges = deprecateForMajor(9, 'videojs.createTimeRanges', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n    /**\n     * Deprecated reference to the {@link module:time.formatTime|formatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.formatTime|formatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.format instead.\n     */\n    videojs.formatTime = deprecateForMajor(9, 'videojs.formatTime', 'videojs.time.formatTime', formatTime);\n\n    /**\n     * Deprecated reference to the {@link module:time.setFormatTime|setFormatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.setFormatTime|setFormatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.setFormat instead.\n     */\n    videojs.setFormatTime = deprecateForMajor(9, 'videojs.setFormatTime', 'videojs.time.setFormatTime', setFormatTime);\n\n    /**\n     * Deprecated reference to the {@link module:time.resetFormatTime|resetFormatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.resetFormatTime|resetFormatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.resetFormat instead.\n     */\n    videojs.resetFormatTime = deprecateForMajor(9, 'videojs.resetFormatTime', 'videojs.time.resetFormatTime', resetFormatTime);\n\n    /**\n     * Deprecated reference to the {@link module:url.parseUrl|Url.parseUrl function}\n     *\n     * @type {Function}\n     * @see {@link module:url.parseUrl|parseUrl}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.parseUrl instead.\n     */\n    videojs.parseUrl = deprecateForMajor(9, 'videojs.parseUrl', 'videojs.url.parseUrl', parseUrl);\n\n    /**\n     * Deprecated reference to the {@link module:url.isCrossOrigin|Url.isCrossOrigin function}\n     *\n     * @type {Function}\n     * @see {@link module:url.isCrossOrigin|isCrossOrigin}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.isCrossOrigin instead.\n     */\n    videojs.isCrossOrigin = deprecateForMajor(9, 'videojs.isCrossOrigin', 'videojs.url.isCrossOrigin', isCrossOrigin);\n    videojs.EventTarget = EventTarget$2;\n    videojs.any = any;\n    videojs.on = on;\n    videojs.one = one;\n    videojs.off = off;\n    videojs.trigger = trigger;\n\n    /**\n     * A cross-browser XMLHttpRequest wrapper.\n     *\n     * @function\n     * @param    {Object} options\n     *           Settings for the request.\n     *\n     * @return   {XMLHttpRequest|XDomainRequest}\n     *           The request object.\n     *\n     * @see      https://github.com/Raynos/xhr\n     */\n    videojs.xhr = lib;\n    videojs.TextTrack = TextTrack;\n    videojs.AudioTrack = AudioTrack;\n    videojs.VideoTrack = VideoTrack;\n    ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(k => {\n        videojs[k] = function () {\n            log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);\n            return Dom[k].apply(null, arguments);\n        };\n    });\n    videojs.computedStyle = deprecateForMajor(9, 'videojs.computedStyle', 'videojs.dom.computedStyle', computedStyle);\n\n    /**\n     * A reference to the {@link module:dom|DOM utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:dom|dom}\n     */\n    videojs.dom = Dom;\n\n    /**\n     * A reference to the {@link module:fn|fn utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:fn|fn}\n     */\n    videojs.fn = Fn;\n\n    /**\n     * A reference to the {@link module:num|num utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:num|num}\n     */\n    videojs.num = Num;\n\n    /**\n     * A reference to the {@link module:str|str utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:str|str}\n     */\n    videojs.str = Str;\n\n    /**\n     * A reference to the {@link module:url|URL utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:url|url}\n     */\n    videojs.url = Url;\n\n    createCommonjsModule(function (module, exports) {\n        /*! @name videojs-contrib-quality-levels @version 4.0.0 @license Apache-2.0 */\n        (function (global, factory) {\n            module.exports = factory(videojs) ;\n        })(commonjsGlobal, function (videojs) {\n\n            function _interopDefaultLegacy(e) {\n                return e && typeof e === 'object' && 'default' in e ? e : {\n                    'default': e\n                };\n            }\n            var videojs__default = /*#__PURE__*/_interopDefaultLegacy(videojs);\n\n            /**\n             * A single QualityLevel.\n             *\n             * interface QualityLevel {\n             *   readonly attribute DOMString id;\n             *            attribute DOMString label;\n             *   readonly attribute long width;\n             *   readonly attribute long height;\n             *   readonly attribute long bitrate;\n             *            attribute boolean enabled;\n             * };\n             *\n             * @class QualityLevel\n             */\n            class QualityLevel {\n                /**\n                 * Creates a QualityLevel\n                 *\n                 * @param {Representation|Object} representation The representation of the quality level\n                 * @param {string}   representation.id        Unique id of the QualityLevel\n                 * @param {number=}  representation.width     Resolution width of the QualityLevel\n                 * @param {number=}  representation.height    Resolution height of the QualityLevel\n                 * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n                 * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n                 * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n                 */\n                constructor(representation) {\n                    let level = this; // eslint-disable-line\n\n                    level.id = representation.id;\n                    level.label = level.id;\n                    level.width = representation.width;\n                    level.height = representation.height;\n                    level.bitrate = representation.bandwidth;\n                    level.frameRate = representation.frameRate;\n                    level.enabled_ = representation.enabled;\n                    Object.defineProperty(level, 'enabled', {\n                        /**\n                         * Get whether the QualityLevel is enabled.\n                         *\n                         * @return {boolean} True if the QualityLevel is enabled.\n                         */\n                        get() {\n                            return level.enabled_();\n                        },\n                        /**\n                         * Enable or disable the QualityLevel.\n                         *\n                         * @param {boolean} enable true to enable QualityLevel, false to disable.\n                         */\n                        set(enable) {\n                            level.enabled_(enable);\n                        }\n                    });\n                    return level;\n                }\n            }\n\n            /**\n             * A list of QualityLevels.\n             *\n             * interface QualityLevelList : EventTarget {\n             *   getter QualityLevel (unsigned long index);\n             *   readonly attribute unsigned long length;\n             *   readonly attribute long selectedIndex;\n             *\n             *   void addQualityLevel(QualityLevel qualityLevel)\n             *   void removeQualityLevel(QualityLevel remove)\n             *   QualityLevel? getQualityLevelById(DOMString id);\n             *\n             *   attribute EventHandler onchange;\n             *   attribute EventHandler onaddqualitylevel;\n             *   attribute EventHandler onremovequalitylevel;\n             * };\n             *\n             * @extends videojs.EventTarget\n             * @class QualityLevelList\n             */\n\n            class QualityLevelList extends videojs__default['default'].EventTarget {\n                /**\n                 * Creates a QualityLevelList.\n                 */\n                constructor() {\n                    super();\n                    let list = this; // eslint-disable-line\n\n                    list.levels_ = [];\n                    list.selectedIndex_ = -1;\n                    /**\n                     * Get the index of the currently selected QualityLevel.\n                     *\n                     * @returns {number} The index of the selected QualityLevel. -1 if none selected.\n                     * @readonly\n                     */\n\n                    Object.defineProperty(list, 'selectedIndex', {\n                        get() {\n                            return list.selectedIndex_;\n                        }\n                    });\n                    /**\n                     * Get the length of the list of QualityLevels.\n                     *\n                     * @returns {number} The length of the list.\n                     * @readonly\n                     */\n\n                    Object.defineProperty(list, 'length', {\n                        get() {\n                            return list.levels_.length;\n                        }\n                    });\n                    list[Symbol.iterator] = () => list.levels_.values();\n                    return list;\n                }\n                /**\n                 * Adds a quality level to the list.\n                 *\n                 * @param {Representation|Object} representation The representation of the quality level\n                 * @param {string}   representation.id        Unique id of the QualityLevel\n                 * @param {number=}  representation.width     Resolution width of the QualityLevel\n                 * @param {number=}  representation.height    Resolution height of the QualityLevel\n                 * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n                 * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n                 * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n                 * @return {QualityLevel} the QualityLevel added to the list\n                 * @method addQualityLevel\n                 */\n\n                addQualityLevel(representation) {\n                    let qualityLevel = this.getQualityLevelById(representation.id); // Do not add duplicate quality levels\n\n                    if (qualityLevel) {\n                        return qualityLevel;\n                    }\n                    const index = this.levels_.length;\n                    qualityLevel = new QualityLevel(representation);\n                    if (!('' + index in this)) {\n                        Object.defineProperty(this, index, {\n                            get() {\n                                return this.levels_[index];\n                            }\n                        });\n                    }\n                    this.levels_.push(qualityLevel);\n                    this.trigger({\n                        qualityLevel,\n                        type: 'addqualitylevel'\n                    });\n                    return qualityLevel;\n                }\n                /**\n                 * Removes a quality level from the list.\n                 *\n                 * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.\n                 * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed\n                 * @method removeQualityLevel\n                 */\n\n                removeQualityLevel(qualityLevel) {\n                    let removed = null;\n                    for (let i = 0, l = this.length; i < l; i++) {\n                        if (this[i] === qualityLevel) {\n                            removed = this.levels_.splice(i, 1)[0];\n                            if (this.selectedIndex_ === i) {\n                                this.selectedIndex_ = -1;\n                            } else if (this.selectedIndex_ > i) {\n                                this.selectedIndex_--;\n                            }\n                            break;\n                        }\n                    }\n                    if (removed) {\n                        this.trigger({\n                            qualityLevel,\n                            type: 'removequalitylevel'\n                        });\n                    }\n                    return removed;\n                }\n                /**\n                 * Searches for a QualityLevel with the given id.\n                 *\n                 * @param {string} id The id of the QualityLevel to find.\n                 * @return {QualityLevel|null} The QualityLevel with id, or null if not found.\n                 * @method getQualityLevelById\n                 */\n\n                getQualityLevelById(id) {\n                    for (let i = 0, l = this.length; i < l; i++) {\n                        const level = this[i];\n                        if (level.id === id) {\n                            return level;\n                        }\n                    }\n                    return null;\n                }\n                /**\n                 * Resets the list of QualityLevels to empty\n                 *\n                 * @method dispose\n                 */\n\n                dispose() {\n                    this.selectedIndex_ = -1;\n                    this.levels_.length = 0;\n                }\n            }\n            /**\n             * change - The selected QualityLevel has changed.\n             * addqualitylevel - A QualityLevel has been added to the QualityLevelList.\n             * removequalitylevel - A QualityLevel has been removed from the QualityLevelList.\n             */\n\n            QualityLevelList.prototype.allowedEvents_ = {\n                change: 'change',\n                addqualitylevel: 'addqualitylevel',\n                removequalitylevel: 'removequalitylevel'\n            }; // emulate attribute EventHandler support to allow for feature detection\n\n            for (const event in QualityLevelList.prototype.allowedEvents_) {\n                QualityLevelList.prototype['on' + event] = null;\n            }\n            var version = \"4.0.0\";\n\n            /**\n             * Initialization function for the qualityLevels plugin. Sets up the QualityLevelList and\n             * event handlers.\n             *\n             * @param {Player} player Player object.\n             * @param {Object} options Plugin options object.\n             * @return {QualityLevelList} a list of QualityLevels\n             */\n\n            const initPlugin = function (player, options) {\n                const originalPluginFn = player.qualityLevels;\n                const qualityLevelList = new QualityLevelList();\n                const disposeHandler = function () {\n                    qualityLevelList.dispose();\n                    player.qualityLevels = originalPluginFn;\n                    player.off('dispose', disposeHandler);\n                };\n                player.on('dispose', disposeHandler);\n                player.qualityLevels = () => qualityLevelList;\n                player.qualityLevels.VERSION = version;\n                return qualityLevelList;\n            };\n            /**\n             * A video.js plugin.\n             *\n             * In the plugin function, the value of `this` is a video.js `Player`\n             * instance. You cannot rely on the player being in a \"ready\" state here,\n             * depending on how the plugin is invoked. This may or may not be important\n             * to you; if not, remove the wait for \"ready\"!\n             *\n             * @param {Object} options Plugin options object\n             * @return {QualityLevelList} a list of QualityLevels\n             */\n\n            const qualityLevels = function (options) {\n                return initPlugin(this, videojs__default['default'].obj.merge({}, options));\n            }; // Register the plugin with video.js.\n\n            videojs__default['default'].registerPlugin('qualityLevels', qualityLevels); // Include the version number.\n\n            qualityLevels.VERSION = version;\n            return qualityLevels;\n        });\n    });\n\n    var urlToolkit = createCommonjsModule(function (module, exports) {\n        // see https://tools.ietf.org/html/rfc1808\n\n        (function (root) {\n            var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n            var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n            var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n            var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n            var URLToolkit = {\n                // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n                // E.g\n                // With opts.alwaysNormalize = false (default, spec compliant)\n                // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n                // With opts.alwaysNormalize = true (not spec compliant)\n                // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n                buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n                    opts = opts || {};\n                    // remove any remaining space and CRLF\n                    baseURL = baseURL.trim();\n                    relativeURL = relativeURL.trim();\n                    if (!relativeURL) {\n                        // 2a) If the embedded URL is entirely empty, it inherits the\n                        // entire base URL (i.e., is set equal to the base URL)\n                        // and we are done.\n                        if (!opts.alwaysNormalize) {\n                            return baseURL;\n                        }\n                        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n                        if (!basePartsForNormalise) {\n                            throw new Error('Error trying to parse base URL.');\n                        }\n                        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n                        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n                    }\n                    var relativeParts = URLToolkit.parseURL(relativeURL);\n                    if (!relativeParts) {\n                        throw new Error('Error trying to parse relative URL.');\n                    }\n                    if (relativeParts.scheme) {\n                        // 2b) If the embedded URL starts with a scheme name, it is\n                        // interpreted as an absolute URL and we are done.\n                        if (!opts.alwaysNormalize) {\n                            return relativeURL;\n                        }\n                        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n                        return URLToolkit.buildURLFromParts(relativeParts);\n                    }\n                    var baseParts = URLToolkit.parseURL(baseURL);\n                    if (!baseParts) {\n                        throw new Error('Error trying to parse base URL.');\n                    }\n                    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n                        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n                        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n                        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n                        baseParts.netLoc = pathParts[1];\n                        baseParts.path = pathParts[2];\n                    }\n                    if (baseParts.netLoc && !baseParts.path) {\n                        baseParts.path = '/';\n                    }\n                    var builtParts = {\n                        // 2c) Otherwise, the embedded URL inherits the scheme of\n                        // the base URL.\n                        scheme: baseParts.scheme,\n                        netLoc: relativeParts.netLoc,\n                        path: null,\n                        params: relativeParts.params,\n                        query: relativeParts.query,\n                        fragment: relativeParts.fragment\n                    };\n                    if (!relativeParts.netLoc) {\n                        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n                        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n                        // (if any) of the base URL.\n                        builtParts.netLoc = baseParts.netLoc;\n                        // 4) If the embedded URL path is preceded by a slash \"/\", the\n                        // path is not relative and we skip to Step 7.\n                        if (relativeParts.path[0] !== '/') {\n                            if (!relativeParts.path) {\n                                // 5) If the embedded URL path is empty (and not preceded by a\n                                // slash), then the embedded URL inherits the base URL path\n                                builtParts.path = baseParts.path;\n                                // 5a) if the embedded URL's <params> is non-empty, we skip to\n                                // step 7; otherwise, it inherits the <params> of the base\n                                // URL (if any) and\n                                if (!relativeParts.params) {\n                                    builtParts.params = baseParts.params;\n                                    // 5b) if the embedded URL's <query> is non-empty, we skip to\n                                    // step 7; otherwise, it inherits the <query> of the base\n                                    // URL (if any) and we skip to step 7.\n                                    if (!relativeParts.query) {\n                                        builtParts.query = baseParts.query;\n                                    }\n                                }\n                            } else {\n                                // 6) The last segment of the base URL's path (anything\n                                // following the rightmost slash \"/\", or the entire path if no\n                                // slash is present) is removed and the embedded URL's path is\n                                // appended in its place.\n                                var baseURLPath = baseParts.path;\n                                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n                                builtParts.path = URLToolkit.normalizePath(newPath);\n                            }\n                        }\n                    }\n                    if (builtParts.path === null) {\n                        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n                    }\n                    return URLToolkit.buildURLFromParts(builtParts);\n                },\n                parseURL: function (url) {\n                    var parts = URL_REGEX.exec(url);\n                    if (!parts) {\n                        return null;\n                    }\n                    return {\n                        scheme: parts[1] || '',\n                        netLoc: parts[2] || '',\n                        path: parts[3] || '',\n                        params: parts[4] || '',\n                        query: parts[5] || '',\n                        fragment: parts[6] || ''\n                    };\n                },\n                normalizePath: function (path) {\n                    // The following operations are\n                    // then applied, in order, to the new path:\n                    // 6a) All occurrences of \"./\", where \".\" is a complete path\n                    // segment, are removed.\n                    // 6b) If the path ends with \".\" as a complete path segment,\n                    // that \".\" is removed.\n                    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n                    // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n                    // complete path segment not equal to \"..\", are removed.\n                    // Removal of these path segments is performed iteratively,\n                    // removing the leftmost matching pattern on each iteration,\n                    // until no matching pattern remains.\n                    // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n                    // complete path segment not equal to \"..\", that\n                    // \"<segment>/..\" is removed.\n                    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n                    return path.split('').reverse().join('');\n                },\n                buildURLFromParts: function (parts) {\n                    return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n                }\n            };\n            module.exports = URLToolkit;\n        })();\n    });\n\n    var DEFAULT_LOCATION = 'http://example.com';\n    var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {\n        // return early if we don't need to resolve\n        if (/^[a-z]+:/i.test(relativeUrl)) {\n            return relativeUrl;\n        } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n        if (/^data:/.test(baseUrl)) {\n            baseUrl = window.location && window.location.href || '';\n        } // IE11 supports URL but not the URL constructor\n        // feature detect the behavior we want\n\n        var nativeURL = typeof window.URL === 'function';\n        var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n        // and if baseUrl isn't an absolute url\n\n        var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n        if (nativeURL) {\n            baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);\n        } else if (!/\\/\\//i.test(baseUrl)) {\n            baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\n        }\n        if (nativeURL) {\n            var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n            // and if we're location-less, remove the location\n            // otherwise, return the url unmodified\n\n            if (removeLocation) {\n                return newUrl.href.slice(DEFAULT_LOCATION.length);\n            } else if (protocolLess) {\n                return newUrl.href.slice(newUrl.protocol.length);\n            }\n            return newUrl.href;\n        }\n        return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n    };\n\n    /**\n     * @file stream.js\n     */\n\n    /**\n     * A lightweight readable stream implemention that handles event dispatching.\n     *\n     * @class Stream\n     */\n    var Stream = /*#__PURE__*/function () {\n        function Stream() {\n            this.listeners = {};\n        }\n        /**\n         * Add a listener for a specified event type.\n         *\n         * @param {string} type the event name\n         * @param {Function} listener the callback to be invoked when an event of\n         * the specified type occurs\n         */\n\n        var _proto = Stream.prototype;\n        _proto.on = function on(type, listener) {\n            if (!this.listeners[type]) {\n                this.listeners[type] = [];\n            }\n            this.listeners[type].push(listener);\n        }\n        /**\n         * Remove a listener for a specified event type.\n         *\n         * @param {string} type the event name\n         * @param {Function} listener  a function previously registered for this\n         * type of event through `on`\n         * @return {boolean} if we could turn it off or not\n         */;\n\n        _proto.off = function off(type, listener) {\n            if (!this.listeners[type]) {\n                return false;\n            }\n            var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n            // In Video.js we slice listener functions\n            // on trigger so that it does not mess up the order\n            // while we loop through.\n            //\n            // Here we slice on off so that the loop in trigger\n            // can continue using it's old reference to loop without\n            // messing up the order.\n\n            this.listeners[type] = this.listeners[type].slice(0);\n            this.listeners[type].splice(index, 1);\n            return index > -1;\n        }\n        /**\n         * Trigger an event of the specified type on this stream. Any additional\n         * arguments to this function are passed as parameters to event listeners.\n         *\n         * @param {string} type the event name\n         */;\n\n        _proto.trigger = function trigger(type) {\n            var callbacks = this.listeners[type];\n            if (!callbacks) {\n                return;\n            } // Slicing the arguments on every invocation of this method\n            // can add a significant amount of overhead. Avoid the\n            // intermediate object creation for the common case of a\n            // single callback argument\n\n            if (arguments.length === 2) {\n                var length = callbacks.length;\n                for (var i = 0; i < length; ++i) {\n                    callbacks[i].call(this, arguments[1]);\n                }\n            } else {\n                var args = Array.prototype.slice.call(arguments, 1);\n                var _length = callbacks.length;\n                for (var _i = 0; _i < _length; ++_i) {\n                    callbacks[_i].apply(this, args);\n                }\n            }\n        }\n        /**\n         * Destroys the stream and cleans up.\n         */;\n\n        _proto.dispose = function dispose() {\n            this.listeners = {};\n        }\n        /**\n         * Forwards all `data` events on this stream to the destination stream. The\n         * destination stream should provide a method `push` to receive the data\n         * events as they arrive.\n         *\n         * @param {Stream} destination the stream that will receive all `data` events\n         * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n         */;\n\n        _proto.pipe = function pipe(destination) {\n            this.on('data', function (data) {\n                destination.push(data);\n            });\n        };\n        return Stream;\n    }();\n\n    var atob$1 = function atob(s) {\n        return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n    };\n    function decodeB64ToUint8Array$1(b64Text) {\n        var decodedString = atob$1(b64Text);\n        var array = new Uint8Array(decodedString.length);\n        for (var i = 0; i < decodedString.length; i++) {\n            array[i] = decodedString.charCodeAt(i);\n        }\n        return array;\n    }\n\n    /*! @name m3u8-parser @version 7.1.0 @license Apache-2.0 */\n\n    /**\n     * @file m3u8/line-stream.js\n     */\n    /**\n     * A stream that buffers string input and generates a `data` event for each\n     * line.\n     *\n     * @class LineStream\n     * @extends Stream\n     */\n\n    class LineStream extends Stream {\n        constructor() {\n            super();\n            this.buffer = '';\n        }\n        /**\n         * Add new data to be parsed.\n         *\n         * @param {string} data the text to process\n         */\n\n        push(data) {\n            let nextNewline;\n            this.buffer += data;\n            nextNewline = this.buffer.indexOf('\\n');\n            for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n                this.trigger('data', this.buffer.substring(0, nextNewline));\n                this.buffer = this.buffer.substring(nextNewline + 1);\n            }\n        }\n    }\n    const TAB = String.fromCharCode(0x09);\n    const parseByterange = function (byterangeString) {\n        // optionally match and capture 0+ digits before `@`\n        // optionally match and capture 0+ digits after `@`\n        const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n        const result = {};\n        if (match[1]) {\n            result.length = parseInt(match[1], 10);\n        }\n        if (match[2]) {\n            result.offset = parseInt(match[2], 10);\n        }\n        return result;\n    };\n    /**\n     * \"forgiving\" attribute list psuedo-grammar:\n     * attributes -> keyvalue (',' keyvalue)*\n     * keyvalue   -> key '=' value\n     * key        -> [^=]*\n     * value      -> '\"' [^\"]* '\"' | [^,]*\n     */\n\n    const attributeSeparator = function () {\n        const key = '[^=]*';\n        const value = '\"[^\"]*\"|[^,]*';\n        const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n        return new RegExp('(?:^|,)(' + keyvalue + ')');\n    };\n    /**\n     * Parse attributes from a line given the separator\n     *\n     * @param {string} attributes the attribute line to parse\n     */\n\n    const parseAttributes$1 = function (attributes) {\n        const result = {};\n        if (!attributes) {\n            return result;\n        } // split the string using attributes as the separator\n\n        const attrs = attributes.split(attributeSeparator());\n        let i = attrs.length;\n        let attr;\n        while (i--) {\n            // filter out unmatched portions of the string\n            if (attrs[i] === '') {\n                continue;\n            } // split the key and value\n\n            attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n            attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n            attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n            attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n            result[attr[0]] = attr[1];\n        }\n        return result;\n    };\n    /**\n     * A line-level M3U8 parser event stream. It expects to receive input one\n     * line at a time and performs a context-free parse of its contents. A stream\n     * interpretation of a manifest can be useful if the manifest is expected to\n     * be too large to fit comfortably into memory or the entirety of the input\n     * is not immediately available. Otherwise, it's probably much easier to work\n     * with a regular `Parser` object.\n     *\n     * Produces `data` events with an object that captures the parser's\n     * interpretation of the input. That object has a property `tag` that is one\n     * of `uri`, `comment`, or `tag`. URIs only have a single additional\n     * property, `line`, which captures the entirety of the input without\n     * interpretation. Comments similarly have a single additional property\n     * `text` which is the input without the leading `#`.\n     *\n     * Tags always have a property `tagType` which is the lower-cased version of\n     * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n     * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n     * tags are given the tag type `unknown` and a single additional property\n     * `data` with the remainder of the input.\n     *\n     * @class ParseStream\n     * @extends Stream\n     */\n\n    class ParseStream extends Stream {\n        constructor() {\n            super();\n            this.customParsers = [];\n            this.tagMappers = [];\n        }\n        /**\n         * Parses an additional line of input.\n         *\n         * @param {string} line a single line of an M3U8 file to parse\n         */\n\n        push(line) {\n            let match;\n            let event; // strip whitespace\n\n            line = line.trim();\n            if (line.length === 0) {\n                // ignore empty lines\n                return;\n            } // URIs\n\n            if (line[0] !== '#') {\n                this.trigger('data', {\n                    type: 'uri',\n                    uri: line\n                });\n                return;\n            } // map tags\n\n            const newLines = this.tagMappers.reduce((acc, mapper) => {\n                const mappedLine = mapper(line); // skip if unchanged\n\n                if (mappedLine === line) {\n                    return acc;\n                }\n                return acc.concat([mappedLine]);\n            }, [line]);\n            newLines.forEach(newLine => {\n                for (let i = 0; i < this.customParsers.length; i++) {\n                    if (this.customParsers[i].call(this, newLine)) {\n                        return;\n                    }\n                } // Comments\n\n                if (newLine.indexOf('#EXT') !== 0) {\n                    this.trigger('data', {\n                        type: 'comment',\n                        text: newLine.slice(1)\n                    });\n                    return;\n                } // strip off any carriage returns here so the regex matching\n                // doesn't have to account for them.\n\n                newLine = newLine.replace('\\r', ''); // Tags\n\n                match = /^#EXTM3U/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'm3u'\n                    });\n                    return;\n                }\n                match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'inf'\n                    };\n                    if (match[1]) {\n                        event.duration = parseFloat(match[1]);\n                    }\n                    if (match[2]) {\n                        event.title = match[2];\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'targetduration'\n                    };\n                    if (match[1]) {\n                        event.duration = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'version'\n                    };\n                    if (match[1]) {\n                        event.version = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'media-sequence'\n                    };\n                    if (match[1]) {\n                        event.number = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'discontinuity-sequence'\n                    };\n                    if (match[1]) {\n                        event.number = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'playlist-type'\n                    };\n                    if (match[1]) {\n                        event.playlistType = match[1];\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = _extends$1(parseByterange(match[1]), {\n                        type: 'tag',\n                        tagType: 'byterange'\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'allow-cache'\n                    };\n                    if (match[1]) {\n                        event.allowed = !/NO/.test(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'map'\n                    };\n                    if (match[1]) {\n                        const attributes = parseAttributes$1(match[1]);\n                        if (attributes.URI) {\n                            event.uri = attributes.URI;\n                        }\n                        if (attributes.BYTERANGE) {\n                            event.byterange = parseByterange(attributes.BYTERANGE);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'stream-inf'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                        if (event.attributes.RESOLUTION) {\n                            const split = event.attributes.RESOLUTION.split('x');\n                            const resolution = {};\n                            if (split[0]) {\n                                resolution.width = parseInt(split[0], 10);\n                            }\n                            if (split[1]) {\n                                resolution.height = parseInt(split[1], 10);\n                            }\n                            event.attributes.RESOLUTION = resolution;\n                        }\n                        if (event.attributes.BANDWIDTH) {\n                            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n                        }\n                        if (event.attributes['FRAME-RATE']) {\n                            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n                        }\n                        if (event.attributes['PROGRAM-ID']) {\n                            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'media'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-ENDLIST/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'endlist'\n                    });\n                    return;\n                }\n                match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'discontinuity'\n                    });\n                    return;\n                }\n                match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'program-date-time'\n                    };\n                    if (match[1]) {\n                        event.dateTimeString = match[1];\n                        event.dateTimeObject = new Date(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'key'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]); // parse the IV string into a Uint32Array\n\n                        if (event.attributes.IV) {\n                            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n                                event.attributes.IV = event.attributes.IV.substring(2);\n                            }\n                            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n                            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n                            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n                            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n                            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n                            event.attributes.IV = new Uint32Array(event.attributes.IV);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-START:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'start'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                        event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n                        event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-out-cont'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-out'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-in'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'skip'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n                        event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n                    }\n                    if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n                        event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'part'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['DURATION'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    ['INDEPENDENT', 'GAP'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = /YES/.test(event.attributes[key]);\n                        }\n                    });\n                    if (event.attributes.hasOwnProperty('BYTERANGE')) {\n                        event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'server-control'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = /YES/.test(event.attributes[key]);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'part-inf'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['PART-TARGET'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'preload-hint'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseInt(event.attributes[key], 10);\n                            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n                            event.attributes.byterange = event.attributes.byterange || {};\n                            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n                            delete event.attributes[key];\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'rendition-report'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseInt(event.attributes[key], 10);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'daterange'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['ID', 'CLASS'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = String(event.attributes[key]);\n                        }\n                    });\n                    ['START-DATE', 'END-DATE'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = new Date(event.attributes[key]);\n                        }\n                    });\n                    ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    ['END-ON-NEXT'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = /YES/i.test(event.attributes[key]);\n                        }\n                    });\n                    ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = event.attributes[key].toString(16);\n                        }\n                    });\n                    const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n                    for (const key in event.attributes) {\n                        if (!clientAttributePattern.test(key)) {\n                            continue;\n                        }\n                        const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n                        const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n                        event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'independent-segments'\n                    });\n                    return;\n                }\n                match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'content-steering'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    this.trigger('data', event);\n                    return;\n                } // unknown tag type\n\n                this.trigger('data', {\n                    type: 'tag',\n                    data: newLine.slice(4)\n                });\n            });\n        }\n        /**\n         * Add a parser for custom headers\n         *\n         * @param {Object}   options              a map of options for the added parser\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {string}   options.customType   the custom type to register to the output\n         * @param {Function} [options.dataParser] function to parse the line into an object\n         * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n         */\n\n        addParser({\n                      expression,\n                      customType,\n                      dataParser,\n                      segment\n                  }) {\n            if (typeof dataParser !== 'function') {\n                dataParser = line => line;\n            }\n            this.customParsers.push(line => {\n                const match = expression.exec(line);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'custom',\n                        data: dataParser(line),\n                        customType,\n                        segment\n                    });\n                    return true;\n                }\n            });\n        }\n        /**\n         * Add a custom header mapper\n         *\n         * @param {Object}   options\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {Function} options.map          function to translate tag into a different tag\n         */\n\n        addTagMapper({\n                         expression,\n                         map\n                     }) {\n            const mapFn = line => {\n                if (expression.test(line)) {\n                    return map(line);\n                }\n                return line;\n            };\n            this.tagMappers.push(mapFn);\n        }\n    }\n    const camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n    const camelCaseKeys = function (attributes) {\n        const result = {};\n        Object.keys(attributes).forEach(function (key) {\n            result[camelCase(key)] = attributes[key];\n        });\n        return result;\n    }; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n    // we need this helper because defaults are based upon targetDuration and\n    // partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n    // target durations are set.\n\n    const setHoldBack = function (manifest) {\n        const {\n            serverControl,\n            targetDuration,\n            partTargetDuration\n        } = manifest;\n        if (!serverControl) {\n            return;\n        }\n        const tag = '#EXT-X-SERVER-CONTROL';\n        const hb = 'holdBack';\n        const phb = 'partHoldBack';\n        const minTargetDuration = targetDuration && targetDuration * 3;\n        const minPartDuration = partTargetDuration && partTargetDuration * 2;\n        if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n            serverControl[hb] = minTargetDuration;\n            this.trigger('info', {\n                message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n            });\n        }\n        if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n            this.trigger('warn', {\n                message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n            });\n            serverControl[hb] = minTargetDuration;\n        } // default no part hold back to part target duration * 3\n\n        if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n            serverControl[phb] = partTargetDuration * 3;\n            this.trigger('info', {\n                message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n            });\n        } // if part hold back is too small default it to part target duration * 2\n\n        if (partTargetDuration && serverControl[phb] < minPartDuration) {\n            this.trigger('warn', {\n                message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n            });\n            serverControl[phb] = minPartDuration;\n        }\n    };\n    /**\n     * A parser for M3U8 files. The current interpretation of the input is\n     * exposed as a property `manifest` on parser objects. It's just two lines to\n     * create and parse a manifest once you have the contents available as a string:\n     *\n     * ```js\n     * var parser = new m3u8.Parser();\n     * parser.push(xhr.responseText);\n     * ```\n     *\n     * New input can later be applied to update the manifest object by calling\n     * `push` again.\n     *\n     * The parser attempts to create a usable manifest object even if the\n     * underlying input is somewhat nonsensical. It emits `info` and `warning`\n     * events during the parse if it encounters input that seems invalid or\n     * requires some property of the manifest object to be defaulted.\n     *\n     * @class Parser\n     * @extends Stream\n     */\n\n    class Parser extends Stream {\n        constructor() {\n            super();\n            this.lineStream = new LineStream();\n            this.parseStream = new ParseStream();\n            this.lineStream.pipe(this.parseStream);\n            this.lastProgramDateTime = null;\n            /* eslint-disable consistent-this */\n\n            const self = this;\n            /* eslint-enable consistent-this */\n\n            const uris = [];\n            let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n            let currentMap; // if specified, the active decryption key\n\n            let key;\n            let hasParts = false;\n            const noop = function () {};\n            const defaultMediaGroups = {\n                'AUDIO': {},\n                'VIDEO': {},\n                'CLOSED-CAPTIONS': {},\n                'SUBTITLES': {}\n            }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n            // used in MPDs with Widevine encrypted streams.\n\n            const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n            let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n            this.manifest = {\n                allowCache: true,\n                discontinuityStarts: [],\n                dateRanges: [],\n                segments: []\n            }; // keep track of the last seen segment's byte range end, as segments are not required\n            // to provide the offset, in which case it defaults to the next byte after the\n            // previous segment\n\n            let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n            let lastPartByterangeEnd = 0;\n            const dateRangeTags = {};\n            this.on('end', () => {\n                // only add preloadSegment if we don't yet have a uri for it.\n                // and we actually have parts/preloadHints\n                if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n                    return;\n                }\n                if (!currentUri.map && currentMap) {\n                    currentUri.map = currentMap;\n                }\n                if (!currentUri.key && key) {\n                    currentUri.key = key;\n                }\n                if (!currentUri.timeline && typeof currentTimeline === 'number') {\n                    currentUri.timeline = currentTimeline;\n                }\n                this.manifest.preloadSegment = currentUri;\n            }); // update the manifest with the m3u8 entry from the parse stream\n\n            this.parseStream.on('data', function (entry) {\n                let mediaGroup;\n                let rendition;\n                ({\n                    tag() {\n                        // switch based on the tag type\n                        (({\n                            version() {\n                                if (entry.version) {\n                                    this.manifest.version = entry.version;\n                                }\n                            },\n                            'allow-cache'() {\n                                this.manifest.allowCache = entry.allowed;\n                                if (!('allowed' in entry)) {\n                                    this.trigger('info', {\n                                        message: 'defaulting allowCache to YES'\n                                    });\n                                    this.manifest.allowCache = true;\n                                }\n                            },\n                            byterange() {\n                                const byterange = {};\n                                if ('length' in entry) {\n                                    currentUri.byterange = byterange;\n                                    byterange.length = entry.length;\n                                    if (!('offset' in entry)) {\n                                        /*\n                     * From the latest spec (as of this writing):\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                     *\n                     * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                     *\n                     * \"If o [offset] is not present, the sub-range begins at the next byte\n                     * following the sub-range of the previous media segment.\"\n                     */\n                                        entry.offset = lastByterangeEnd;\n                                    }\n                                }\n                                if ('offset' in entry) {\n                                    currentUri.byterange = byterange;\n                                    byterange.offset = entry.offset;\n                                }\n                                lastByterangeEnd = byterange.offset + byterange.length;\n                            },\n                            endlist() {\n                                this.manifest.endList = true;\n                            },\n                            inf() {\n                                if (!('mediaSequence' in this.manifest)) {\n                                    this.manifest.mediaSequence = 0;\n                                    this.trigger('info', {\n                                        message: 'defaulting media sequence to zero'\n                                    });\n                                }\n                                if (!('discontinuitySequence' in this.manifest)) {\n                                    this.manifest.discontinuitySequence = 0;\n                                    this.trigger('info', {\n                                        message: 'defaulting discontinuity sequence to zero'\n                                    });\n                                }\n                                if (entry.title) {\n                                    currentUri.title = entry.title;\n                                }\n                                if (entry.duration > 0) {\n                                    currentUri.duration = entry.duration;\n                                }\n                                if (entry.duration === 0) {\n                                    currentUri.duration = 0.01;\n                                    this.trigger('info', {\n                                        message: 'updating zero segment duration to a small value'\n                                    });\n                                }\n                                this.manifest.segments = uris;\n                            },\n                            key() {\n                                if (!entry.attributes) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring key declaration without attribute list'\n                                    });\n                                    return;\n                                } // clear the active encryption key\n\n                                if (entry.attributes.METHOD === 'NONE') {\n                                    key = null;\n                                    return;\n                                }\n                                if (!entry.attributes.URI) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring key declaration without URI'\n                                    });\n                                    return;\n                                }\n                                if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                                    this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                                        attributes: entry.attributes\n                                    };\n                                    return;\n                                }\n                                if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                                    this.manifest.contentProtection['com.microsoft.playready'] = {\n                                        uri: entry.attributes.URI\n                                    };\n                                    return;\n                                } // check if the content is encrypted for Widevine\n                                // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n                                if (entry.attributes.KEYFORMAT === widevineUuid) {\n                                    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n                                    if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                                        this.trigger('warn', {\n                                            message: 'invalid key method provided for Widevine'\n                                        });\n                                        return;\n                                    }\n                                    if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                                        this.trigger('warn', {\n                                            message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                                        });\n                                    }\n                                    if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                                        this.trigger('warn', {\n                                            message: 'invalid key URI provided for Widevine'\n                                        });\n                                        return;\n                                    }\n                                    if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                                        this.trigger('warn', {\n                                            message: 'invalid key ID provided for Widevine'\n                                        });\n                                        return;\n                                    } // if Widevine key attributes are valid, store them as `contentProtection`\n                                    // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {};\n                                    this.manifest.contentProtection['com.widevine.alpha'] = {\n                                        attributes: {\n                                            schemeIdUri: entry.attributes.KEYFORMAT,\n                                            // remove '0x' from the key id string\n                                            keyId: entry.attributes.KEYID.substring(2)\n                                        },\n                                        // decode the base64-encoded PSSH box\n                                        pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(',')[1])\n                                    };\n                                    return;\n                                }\n                                if (!entry.attributes.METHOD) {\n                                    this.trigger('warn', {\n                                        message: 'defaulting key method to AES-128'\n                                    });\n                                } // setup an encryption key for upcoming segments\n\n                                key = {\n                                    method: entry.attributes.METHOD || 'AES-128',\n                                    uri: entry.attributes.URI\n                                };\n                                if (typeof entry.attributes.IV !== 'undefined') {\n                                    key.iv = entry.attributes.IV;\n                                }\n                            },\n                            'media-sequence'() {\n                                if (!isFinite(entry.number)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid media sequence: ' + entry.number\n                                    });\n                                    return;\n                                }\n                                this.manifest.mediaSequence = entry.number;\n                            },\n                            'discontinuity-sequence'() {\n                                if (!isFinite(entry.number)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                                    });\n                                    return;\n                                }\n                                this.manifest.discontinuitySequence = entry.number;\n                                currentTimeline = entry.number;\n                            },\n                            'playlist-type'() {\n                                if (!/VOD|EVENT/.test(entry.playlistType)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring unknown playlist type: ' + entry.playlist\n                                    });\n                                    return;\n                                }\n                                this.manifest.playlistType = entry.playlistType;\n                            },\n                            map() {\n                                currentMap = {};\n                                if (entry.uri) {\n                                    currentMap.uri = entry.uri;\n                                }\n                                if (entry.byterange) {\n                                    currentMap.byterange = entry.byterange;\n                                }\n                                if (key) {\n                                    currentMap.key = key;\n                                }\n                            },\n                            'stream-inf'() {\n                                this.manifest.playlists = uris;\n                                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                                if (!entry.attributes) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring empty stream-inf attributes'\n                                    });\n                                    return;\n                                }\n                                if (!currentUri.attributes) {\n                                    currentUri.attributes = {};\n                                }\n                                _extends$1(currentUri.attributes, entry.attributes);\n                            },\n                            media() {\n                                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring incomplete or missing media group'\n                                    });\n                                    return;\n                                } // find the media group, creating defaults as necessary\n\n                                const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n                                mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n                                mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n                                rendition = {\n                                    default: /yes/i.test(entry.attributes.DEFAULT)\n                                };\n                                if (rendition.default) {\n                                    rendition.autoselect = true;\n                                } else {\n                                    rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n                                }\n                                if (entry.attributes.LANGUAGE) {\n                                    rendition.language = entry.attributes.LANGUAGE;\n                                }\n                                if (entry.attributes.URI) {\n                                    rendition.uri = entry.attributes.URI;\n                                }\n                                if (entry.attributes['INSTREAM-ID']) {\n                                    rendition.instreamId = entry.attributes['INSTREAM-ID'];\n                                }\n                                if (entry.attributes.CHARACTERISTICS) {\n                                    rendition.characteristics = entry.attributes.CHARACTERISTICS;\n                                }\n                                if (entry.attributes.FORCED) {\n                                    rendition.forced = /yes/i.test(entry.attributes.FORCED);\n                                } // insert the new rendition\n\n                                mediaGroup[entry.attributes.NAME] = rendition;\n                            },\n                            discontinuity() {\n                                currentTimeline += 1;\n                                currentUri.discontinuity = true;\n                                this.manifest.discontinuityStarts.push(uris.length);\n                            },\n                            'program-date-time'() {\n                                if (typeof this.manifest.dateTimeString === 'undefined') {\n                                    // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                                    // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                                    // to the manifest object\n                                    // TODO: Consider removing this in future major version\n                                    this.manifest.dateTimeString = entry.dateTimeString;\n                                    this.manifest.dateTimeObject = entry.dateTimeObject;\n                                }\n                                currentUri.dateTimeString = entry.dateTimeString;\n                                currentUri.dateTimeObject = entry.dateTimeObject;\n                                const {\n                                    lastProgramDateTime\n                                } = this;\n                                this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n                                // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n                                if (lastProgramDateTime === null) {\n                                    // Extrapolate Program Date Time backward\n                                    // Since it is first program date time occurrence we're assuming that\n                                    // all this.manifest.segments have no program date time info\n                                    this.manifest.segments.reduceRight((programDateTime, segment) => {\n                                        segment.programDateTime = programDateTime - segment.duration * 1000;\n                                        return segment.programDateTime;\n                                    }, this.lastProgramDateTime);\n                                }\n                            },\n                            targetduration() {\n                                if (!isFinite(entry.duration) || entry.duration < 0) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid target duration: ' + entry.duration\n                                    });\n                                    return;\n                                }\n                                this.manifest.targetDuration = entry.duration;\n                                setHoldBack.call(this, this.manifest);\n                            },\n                            start() {\n                                if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring start declaration without appropriate attribute list'\n                                    });\n                                    return;\n                                }\n                                this.manifest.start = {\n                                    timeOffset: entry.attributes['TIME-OFFSET'],\n                                    precise: entry.attributes.PRECISE\n                                };\n                            },\n                            'cue-out'() {\n                                currentUri.cueOut = entry.data;\n                            },\n                            'cue-out-cont'() {\n                                currentUri.cueOutCont = entry.data;\n                            },\n                            'cue-in'() {\n                                currentUri.cueIn = entry.data;\n                            },\n                            'skip'() {\n                                this.manifest.skip = camelCaseKeys(entry.attributes);\n                                this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n                            },\n                            'part'() {\n                                hasParts = true; // parts are always specifed before a segment\n\n                                const segmentIndex = this.manifest.segments.length;\n                                const part = camelCaseKeys(entry.attributes);\n                                currentUri.parts = currentUri.parts || [];\n                                currentUri.parts.push(part);\n                                if (part.byterange) {\n                                    if (!part.byterange.hasOwnProperty('offset')) {\n                                        part.byterange.offset = lastPartByterangeEnd;\n                                    }\n                                    lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n                                }\n                                const partIndex = currentUri.parts.length - 1;\n                                this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n                                if (this.manifest.renditionReports) {\n                                    this.manifest.renditionReports.forEach((r, i) => {\n                                        if (!r.hasOwnProperty('lastPart')) {\n                                            this.trigger('warn', {\n                                                message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                                            });\n                                        }\n                                    });\n                                }\n                            },\n                            'server-control'() {\n                                const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n                                if (!attrs.hasOwnProperty('canBlockReload')) {\n                                    attrs.canBlockReload = false;\n                                    this.trigger('info', {\n                                        message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                                    });\n                                }\n                                setHoldBack.call(this, this.manifest);\n                                if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                                    this.trigger('warn', {\n                                        message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                                    });\n                                }\n                            },\n                            'preload-hint'() {\n                                // parts are always specifed before a segment\n                                const segmentIndex = this.manifest.segments.length;\n                                const hint = camelCaseKeys(entry.attributes);\n                                const isPart = hint.type && hint.type === 'PART';\n                                currentUri.preloadHints = currentUri.preloadHints || [];\n                                currentUri.preloadHints.push(hint);\n                                if (hint.byterange) {\n                                    if (!hint.byterange.hasOwnProperty('offset')) {\n                                        // use last part byterange end or zero if not a part.\n                                        hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n                                        if (isPart) {\n                                            lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                                        }\n                                    }\n                                }\n                                const index = currentUri.preloadHints.length - 1;\n                                this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n                                if (!hint.type) {\n                                    return;\n                                } // search through all preload hints except for the current one for\n                                // a duplicate type.\n\n                                for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                                    const otherHint = currentUri.preloadHints[i];\n                                    if (!otherHint.type) {\n                                        continue;\n                                    }\n                                    if (otherHint.type === hint.type) {\n                                        this.trigger('warn', {\n                                            message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                                        });\n                                    }\n                                }\n                            },\n                            'rendition-report'() {\n                                const report = camelCaseKeys(entry.attributes);\n                                this.manifest.renditionReports = this.manifest.renditionReports || [];\n                                this.manifest.renditionReports.push(report);\n                                const index = this.manifest.renditionReports.length - 1;\n                                const required = ['LAST-MSN', 'URI'];\n                                if (hasParts) {\n                                    required.push('LAST-PART');\n                                }\n                                this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n                            },\n                            'part-inf'() {\n                                this.manifest.partInf = camelCaseKeys(entry.attributes);\n                                this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n                                if (this.manifest.partInf.partTarget) {\n                                    this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n                                }\n                                setHoldBack.call(this, this.manifest);\n                            },\n                            'daterange'() {\n                                this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n                                const index = this.manifest.dateRanges.length - 1;\n                                this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n                                const dateRange = this.manifest.dateRanges[index];\n                                if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                                    this.trigger('warn', {\n                                        message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                                    });\n                                }\n                                if (dateRange.duration && dateRange.duration < 0) {\n                                    this.trigger('warn', {\n                                        message: 'EXT-X-DATERANGE DURATION must not be negative'\n                                    });\n                                }\n                                if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                                    this.trigger('warn', {\n                                        message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                                    });\n                                }\n                                const endOnNextYes = !!dateRange.endOnNext;\n                                if (endOnNextYes && !dateRange.class) {\n                                    this.trigger('warn', {\n                                        message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                                    });\n                                }\n                                if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                                    this.trigger('warn', {\n                                        message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                                    });\n                                }\n                                if (dateRange.duration && dateRange.endDate) {\n                                    const startDate = dateRange.startDate;\n                                    const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                                    this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n                                }\n                                if (!dateRangeTags[dateRange.id]) {\n                                    dateRangeTags[dateRange.id] = dateRange;\n                                } else {\n                                    for (const attribute in dateRangeTags[dateRange.id]) {\n                                        if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                                            this.trigger('warn', {\n                                                message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                                            });\n                                            break;\n                                        }\n                                    } // if tags with the same ID do not have conflicting attributes, merge them\n\n                                    const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                                    this.manifest.dateRanges[dateRangeWithSameId] = _extends$1(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                                    dateRangeTags[dateRange.id] = _extends$1(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                                    this.manifest.dateRanges.pop();\n                                }\n                            },\n                            'independent-segments'() {\n                                this.manifest.independentSegments = true;\n                            },\n                            'content-steering'() {\n                                this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n                                this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n                            }\n                        })[entry.tagType] || noop).call(self);\n                    },\n                    uri() {\n                        currentUri.uri = entry.uri;\n                        uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n                        if (this.manifest.targetDuration && !('duration' in currentUri)) {\n                            this.trigger('warn', {\n                                message: 'defaulting segment duration to the target duration'\n                            });\n                            currentUri.duration = this.manifest.targetDuration;\n                        } // annotate with encryption information, if necessary\n\n                        if (key) {\n                            currentUri.key = key;\n                        }\n                        currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n                        if (currentMap) {\n                            currentUri.map = currentMap;\n                        } // reset the last byterange end as it needs to be 0 between parts\n\n                        lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n                        if (this.lastProgramDateTime !== null) {\n                            currentUri.programDateTime = this.lastProgramDateTime;\n                            this.lastProgramDateTime += currentUri.duration * 1000;\n                        } // prepare for the next URI\n\n                        currentUri = {};\n                    },\n                    comment() {// comments are not important for playback\n                    },\n                    custom() {\n                        // if this is segment-level data attach the output to the segment\n                        if (entry.segment) {\n                            currentUri.custom = currentUri.custom || {};\n                            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n                        } else {\n                            this.manifest.custom = this.manifest.custom || {};\n                            this.manifest.custom[entry.customType] = entry.data;\n                        }\n                    }\n                })[entry.type].call(self);\n            });\n        }\n        warnOnMissingAttributes_(identifier, attributes, required) {\n            const missing = [];\n            required.forEach(function (key) {\n                if (!attributes.hasOwnProperty(key)) {\n                    missing.push(key);\n                }\n            });\n            if (missing.length) {\n                this.trigger('warn', {\n                    message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n                });\n            }\n        }\n        /**\n         * Parse the input string and update the manifest object.\n         *\n         * @param {string} chunk a potentially incomplete portion of the manifest\n         */\n\n        push(chunk) {\n            this.lineStream.push(chunk);\n        }\n        /**\n         * Flush any remaining input. This can be handy if the last line of an M3U8\n         * manifest did not contain a trailing newline but the file has been\n         * completely received.\n         */\n\n        end() {\n            // flush any buffered input\n            this.lineStream.push('\\n');\n            if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n                this.trigger('warn', {\n                    message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n                });\n            }\n            this.lastProgramDateTime = null;\n            this.trigger('end');\n        }\n        /**\n         * Add an additional parser for non-standard tags\n         *\n         * @param {Object}   options              a map of options for the added parser\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {string}   options.customType   the custom type to register to the output\n         * @param {Function} [options.dataParser] function to parse the line into an object\n         * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n         */\n\n        addParser(options) {\n            this.parseStream.addParser(options);\n        }\n        /**\n         * Add a custom header mapper\n         *\n         * @param {Object}   options\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {Function} options.map          function to translate tag into a different tag\n         */\n\n        addTagMapper(options) {\n            this.parseStream.addTagMapper(options);\n        }\n    }\n\n    var regexs = {\n        // to determine mime types\n        mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n        webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n        ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n        // to determine if a codec is audio or video\n        video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n        audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n        text: /^(stpp.ttml.im1t)/,\n        // mux.js support regex\n        muxerVideo: /^(avc0?1)/,\n        muxerAudio: /^(mp4a)/,\n        // match nothing as muxer does not support text right now.\n        // there cannot never be a character before the start of a string\n        // so this matches nothing.\n        muxerText: /a^/\n    };\n    var mediaTypes = ['video', 'audio', 'text'];\n    var upperMediaTypes = ['Video', 'Audio', 'Text'];\n    /**\n     * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n     * `avc1.<hhhhhh>`\n     *\n     * @param {string} codec\n     *        Codec string to translate\n     * @return {string}\n     *         The translated codec string\n     */\n\n    var translateLegacyCodec = function translateLegacyCodec(codec) {\n        if (!codec) {\n            return codec;\n        }\n        return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n            var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n            var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n            return 'avc1.' + profileHex + '00' + avcLevelHex;\n        });\n    };\n    /**\n     * @typedef {Object} ParsedCodecInfo\n     * @property {number} codecCount\n     *           Number of codecs parsed\n     * @property {string} [videoCodec]\n     *           Parsed video codec (if found)\n     * @property {string} [videoObjectTypeIndicator]\n     *           Video object type indicator (if found)\n     * @property {string|null} audioProfile\n     *           Audio profile\n     */\n\n    /**\n     * Parses a codec string to retrieve the number of codecs specified, the video codec and\n     * object type indicator, and the audio profile.\n     *\n     * @param {string} [codecString]\n     *        The codec string to parse\n     * @return {ParsedCodecInfo}\n     *         Parsed codec info\n     */\n\n    var parseCodecs = function parseCodecs(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        var codecs = codecString.split(',');\n        var result = [];\n        codecs.forEach(function (codec) {\n            codec = codec.trim();\n            var codecType;\n            mediaTypes.forEach(function (name) {\n                var match = regexs[name].exec(codec.toLowerCase());\n                if (!match || match.length <= 1) {\n                    return;\n                }\n                codecType = name; // maintain codec case\n\n                var type = codec.substring(0, match[1].length);\n                var details = codec.replace(type, '');\n                result.push({\n                    type: type,\n                    details: details,\n                    mediaType: name\n                });\n            });\n            if (!codecType) {\n                result.push({\n                    type: codec,\n                    details: '',\n                    mediaType: 'unknown'\n                });\n            }\n        });\n        return result;\n    };\n    /**\n     * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n     * a default alternate audio playlist for the provided audio group.\n     *\n     * @param {Object} master\n     *        The master playlist\n     * @param {string} audioGroupId\n     *        ID of the audio group for which to find the default codec info\n     * @return {ParsedCodecInfo}\n     *         Parsed codec info\n     */\n\n    var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n        if (!master.mediaGroups.AUDIO || !audioGroupId) {\n            return null;\n        }\n        var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n        if (!audioGroup) {\n            return null;\n        }\n        for (var name in audioGroup) {\n            var audioType = audioGroup[name];\n            if (audioType.default && audioType.playlists) {\n                // codec should be the same for all playlists within the audio type\n                return parseCodecs(audioType.playlists[0].attributes.CODECS);\n            }\n        }\n        return null;\n    };\n    var isAudioCodec = function isAudioCodec(codec) {\n        if (codec === void 0) {\n            codec = '';\n        }\n        return regexs.audio.test(codec.trim().toLowerCase());\n    };\n    var isTextCodec = function isTextCodec(codec) {\n        if (codec === void 0) {\n            codec = '';\n        }\n        return regexs.text.test(codec.trim().toLowerCase());\n    };\n    var getMimeForCodec = function getMimeForCodec(codecString) {\n        if (!codecString || typeof codecString !== 'string') {\n            return;\n        }\n        var codecs = codecString.toLowerCase().split(',').map(function (c) {\n            return translateLegacyCodec(c.trim());\n        }); // default to video type\n\n        var type = 'video'; // only change to audio type if the only codec we have is\n        // audio\n\n        if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n            type = 'audio';\n        } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n            // text uses application/<container> for now\n            type = 'application';\n        } // default the container to mp4\n\n        var container = 'mp4'; // every codec must be able to go into the container\n        // for that container to be the correct one\n\n        if (codecs.every(function (c) {\n            return regexs.mp4.test(c);\n        })) {\n            container = 'mp4';\n        } else if (codecs.every(function (c) {\n            return regexs.webm.test(c);\n        })) {\n            container = 'webm';\n        } else if (codecs.every(function (c) {\n            return regexs.ogg.test(c);\n        })) {\n            container = 'ogg';\n        }\n        return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n    };\n    var browserSupportsCodec = function browserSupportsCodec(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n    };\n    var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        return codecString.toLowerCase().split(',').every(function (codec) {\n            codec = codec.trim(); // any match is supported.\n\n            for (var i = 0; i < upperMediaTypes.length; i++) {\n                var type = upperMediaTypes[i];\n                if (regexs[\"muxer\" + type].test(codec)) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    };\n    var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\n    var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\n\n    var MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\n    var DASH_REGEX = /^application\\/dash\\+xml/i;\n    /**\n     * Returns a string that describes the type of source based on a video source object's\n     * media type.\n     *\n     * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\n     *\n     * @param {string} type\n     *        Video source object media type\n     * @return {('hls'|'dash'|'vhs-json'|null)}\n     *         VHS source type string\n     */\n\n    var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n        if (MPEGURL_REGEX.test(type)) {\n            return 'hls';\n        }\n        if (DASH_REGEX.test(type)) {\n            return 'dash';\n        } // Denotes the special case of a manifest object passed to http-streaming instead of a\n        // source URL.\n        //\n        // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\n        //\n        // In this case, vnd stands for vendor, video.js for the organization, VHS for this\n        // project, and the +json suffix identifies the structure of the media type.\n\n        if (type === 'application/vnd.videojs.vhs+json') {\n            return 'vhs-json';\n        }\n        return null;\n    };\n\n    // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n    // we used to do this with log2 but BigInt does not support builtin math\n    // Math.ceil(log2(x));\n\n    var countBits = function countBits(x) {\n        return x.toString(2).length;\n    }; // count the number of whole bytes it would take to represent a number\n\n    var countBytes = function countBytes(x) {\n        return Math.ceil(countBits(x) / 8);\n    };\n    var isArrayBufferView = function isArrayBufferView(obj) {\n        if (ArrayBuffer.isView === 'function') {\n            return ArrayBuffer.isView(obj);\n        }\n        return obj && obj.buffer instanceof ArrayBuffer;\n    };\n    var isTypedArray = function isTypedArray(obj) {\n        return isArrayBufferView(obj);\n    };\n    var toUint8 = function toUint8(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return bytes;\n        }\n        if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n            // any non-number or NaN leads to empty uint8array\n            // eslint-disable-next-line\n            if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n                bytes = 0;\n            } else {\n                bytes = [bytes];\n            }\n        }\n        return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n    };\n    var BigInt = window.BigInt || Number;\n    var BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n    (function () {\n        var a = new Uint16Array([0xFFCC]);\n        var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n        if (b[0] === 0xFF) {\n            return 'big';\n        }\n        if (b[0] === 0xCC) {\n            return 'little';\n        }\n        return 'unknown';\n    })();\n    var bytesToNumber = function bytesToNumber(bytes, _temp) {\n        var _ref = _temp === void 0 ? {} : _temp,\n            _ref$signed = _ref.signed,\n            signed = _ref$signed === void 0 ? false : _ref$signed,\n            _ref$le = _ref.le,\n            le = _ref$le === void 0 ? false : _ref$le;\n        bytes = toUint8(bytes);\n        var fn = le ? 'reduce' : 'reduceRight';\n        var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n        var number = obj.call(bytes, function (total, byte, i) {\n            var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n            return total + BigInt(byte) * BYTE_TABLE[exponent];\n        }, BigInt(0));\n        if (signed) {\n            var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n            number = BigInt(number);\n            if (number > max) {\n                number -= max;\n                number -= max;\n                number -= BigInt(2);\n            }\n        }\n        return Number(number);\n    };\n    var numberToBytes = function numberToBytes(number, _temp2) {\n        var _ref2 = _temp2 === void 0 ? {} : _temp2,\n            _ref2$le = _ref2.le,\n            le = _ref2$le === void 0 ? false : _ref2$le;\n\n        // eslint-disable-next-line\n        if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n            number = 0;\n        }\n        number = BigInt(number);\n        var byteCount = countBytes(number);\n        var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n        for (var i = 0; i < byteCount; i++) {\n            var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n            bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n            if (number < 0) {\n                bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n                bytes[byteIndex] -= i === 0 ? 1 : 2;\n            }\n        }\n        return bytes;\n    };\n    var stringToBytes = function stringToBytes(string, stringIsBytes) {\n        if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n            string = string.toString();\n        }\n        if (typeof string !== 'string') {\n            return new Uint8Array();\n        } // If the string already is bytes, we don't have to do this\n        // otherwise we do this so that we split multi length characters\n        // into individual bytes\n\n        if (!stringIsBytes) {\n            string = unescape(encodeURIComponent(string));\n        }\n        var view = new Uint8Array(string.length);\n        for (var i = 0; i < string.length; i++) {\n            view[i] = string.charCodeAt(i);\n        }\n        return view;\n    };\n    var concatTypedArrays = function concatTypedArrays() {\n        for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n            buffers[_key] = arguments[_key];\n        }\n        buffers = buffers.filter(function (b) {\n            return b && (b.byteLength || b.length) && typeof b !== 'string';\n        });\n        if (buffers.length <= 1) {\n            // for 0 length we will return empty uint8\n            // for 1 length we return the first uint8\n            return toUint8(buffers[0]);\n        }\n        var totalLen = buffers.reduce(function (total, buf, i) {\n            return total + (buf.byteLength || buf.length);\n        }, 0);\n        var tempBuffer = new Uint8Array(totalLen);\n        var offset = 0;\n        buffers.forEach(function (buf) {\n            buf = toUint8(buf);\n            tempBuffer.set(buf, offset);\n            offset += buf.byteLength;\n        });\n        return tempBuffer;\n    };\n    /**\n     * Check if the bytes \"b\" are contained within bytes \"a\".\n     *\n     * @param {Uint8Array|Array} a\n     *        Bytes to check in\n     *\n     * @param {Uint8Array|Array} b\n     *        Bytes to check for\n     *\n     * @param {Object} options\n     *        options\n     *\n     * @param {Array|Uint8Array} [offset=0]\n     *        offset to use when looking at bytes in a\n     *\n     * @param {Array|Uint8Array} [mask=[]]\n     *        mask to use on bytes before comparison.\n     *\n     * @return {boolean}\n     *         If all bytes in b are inside of a, taking into account\n     *         bit masks.\n     */\n\n    var bytesMatch = function bytesMatch(a, b, _temp3) {\n        var _ref3 = _temp3 === void 0 ? {} : _temp3,\n            _ref3$offset = _ref3.offset,\n            offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n            _ref3$mask = _ref3.mask,\n            mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n        a = toUint8(a);\n        b = toUint8(b); // ie 11 does not support uint8 every\n\n        var fn = b.every ? b.every : Array.prototype.every;\n        return b.length && a.length - offset >= b.length &&\n            // ie 11 doesn't support every on uin8\n            fn.call(b, function (bByte, i) {\n                var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n                return bByte === aByte;\n            });\n    };\n\n    /**\n     * Loops through all supported media groups in master and calls the provided\n     * callback for each group\n     *\n     * @param {Object} master\n     *        The parsed master manifest object\n     * @param {string[]} groups\n     *        The media groups to call the callback for\n     * @param {Function} callback\n     *        Callback to call for each media group\n     */\n    var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {\n        groups.forEach(function (mediaType) {\n            for (var groupKey in master.mediaGroups[mediaType]) {\n                for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n                    var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n                    callback(mediaProperties, mediaType, groupKey, labelKey);\n                }\n            }\n        });\n    };\n\n    var atob = function atob(s) {\n        return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n    };\n    function decodeB64ToUint8Array(b64Text) {\n        var decodedString = atob(b64Text);\n        var array = new Uint8Array(decodedString.length);\n        for (var i = 0; i < decodedString.length; i++) {\n            array[i] = decodedString.charCodeAt(i);\n        }\n        return array;\n    }\n\n    /**\n     * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.\n     *\n     * Works with anything that has a `length` property and index access properties, including NodeList.\n     *\n     * @template {unknown} T\n     * @param {Array<T> | ({length:number, [number]: T})} list\n     * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate\n     * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,\n     * \t\t\t\tallows injecting a custom implementation in tests\n     * @returns {T | undefined}\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n     * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find\n     */\n    function find$1(list, predicate, ac) {\n        if (ac === undefined) {\n            ac = Array.prototype;\n        }\n        if (list && typeof ac.find === 'function') {\n            return ac.find.call(list, predicate);\n        }\n        for (var i = 0; i < list.length; i++) {\n            if (Object.prototype.hasOwnProperty.call(list, i)) {\n                var item = list[i];\n                if (predicate.call(undefined, item, i, list)) {\n                    return item;\n                }\n            }\n        }\n    }\n\n    /**\n     * \"Shallow freezes\" an object to render it immutable.\n     * Uses `Object.freeze` if available,\n     * otherwise the immutability is only in the type.\n     *\n     * Is used to create \"enum like\" objects.\n     *\n     * @template T\n     * @param {T} object the object to freeze\n     * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,\n     * \t\t\t\tallows to inject custom object constructor for tests\n     * @returns {Readonly<T>}\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n     */\n    function freeze(object, oc) {\n        if (oc === undefined) {\n            oc = Object;\n        }\n        return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;\n    }\n\n    /**\n     * Since we can not rely on `Object.assign` we provide a simplified version\n     * that is sufficient for our needs.\n     *\n     * @param {Object} target\n     * @param {Object | null | undefined} source\n     *\n     * @returns {Object} target\n     * @throws TypeError if target is not an object\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n     * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign\n     */\n    function assign(target, source) {\n        if (target === null || typeof target !== 'object') {\n            throw new TypeError('target is not an object');\n        }\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * All mime types that are allowed as input to `DOMParser.parseFromString`\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec\n     * @see DOMParser.prototype.parseFromString\n     */\n    var MIME_TYPE = freeze({\n        /**\n         * `text/html`, the only mime type that triggers treating an XML document as HTML.\n         *\n         * @see DOMParser.SupportedType.isHTML\n         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec\n         */\n        HTML: 'text/html',\n        /**\n         * Helper method to check a mime type if it indicates an HTML document\n         *\n         * @param {string} [value]\n         * @returns {boolean}\n         *\n         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring \t */\n        isHTML: function (value) {\n            return value === MIME_TYPE.HTML;\n        },\n        /**\n         * `application/xml`, the standard mime type for XML documents.\n         *\n         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration\n         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303\n         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n         */\n        XML_APPLICATION: 'application/xml',\n        /**\n         * `text/html`, an alias for `application/xml`.\n         *\n         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303\n         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n         */\n        XML_TEXT: 'text/xml',\n        /**\n         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,\n         * but is parsed as an XML document.\n         *\n         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec\n         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia\n         */\n        XML_XHTML_APPLICATION: 'application/xhtml+xml',\n        /**\n         * `image/svg+xml`,\n         *\n         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration\n         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1\n         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia\n         */\n        XML_SVG_IMAGE: 'image/svg+xml'\n    });\n\n    /**\n     * Namespaces that are used in this code base.\n     *\n     * @see http://www.w3.org/TR/REC-xml-names\n     */\n    var NAMESPACE$3 = freeze({\n        /**\n         * The XHTML namespace.\n         *\n         * @see http://www.w3.org/1999/xhtml\n         */\n        HTML: 'http://www.w3.org/1999/xhtml',\n        /**\n         * Checks if `uri` equals `NAMESPACE.HTML`.\n         *\n         * @param {string} [uri]\n         *\n         * @see NAMESPACE.HTML\n         */\n        isHTML: function (uri) {\n            return uri === NAMESPACE$3.HTML;\n        },\n        /**\n         * The SVG namespace.\n         *\n         * @see http://www.w3.org/2000/svg\n         */\n        SVG: 'http://www.w3.org/2000/svg',\n        /**\n         * The `xml:` namespace.\n         *\n         * @see http://www.w3.org/XML/1998/namespace\n         */\n        XML: 'http://www.w3.org/XML/1998/namespace',\n        /**\n         * The `xmlns:` namespace\n         *\n         * @see https://www.w3.org/2000/xmlns/\n         */\n        XMLNS: 'http://www.w3.org/2000/xmlns/'\n    });\n    var assign_1 = assign;\n    var find_1 = find$1;\n    var freeze_1 = freeze;\n    var MIME_TYPE_1 = MIME_TYPE;\n    var NAMESPACE_1 = NAMESPACE$3;\n    var conventions = {\n        assign: assign_1,\n        find: find_1,\n        freeze: freeze_1,\n        MIME_TYPE: MIME_TYPE_1,\n        NAMESPACE: NAMESPACE_1\n    };\n\n    var find = conventions.find;\n    var NAMESPACE$2 = conventions.NAMESPACE;\n\n    /**\n     * A prerequisite for `[].filter`, to drop elements that are empty\n     * @param {string} input\n     * @returns {boolean}\n     */\n    function notEmptyString(input) {\n        return input !== '';\n    }\n    /**\n     * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n     * @see https://infra.spec.whatwg.org/#ascii-whitespace\n     *\n     * @param {string} input\n     * @returns {string[]} (can be empty)\n     */\n    function splitOnASCIIWhitespace(input) {\n        // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n        return input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\n    }\n\n    /**\n     * Adds element as a key to current if it is not already present.\n     *\n     * @param {Record<string, boolean | undefined>} current\n     * @param {string} element\n     * @returns {Record<string, boolean | undefined>}\n     */\n    function orderedSetReducer(current, element) {\n        if (!current.hasOwnProperty(element)) {\n            current[element] = true;\n        }\n        return current;\n    }\n\n    /**\n     * @see https://infra.spec.whatwg.org/#ordered-set\n     * @param {string} input\n     * @returns {string[]}\n     */\n    function toOrderedSet(input) {\n        if (!input) return [];\n        var list = splitOnASCIIWhitespace(input);\n        return Object.keys(list.reduce(orderedSetReducer, {}));\n    }\n\n    /**\n     * Uses `list.indexOf` to implement something like `Array.prototype.includes`,\n     * which we can not rely on being available.\n     *\n     * @param {any[]} list\n     * @returns {function(any): boolean}\n     */\n    function arrayIncludes(list) {\n        return function (element) {\n            return list && list.indexOf(element) !== -1;\n        };\n    }\n    function copy(src, dest) {\n        for (var p in src) {\n            if (Object.prototype.hasOwnProperty.call(src, p)) {\n                dest[p] = src[p];\n            }\n        }\n    }\n\n    /**\n     ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n     ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n     */\n    function _extends(Class, Super) {\n        var pt = Class.prototype;\n        if (!(pt instanceof Super)) {\n            function t() {}\n            t.prototype = Super.prototype;\n            t = new t();\n            copy(pt, t);\n            Class.prototype = pt = t;\n        }\n        if (pt.constructor != Class) {\n            if (typeof Class != 'function') {\n                console.error(\"unknown Class:\" + Class);\n            }\n            pt.constructor = Class;\n        }\n    }\n\n    // Node Types\n    var NodeType = {};\n    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\n    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\n    var TEXT_NODE = NodeType.TEXT_NODE = 3;\n    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\n    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\n    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;\n    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\n    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;\n    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\n    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\n    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;\n\n    // ExceptionCode\n    var ExceptionCode = {};\n    var ExceptionMessage = {};\n    ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\n    ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\n    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\n    ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\n    ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\n    ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\n    ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\n    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\n    ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\n    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10);\n    //level2\n    ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\n    ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\n    ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\n    ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\n    ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\n\n    /**\n     * DOM Level 2\n     * Object DOMException\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n     * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n     */\n    function DOMException(code, message) {\n        if (message instanceof Error) {\n            var error = message;\n        } else {\n            error = this;\n            Error.call(this, ExceptionMessage[code]);\n            this.message = ExceptionMessage[code];\n            if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n        }\n        error.code = code;\n        if (message) this.message = this.message + \": \" + message;\n        return error;\n    }\n    DOMException.prototype = Error.prototype;\n    copy(ExceptionCode, DOMException);\n\n    /**\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n     * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n     * The items in the NodeList are accessible via an integral index, starting from 0.\n     */\n    function NodeList() {}\n    NodeList.prototype = {\n        /**\n         * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n         * @standard level1\n         */\n        length: 0,\n        /**\n         * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n         * @standard level1\n         * @param index  unsigned long\n         *   Index into the collection.\n         * @return Node\n         * \tThe node at the indexth position in the NodeList, or null if that is not a valid index.\n         */\n        item: function (index) {\n            return index >= 0 && index < this.length ? this[index] : null;\n        },\n        toString: function (isHTML, nodeFilter) {\n            for (var buf = [], i = 0; i < this.length; i++) {\n                serializeToString(this[i], buf, isHTML, nodeFilter);\n            }\n            return buf.join('');\n        },\n        /**\n         * @private\n         * @param {function (Node):boolean} predicate\n         * @returns {Node[]}\n         */\n        filter: function (predicate) {\n            return Array.prototype.filter.call(this, predicate);\n        },\n        /**\n         * @private\n         * @param {Node} item\n         * @returns {number}\n         */\n        indexOf: function (item) {\n            return Array.prototype.indexOf.call(this, item);\n        }\n    };\n    function LiveNodeList(node, refresh) {\n        this._node = node;\n        this._refresh = refresh;\n        _updateLiveList(this);\n    }\n    function _updateLiveList(list) {\n        var inc = list._node._inc || list._node.ownerDocument._inc;\n        if (list._inc !== inc) {\n            var ls = list._refresh(list._node);\n            __set__(list, 'length', ls.length);\n            if (!list.$$length || ls.length < list.$$length) {\n                for (var i = ls.length; (i in list); i++) {\n                    if (Object.prototype.hasOwnProperty.call(list, i)) {\n                        delete list[i];\n                    }\n                }\n            }\n            copy(ls, list);\n            list._inc = inc;\n        }\n    }\n    LiveNodeList.prototype.item = function (i) {\n        _updateLiveList(this);\n        return this[i] || null;\n    };\n    _extends(LiveNodeList, NodeList);\n\n    /**\n     * Objects implementing the NamedNodeMap interface are used\n     * to represent collections of nodes that can be accessed by name.\n     * Note that NamedNodeMap does not inherit from NodeList;\n     * NamedNodeMaps are not maintained in any particular order.\n     * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,\n     * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n     * and does not imply that the DOM specifies an order to these Nodes.\n     * NamedNodeMap objects in the DOM are live.\n     * used for attributes or DocumentType entities\n     */\n    function NamedNodeMap() {}\n    function _findNodeIndex(list, node) {\n        var i = list.length;\n        while (i--) {\n            if (list[i] === node) {\n                return i;\n            }\n        }\n    }\n    function _addNamedNode(el, list, newAttr, oldAttr) {\n        if (oldAttr) {\n            list[_findNodeIndex(list, oldAttr)] = newAttr;\n        } else {\n            list[list.length++] = newAttr;\n        }\n        if (el) {\n            newAttr.ownerElement = el;\n            var doc = el.ownerDocument;\n            if (doc) {\n                oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n                _onAddAttribute(doc, el, newAttr);\n            }\n        }\n    }\n    function _removeNamedNode(el, list, attr) {\n        //console.log('remove attr:'+attr)\n        var i = _findNodeIndex(list, attr);\n        if (i >= 0) {\n            var lastIndex = list.length - 1;\n            while (i < lastIndex) {\n                list[i] = list[++i];\n            }\n            list.length = lastIndex;\n            if (el) {\n                var doc = el.ownerDocument;\n                if (doc) {\n                    _onRemoveAttribute(doc, el, attr);\n                    attr.ownerElement = null;\n                }\n            }\n        } else {\n            throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));\n        }\n    }\n    NamedNodeMap.prototype = {\n        length: 0,\n        item: NodeList.prototype.item,\n        getNamedItem: function (key) {\n            //\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n            //\t\t\treturn null;\n            //\t\t}\n            //console.log()\n            var i = this.length;\n            while (i--) {\n                var attr = this[i];\n                //console.log(attr.nodeName,key)\n                if (attr.nodeName == key) {\n                    return attr;\n                }\n            }\n        },\n        setNamedItem: function (attr) {\n            var el = attr.ownerElement;\n            if (el && el != this._ownerElement) {\n                throw new DOMException(INUSE_ATTRIBUTE_ERR);\n            }\n            var oldAttr = this.getNamedItem(attr.nodeName);\n            _addNamedNode(this._ownerElement, this, attr, oldAttr);\n            return oldAttr;\n        },\n        /* returns Node */\n        setNamedItemNS: function (attr) {\n            // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n            var el = attr.ownerElement,\n                oldAttr;\n            if (el && el != this._ownerElement) {\n                throw new DOMException(INUSE_ATTRIBUTE_ERR);\n            }\n            oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n            _addNamedNode(this._ownerElement, this, attr, oldAttr);\n            return oldAttr;\n        },\n        /* returns Node */\n        removeNamedItem: function (key) {\n            var attr = this.getNamedItem(key);\n            _removeNamedNode(this._ownerElement, this, attr);\n            return attr;\n        },\n        // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\n        //for level2\n        removeNamedItemNS: function (namespaceURI, localName) {\n            var attr = this.getNamedItemNS(namespaceURI, localName);\n            _removeNamedNode(this._ownerElement, this, attr);\n            return attr;\n        },\n        getNamedItemNS: function (namespaceURI, localName) {\n            var i = this.length;\n            while (i--) {\n                var node = this[i];\n                if (node.localName == localName && node.namespaceURI == namespaceURI) {\n                    return node;\n                }\n            }\n            return null;\n        }\n    };\n\n    /**\n     * The DOMImplementation interface represents an object providing methods\n     * which are not dependent on any particular document.\n     * Such an object is returned by the `Document.implementation` property.\n     *\n     * __The individual methods describe the differences compared to the specs.__\n     *\n     * @constructor\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n     * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n     */\n    function DOMImplementation$1() {}\n    DOMImplementation$1.prototype = {\n        /**\n         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.\n         * The different implementations fairly diverged in what kind of features were reported.\n         * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.\n         *\n         * @deprecated It is deprecated and modern browsers return true in all cases.\n         *\n         * @param {string} feature\n         * @param {string} [version]\n         * @returns {boolean} always true\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n         */\n        hasFeature: function (feature, version) {\n            return true;\n        },\n        /**\n         * Creates an XML Document object of the specified type with its document element.\n         *\n         * __It behaves slightly different from the description in the living standard__:\n         * - There is no interface/class `XMLDocument`, it returns a `Document` instance.\n         * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n         * - this implementation is not validating names or qualified names\n         *   (when parsing XML strings, the SAX parser takes care of that)\n         *\n         * @param {string|null} namespaceURI\n         * @param {string} qualifiedName\n         * @param {DocumentType=null} doctype\n         * @returns {Document}\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core\n         *\n         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n         */\n        createDocument: function (namespaceURI, qualifiedName, doctype) {\n            var doc = new Document();\n            doc.implementation = this;\n            doc.childNodes = new NodeList();\n            doc.doctype = doctype || null;\n            if (doctype) {\n                doc.appendChild(doctype);\n            }\n            if (qualifiedName) {\n                var root = doc.createElementNS(namespaceURI, qualifiedName);\n                doc.appendChild(root);\n            }\n            return doc;\n        },\n        /**\n         * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.\n         *\n         * __This behavior is slightly different from the in the specs__:\n         * - this implementation is not validating names or qualified names\n         *   (when parsing XML strings, the SAX parser takes care of that)\n         *\n         * @param {string} qualifiedName\n         * @param {string} [publicId]\n         * @param {string} [systemId]\n         * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation\n         * \t\t\t\t  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN\n         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard\n         *\n         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n         */\n        createDocumentType: function (qualifiedName, publicId, systemId) {\n            var node = new DocumentType();\n            node.name = qualifiedName;\n            node.nodeName = qualifiedName;\n            node.publicId = publicId || '';\n            node.systemId = systemId || '';\n            return node;\n        }\n    };\n\n    /**\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n     */\n\n    function Node() {}\n    Node.prototype = {\n        firstChild: null,\n        lastChild: null,\n        previousSibling: null,\n        nextSibling: null,\n        attributes: null,\n        parentNode: null,\n        childNodes: null,\n        ownerDocument: null,\n        nodeValue: null,\n        namespaceURI: null,\n        prefix: null,\n        localName: null,\n        // Modified in DOM Level 2:\n        insertBefore: function (newChild, refChild) {\n            //raises\n            return _insertBefore(this, newChild, refChild);\n        },\n        replaceChild: function (newChild, oldChild) {\n            //raises\n            _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n            if (oldChild) {\n                this.removeChild(oldChild);\n            }\n        },\n        removeChild: function (oldChild) {\n            return _removeChild(this, oldChild);\n        },\n        appendChild: function (newChild) {\n            return this.insertBefore(newChild, null);\n        },\n        hasChildNodes: function () {\n            return this.firstChild != null;\n        },\n        cloneNode: function (deep) {\n            return cloneNode(this.ownerDocument || this, this, deep);\n        },\n        // Modified in DOM Level 2:\n        normalize: function () {\n            var child = this.firstChild;\n            while (child) {\n                var next = child.nextSibling;\n                if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n                    this.removeChild(next);\n                    child.appendData(next.data);\n                } else {\n                    child.normalize();\n                    child = next;\n                }\n            }\n        },\n        // Introduced in DOM Level 2:\n        isSupported: function (feature, version) {\n            return this.ownerDocument.implementation.hasFeature(feature, version);\n        },\n        // Introduced in DOM Level 2:\n        hasAttributes: function () {\n            return this.attributes.length > 0;\n        },\n        /**\n         * Look up the prefix associated to the given namespace URI, starting from this node.\n         * **The default namespace declarations are ignored by this method.**\n         * See Namespace Prefix Lookup for details on the algorithm used by this method.\n         *\n         * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._\n         *\n         * @param {string | null} namespaceURI\n         * @returns {string | null}\n         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n         * @see https://github.com/xmldom/xmldom/issues/322\n         */\n        lookupPrefix: function (namespaceURI) {\n            var el = this;\n            while (el) {\n                var map = el._nsMap;\n                //console.dir(map)\n                if (map) {\n                    for (var n in map) {\n                        if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {\n                            return n;\n                        }\n                    }\n                }\n                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n            }\n            return null;\n        },\n        // Introduced in DOM Level 3:\n        lookupNamespaceURI: function (prefix) {\n            var el = this;\n            while (el) {\n                var map = el._nsMap;\n                //console.dir(map)\n                if (map) {\n                    if (Object.prototype.hasOwnProperty.call(map, prefix)) {\n                        return map[prefix];\n                    }\n                }\n                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n            }\n            return null;\n        },\n        // Introduced in DOM Level 3:\n        isDefaultNamespace: function (namespaceURI) {\n            var prefix = this.lookupPrefix(namespaceURI);\n            return prefix == null;\n        }\n    };\n    function _xmlEncoder(c) {\n        return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n    }\n    copy(NodeType, Node);\n    copy(NodeType, Node.prototype);\n\n    /**\n     * @param callback return true for continue,false for break\n     * @return boolean true: break visit;\n     */\n    function _visitNode(node, callback) {\n        if (callback(node)) {\n            return true;\n        }\n        if (node = node.firstChild) {\n            do {\n                if (_visitNode(node, callback)) {\n                    return true;\n                }\n            } while (node = node.nextSibling);\n        }\n    }\n    function Document() {\n        this.ownerDocument = this;\n    }\n    function _onAddAttribute(doc, el, newAttr) {\n        doc && doc._inc++;\n        var ns = newAttr.namespaceURI;\n        if (ns === NAMESPACE$2.XMLNS) {\n            //update namespace\n            el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n        }\n    }\n    function _onRemoveAttribute(doc, el, newAttr, remove) {\n        doc && doc._inc++;\n        var ns = newAttr.namespaceURI;\n        if (ns === NAMESPACE$2.XMLNS) {\n            //update namespace\n            delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n        }\n    }\n\n    /**\n     * Updates `el.childNodes`, updating the indexed items and it's `length`.\n     * Passing `newChild` means it will be appended.\n     * Otherwise it's assumed that an item has been removed,\n     * and `el.firstNode` and it's `.nextSibling` are used\n     * to walk the current list of child nodes.\n     *\n     * @param {Document} doc\n     * @param {Node} el\n     * @param {Node} [newChild]\n     * @private\n     */\n    function _onUpdateChild(doc, el, newChild) {\n        if (doc && doc._inc) {\n            doc._inc++;\n            //update childNodes\n            var cs = el.childNodes;\n            if (newChild) {\n                cs[cs.length++] = newChild;\n            } else {\n                var child = el.firstChild;\n                var i = 0;\n                while (child) {\n                    cs[i++] = child;\n                    child = child.nextSibling;\n                }\n                cs.length = i;\n                delete cs[cs.length];\n            }\n        }\n    }\n\n    /**\n     * Removes the connections between `parentNode` and `child`\n     * and any existing `child.previousSibling` or `child.nextSibling`.\n     *\n     * @see https://github.com/xmldom/xmldom/issues/135\n     * @see https://github.com/xmldom/xmldom/issues/145\n     *\n     * @param {Node} parentNode\n     * @param {Node} child\n     * @returns {Node} the child that was removed.\n     * @private\n     */\n    function _removeChild(parentNode, child) {\n        var previous = child.previousSibling;\n        var next = child.nextSibling;\n        if (previous) {\n            previous.nextSibling = next;\n        } else {\n            parentNode.firstChild = next;\n        }\n        if (next) {\n            next.previousSibling = previous;\n        } else {\n            parentNode.lastChild = previous;\n        }\n        child.parentNode = null;\n        child.previousSibling = null;\n        child.nextSibling = null;\n        _onUpdateChild(parentNode.ownerDocument, parentNode);\n        return child;\n    }\n\n    /**\n     * Returns `true` if `node` can be a parent for insertion.\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function hasValidParentNodeType(node) {\n        return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);\n    }\n\n    /**\n     * Returns `true` if `node` can be inserted according to it's `nodeType`.\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function hasInsertableNodeType(node) {\n        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);\n    }\n\n    /**\n     * Returns true if `node` is a DOCTYPE node\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isDocTypeNode(node) {\n        return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n    }\n\n    /**\n     * Returns true if the node is an element\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isElementNode(node) {\n        return node && node.nodeType === Node.ELEMENT_NODE;\n    }\n    /**\n     * Returns true if `node` is a text node\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isTextNode(node) {\n        return node && node.nodeType === Node.TEXT_NODE;\n    }\n\n    /**\n     * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n     * according to the presence and position of a doctype node on the same level.\n     *\n     * @param {Document} doc The document node\n     * @param {Node} child the node that would become the nextSibling if the element would be inserted\n     * @returns {boolean} `true` if an element can be inserted before child\n     * @private\n     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function isElementInsertionPossible(doc, child) {\n        var parentChildNodes = doc.childNodes || [];\n        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n            return false;\n        }\n        var docTypeNode = find(parentChildNodes, isDocTypeNode);\n        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n    }\n\n    /**\n     * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n     * according to the presence and position of a doctype node on the same level.\n     *\n     * @param {Node} doc The document node\n     * @param {Node} child the node that would become the nextSibling if the element would be inserted\n     * @returns {boolean} `true` if an element can be inserted before child\n     * @private\n     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function isElementReplacementPossible(doc, child) {\n        var parentChildNodes = doc.childNodes || [];\n        function hasElementChildThatIsNotChild(node) {\n            return isElementNode(node) && node !== child;\n        }\n        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n            return false;\n        }\n        var docTypeNode = find(parentChildNodes, isDocTypeNode);\n        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n    }\n\n    /**\n     * @private\n     * Steps 1-5 of the checks before inserting and before replacing a child are the same.\n     *\n     * @param {Node} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node=} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreInsertionValidity1to5(parent, node, child) {\n        // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n        if (!hasValidParentNodeType(parent)) {\n            throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n        }\n        // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n        // not implemented!\n        // 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n        if (child && child.parentNode !== parent) {\n            throw new DOMException(NOT_FOUND_ERR, 'child not in parent');\n        }\n        if (\n            // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n            !hasInsertableNodeType(node) ||\n            // 5. If either `node` is a Text node and `parent` is a document,\n            // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n            // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n            // or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n            isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {\n            throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType);\n        }\n    }\n\n    /**\n     * @private\n     * Step 6 of the checks before inserting and before replacing a child are different.\n     *\n     * @param {Document} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreInsertionValidityInDocument(parent, node, child) {\n        var parentChildNodes = parent.childNodes || [];\n        var nodeChildNodes = node.childNodes || [];\n\n        // DocumentFragment\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            var nodeChildElements = nodeChildNodes.filter(isElementNode);\n            // If node has more than one element child or has a Text node child.\n            if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n            }\n            // Otherwise, if `node` has one element child and either `parent` has an element child,\n            // `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n            if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n            }\n        }\n        // Element\n        if (isElementNode(node)) {\n            // `parent` has an element child, `child` is a doctype,\n            // or `child` is non-null and a doctype is following `child`.\n            if (!isElementInsertionPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n            }\n        }\n        // DocumentType\n        if (isDocTypeNode(node)) {\n            // `parent` has a doctype child,\n            if (find(parentChildNodes, isDocTypeNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n            }\n            var parentElementChild = find(parentChildNodes, isElementNode);\n            // `child` is non-null and an element is preceding `child`,\n            if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n            }\n            // or `child` is null and `parent` has an element child.\n            if (!child && parentElementChild) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n            }\n        }\n    }\n\n    /**\n     * @private\n     * Step 6 of the checks before inserting and before replacing a child are different.\n     *\n     * @param {Document} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreReplacementValidityInDocument(parent, node, child) {\n        var parentChildNodes = parent.childNodes || [];\n        var nodeChildNodes = node.childNodes || [];\n\n        // DocumentFragment\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            var nodeChildElements = nodeChildNodes.filter(isElementNode);\n            // If `node` has more than one element child or has a Text node child.\n            if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n            }\n            // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n            if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n            }\n        }\n        // Element\n        if (isElementNode(node)) {\n            // `parent` has an element child that is not `child` or a doctype is following `child`.\n            if (!isElementReplacementPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n            }\n        }\n        // DocumentType\n        if (isDocTypeNode(node)) {\n            function hasDoctypeChildThatIsNotChild(node) {\n                return isDocTypeNode(node) && node !== child;\n            }\n\n            // `parent` has a doctype child that is not `child`,\n            if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n            }\n            var parentElementChild = find(parentChildNodes, isElementNode);\n            // or an element is preceding `child`.\n            if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n            }\n        }\n    }\n\n    /**\n     * @private\n     * @param {Node} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node=} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function _insertBefore(parent, node, child, _inDocumentAssertion) {\n        // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n        assertPreInsertionValidity1to5(parent, node, child);\n\n        // If parent is a document, and any of the statements below, switched on the interface node implements,\n        // are true, then throw a \"HierarchyRequestError\" DOMException.\n        if (parent.nodeType === Node.DOCUMENT_NODE) {\n            (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n        }\n        var cp = node.parentNode;\n        if (cp) {\n            cp.removeChild(node); //remove and update\n        }\n\n        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            var newFirst = node.firstChild;\n            if (newFirst == null) {\n                return node;\n            }\n            var newLast = node.lastChild;\n        } else {\n            newFirst = newLast = node;\n        }\n        var pre = child ? child.previousSibling : parent.lastChild;\n        newFirst.previousSibling = pre;\n        newLast.nextSibling = child;\n        if (pre) {\n            pre.nextSibling = newFirst;\n        } else {\n            parent.firstChild = newFirst;\n        }\n        if (child == null) {\n            parent.lastChild = newLast;\n        } else {\n            child.previousSibling = newLast;\n        }\n        do {\n            newFirst.parentNode = parent;\n        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n        _onUpdateChild(parent.ownerDocument || parent, parent);\n        //console.log(parent.lastChild.nextSibling == null)\n        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n            node.firstChild = node.lastChild = null;\n        }\n        return node;\n    }\n\n    /**\n     * Appends `newChild` to `parentNode`.\n     * If `newChild` is already connected to a `parentNode` it is first removed from it.\n     *\n     * @see https://github.com/xmldom/xmldom/issues/135\n     * @see https://github.com/xmldom/xmldom/issues/145\n     * @param {Node} parentNode\n     * @param {Node} newChild\n     * @returns {Node}\n     * @private\n     */\n    function _appendSingleChild(parentNode, newChild) {\n        if (newChild.parentNode) {\n            newChild.parentNode.removeChild(newChild);\n        }\n        newChild.parentNode = parentNode;\n        newChild.previousSibling = parentNode.lastChild;\n        newChild.nextSibling = null;\n        if (newChild.previousSibling) {\n            newChild.previousSibling.nextSibling = newChild;\n        } else {\n            parentNode.firstChild = newChild;\n        }\n        parentNode.lastChild = newChild;\n        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n        return newChild;\n    }\n    Document.prototype = {\n        //implementation : null,\n        nodeName: '#document',\n        nodeType: DOCUMENT_NODE,\n        /**\n         * The DocumentType node of the document.\n         *\n         * @readonly\n         * @type DocumentType\n         */\n        doctype: null,\n        documentElement: null,\n        _inc: 1,\n        insertBefore: function (newChild, refChild) {\n            //raises\n            if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n                var child = newChild.firstChild;\n                while (child) {\n                    var next = child.nextSibling;\n                    this.insertBefore(child, refChild);\n                    child = next;\n                }\n                return newChild;\n            }\n            _insertBefore(this, newChild, refChild);\n            newChild.ownerDocument = this;\n            if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n                this.documentElement = newChild;\n            }\n            return newChild;\n        },\n        removeChild: function (oldChild) {\n            if (this.documentElement == oldChild) {\n                this.documentElement = null;\n            }\n            return _removeChild(this, oldChild);\n        },\n        replaceChild: function (newChild, oldChild) {\n            //raises\n            _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n            newChild.ownerDocument = this;\n            if (oldChild) {\n                this.removeChild(oldChild);\n            }\n            if (isElementNode(newChild)) {\n                this.documentElement = newChild;\n            }\n        },\n        // Introduced in DOM Level 2:\n        importNode: function (importedNode, deep) {\n            return importNode(this, importedNode, deep);\n        },\n        // Introduced in DOM Level 2:\n        getElementById: function (id) {\n            var rtv = null;\n            _visitNode(this.documentElement, function (node) {\n                if (node.nodeType == ELEMENT_NODE) {\n                    if (node.getAttribute('id') == id) {\n                        rtv = node;\n                        return true;\n                    }\n                }\n            });\n            return rtv;\n        },\n        /**\n         * The `getElementsByClassName` method of `Document` interface returns an array-like object\n         * of all child elements which have **all** of the given class name(s).\n         *\n         * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.\n         *\n         *\n         * Warning: This is a live LiveNodeList.\n         * Changes in the DOM will reflect in the array as the changes occur.\n         * If an element selected by this array no longer qualifies for the selector,\n         * it will automatically be removed. Be aware of this for iteration purposes.\n         *\n         * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n         */\n        getElementsByClassName: function (classNames) {\n            var classNamesSet = toOrderedSet(classNames);\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                if (classNamesSet.length > 0) {\n                    _visitNode(base.documentElement, function (node) {\n                        if (node !== base && node.nodeType === ELEMENT_NODE) {\n                            var nodeClassNames = node.getAttribute('class');\n                            // can be null if the attribute does not exist\n                            if (nodeClassNames) {\n                                // before splitting and iterating just compare them for the most common case\n                                var matches = classNames === nodeClassNames;\n                                if (!matches) {\n                                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);\n                                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\n                                }\n                                if (matches) {\n                                    ls.push(node);\n                                }\n                            }\n                        }\n                    });\n                }\n                return ls;\n            });\n        },\n        //document factory method:\n        createElement: function (tagName) {\n            var node = new Element();\n            node.ownerDocument = this;\n            node.nodeName = tagName;\n            node.tagName = tagName;\n            node.localName = tagName;\n            node.childNodes = new NodeList();\n            var attrs = node.attributes = new NamedNodeMap();\n            attrs._ownerElement = node;\n            return node;\n        },\n        createDocumentFragment: function () {\n            var node = new DocumentFragment();\n            node.ownerDocument = this;\n            node.childNodes = new NodeList();\n            return node;\n        },\n        createTextNode: function (data) {\n            var node = new Text();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createComment: function (data) {\n            var node = new Comment();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createCDATASection: function (data) {\n            var node = new CDATASection();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createProcessingInstruction: function (target, data) {\n            var node = new ProcessingInstruction();\n            node.ownerDocument = this;\n            node.tagName = node.nodeName = node.target = target;\n            node.nodeValue = node.data = data;\n            return node;\n        },\n        createAttribute: function (name) {\n            var node = new Attr();\n            node.ownerDocument = this;\n            node.name = name;\n            node.nodeName = name;\n            node.localName = name;\n            node.specified = true;\n            return node;\n        },\n        createEntityReference: function (name) {\n            var node = new EntityReference();\n            node.ownerDocument = this;\n            node.nodeName = name;\n            return node;\n        },\n        // Introduced in DOM Level 2:\n        createElementNS: function (namespaceURI, qualifiedName) {\n            var node = new Element();\n            var pl = qualifiedName.split(':');\n            var attrs = node.attributes = new NamedNodeMap();\n            node.childNodes = new NodeList();\n            node.ownerDocument = this;\n            node.nodeName = qualifiedName;\n            node.tagName = qualifiedName;\n            node.namespaceURI = namespaceURI;\n            if (pl.length == 2) {\n                node.prefix = pl[0];\n                node.localName = pl[1];\n            } else {\n                //el.prefix = null;\n                node.localName = qualifiedName;\n            }\n            attrs._ownerElement = node;\n            return node;\n        },\n        // Introduced in DOM Level 2:\n        createAttributeNS: function (namespaceURI, qualifiedName) {\n            var node = new Attr();\n            var pl = qualifiedName.split(':');\n            node.ownerDocument = this;\n            node.nodeName = qualifiedName;\n            node.name = qualifiedName;\n            node.namespaceURI = namespaceURI;\n            node.specified = true;\n            if (pl.length == 2) {\n                node.prefix = pl[0];\n                node.localName = pl[1];\n            } else {\n                //el.prefix = null;\n                node.localName = qualifiedName;\n            }\n            return node;\n        }\n    };\n    _extends(Document, Node);\n    function Element() {\n        this._nsMap = {};\n    }\n    Element.prototype = {\n        nodeType: ELEMENT_NODE,\n        hasAttribute: function (name) {\n            return this.getAttributeNode(name) != null;\n        },\n        getAttribute: function (name) {\n            var attr = this.getAttributeNode(name);\n            return attr && attr.value || '';\n        },\n        getAttributeNode: function (name) {\n            return this.attributes.getNamedItem(name);\n        },\n        setAttribute: function (name, value) {\n            var attr = this.ownerDocument.createAttribute(name);\n            attr.value = attr.nodeValue = \"\" + value;\n            this.setAttributeNode(attr);\n        },\n        removeAttribute: function (name) {\n            var attr = this.getAttributeNode(name);\n            attr && this.removeAttributeNode(attr);\n        },\n        //four real opeartion method\n        appendChild: function (newChild) {\n            if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n                return this.insertBefore(newChild, null);\n            } else {\n                return _appendSingleChild(this, newChild);\n            }\n        },\n        setAttributeNode: function (newAttr) {\n            return this.attributes.setNamedItem(newAttr);\n        },\n        setAttributeNodeNS: function (newAttr) {\n            return this.attributes.setNamedItemNS(newAttr);\n        },\n        removeAttributeNode: function (oldAttr) {\n            //console.log(this == oldAttr.ownerElement)\n            return this.attributes.removeNamedItem(oldAttr.nodeName);\n        },\n        //get real attribute name,and remove it by removeAttributeNode\n        removeAttributeNS: function (namespaceURI, localName) {\n            var old = this.getAttributeNodeNS(namespaceURI, localName);\n            old && this.removeAttributeNode(old);\n        },\n        hasAttributeNS: function (namespaceURI, localName) {\n            return this.getAttributeNodeNS(namespaceURI, localName) != null;\n        },\n        getAttributeNS: function (namespaceURI, localName) {\n            var attr = this.getAttributeNodeNS(namespaceURI, localName);\n            return attr && attr.value || '';\n        },\n        setAttributeNS: function (namespaceURI, qualifiedName, value) {\n            var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n            attr.value = attr.nodeValue = \"\" + value;\n            this.setAttributeNode(attr);\n        },\n        getAttributeNodeNS: function (namespaceURI, localName) {\n            return this.attributes.getNamedItemNS(namespaceURI, localName);\n        },\n        getElementsByTagName: function (tagName) {\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                _visitNode(base, function (node) {\n                    if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\n                        ls.push(node);\n                    }\n                });\n                return ls;\n            });\n        },\n        getElementsByTagNameNS: function (namespaceURI, localName) {\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                _visitNode(base, function (node) {\n                    if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n                        ls.push(node);\n                    }\n                });\n                return ls;\n            });\n        }\n    };\n    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\n    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n    _extends(Element, Node);\n    function Attr() {}\n    Attr.prototype.nodeType = ATTRIBUTE_NODE;\n    _extends(Attr, Node);\n    function CharacterData() {}\n    CharacterData.prototype = {\n        data: '',\n        substringData: function (offset, count) {\n            return this.data.substring(offset, offset + count);\n        },\n        appendData: function (text) {\n            text = this.data + text;\n            this.nodeValue = this.data = text;\n            this.length = text.length;\n        },\n        insertData: function (offset, text) {\n            this.replaceData(offset, 0, text);\n        },\n        appendChild: function (newChild) {\n            throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);\n        },\n        deleteData: function (offset, count) {\n            this.replaceData(offset, count, \"\");\n        },\n        replaceData: function (offset, count, text) {\n            var start = this.data.substring(0, offset);\n            var end = this.data.substring(offset + count);\n            text = start + text + end;\n            this.nodeValue = this.data = text;\n            this.length = text.length;\n        }\n    };\n    _extends(CharacterData, Node);\n    function Text() {}\n    Text.prototype = {\n        nodeName: \"#text\",\n        nodeType: TEXT_NODE,\n        splitText: function (offset) {\n            var text = this.data;\n            var newText = text.substring(offset);\n            text = text.substring(0, offset);\n            this.data = this.nodeValue = text;\n            this.length = text.length;\n            var newNode = this.ownerDocument.createTextNode(newText);\n            if (this.parentNode) {\n                this.parentNode.insertBefore(newNode, this.nextSibling);\n            }\n            return newNode;\n        }\n    };\n    _extends(Text, CharacterData);\n    function Comment() {}\n    Comment.prototype = {\n        nodeName: \"#comment\",\n        nodeType: COMMENT_NODE\n    };\n    _extends(Comment, CharacterData);\n    function CDATASection() {}\n    CDATASection.prototype = {\n        nodeName: \"#cdata-section\",\n        nodeType: CDATA_SECTION_NODE\n    };\n    _extends(CDATASection, CharacterData);\n    function DocumentType() {}\n    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n    _extends(DocumentType, Node);\n    function Notation() {}\n    Notation.prototype.nodeType = NOTATION_NODE;\n    _extends(Notation, Node);\n    function Entity() {}\n    Entity.prototype.nodeType = ENTITY_NODE;\n    _extends(Entity, Node);\n    function EntityReference() {}\n    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n    _extends(EntityReference, Node);\n    function DocumentFragment() {}\n    DocumentFragment.prototype.nodeName = \"#document-fragment\";\n    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n    _extends(DocumentFragment, Node);\n    function ProcessingInstruction() {}\n    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n    _extends(ProcessingInstruction, Node);\n    function XMLSerializer() {}\n    XMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {\n        return nodeSerializeToString.call(node, isHtml, nodeFilter);\n    };\n    Node.prototype.toString = nodeSerializeToString;\n    function nodeSerializeToString(isHtml, nodeFilter) {\n        var buf = [];\n        var refNode = this.nodeType == 9 && this.documentElement || this;\n        var prefix = refNode.prefix;\n        var uri = refNode.namespaceURI;\n        if (uri && prefix == null) {\n            //console.log(prefix)\n            var prefix = refNode.lookupPrefix(uri);\n            if (prefix == null) {\n                //isHTML = true;\n                var visibleNamespaces = [{\n                    namespace: uri,\n                    prefix: null\n                }\n                    //{namespace:uri,prefix:''}\n                ];\n            }\n        }\n\n        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);\n        //console.log('###',this.nodeType,uri,prefix,buf.join(''))\n        return buf.join('');\n    }\n    function needNamespaceDefine(node, isHTML, visibleNamespaces) {\n        var prefix = node.prefix || '';\n        var uri = node.namespaceURI;\n        // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n        // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n        // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n        // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n        // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n        // > [...] Furthermore, the attribute value [...] must not be an empty string.\n        // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n        if (!uri) {\n            return false;\n        }\n        if (prefix === \"xml\" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {\n            return false;\n        }\n        var i = visibleNamespaces.length;\n        while (i--) {\n            var ns = visibleNamespaces[i];\n            // get namespace prefix\n            if (ns.prefix === prefix) {\n                return ns.namespace !== uri;\n            }\n        }\n        return true;\n    }\n    /**\n     * Well-formed constraint: No < in Attribute Values\n     * > The replacement text of any entity referred to directly or indirectly\n     * > in an attribute value must not contain a <.\n     * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n     * @see https://www.w3.org/TR/xml11/#NT-AttValue\n     *\n     * Literal whitespace other than space that appear in attribute values\n     * are serialized as their entity references, so they will be preserved.\n     * (In contrast to whitespace literals in the input which are normalized to spaces)\n     * @see https://www.w3.org/TR/xml11/#AVNormalize\n     * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n     */\n    function addSerializedAttribute(buf, qualifiedName, value) {\n        buf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"');\n    }\n    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {\n        if (!visibleNamespaces) {\n            visibleNamespaces = [];\n        }\n        if (nodeFilter) {\n            node = nodeFilter(node);\n            if (node) {\n                if (typeof node == 'string') {\n                    buf.push(node);\n                    return;\n                }\n            } else {\n                return;\n            }\n            //buf.sort.apply(attrs, attributeSorter);\n        }\n\n        switch (node.nodeType) {\n            case ELEMENT_NODE:\n                var attrs = node.attributes;\n                var len = attrs.length;\n                var child = node.firstChild;\n                var nodeName = node.tagName;\n                isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;\n                var prefixedNodeName = nodeName;\n                if (!isHTML && !node.prefix && node.namespaceURI) {\n                    var defaultNS;\n                    // lookup current default ns from `xmlns` attribute\n                    for (var ai = 0; ai < attrs.length; ai++) {\n                        if (attrs.item(ai).name === 'xmlns') {\n                            defaultNS = attrs.item(ai).value;\n                            break;\n                        }\n                    }\n                    if (!defaultNS) {\n                        // lookup current default ns in visibleNamespaces\n                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n                            var namespace = visibleNamespaces[nsi];\n                            if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n                                defaultNS = namespace.namespace;\n                                break;\n                            }\n                        }\n                    }\n                    if (defaultNS !== node.namespaceURI) {\n                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n                            var namespace = visibleNamespaces[nsi];\n                            if (namespace.namespace === node.namespaceURI) {\n                                if (namespace.prefix) {\n                                    prefixedNodeName = namespace.prefix + ':' + nodeName;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                buf.push('<', prefixedNodeName);\n                for (var i = 0; i < len; i++) {\n                    // add namespaces for attributes\n                    var attr = attrs.item(i);\n                    if (attr.prefix == 'xmlns') {\n                        visibleNamespaces.push({\n                            prefix: attr.localName,\n                            namespace: attr.value\n                        });\n                    } else if (attr.nodeName == 'xmlns') {\n                        visibleNamespaces.push({\n                            prefix: '',\n                            namespace: attr.value\n                        });\n                    }\n                }\n                for (var i = 0; i < len; i++) {\n                    var attr = attrs.item(i);\n                    if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n                        var prefix = attr.prefix || '';\n                        var uri = attr.namespaceURI;\n                        addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n                        visibleNamespaces.push({\n                            prefix: prefix,\n                            namespace: uri\n                        });\n                    }\n                    serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);\n                }\n\n                // add namespace for current node\n                if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n                    var prefix = node.prefix || '';\n                    var uri = node.namespaceURI;\n                    addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n                    visibleNamespaces.push({\n                        prefix: prefix,\n                        namespace: uri\n                    });\n                }\n                if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {\n                    buf.push('>');\n                    //if is cdata child node\n                    if (isHTML && /^script$/i.test(nodeName)) {\n                        while (child) {\n                            if (child.data) {\n                                buf.push(child.data);\n                            } else {\n                                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                            }\n                            child = child.nextSibling;\n                        }\n                    } else {\n                        while (child) {\n                            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                            child = child.nextSibling;\n                        }\n                    }\n                    buf.push('</', prefixedNodeName, '>');\n                } else {\n                    buf.push('/>');\n                }\n                // remove added visible namespaces\n                //visibleNamespaces.length = startVisibleNamespaces;\n                return;\n            case DOCUMENT_NODE:\n            case DOCUMENT_FRAGMENT_NODE:\n                var child = node.firstChild;\n                while (child) {\n                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                    child = child.nextSibling;\n                }\n                return;\n            case ATTRIBUTE_NODE:\n                return addSerializedAttribute(buf, node.name, node.value);\n            case TEXT_NODE:\n                /**\n                 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n                 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\n                 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\n                 * `&amp;` and `&lt;` respectively.\n                 * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\n                 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\n                 * when that string is not marking the end of a CDATA section.\n                 *\n                 * In the content of elements, character data is any string of characters\n                 * which does not contain the start-delimiter of any markup\n                 * and does not include the CDATA-section-close delimiter, `]]>`.\n                 *\n                 * @see https://www.w3.org/TR/xml/#NT-CharData\n                 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n                 */\n                return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));\n            case CDATA_SECTION_NODE:\n                return buf.push('<![CDATA[', node.data, ']]>');\n            case COMMENT_NODE:\n                return buf.push(\"<!--\", node.data, \"-->\");\n            case DOCUMENT_TYPE_NODE:\n                var pubid = node.publicId;\n                var sysid = node.systemId;\n                buf.push('<!DOCTYPE ', node.name);\n                if (pubid) {\n                    buf.push(' PUBLIC ', pubid);\n                    if (sysid && sysid != '.') {\n                        buf.push(' ', sysid);\n                    }\n                    buf.push('>');\n                } else if (sysid && sysid != '.') {\n                    buf.push(' SYSTEM ', sysid, '>');\n                } else {\n                    var sub = node.internalSubset;\n                    if (sub) {\n                        buf.push(\" [\", sub, \"]\");\n                    }\n                    buf.push(\">\");\n                }\n                return;\n            case PROCESSING_INSTRUCTION_NODE:\n                return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\n            case ENTITY_REFERENCE_NODE:\n                return buf.push('&', node.nodeName, ';');\n            //case ENTITY_NODE:\n            //case NOTATION_NODE:\n            default:\n                buf.push('??', node.nodeName);\n        }\n    }\n    function importNode(doc, node, deep) {\n        var node2;\n        switch (node.nodeType) {\n            case ELEMENT_NODE:\n                node2 = node.cloneNode(false);\n                node2.ownerDocument = doc;\n            //var attrs = node2.attributes;\n            //var len = attrs.length;\n            //for(var i=0;i<len;i++){\n            //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n            //}\n            case DOCUMENT_FRAGMENT_NODE:\n                break;\n            case ATTRIBUTE_NODE:\n                deep = true;\n                break;\n            //case ENTITY_REFERENCE_NODE:\n            //case PROCESSING_INSTRUCTION_NODE:\n            ////case TEXT_NODE:\n            //case CDATA_SECTION_NODE:\n            //case COMMENT_NODE:\n            //\tdeep = false;\n            //\tbreak;\n            //case DOCUMENT_NODE:\n            //case DOCUMENT_TYPE_NODE:\n            //cannot be imported.\n            //case ENTITY_NODE:\n            //case NOTATION_NODE：\n            //can not hit in level3\n            //default:throw e;\n        }\n\n        if (!node2) {\n            node2 = node.cloneNode(false); //false\n        }\n\n        node2.ownerDocument = doc;\n        node2.parentNode = null;\n        if (deep) {\n            var child = node.firstChild;\n            while (child) {\n                node2.appendChild(importNode(doc, child, deep));\n                child = child.nextSibling;\n            }\n        }\n        return node2;\n    }\n    //\n    //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n    //\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\n    function cloneNode(doc, node, deep) {\n        var node2 = new node.constructor();\n        for (var n in node) {\n            if (Object.prototype.hasOwnProperty.call(node, n)) {\n                var v = node[n];\n                if (typeof v != \"object\") {\n                    if (v != node2[n]) {\n                        node2[n] = v;\n                    }\n                }\n            }\n        }\n        if (node.childNodes) {\n            node2.childNodes = new NodeList();\n        }\n        node2.ownerDocument = doc;\n        switch (node2.nodeType) {\n            case ELEMENT_NODE:\n                var attrs = node.attributes;\n                var attrs2 = node2.attributes = new NamedNodeMap();\n                var len = attrs.length;\n                attrs2._ownerElement = node2;\n                for (var i = 0; i < len; i++) {\n                    node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));\n                }\n                break;\n            case ATTRIBUTE_NODE:\n                deep = true;\n        }\n        if (deep) {\n            var child = node.firstChild;\n            while (child) {\n                node2.appendChild(cloneNode(doc, child, deep));\n                child = child.nextSibling;\n            }\n        }\n        return node2;\n    }\n    function __set__(object, key, value) {\n        object[key] = value;\n    }\n    //do dynamic\n    try {\n        if (Object.defineProperty) {\n            Object.defineProperty(LiveNodeList.prototype, 'length', {\n                get: function () {\n                    _updateLiveList(this);\n                    return this.$$length;\n                }\n            });\n            Object.defineProperty(Node.prototype, 'textContent', {\n                get: function () {\n                    return getTextContent(this);\n                },\n                set: function (data) {\n                    switch (this.nodeType) {\n                        case ELEMENT_NODE:\n                        case DOCUMENT_FRAGMENT_NODE:\n                            while (this.firstChild) {\n                                this.removeChild(this.firstChild);\n                            }\n                            if (data || String(data)) {\n                                this.appendChild(this.ownerDocument.createTextNode(data));\n                            }\n                            break;\n                        default:\n                            this.data = data;\n                            this.value = data;\n                            this.nodeValue = data;\n                    }\n                }\n            });\n            function getTextContent(node) {\n                switch (node.nodeType) {\n                    case ELEMENT_NODE:\n                    case DOCUMENT_FRAGMENT_NODE:\n                        var buf = [];\n                        node = node.firstChild;\n                        while (node) {\n                            if (node.nodeType !== 7 && node.nodeType !== 8) {\n                                buf.push(getTextContent(node));\n                            }\n                            node = node.nextSibling;\n                        }\n                        return buf.join('');\n                    default:\n                        return node.nodeValue;\n                }\n            }\n            __set__ = function (object, key, value) {\n                //console.log(value)\n                object['$$' + key] = value;\n            };\n        }\n    } catch (e) {//ie8\n    }\n\n    //if(typeof require == 'function'){\n    var DocumentType_1 = DocumentType;\n    var DOMException_1 = DOMException;\n    var DOMImplementation_1 = DOMImplementation$1;\n    var Element_1 = Element;\n    var Node_1 = Node;\n    var NodeList_1 = NodeList;\n    var XMLSerializer_1 = XMLSerializer;\n    //}\n\n    var dom = {\n        DocumentType: DocumentType_1,\n        DOMException: DOMException_1,\n        DOMImplementation: DOMImplementation_1,\n        Element: Element_1,\n        Node: Node_1,\n        NodeList: NodeList_1,\n        XMLSerializer: XMLSerializer_1\n    };\n\n    var entities = createCommonjsModule(function (module, exports) {\n\n        var freeze = conventions.freeze;\n\n        /**\n         * The entities that are predefined in every XML document.\n         *\n         * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1\n         * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia\n         */\n        exports.XML_ENTITIES = freeze({\n            amp: '&',\n            apos: \"'\",\n            gt: '>',\n            lt: '<',\n            quot: '\"'\n        });\n\n        /**\n         * A map of all entities that are detected in an HTML document.\n         * They contain all entries from `XML_ENTITIES`.\n         *\n         * @see XML_ENTITIES\n         * @see DOMParser.parseFromString\n         * @see DOMImplementation.prototype.createHTMLDocument\n         * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec\n         * @see https://html.spec.whatwg.org/entities.json JSON\n         * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names\n         * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)\n         */\n        exports.HTML_ENTITIES = freeze({\n            Aacute: '\\u00C1',\n            aacute: '\\u00E1',\n            Abreve: '\\u0102',\n            abreve: '\\u0103',\n            ac: '\\u223E',\n            acd: '\\u223F',\n            acE: '\\u223E\\u0333',\n            Acirc: '\\u00C2',\n            acirc: '\\u00E2',\n            acute: '\\u00B4',\n            Acy: '\\u0410',\n            acy: '\\u0430',\n            AElig: '\\u00C6',\n            aelig: '\\u00E6',\n            af: '\\u2061',\n            Afr: '\\uD835\\uDD04',\n            afr: '\\uD835\\uDD1E',\n            Agrave: '\\u00C0',\n            agrave: '\\u00E0',\n            alefsym: '\\u2135',\n            aleph: '\\u2135',\n            Alpha: '\\u0391',\n            alpha: '\\u03B1',\n            Amacr: '\\u0100',\n            amacr: '\\u0101',\n            amalg: '\\u2A3F',\n            AMP: '\\u0026',\n            amp: '\\u0026',\n            And: '\\u2A53',\n            and: '\\u2227',\n            andand: '\\u2A55',\n            andd: '\\u2A5C',\n            andslope: '\\u2A58',\n            andv: '\\u2A5A',\n            ang: '\\u2220',\n            ange: '\\u29A4',\n            angle: '\\u2220',\n            angmsd: '\\u2221',\n            angmsdaa: '\\u29A8',\n            angmsdab: '\\u29A9',\n            angmsdac: '\\u29AA',\n            angmsdad: '\\u29AB',\n            angmsdae: '\\u29AC',\n            angmsdaf: '\\u29AD',\n            angmsdag: '\\u29AE',\n            angmsdah: '\\u29AF',\n            angrt: '\\u221F',\n            angrtvb: '\\u22BE',\n            angrtvbd: '\\u299D',\n            angsph: '\\u2222',\n            angst: '\\u00C5',\n            angzarr: '\\u237C',\n            Aogon: '\\u0104',\n            aogon: '\\u0105',\n            Aopf: '\\uD835\\uDD38',\n            aopf: '\\uD835\\uDD52',\n            ap: '\\u2248',\n            apacir: '\\u2A6F',\n            apE: '\\u2A70',\n            ape: '\\u224A',\n            apid: '\\u224B',\n            apos: '\\u0027',\n            ApplyFunction: '\\u2061',\n            approx: '\\u2248',\n            approxeq: '\\u224A',\n            Aring: '\\u00C5',\n            aring: '\\u00E5',\n            Ascr: '\\uD835\\uDC9C',\n            ascr: '\\uD835\\uDCB6',\n            Assign: '\\u2254',\n            ast: '\\u002A',\n            asymp: '\\u2248',\n            asympeq: '\\u224D',\n            Atilde: '\\u00C3',\n            atilde: '\\u00E3',\n            Auml: '\\u00C4',\n            auml: '\\u00E4',\n            awconint: '\\u2233',\n            awint: '\\u2A11',\n            backcong: '\\u224C',\n            backepsilon: '\\u03F6',\n            backprime: '\\u2035',\n            backsim: '\\u223D',\n            backsimeq: '\\u22CD',\n            Backslash: '\\u2216',\n            Barv: '\\u2AE7',\n            barvee: '\\u22BD',\n            Barwed: '\\u2306',\n            barwed: '\\u2305',\n            barwedge: '\\u2305',\n            bbrk: '\\u23B5',\n            bbrktbrk: '\\u23B6',\n            bcong: '\\u224C',\n            Bcy: '\\u0411',\n            bcy: '\\u0431',\n            bdquo: '\\u201E',\n            becaus: '\\u2235',\n            Because: '\\u2235',\n            because: '\\u2235',\n            bemptyv: '\\u29B0',\n            bepsi: '\\u03F6',\n            bernou: '\\u212C',\n            Bernoullis: '\\u212C',\n            Beta: '\\u0392',\n            beta: '\\u03B2',\n            beth: '\\u2136',\n            between: '\\u226C',\n            Bfr: '\\uD835\\uDD05',\n            bfr: '\\uD835\\uDD1F',\n            bigcap: '\\u22C2',\n            bigcirc: '\\u25EF',\n            bigcup: '\\u22C3',\n            bigodot: '\\u2A00',\n            bigoplus: '\\u2A01',\n            bigotimes: '\\u2A02',\n            bigsqcup: '\\u2A06',\n            bigstar: '\\u2605',\n            bigtriangledown: '\\u25BD',\n            bigtriangleup: '\\u25B3',\n            biguplus: '\\u2A04',\n            bigvee: '\\u22C1',\n            bigwedge: '\\u22C0',\n            bkarow: '\\u290D',\n            blacklozenge: '\\u29EB',\n            blacksquare: '\\u25AA',\n            blacktriangle: '\\u25B4',\n            blacktriangledown: '\\u25BE',\n            blacktriangleleft: '\\u25C2',\n            blacktriangleright: '\\u25B8',\n            blank: '\\u2423',\n            blk12: '\\u2592',\n            blk14: '\\u2591',\n            blk34: '\\u2593',\n            block: '\\u2588',\n            bne: '\\u003D\\u20E5',\n            bnequiv: '\\u2261\\u20E5',\n            bNot: '\\u2AED',\n            bnot: '\\u2310',\n            Bopf: '\\uD835\\uDD39',\n            bopf: '\\uD835\\uDD53',\n            bot: '\\u22A5',\n            bottom: '\\u22A5',\n            bowtie: '\\u22C8',\n            boxbox: '\\u29C9',\n            boxDL: '\\u2557',\n            boxDl: '\\u2556',\n            boxdL: '\\u2555',\n            boxdl: '\\u2510',\n            boxDR: '\\u2554',\n            boxDr: '\\u2553',\n            boxdR: '\\u2552',\n            boxdr: '\\u250C',\n            boxH: '\\u2550',\n            boxh: '\\u2500',\n            boxHD: '\\u2566',\n            boxHd: '\\u2564',\n            boxhD: '\\u2565',\n            boxhd: '\\u252C',\n            boxHU: '\\u2569',\n            boxHu: '\\u2567',\n            boxhU: '\\u2568',\n            boxhu: '\\u2534',\n            boxminus: '\\u229F',\n            boxplus: '\\u229E',\n            boxtimes: '\\u22A0',\n            boxUL: '\\u255D',\n            boxUl: '\\u255C',\n            boxuL: '\\u255B',\n            boxul: '\\u2518',\n            boxUR: '\\u255A',\n            boxUr: '\\u2559',\n            boxuR: '\\u2558',\n            boxur: '\\u2514',\n            boxV: '\\u2551',\n            boxv: '\\u2502',\n            boxVH: '\\u256C',\n            boxVh: '\\u256B',\n            boxvH: '\\u256A',\n            boxvh: '\\u253C',\n            boxVL: '\\u2563',\n            boxVl: '\\u2562',\n            boxvL: '\\u2561',\n            boxvl: '\\u2524',\n            boxVR: '\\u2560',\n            boxVr: '\\u255F',\n            boxvR: '\\u255E',\n            boxvr: '\\u251C',\n            bprime: '\\u2035',\n            Breve: '\\u02D8',\n            breve: '\\u02D8',\n            brvbar: '\\u00A6',\n            Bscr: '\\u212C',\n            bscr: '\\uD835\\uDCB7',\n            bsemi: '\\u204F',\n            bsim: '\\u223D',\n            bsime: '\\u22CD',\n            bsol: '\\u005C',\n            bsolb: '\\u29C5',\n            bsolhsub: '\\u27C8',\n            bull: '\\u2022',\n            bullet: '\\u2022',\n            bump: '\\u224E',\n            bumpE: '\\u2AAE',\n            bumpe: '\\u224F',\n            Bumpeq: '\\u224E',\n            bumpeq: '\\u224F',\n            Cacute: '\\u0106',\n            cacute: '\\u0107',\n            Cap: '\\u22D2',\n            cap: '\\u2229',\n            capand: '\\u2A44',\n            capbrcup: '\\u2A49',\n            capcap: '\\u2A4B',\n            capcup: '\\u2A47',\n            capdot: '\\u2A40',\n            CapitalDifferentialD: '\\u2145',\n            caps: '\\u2229\\uFE00',\n            caret: '\\u2041',\n            caron: '\\u02C7',\n            Cayleys: '\\u212D',\n            ccaps: '\\u2A4D',\n            Ccaron: '\\u010C',\n            ccaron: '\\u010D',\n            Ccedil: '\\u00C7',\n            ccedil: '\\u00E7',\n            Ccirc: '\\u0108',\n            ccirc: '\\u0109',\n            Cconint: '\\u2230',\n            ccups: '\\u2A4C',\n            ccupssm: '\\u2A50',\n            Cdot: '\\u010A',\n            cdot: '\\u010B',\n            cedil: '\\u00B8',\n            Cedilla: '\\u00B8',\n            cemptyv: '\\u29B2',\n            cent: '\\u00A2',\n            CenterDot: '\\u00B7',\n            centerdot: '\\u00B7',\n            Cfr: '\\u212D',\n            cfr: '\\uD835\\uDD20',\n            CHcy: '\\u0427',\n            chcy: '\\u0447',\n            check: '\\u2713',\n            checkmark: '\\u2713',\n            Chi: '\\u03A7',\n            chi: '\\u03C7',\n            cir: '\\u25CB',\n            circ: '\\u02C6',\n            circeq: '\\u2257',\n            circlearrowleft: '\\u21BA',\n            circlearrowright: '\\u21BB',\n            circledast: '\\u229B',\n            circledcirc: '\\u229A',\n            circleddash: '\\u229D',\n            CircleDot: '\\u2299',\n            circledR: '\\u00AE',\n            circledS: '\\u24C8',\n            CircleMinus: '\\u2296',\n            CirclePlus: '\\u2295',\n            CircleTimes: '\\u2297',\n            cirE: '\\u29C3',\n            cire: '\\u2257',\n            cirfnint: '\\u2A10',\n            cirmid: '\\u2AEF',\n            cirscir: '\\u29C2',\n            ClockwiseContourIntegral: '\\u2232',\n            CloseCurlyDoubleQuote: '\\u201D',\n            CloseCurlyQuote: '\\u2019',\n            clubs: '\\u2663',\n            clubsuit: '\\u2663',\n            Colon: '\\u2237',\n            colon: '\\u003A',\n            Colone: '\\u2A74',\n            colone: '\\u2254',\n            coloneq: '\\u2254',\n            comma: '\\u002C',\n            commat: '\\u0040',\n            comp: '\\u2201',\n            compfn: '\\u2218',\n            complement: '\\u2201',\n            complexes: '\\u2102',\n            cong: '\\u2245',\n            congdot: '\\u2A6D',\n            Congruent: '\\u2261',\n            Conint: '\\u222F',\n            conint: '\\u222E',\n            ContourIntegral: '\\u222E',\n            Copf: '\\u2102',\n            copf: '\\uD835\\uDD54',\n            coprod: '\\u2210',\n            Coproduct: '\\u2210',\n            COPY: '\\u00A9',\n            copy: '\\u00A9',\n            copysr: '\\u2117',\n            CounterClockwiseContourIntegral: '\\u2233',\n            crarr: '\\u21B5',\n            Cross: '\\u2A2F',\n            cross: '\\u2717',\n            Cscr: '\\uD835\\uDC9E',\n            cscr: '\\uD835\\uDCB8',\n            csub: '\\u2ACF',\n            csube: '\\u2AD1',\n            csup: '\\u2AD0',\n            csupe: '\\u2AD2',\n            ctdot: '\\u22EF',\n            cudarrl: '\\u2938',\n            cudarrr: '\\u2935',\n            cuepr: '\\u22DE',\n            cuesc: '\\u22DF',\n            cularr: '\\u21B6',\n            cularrp: '\\u293D',\n            Cup: '\\u22D3',\n            cup: '\\u222A',\n            cupbrcap: '\\u2A48',\n            CupCap: '\\u224D',\n            cupcap: '\\u2A46',\n            cupcup: '\\u2A4A',\n            cupdot: '\\u228D',\n            cupor: '\\u2A45',\n            cups: '\\u222A\\uFE00',\n            curarr: '\\u21B7',\n            curarrm: '\\u293C',\n            curlyeqprec: '\\u22DE',\n            curlyeqsucc: '\\u22DF',\n            curlyvee: '\\u22CE',\n            curlywedge: '\\u22CF',\n            curren: '\\u00A4',\n            curvearrowleft: '\\u21B6',\n            curvearrowright: '\\u21B7',\n            cuvee: '\\u22CE',\n            cuwed: '\\u22CF',\n            cwconint: '\\u2232',\n            cwint: '\\u2231',\n            cylcty: '\\u232D',\n            Dagger: '\\u2021',\n            dagger: '\\u2020',\n            daleth: '\\u2138',\n            Darr: '\\u21A1',\n            dArr: '\\u21D3',\n            darr: '\\u2193',\n            dash: '\\u2010',\n            Dashv: '\\u2AE4',\n            dashv: '\\u22A3',\n            dbkarow: '\\u290F',\n            dblac: '\\u02DD',\n            Dcaron: '\\u010E',\n            dcaron: '\\u010F',\n            Dcy: '\\u0414',\n            dcy: '\\u0434',\n            DD: '\\u2145',\n            dd: '\\u2146',\n            ddagger: '\\u2021',\n            ddarr: '\\u21CA',\n            DDotrahd: '\\u2911',\n            ddotseq: '\\u2A77',\n            deg: '\\u00B0',\n            Del: '\\u2207',\n            Delta: '\\u0394',\n            delta: '\\u03B4',\n            demptyv: '\\u29B1',\n            dfisht: '\\u297F',\n            Dfr: '\\uD835\\uDD07',\n            dfr: '\\uD835\\uDD21',\n            dHar: '\\u2965',\n            dharl: '\\u21C3',\n            dharr: '\\u21C2',\n            DiacriticalAcute: '\\u00B4',\n            DiacriticalDot: '\\u02D9',\n            DiacriticalDoubleAcute: '\\u02DD',\n            DiacriticalGrave: '\\u0060',\n            DiacriticalTilde: '\\u02DC',\n            diam: '\\u22C4',\n            Diamond: '\\u22C4',\n            diamond: '\\u22C4',\n            diamondsuit: '\\u2666',\n            diams: '\\u2666',\n            die: '\\u00A8',\n            DifferentialD: '\\u2146',\n            digamma: '\\u03DD',\n            disin: '\\u22F2',\n            div: '\\u00F7',\n            divide: '\\u00F7',\n            divideontimes: '\\u22C7',\n            divonx: '\\u22C7',\n            DJcy: '\\u0402',\n            djcy: '\\u0452',\n            dlcorn: '\\u231E',\n            dlcrop: '\\u230D',\n            dollar: '\\u0024',\n            Dopf: '\\uD835\\uDD3B',\n            dopf: '\\uD835\\uDD55',\n            Dot: '\\u00A8',\n            dot: '\\u02D9',\n            DotDot: '\\u20DC',\n            doteq: '\\u2250',\n            doteqdot: '\\u2251',\n            DotEqual: '\\u2250',\n            dotminus: '\\u2238',\n            dotplus: '\\u2214',\n            dotsquare: '\\u22A1',\n            doublebarwedge: '\\u2306',\n            DoubleContourIntegral: '\\u222F',\n            DoubleDot: '\\u00A8',\n            DoubleDownArrow: '\\u21D3',\n            DoubleLeftArrow: '\\u21D0',\n            DoubleLeftRightArrow: '\\u21D4',\n            DoubleLeftTee: '\\u2AE4',\n            DoubleLongLeftArrow: '\\u27F8',\n            DoubleLongLeftRightArrow: '\\u27FA',\n            DoubleLongRightArrow: '\\u27F9',\n            DoubleRightArrow: '\\u21D2',\n            DoubleRightTee: '\\u22A8',\n            DoubleUpArrow: '\\u21D1',\n            DoubleUpDownArrow: '\\u21D5',\n            DoubleVerticalBar: '\\u2225',\n            DownArrow: '\\u2193',\n            Downarrow: '\\u21D3',\n            downarrow: '\\u2193',\n            DownArrowBar: '\\u2913',\n            DownArrowUpArrow: '\\u21F5',\n            DownBreve: '\\u0311',\n            downdownarrows: '\\u21CA',\n            downharpoonleft: '\\u21C3',\n            downharpoonright: '\\u21C2',\n            DownLeftRightVector: '\\u2950',\n            DownLeftTeeVector: '\\u295E',\n            DownLeftVector: '\\u21BD',\n            DownLeftVectorBar: '\\u2956',\n            DownRightTeeVector: '\\u295F',\n            DownRightVector: '\\u21C1',\n            DownRightVectorBar: '\\u2957',\n            DownTee: '\\u22A4',\n            DownTeeArrow: '\\u21A7',\n            drbkarow: '\\u2910',\n            drcorn: '\\u231F',\n            drcrop: '\\u230C',\n            Dscr: '\\uD835\\uDC9F',\n            dscr: '\\uD835\\uDCB9',\n            DScy: '\\u0405',\n            dscy: '\\u0455',\n            dsol: '\\u29F6',\n            Dstrok: '\\u0110',\n            dstrok: '\\u0111',\n            dtdot: '\\u22F1',\n            dtri: '\\u25BF',\n            dtrif: '\\u25BE',\n            duarr: '\\u21F5',\n            duhar: '\\u296F',\n            dwangle: '\\u29A6',\n            DZcy: '\\u040F',\n            dzcy: '\\u045F',\n            dzigrarr: '\\u27FF',\n            Eacute: '\\u00C9',\n            eacute: '\\u00E9',\n            easter: '\\u2A6E',\n            Ecaron: '\\u011A',\n            ecaron: '\\u011B',\n            ecir: '\\u2256',\n            Ecirc: '\\u00CA',\n            ecirc: '\\u00EA',\n            ecolon: '\\u2255',\n            Ecy: '\\u042D',\n            ecy: '\\u044D',\n            eDDot: '\\u2A77',\n            Edot: '\\u0116',\n            eDot: '\\u2251',\n            edot: '\\u0117',\n            ee: '\\u2147',\n            efDot: '\\u2252',\n            Efr: '\\uD835\\uDD08',\n            efr: '\\uD835\\uDD22',\n            eg: '\\u2A9A',\n            Egrave: '\\u00C8',\n            egrave: '\\u00E8',\n            egs: '\\u2A96',\n            egsdot: '\\u2A98',\n            el: '\\u2A99',\n            Element: '\\u2208',\n            elinters: '\\u23E7',\n            ell: '\\u2113',\n            els: '\\u2A95',\n            elsdot: '\\u2A97',\n            Emacr: '\\u0112',\n            emacr: '\\u0113',\n            empty: '\\u2205',\n            emptyset: '\\u2205',\n            EmptySmallSquare: '\\u25FB',\n            emptyv: '\\u2205',\n            EmptyVerySmallSquare: '\\u25AB',\n            emsp: '\\u2003',\n            emsp13: '\\u2004',\n            emsp14: '\\u2005',\n            ENG: '\\u014A',\n            eng: '\\u014B',\n            ensp: '\\u2002',\n            Eogon: '\\u0118',\n            eogon: '\\u0119',\n            Eopf: '\\uD835\\uDD3C',\n            eopf: '\\uD835\\uDD56',\n            epar: '\\u22D5',\n            eparsl: '\\u29E3',\n            eplus: '\\u2A71',\n            epsi: '\\u03B5',\n            Epsilon: '\\u0395',\n            epsilon: '\\u03B5',\n            epsiv: '\\u03F5',\n            eqcirc: '\\u2256',\n            eqcolon: '\\u2255',\n            eqsim: '\\u2242',\n            eqslantgtr: '\\u2A96',\n            eqslantless: '\\u2A95',\n            Equal: '\\u2A75',\n            equals: '\\u003D',\n            EqualTilde: '\\u2242',\n            equest: '\\u225F',\n            Equilibrium: '\\u21CC',\n            equiv: '\\u2261',\n            equivDD: '\\u2A78',\n            eqvparsl: '\\u29E5',\n            erarr: '\\u2971',\n            erDot: '\\u2253',\n            Escr: '\\u2130',\n            escr: '\\u212F',\n            esdot: '\\u2250',\n            Esim: '\\u2A73',\n            esim: '\\u2242',\n            Eta: '\\u0397',\n            eta: '\\u03B7',\n            ETH: '\\u00D0',\n            eth: '\\u00F0',\n            Euml: '\\u00CB',\n            euml: '\\u00EB',\n            euro: '\\u20AC',\n            excl: '\\u0021',\n            exist: '\\u2203',\n            Exists: '\\u2203',\n            expectation: '\\u2130',\n            ExponentialE: '\\u2147',\n            exponentiale: '\\u2147',\n            fallingdotseq: '\\u2252',\n            Fcy: '\\u0424',\n            fcy: '\\u0444',\n            female: '\\u2640',\n            ffilig: '\\uFB03',\n            fflig: '\\uFB00',\n            ffllig: '\\uFB04',\n            Ffr: '\\uD835\\uDD09',\n            ffr: '\\uD835\\uDD23',\n            filig: '\\uFB01',\n            FilledSmallSquare: '\\u25FC',\n            FilledVerySmallSquare: '\\u25AA',\n            fjlig: '\\u0066\\u006A',\n            flat: '\\u266D',\n            fllig: '\\uFB02',\n            fltns: '\\u25B1',\n            fnof: '\\u0192',\n            Fopf: '\\uD835\\uDD3D',\n            fopf: '\\uD835\\uDD57',\n            ForAll: '\\u2200',\n            forall: '\\u2200',\n            fork: '\\u22D4',\n            forkv: '\\u2AD9',\n            Fouriertrf: '\\u2131',\n            fpartint: '\\u2A0D',\n            frac12: '\\u00BD',\n            frac13: '\\u2153',\n            frac14: '\\u00BC',\n            frac15: '\\u2155',\n            frac16: '\\u2159',\n            frac18: '\\u215B',\n            frac23: '\\u2154',\n            frac25: '\\u2156',\n            frac34: '\\u00BE',\n            frac35: '\\u2157',\n            frac38: '\\u215C',\n            frac45: '\\u2158',\n            frac56: '\\u215A',\n            frac58: '\\u215D',\n            frac78: '\\u215E',\n            frasl: '\\u2044',\n            frown: '\\u2322',\n            Fscr: '\\u2131',\n            fscr: '\\uD835\\uDCBB',\n            gacute: '\\u01F5',\n            Gamma: '\\u0393',\n            gamma: '\\u03B3',\n            Gammad: '\\u03DC',\n            gammad: '\\u03DD',\n            gap: '\\u2A86',\n            Gbreve: '\\u011E',\n            gbreve: '\\u011F',\n            Gcedil: '\\u0122',\n            Gcirc: '\\u011C',\n            gcirc: '\\u011D',\n            Gcy: '\\u0413',\n            gcy: '\\u0433',\n            Gdot: '\\u0120',\n            gdot: '\\u0121',\n            gE: '\\u2267',\n            ge: '\\u2265',\n            gEl: '\\u2A8C',\n            gel: '\\u22DB',\n            geq: '\\u2265',\n            geqq: '\\u2267',\n            geqslant: '\\u2A7E',\n            ges: '\\u2A7E',\n            gescc: '\\u2AA9',\n            gesdot: '\\u2A80',\n            gesdoto: '\\u2A82',\n            gesdotol: '\\u2A84',\n            gesl: '\\u22DB\\uFE00',\n            gesles: '\\u2A94',\n            Gfr: '\\uD835\\uDD0A',\n            gfr: '\\uD835\\uDD24',\n            Gg: '\\u22D9',\n            gg: '\\u226B',\n            ggg: '\\u22D9',\n            gimel: '\\u2137',\n            GJcy: '\\u0403',\n            gjcy: '\\u0453',\n            gl: '\\u2277',\n            gla: '\\u2AA5',\n            glE: '\\u2A92',\n            glj: '\\u2AA4',\n            gnap: '\\u2A8A',\n            gnapprox: '\\u2A8A',\n            gnE: '\\u2269',\n            gne: '\\u2A88',\n            gneq: '\\u2A88',\n            gneqq: '\\u2269',\n            gnsim: '\\u22E7',\n            Gopf: '\\uD835\\uDD3E',\n            gopf: '\\uD835\\uDD58',\n            grave: '\\u0060',\n            GreaterEqual: '\\u2265',\n            GreaterEqualLess: '\\u22DB',\n            GreaterFullEqual: '\\u2267',\n            GreaterGreater: '\\u2AA2',\n            GreaterLess: '\\u2277',\n            GreaterSlantEqual: '\\u2A7E',\n            GreaterTilde: '\\u2273',\n            Gscr: '\\uD835\\uDCA2',\n            gscr: '\\u210A',\n            gsim: '\\u2273',\n            gsime: '\\u2A8E',\n            gsiml: '\\u2A90',\n            Gt: '\\u226B',\n            GT: '\\u003E',\n            gt: '\\u003E',\n            gtcc: '\\u2AA7',\n            gtcir: '\\u2A7A',\n            gtdot: '\\u22D7',\n            gtlPar: '\\u2995',\n            gtquest: '\\u2A7C',\n            gtrapprox: '\\u2A86',\n            gtrarr: '\\u2978',\n            gtrdot: '\\u22D7',\n            gtreqless: '\\u22DB',\n            gtreqqless: '\\u2A8C',\n            gtrless: '\\u2277',\n            gtrsim: '\\u2273',\n            gvertneqq: '\\u2269\\uFE00',\n            gvnE: '\\u2269\\uFE00',\n            Hacek: '\\u02C7',\n            hairsp: '\\u200A',\n            half: '\\u00BD',\n            hamilt: '\\u210B',\n            HARDcy: '\\u042A',\n            hardcy: '\\u044A',\n            hArr: '\\u21D4',\n            harr: '\\u2194',\n            harrcir: '\\u2948',\n            harrw: '\\u21AD',\n            Hat: '\\u005E',\n            hbar: '\\u210F',\n            Hcirc: '\\u0124',\n            hcirc: '\\u0125',\n            hearts: '\\u2665',\n            heartsuit: '\\u2665',\n            hellip: '\\u2026',\n            hercon: '\\u22B9',\n            Hfr: '\\u210C',\n            hfr: '\\uD835\\uDD25',\n            HilbertSpace: '\\u210B',\n            hksearow: '\\u2925',\n            hkswarow: '\\u2926',\n            hoarr: '\\u21FF',\n            homtht: '\\u223B',\n            hookleftarrow: '\\u21A9',\n            hookrightarrow: '\\u21AA',\n            Hopf: '\\u210D',\n            hopf: '\\uD835\\uDD59',\n            horbar: '\\u2015',\n            HorizontalLine: '\\u2500',\n            Hscr: '\\u210B',\n            hscr: '\\uD835\\uDCBD',\n            hslash: '\\u210F',\n            Hstrok: '\\u0126',\n            hstrok: '\\u0127',\n            HumpDownHump: '\\u224E',\n            HumpEqual: '\\u224F',\n            hybull: '\\u2043',\n            hyphen: '\\u2010',\n            Iacute: '\\u00CD',\n            iacute: '\\u00ED',\n            ic: '\\u2063',\n            Icirc: '\\u00CE',\n            icirc: '\\u00EE',\n            Icy: '\\u0418',\n            icy: '\\u0438',\n            Idot: '\\u0130',\n            IEcy: '\\u0415',\n            iecy: '\\u0435',\n            iexcl: '\\u00A1',\n            iff: '\\u21D4',\n            Ifr: '\\u2111',\n            ifr: '\\uD835\\uDD26',\n            Igrave: '\\u00CC',\n            igrave: '\\u00EC',\n            ii: '\\u2148',\n            iiiint: '\\u2A0C',\n            iiint: '\\u222D',\n            iinfin: '\\u29DC',\n            iiota: '\\u2129',\n            IJlig: '\\u0132',\n            ijlig: '\\u0133',\n            Im: '\\u2111',\n            Imacr: '\\u012A',\n            imacr: '\\u012B',\n            image: '\\u2111',\n            ImaginaryI: '\\u2148',\n            imagline: '\\u2110',\n            imagpart: '\\u2111',\n            imath: '\\u0131',\n            imof: '\\u22B7',\n            imped: '\\u01B5',\n            Implies: '\\u21D2',\n            in: '\\u2208',\n            incare: '\\u2105',\n            infin: '\\u221E',\n            infintie: '\\u29DD',\n            inodot: '\\u0131',\n            Int: '\\u222C',\n            int: '\\u222B',\n            intcal: '\\u22BA',\n            integers: '\\u2124',\n            Integral: '\\u222B',\n            intercal: '\\u22BA',\n            Intersection: '\\u22C2',\n            intlarhk: '\\u2A17',\n            intprod: '\\u2A3C',\n            InvisibleComma: '\\u2063',\n            InvisibleTimes: '\\u2062',\n            IOcy: '\\u0401',\n            iocy: '\\u0451',\n            Iogon: '\\u012E',\n            iogon: '\\u012F',\n            Iopf: '\\uD835\\uDD40',\n            iopf: '\\uD835\\uDD5A',\n            Iota: '\\u0399',\n            iota: '\\u03B9',\n            iprod: '\\u2A3C',\n            iquest: '\\u00BF',\n            Iscr: '\\u2110',\n            iscr: '\\uD835\\uDCBE',\n            isin: '\\u2208',\n            isindot: '\\u22F5',\n            isinE: '\\u22F9',\n            isins: '\\u22F4',\n            isinsv: '\\u22F3',\n            isinv: '\\u2208',\n            it: '\\u2062',\n            Itilde: '\\u0128',\n            itilde: '\\u0129',\n            Iukcy: '\\u0406',\n            iukcy: '\\u0456',\n            Iuml: '\\u00CF',\n            iuml: '\\u00EF',\n            Jcirc: '\\u0134',\n            jcirc: '\\u0135',\n            Jcy: '\\u0419',\n            jcy: '\\u0439',\n            Jfr: '\\uD835\\uDD0D',\n            jfr: '\\uD835\\uDD27',\n            jmath: '\\u0237',\n            Jopf: '\\uD835\\uDD41',\n            jopf: '\\uD835\\uDD5B',\n            Jscr: '\\uD835\\uDCA5',\n            jscr: '\\uD835\\uDCBF',\n            Jsercy: '\\u0408',\n            jsercy: '\\u0458',\n            Jukcy: '\\u0404',\n            jukcy: '\\u0454',\n            Kappa: '\\u039A',\n            kappa: '\\u03BA',\n            kappav: '\\u03F0',\n            Kcedil: '\\u0136',\n            kcedil: '\\u0137',\n            Kcy: '\\u041A',\n            kcy: '\\u043A',\n            Kfr: '\\uD835\\uDD0E',\n            kfr: '\\uD835\\uDD28',\n            kgreen: '\\u0138',\n            KHcy: '\\u0425',\n            khcy: '\\u0445',\n            KJcy: '\\u040C',\n            kjcy: '\\u045C',\n            Kopf: '\\uD835\\uDD42',\n            kopf: '\\uD835\\uDD5C',\n            Kscr: '\\uD835\\uDCA6',\n            kscr: '\\uD835\\uDCC0',\n            lAarr: '\\u21DA',\n            Lacute: '\\u0139',\n            lacute: '\\u013A',\n            laemptyv: '\\u29B4',\n            lagran: '\\u2112',\n            Lambda: '\\u039B',\n            lambda: '\\u03BB',\n            Lang: '\\u27EA',\n            lang: '\\u27E8',\n            langd: '\\u2991',\n            langle: '\\u27E8',\n            lap: '\\u2A85',\n            Laplacetrf: '\\u2112',\n            laquo: '\\u00AB',\n            Larr: '\\u219E',\n            lArr: '\\u21D0',\n            larr: '\\u2190',\n            larrb: '\\u21E4',\n            larrbfs: '\\u291F',\n            larrfs: '\\u291D',\n            larrhk: '\\u21A9',\n            larrlp: '\\u21AB',\n            larrpl: '\\u2939',\n            larrsim: '\\u2973',\n            larrtl: '\\u21A2',\n            lat: '\\u2AAB',\n            lAtail: '\\u291B',\n            latail: '\\u2919',\n            late: '\\u2AAD',\n            lates: '\\u2AAD\\uFE00',\n            lBarr: '\\u290E',\n            lbarr: '\\u290C',\n            lbbrk: '\\u2772',\n            lbrace: '\\u007B',\n            lbrack: '\\u005B',\n            lbrke: '\\u298B',\n            lbrksld: '\\u298F',\n            lbrkslu: '\\u298D',\n            Lcaron: '\\u013D',\n            lcaron: '\\u013E',\n            Lcedil: '\\u013B',\n            lcedil: '\\u013C',\n            lceil: '\\u2308',\n            lcub: '\\u007B',\n            Lcy: '\\u041B',\n            lcy: '\\u043B',\n            ldca: '\\u2936',\n            ldquo: '\\u201C',\n            ldquor: '\\u201E',\n            ldrdhar: '\\u2967',\n            ldrushar: '\\u294B',\n            ldsh: '\\u21B2',\n            lE: '\\u2266',\n            le: '\\u2264',\n            LeftAngleBracket: '\\u27E8',\n            LeftArrow: '\\u2190',\n            Leftarrow: '\\u21D0',\n            leftarrow: '\\u2190',\n            LeftArrowBar: '\\u21E4',\n            LeftArrowRightArrow: '\\u21C6',\n            leftarrowtail: '\\u21A2',\n            LeftCeiling: '\\u2308',\n            LeftDoubleBracket: '\\u27E6',\n            LeftDownTeeVector: '\\u2961',\n            LeftDownVector: '\\u21C3',\n            LeftDownVectorBar: '\\u2959',\n            LeftFloor: '\\u230A',\n            leftharpoondown: '\\u21BD',\n            leftharpoonup: '\\u21BC',\n            leftleftarrows: '\\u21C7',\n            LeftRightArrow: '\\u2194',\n            Leftrightarrow: '\\u21D4',\n            leftrightarrow: '\\u2194',\n            leftrightarrows: '\\u21C6',\n            leftrightharpoons: '\\u21CB',\n            leftrightsquigarrow: '\\u21AD',\n            LeftRightVector: '\\u294E',\n            LeftTee: '\\u22A3',\n            LeftTeeArrow: '\\u21A4',\n            LeftTeeVector: '\\u295A',\n            leftthreetimes: '\\u22CB',\n            LeftTriangle: '\\u22B2',\n            LeftTriangleBar: '\\u29CF',\n            LeftTriangleEqual: '\\u22B4',\n            LeftUpDownVector: '\\u2951',\n            LeftUpTeeVector: '\\u2960',\n            LeftUpVector: '\\u21BF',\n            LeftUpVectorBar: '\\u2958',\n            LeftVector: '\\u21BC',\n            LeftVectorBar: '\\u2952',\n            lEg: '\\u2A8B',\n            leg: '\\u22DA',\n            leq: '\\u2264',\n            leqq: '\\u2266',\n            leqslant: '\\u2A7D',\n            les: '\\u2A7D',\n            lescc: '\\u2AA8',\n            lesdot: '\\u2A7F',\n            lesdoto: '\\u2A81',\n            lesdotor: '\\u2A83',\n            lesg: '\\u22DA\\uFE00',\n            lesges: '\\u2A93',\n            lessapprox: '\\u2A85',\n            lessdot: '\\u22D6',\n            lesseqgtr: '\\u22DA',\n            lesseqqgtr: '\\u2A8B',\n            LessEqualGreater: '\\u22DA',\n            LessFullEqual: '\\u2266',\n            LessGreater: '\\u2276',\n            lessgtr: '\\u2276',\n            LessLess: '\\u2AA1',\n            lesssim: '\\u2272',\n            LessSlantEqual: '\\u2A7D',\n            LessTilde: '\\u2272',\n            lfisht: '\\u297C',\n            lfloor: '\\u230A',\n            Lfr: '\\uD835\\uDD0F',\n            lfr: '\\uD835\\uDD29',\n            lg: '\\u2276',\n            lgE: '\\u2A91',\n            lHar: '\\u2962',\n            lhard: '\\u21BD',\n            lharu: '\\u21BC',\n            lharul: '\\u296A',\n            lhblk: '\\u2584',\n            LJcy: '\\u0409',\n            ljcy: '\\u0459',\n            Ll: '\\u22D8',\n            ll: '\\u226A',\n            llarr: '\\u21C7',\n            llcorner: '\\u231E',\n            Lleftarrow: '\\u21DA',\n            llhard: '\\u296B',\n            lltri: '\\u25FA',\n            Lmidot: '\\u013F',\n            lmidot: '\\u0140',\n            lmoust: '\\u23B0',\n            lmoustache: '\\u23B0',\n            lnap: '\\u2A89',\n            lnapprox: '\\u2A89',\n            lnE: '\\u2268',\n            lne: '\\u2A87',\n            lneq: '\\u2A87',\n            lneqq: '\\u2268',\n            lnsim: '\\u22E6',\n            loang: '\\u27EC',\n            loarr: '\\u21FD',\n            lobrk: '\\u27E6',\n            LongLeftArrow: '\\u27F5',\n            Longleftarrow: '\\u27F8',\n            longleftarrow: '\\u27F5',\n            LongLeftRightArrow: '\\u27F7',\n            Longleftrightarrow: '\\u27FA',\n            longleftrightarrow: '\\u27F7',\n            longmapsto: '\\u27FC',\n            LongRightArrow: '\\u27F6',\n            Longrightarrow: '\\u27F9',\n            longrightarrow: '\\u27F6',\n            looparrowleft: '\\u21AB',\n            looparrowright: '\\u21AC',\n            lopar: '\\u2985',\n            Lopf: '\\uD835\\uDD43',\n            lopf: '\\uD835\\uDD5D',\n            loplus: '\\u2A2D',\n            lotimes: '\\u2A34',\n            lowast: '\\u2217',\n            lowbar: '\\u005F',\n            LowerLeftArrow: '\\u2199',\n            LowerRightArrow: '\\u2198',\n            loz: '\\u25CA',\n            lozenge: '\\u25CA',\n            lozf: '\\u29EB',\n            lpar: '\\u0028',\n            lparlt: '\\u2993',\n            lrarr: '\\u21C6',\n            lrcorner: '\\u231F',\n            lrhar: '\\u21CB',\n            lrhard: '\\u296D',\n            lrm: '\\u200E',\n            lrtri: '\\u22BF',\n            lsaquo: '\\u2039',\n            Lscr: '\\u2112',\n            lscr: '\\uD835\\uDCC1',\n            Lsh: '\\u21B0',\n            lsh: '\\u21B0',\n            lsim: '\\u2272',\n            lsime: '\\u2A8D',\n            lsimg: '\\u2A8F',\n            lsqb: '\\u005B',\n            lsquo: '\\u2018',\n            lsquor: '\\u201A',\n            Lstrok: '\\u0141',\n            lstrok: '\\u0142',\n            Lt: '\\u226A',\n            LT: '\\u003C',\n            lt: '\\u003C',\n            ltcc: '\\u2AA6',\n            ltcir: '\\u2A79',\n            ltdot: '\\u22D6',\n            lthree: '\\u22CB',\n            ltimes: '\\u22C9',\n            ltlarr: '\\u2976',\n            ltquest: '\\u2A7B',\n            ltri: '\\u25C3',\n            ltrie: '\\u22B4',\n            ltrif: '\\u25C2',\n            ltrPar: '\\u2996',\n            lurdshar: '\\u294A',\n            luruhar: '\\u2966',\n            lvertneqq: '\\u2268\\uFE00',\n            lvnE: '\\u2268\\uFE00',\n            macr: '\\u00AF',\n            male: '\\u2642',\n            malt: '\\u2720',\n            maltese: '\\u2720',\n            Map: '\\u2905',\n            map: '\\u21A6',\n            mapsto: '\\u21A6',\n            mapstodown: '\\u21A7',\n            mapstoleft: '\\u21A4',\n            mapstoup: '\\u21A5',\n            marker: '\\u25AE',\n            mcomma: '\\u2A29',\n            Mcy: '\\u041C',\n            mcy: '\\u043C',\n            mdash: '\\u2014',\n            mDDot: '\\u223A',\n            measuredangle: '\\u2221',\n            MediumSpace: '\\u205F',\n            Mellintrf: '\\u2133',\n            Mfr: '\\uD835\\uDD10',\n            mfr: '\\uD835\\uDD2A',\n            mho: '\\u2127',\n            micro: '\\u00B5',\n            mid: '\\u2223',\n            midast: '\\u002A',\n            midcir: '\\u2AF0',\n            middot: '\\u00B7',\n            minus: '\\u2212',\n            minusb: '\\u229F',\n            minusd: '\\u2238',\n            minusdu: '\\u2A2A',\n            MinusPlus: '\\u2213',\n            mlcp: '\\u2ADB',\n            mldr: '\\u2026',\n            mnplus: '\\u2213',\n            models: '\\u22A7',\n            Mopf: '\\uD835\\uDD44',\n            mopf: '\\uD835\\uDD5E',\n            mp: '\\u2213',\n            Mscr: '\\u2133',\n            mscr: '\\uD835\\uDCC2',\n            mstpos: '\\u223E',\n            Mu: '\\u039C',\n            mu: '\\u03BC',\n            multimap: '\\u22B8',\n            mumap: '\\u22B8',\n            nabla: '\\u2207',\n            Nacute: '\\u0143',\n            nacute: '\\u0144',\n            nang: '\\u2220\\u20D2',\n            nap: '\\u2249',\n            napE: '\\u2A70\\u0338',\n            napid: '\\u224B\\u0338',\n            napos: '\\u0149',\n            napprox: '\\u2249',\n            natur: '\\u266E',\n            natural: '\\u266E',\n            naturals: '\\u2115',\n            nbsp: '\\u00A0',\n            nbump: '\\u224E\\u0338',\n            nbumpe: '\\u224F\\u0338',\n            ncap: '\\u2A43',\n            Ncaron: '\\u0147',\n            ncaron: '\\u0148',\n            Ncedil: '\\u0145',\n            ncedil: '\\u0146',\n            ncong: '\\u2247',\n            ncongdot: '\\u2A6D\\u0338',\n            ncup: '\\u2A42',\n            Ncy: '\\u041D',\n            ncy: '\\u043D',\n            ndash: '\\u2013',\n            ne: '\\u2260',\n            nearhk: '\\u2924',\n            neArr: '\\u21D7',\n            nearr: '\\u2197',\n            nearrow: '\\u2197',\n            nedot: '\\u2250\\u0338',\n            NegativeMediumSpace: '\\u200B',\n            NegativeThickSpace: '\\u200B',\n            NegativeThinSpace: '\\u200B',\n            NegativeVeryThinSpace: '\\u200B',\n            nequiv: '\\u2262',\n            nesear: '\\u2928',\n            nesim: '\\u2242\\u0338',\n            NestedGreaterGreater: '\\u226B',\n            NestedLessLess: '\\u226A',\n            NewLine: '\\u000A',\n            nexist: '\\u2204',\n            nexists: '\\u2204',\n            Nfr: '\\uD835\\uDD11',\n            nfr: '\\uD835\\uDD2B',\n            ngE: '\\u2267\\u0338',\n            nge: '\\u2271',\n            ngeq: '\\u2271',\n            ngeqq: '\\u2267\\u0338',\n            ngeqslant: '\\u2A7E\\u0338',\n            nges: '\\u2A7E\\u0338',\n            nGg: '\\u22D9\\u0338',\n            ngsim: '\\u2275',\n            nGt: '\\u226B\\u20D2',\n            ngt: '\\u226F',\n            ngtr: '\\u226F',\n            nGtv: '\\u226B\\u0338',\n            nhArr: '\\u21CE',\n            nharr: '\\u21AE',\n            nhpar: '\\u2AF2',\n            ni: '\\u220B',\n            nis: '\\u22FC',\n            nisd: '\\u22FA',\n            niv: '\\u220B',\n            NJcy: '\\u040A',\n            njcy: '\\u045A',\n            nlArr: '\\u21CD',\n            nlarr: '\\u219A',\n            nldr: '\\u2025',\n            nlE: '\\u2266\\u0338',\n            nle: '\\u2270',\n            nLeftarrow: '\\u21CD',\n            nleftarrow: '\\u219A',\n            nLeftrightarrow: '\\u21CE',\n            nleftrightarrow: '\\u21AE',\n            nleq: '\\u2270',\n            nleqq: '\\u2266\\u0338',\n            nleqslant: '\\u2A7D\\u0338',\n            nles: '\\u2A7D\\u0338',\n            nless: '\\u226E',\n            nLl: '\\u22D8\\u0338',\n            nlsim: '\\u2274',\n            nLt: '\\u226A\\u20D2',\n            nlt: '\\u226E',\n            nltri: '\\u22EA',\n            nltrie: '\\u22EC',\n            nLtv: '\\u226A\\u0338',\n            nmid: '\\u2224',\n            NoBreak: '\\u2060',\n            NonBreakingSpace: '\\u00A0',\n            Nopf: '\\u2115',\n            nopf: '\\uD835\\uDD5F',\n            Not: '\\u2AEC',\n            not: '\\u00AC',\n            NotCongruent: '\\u2262',\n            NotCupCap: '\\u226D',\n            NotDoubleVerticalBar: '\\u2226',\n            NotElement: '\\u2209',\n            NotEqual: '\\u2260',\n            NotEqualTilde: '\\u2242\\u0338',\n            NotExists: '\\u2204',\n            NotGreater: '\\u226F',\n            NotGreaterEqual: '\\u2271',\n            NotGreaterFullEqual: '\\u2267\\u0338',\n            NotGreaterGreater: '\\u226B\\u0338',\n            NotGreaterLess: '\\u2279',\n            NotGreaterSlantEqual: '\\u2A7E\\u0338',\n            NotGreaterTilde: '\\u2275',\n            NotHumpDownHump: '\\u224E\\u0338',\n            NotHumpEqual: '\\u224F\\u0338',\n            notin: '\\u2209',\n            notindot: '\\u22F5\\u0338',\n            notinE: '\\u22F9\\u0338',\n            notinva: '\\u2209',\n            notinvb: '\\u22F7',\n            notinvc: '\\u22F6',\n            NotLeftTriangle: '\\u22EA',\n            NotLeftTriangleBar: '\\u29CF\\u0338',\n            NotLeftTriangleEqual: '\\u22EC',\n            NotLess: '\\u226E',\n            NotLessEqual: '\\u2270',\n            NotLessGreater: '\\u2278',\n            NotLessLess: '\\u226A\\u0338',\n            NotLessSlantEqual: '\\u2A7D\\u0338',\n            NotLessTilde: '\\u2274',\n            NotNestedGreaterGreater: '\\u2AA2\\u0338',\n            NotNestedLessLess: '\\u2AA1\\u0338',\n            notni: '\\u220C',\n            notniva: '\\u220C',\n            notnivb: '\\u22FE',\n            notnivc: '\\u22FD',\n            NotPrecedes: '\\u2280',\n            NotPrecedesEqual: '\\u2AAF\\u0338',\n            NotPrecedesSlantEqual: '\\u22E0',\n            NotReverseElement: '\\u220C',\n            NotRightTriangle: '\\u22EB',\n            NotRightTriangleBar: '\\u29D0\\u0338',\n            NotRightTriangleEqual: '\\u22ED',\n            NotSquareSubset: '\\u228F\\u0338',\n            NotSquareSubsetEqual: '\\u22E2',\n            NotSquareSuperset: '\\u2290\\u0338',\n            NotSquareSupersetEqual: '\\u22E3',\n            NotSubset: '\\u2282\\u20D2',\n            NotSubsetEqual: '\\u2288',\n            NotSucceeds: '\\u2281',\n            NotSucceedsEqual: '\\u2AB0\\u0338',\n            NotSucceedsSlantEqual: '\\u22E1',\n            NotSucceedsTilde: '\\u227F\\u0338',\n            NotSuperset: '\\u2283\\u20D2',\n            NotSupersetEqual: '\\u2289',\n            NotTilde: '\\u2241',\n            NotTildeEqual: '\\u2244',\n            NotTildeFullEqual: '\\u2247',\n            NotTildeTilde: '\\u2249',\n            NotVerticalBar: '\\u2224',\n            npar: '\\u2226',\n            nparallel: '\\u2226',\n            nparsl: '\\u2AFD\\u20E5',\n            npart: '\\u2202\\u0338',\n            npolint: '\\u2A14',\n            npr: '\\u2280',\n            nprcue: '\\u22E0',\n            npre: '\\u2AAF\\u0338',\n            nprec: '\\u2280',\n            npreceq: '\\u2AAF\\u0338',\n            nrArr: '\\u21CF',\n            nrarr: '\\u219B',\n            nrarrc: '\\u2933\\u0338',\n            nrarrw: '\\u219D\\u0338',\n            nRightarrow: '\\u21CF',\n            nrightarrow: '\\u219B',\n            nrtri: '\\u22EB',\n            nrtrie: '\\u22ED',\n            nsc: '\\u2281',\n            nsccue: '\\u22E1',\n            nsce: '\\u2AB0\\u0338',\n            Nscr: '\\uD835\\uDCA9',\n            nscr: '\\uD835\\uDCC3',\n            nshortmid: '\\u2224',\n            nshortparallel: '\\u2226',\n            nsim: '\\u2241',\n            nsime: '\\u2244',\n            nsimeq: '\\u2244',\n            nsmid: '\\u2224',\n            nspar: '\\u2226',\n            nsqsube: '\\u22E2',\n            nsqsupe: '\\u22E3',\n            nsub: '\\u2284',\n            nsubE: '\\u2AC5\\u0338',\n            nsube: '\\u2288',\n            nsubset: '\\u2282\\u20D2',\n            nsubseteq: '\\u2288',\n            nsubseteqq: '\\u2AC5\\u0338',\n            nsucc: '\\u2281',\n            nsucceq: '\\u2AB0\\u0338',\n            nsup: '\\u2285',\n            nsupE: '\\u2AC6\\u0338',\n            nsupe: '\\u2289',\n            nsupset: '\\u2283\\u20D2',\n            nsupseteq: '\\u2289',\n            nsupseteqq: '\\u2AC6\\u0338',\n            ntgl: '\\u2279',\n            Ntilde: '\\u00D1',\n            ntilde: '\\u00F1',\n            ntlg: '\\u2278',\n            ntriangleleft: '\\u22EA',\n            ntrianglelefteq: '\\u22EC',\n            ntriangleright: '\\u22EB',\n            ntrianglerighteq: '\\u22ED',\n            Nu: '\\u039D',\n            nu: '\\u03BD',\n            num: '\\u0023',\n            numero: '\\u2116',\n            numsp: '\\u2007',\n            nvap: '\\u224D\\u20D2',\n            nVDash: '\\u22AF',\n            nVdash: '\\u22AE',\n            nvDash: '\\u22AD',\n            nvdash: '\\u22AC',\n            nvge: '\\u2265\\u20D2',\n            nvgt: '\\u003E\\u20D2',\n            nvHarr: '\\u2904',\n            nvinfin: '\\u29DE',\n            nvlArr: '\\u2902',\n            nvle: '\\u2264\\u20D2',\n            nvlt: '\\u003C\\u20D2',\n            nvltrie: '\\u22B4\\u20D2',\n            nvrArr: '\\u2903',\n            nvrtrie: '\\u22B5\\u20D2',\n            nvsim: '\\u223C\\u20D2',\n            nwarhk: '\\u2923',\n            nwArr: '\\u21D6',\n            nwarr: '\\u2196',\n            nwarrow: '\\u2196',\n            nwnear: '\\u2927',\n            Oacute: '\\u00D3',\n            oacute: '\\u00F3',\n            oast: '\\u229B',\n            ocir: '\\u229A',\n            Ocirc: '\\u00D4',\n            ocirc: '\\u00F4',\n            Ocy: '\\u041E',\n            ocy: '\\u043E',\n            odash: '\\u229D',\n            Odblac: '\\u0150',\n            odblac: '\\u0151',\n            odiv: '\\u2A38',\n            odot: '\\u2299',\n            odsold: '\\u29BC',\n            OElig: '\\u0152',\n            oelig: '\\u0153',\n            ofcir: '\\u29BF',\n            Ofr: '\\uD835\\uDD12',\n            ofr: '\\uD835\\uDD2C',\n            ogon: '\\u02DB',\n            Ograve: '\\u00D2',\n            ograve: '\\u00F2',\n            ogt: '\\u29C1',\n            ohbar: '\\u29B5',\n            ohm: '\\u03A9',\n            oint: '\\u222E',\n            olarr: '\\u21BA',\n            olcir: '\\u29BE',\n            olcross: '\\u29BB',\n            oline: '\\u203E',\n            olt: '\\u29C0',\n            Omacr: '\\u014C',\n            omacr: '\\u014D',\n            Omega: '\\u03A9',\n            omega: '\\u03C9',\n            Omicron: '\\u039F',\n            omicron: '\\u03BF',\n            omid: '\\u29B6',\n            ominus: '\\u2296',\n            Oopf: '\\uD835\\uDD46',\n            oopf: '\\uD835\\uDD60',\n            opar: '\\u29B7',\n            OpenCurlyDoubleQuote: '\\u201C',\n            OpenCurlyQuote: '\\u2018',\n            operp: '\\u29B9',\n            oplus: '\\u2295',\n            Or: '\\u2A54',\n            or: '\\u2228',\n            orarr: '\\u21BB',\n            ord: '\\u2A5D',\n            order: '\\u2134',\n            orderof: '\\u2134',\n            ordf: '\\u00AA',\n            ordm: '\\u00BA',\n            origof: '\\u22B6',\n            oror: '\\u2A56',\n            orslope: '\\u2A57',\n            orv: '\\u2A5B',\n            oS: '\\u24C8',\n            Oscr: '\\uD835\\uDCAA',\n            oscr: '\\u2134',\n            Oslash: '\\u00D8',\n            oslash: '\\u00F8',\n            osol: '\\u2298',\n            Otilde: '\\u00D5',\n            otilde: '\\u00F5',\n            Otimes: '\\u2A37',\n            otimes: '\\u2297',\n            otimesas: '\\u2A36',\n            Ouml: '\\u00D6',\n            ouml: '\\u00F6',\n            ovbar: '\\u233D',\n            OverBar: '\\u203E',\n            OverBrace: '\\u23DE',\n            OverBracket: '\\u23B4',\n            OverParenthesis: '\\u23DC',\n            par: '\\u2225',\n            para: '\\u00B6',\n            parallel: '\\u2225',\n            parsim: '\\u2AF3',\n            parsl: '\\u2AFD',\n            part: '\\u2202',\n            PartialD: '\\u2202',\n            Pcy: '\\u041F',\n            pcy: '\\u043F',\n            percnt: '\\u0025',\n            period: '\\u002E',\n            permil: '\\u2030',\n            perp: '\\u22A5',\n            pertenk: '\\u2031',\n            Pfr: '\\uD835\\uDD13',\n            pfr: '\\uD835\\uDD2D',\n            Phi: '\\u03A6',\n            phi: '\\u03C6',\n            phiv: '\\u03D5',\n            phmmat: '\\u2133',\n            phone: '\\u260E',\n            Pi: '\\u03A0',\n            pi: '\\u03C0',\n            pitchfork: '\\u22D4',\n            piv: '\\u03D6',\n            planck: '\\u210F',\n            planckh: '\\u210E',\n            plankv: '\\u210F',\n            plus: '\\u002B',\n            plusacir: '\\u2A23',\n            plusb: '\\u229E',\n            pluscir: '\\u2A22',\n            plusdo: '\\u2214',\n            plusdu: '\\u2A25',\n            pluse: '\\u2A72',\n            PlusMinus: '\\u00B1',\n            plusmn: '\\u00B1',\n            plussim: '\\u2A26',\n            plustwo: '\\u2A27',\n            pm: '\\u00B1',\n            Poincareplane: '\\u210C',\n            pointint: '\\u2A15',\n            Popf: '\\u2119',\n            popf: '\\uD835\\uDD61',\n            pound: '\\u00A3',\n            Pr: '\\u2ABB',\n            pr: '\\u227A',\n            prap: '\\u2AB7',\n            prcue: '\\u227C',\n            prE: '\\u2AB3',\n            pre: '\\u2AAF',\n            prec: '\\u227A',\n            precapprox: '\\u2AB7',\n            preccurlyeq: '\\u227C',\n            Precedes: '\\u227A',\n            PrecedesEqual: '\\u2AAF',\n            PrecedesSlantEqual: '\\u227C',\n            PrecedesTilde: '\\u227E',\n            preceq: '\\u2AAF',\n            precnapprox: '\\u2AB9',\n            precneqq: '\\u2AB5',\n            precnsim: '\\u22E8',\n            precsim: '\\u227E',\n            Prime: '\\u2033',\n            prime: '\\u2032',\n            primes: '\\u2119',\n            prnap: '\\u2AB9',\n            prnE: '\\u2AB5',\n            prnsim: '\\u22E8',\n            prod: '\\u220F',\n            Product: '\\u220F',\n            profalar: '\\u232E',\n            profline: '\\u2312',\n            profsurf: '\\u2313',\n            prop: '\\u221D',\n            Proportion: '\\u2237',\n            Proportional: '\\u221D',\n            propto: '\\u221D',\n            prsim: '\\u227E',\n            prurel: '\\u22B0',\n            Pscr: '\\uD835\\uDCAB',\n            pscr: '\\uD835\\uDCC5',\n            Psi: '\\u03A8',\n            psi: '\\u03C8',\n            puncsp: '\\u2008',\n            Qfr: '\\uD835\\uDD14',\n            qfr: '\\uD835\\uDD2E',\n            qint: '\\u2A0C',\n            Qopf: '\\u211A',\n            qopf: '\\uD835\\uDD62',\n            qprime: '\\u2057',\n            Qscr: '\\uD835\\uDCAC',\n            qscr: '\\uD835\\uDCC6',\n            quaternions: '\\u210D',\n            quatint: '\\u2A16',\n            quest: '\\u003F',\n            questeq: '\\u225F',\n            QUOT: '\\u0022',\n            quot: '\\u0022',\n            rAarr: '\\u21DB',\n            race: '\\u223D\\u0331',\n            Racute: '\\u0154',\n            racute: '\\u0155',\n            radic: '\\u221A',\n            raemptyv: '\\u29B3',\n            Rang: '\\u27EB',\n            rang: '\\u27E9',\n            rangd: '\\u2992',\n            range: '\\u29A5',\n            rangle: '\\u27E9',\n            raquo: '\\u00BB',\n            Rarr: '\\u21A0',\n            rArr: '\\u21D2',\n            rarr: '\\u2192',\n            rarrap: '\\u2975',\n            rarrb: '\\u21E5',\n            rarrbfs: '\\u2920',\n            rarrc: '\\u2933',\n            rarrfs: '\\u291E',\n            rarrhk: '\\u21AA',\n            rarrlp: '\\u21AC',\n            rarrpl: '\\u2945',\n            rarrsim: '\\u2974',\n            Rarrtl: '\\u2916',\n            rarrtl: '\\u21A3',\n            rarrw: '\\u219D',\n            rAtail: '\\u291C',\n            ratail: '\\u291A',\n            ratio: '\\u2236',\n            rationals: '\\u211A',\n            RBarr: '\\u2910',\n            rBarr: '\\u290F',\n            rbarr: '\\u290D',\n            rbbrk: '\\u2773',\n            rbrace: '\\u007D',\n            rbrack: '\\u005D',\n            rbrke: '\\u298C',\n            rbrksld: '\\u298E',\n            rbrkslu: '\\u2990',\n            Rcaron: '\\u0158',\n            rcaron: '\\u0159',\n            Rcedil: '\\u0156',\n            rcedil: '\\u0157',\n            rceil: '\\u2309',\n            rcub: '\\u007D',\n            Rcy: '\\u0420',\n            rcy: '\\u0440',\n            rdca: '\\u2937',\n            rdldhar: '\\u2969',\n            rdquo: '\\u201D',\n            rdquor: '\\u201D',\n            rdsh: '\\u21B3',\n            Re: '\\u211C',\n            real: '\\u211C',\n            realine: '\\u211B',\n            realpart: '\\u211C',\n            reals: '\\u211D',\n            rect: '\\u25AD',\n            REG: '\\u00AE',\n            reg: '\\u00AE',\n            ReverseElement: '\\u220B',\n            ReverseEquilibrium: '\\u21CB',\n            ReverseUpEquilibrium: '\\u296F',\n            rfisht: '\\u297D',\n            rfloor: '\\u230B',\n            Rfr: '\\u211C',\n            rfr: '\\uD835\\uDD2F',\n            rHar: '\\u2964',\n            rhard: '\\u21C1',\n            rharu: '\\u21C0',\n            rharul: '\\u296C',\n            Rho: '\\u03A1',\n            rho: '\\u03C1',\n            rhov: '\\u03F1',\n            RightAngleBracket: '\\u27E9',\n            RightArrow: '\\u2192',\n            Rightarrow: '\\u21D2',\n            rightarrow: '\\u2192',\n            RightArrowBar: '\\u21E5',\n            RightArrowLeftArrow: '\\u21C4',\n            rightarrowtail: '\\u21A3',\n            RightCeiling: '\\u2309',\n            RightDoubleBracket: '\\u27E7',\n            RightDownTeeVector: '\\u295D',\n            RightDownVector: '\\u21C2',\n            RightDownVectorBar: '\\u2955',\n            RightFloor: '\\u230B',\n            rightharpoondown: '\\u21C1',\n            rightharpoonup: '\\u21C0',\n            rightleftarrows: '\\u21C4',\n            rightleftharpoons: '\\u21CC',\n            rightrightarrows: '\\u21C9',\n            rightsquigarrow: '\\u219D',\n            RightTee: '\\u22A2',\n            RightTeeArrow: '\\u21A6',\n            RightTeeVector: '\\u295B',\n            rightthreetimes: '\\u22CC',\n            RightTriangle: '\\u22B3',\n            RightTriangleBar: '\\u29D0',\n            RightTriangleEqual: '\\u22B5',\n            RightUpDownVector: '\\u294F',\n            RightUpTeeVector: '\\u295C',\n            RightUpVector: '\\u21BE',\n            RightUpVectorBar: '\\u2954',\n            RightVector: '\\u21C0',\n            RightVectorBar: '\\u2953',\n            ring: '\\u02DA',\n            risingdotseq: '\\u2253',\n            rlarr: '\\u21C4',\n            rlhar: '\\u21CC',\n            rlm: '\\u200F',\n            rmoust: '\\u23B1',\n            rmoustache: '\\u23B1',\n            rnmid: '\\u2AEE',\n            roang: '\\u27ED',\n            roarr: '\\u21FE',\n            robrk: '\\u27E7',\n            ropar: '\\u2986',\n            Ropf: '\\u211D',\n            ropf: '\\uD835\\uDD63',\n            roplus: '\\u2A2E',\n            rotimes: '\\u2A35',\n            RoundImplies: '\\u2970',\n            rpar: '\\u0029',\n            rpargt: '\\u2994',\n            rppolint: '\\u2A12',\n            rrarr: '\\u21C9',\n            Rrightarrow: '\\u21DB',\n            rsaquo: '\\u203A',\n            Rscr: '\\u211B',\n            rscr: '\\uD835\\uDCC7',\n            Rsh: '\\u21B1',\n            rsh: '\\u21B1',\n            rsqb: '\\u005D',\n            rsquo: '\\u2019',\n            rsquor: '\\u2019',\n            rthree: '\\u22CC',\n            rtimes: '\\u22CA',\n            rtri: '\\u25B9',\n            rtrie: '\\u22B5',\n            rtrif: '\\u25B8',\n            rtriltri: '\\u29CE',\n            RuleDelayed: '\\u29F4',\n            ruluhar: '\\u2968',\n            rx: '\\u211E',\n            Sacute: '\\u015A',\n            sacute: '\\u015B',\n            sbquo: '\\u201A',\n            Sc: '\\u2ABC',\n            sc: '\\u227B',\n            scap: '\\u2AB8',\n            Scaron: '\\u0160',\n            scaron: '\\u0161',\n            sccue: '\\u227D',\n            scE: '\\u2AB4',\n            sce: '\\u2AB0',\n            Scedil: '\\u015E',\n            scedil: '\\u015F',\n            Scirc: '\\u015C',\n            scirc: '\\u015D',\n            scnap: '\\u2ABA',\n            scnE: '\\u2AB6',\n            scnsim: '\\u22E9',\n            scpolint: '\\u2A13',\n            scsim: '\\u227F',\n            Scy: '\\u0421',\n            scy: '\\u0441',\n            sdot: '\\u22C5',\n            sdotb: '\\u22A1',\n            sdote: '\\u2A66',\n            searhk: '\\u2925',\n            seArr: '\\u21D8',\n            searr: '\\u2198',\n            searrow: '\\u2198',\n            sect: '\\u00A7',\n            semi: '\\u003B',\n            seswar: '\\u2929',\n            setminus: '\\u2216',\n            setmn: '\\u2216',\n            sext: '\\u2736',\n            Sfr: '\\uD835\\uDD16',\n            sfr: '\\uD835\\uDD30',\n            sfrown: '\\u2322',\n            sharp: '\\u266F',\n            SHCHcy: '\\u0429',\n            shchcy: '\\u0449',\n            SHcy: '\\u0428',\n            shcy: '\\u0448',\n            ShortDownArrow: '\\u2193',\n            ShortLeftArrow: '\\u2190',\n            shortmid: '\\u2223',\n            shortparallel: '\\u2225',\n            ShortRightArrow: '\\u2192',\n            ShortUpArrow: '\\u2191',\n            shy: '\\u00AD',\n            Sigma: '\\u03A3',\n            sigma: '\\u03C3',\n            sigmaf: '\\u03C2',\n            sigmav: '\\u03C2',\n            sim: '\\u223C',\n            simdot: '\\u2A6A',\n            sime: '\\u2243',\n            simeq: '\\u2243',\n            simg: '\\u2A9E',\n            simgE: '\\u2AA0',\n            siml: '\\u2A9D',\n            simlE: '\\u2A9F',\n            simne: '\\u2246',\n            simplus: '\\u2A24',\n            simrarr: '\\u2972',\n            slarr: '\\u2190',\n            SmallCircle: '\\u2218',\n            smallsetminus: '\\u2216',\n            smashp: '\\u2A33',\n            smeparsl: '\\u29E4',\n            smid: '\\u2223',\n            smile: '\\u2323',\n            smt: '\\u2AAA',\n            smte: '\\u2AAC',\n            smtes: '\\u2AAC\\uFE00',\n            SOFTcy: '\\u042C',\n            softcy: '\\u044C',\n            sol: '\\u002F',\n            solb: '\\u29C4',\n            solbar: '\\u233F',\n            Sopf: '\\uD835\\uDD4A',\n            sopf: '\\uD835\\uDD64',\n            spades: '\\u2660',\n            spadesuit: '\\u2660',\n            spar: '\\u2225',\n            sqcap: '\\u2293',\n            sqcaps: '\\u2293\\uFE00',\n            sqcup: '\\u2294',\n            sqcups: '\\u2294\\uFE00',\n            Sqrt: '\\u221A',\n            sqsub: '\\u228F',\n            sqsube: '\\u2291',\n            sqsubset: '\\u228F',\n            sqsubseteq: '\\u2291',\n            sqsup: '\\u2290',\n            sqsupe: '\\u2292',\n            sqsupset: '\\u2290',\n            sqsupseteq: '\\u2292',\n            squ: '\\u25A1',\n            Square: '\\u25A1',\n            square: '\\u25A1',\n            SquareIntersection: '\\u2293',\n            SquareSubset: '\\u228F',\n            SquareSubsetEqual: '\\u2291',\n            SquareSuperset: '\\u2290',\n            SquareSupersetEqual: '\\u2292',\n            SquareUnion: '\\u2294',\n            squarf: '\\u25AA',\n            squf: '\\u25AA',\n            srarr: '\\u2192',\n            Sscr: '\\uD835\\uDCAE',\n            sscr: '\\uD835\\uDCC8',\n            ssetmn: '\\u2216',\n            ssmile: '\\u2323',\n            sstarf: '\\u22C6',\n            Star: '\\u22C6',\n            star: '\\u2606',\n            starf: '\\u2605',\n            straightepsilon: '\\u03F5',\n            straightphi: '\\u03D5',\n            strns: '\\u00AF',\n            Sub: '\\u22D0',\n            sub: '\\u2282',\n            subdot: '\\u2ABD',\n            subE: '\\u2AC5',\n            sube: '\\u2286',\n            subedot: '\\u2AC3',\n            submult: '\\u2AC1',\n            subnE: '\\u2ACB',\n            subne: '\\u228A',\n            subplus: '\\u2ABF',\n            subrarr: '\\u2979',\n            Subset: '\\u22D0',\n            subset: '\\u2282',\n            subseteq: '\\u2286',\n            subseteqq: '\\u2AC5',\n            SubsetEqual: '\\u2286',\n            subsetneq: '\\u228A',\n            subsetneqq: '\\u2ACB',\n            subsim: '\\u2AC7',\n            subsub: '\\u2AD5',\n            subsup: '\\u2AD3',\n            succ: '\\u227B',\n            succapprox: '\\u2AB8',\n            succcurlyeq: '\\u227D',\n            Succeeds: '\\u227B',\n            SucceedsEqual: '\\u2AB0',\n            SucceedsSlantEqual: '\\u227D',\n            SucceedsTilde: '\\u227F',\n            succeq: '\\u2AB0',\n            succnapprox: '\\u2ABA',\n            succneqq: '\\u2AB6',\n            succnsim: '\\u22E9',\n            succsim: '\\u227F',\n            SuchThat: '\\u220B',\n            Sum: '\\u2211',\n            sum: '\\u2211',\n            sung: '\\u266A',\n            Sup: '\\u22D1',\n            sup: '\\u2283',\n            sup1: '\\u00B9',\n            sup2: '\\u00B2',\n            sup3: '\\u00B3',\n            supdot: '\\u2ABE',\n            supdsub: '\\u2AD8',\n            supE: '\\u2AC6',\n            supe: '\\u2287',\n            supedot: '\\u2AC4',\n            Superset: '\\u2283',\n            SupersetEqual: '\\u2287',\n            suphsol: '\\u27C9',\n            suphsub: '\\u2AD7',\n            suplarr: '\\u297B',\n            supmult: '\\u2AC2',\n            supnE: '\\u2ACC',\n            supne: '\\u228B',\n            supplus: '\\u2AC0',\n            Supset: '\\u22D1',\n            supset: '\\u2283',\n            supseteq: '\\u2287',\n            supseteqq: '\\u2AC6',\n            supsetneq: '\\u228B',\n            supsetneqq: '\\u2ACC',\n            supsim: '\\u2AC8',\n            supsub: '\\u2AD4',\n            supsup: '\\u2AD6',\n            swarhk: '\\u2926',\n            swArr: '\\u21D9',\n            swarr: '\\u2199',\n            swarrow: '\\u2199',\n            swnwar: '\\u292A',\n            szlig: '\\u00DF',\n            Tab: '\\u0009',\n            target: '\\u2316',\n            Tau: '\\u03A4',\n            tau: '\\u03C4',\n            tbrk: '\\u23B4',\n            Tcaron: '\\u0164',\n            tcaron: '\\u0165',\n            Tcedil: '\\u0162',\n            tcedil: '\\u0163',\n            Tcy: '\\u0422',\n            tcy: '\\u0442',\n            tdot: '\\u20DB',\n            telrec: '\\u2315',\n            Tfr: '\\uD835\\uDD17',\n            tfr: '\\uD835\\uDD31',\n            there4: '\\u2234',\n            Therefore: '\\u2234',\n            therefore: '\\u2234',\n            Theta: '\\u0398',\n            theta: '\\u03B8',\n            thetasym: '\\u03D1',\n            thetav: '\\u03D1',\n            thickapprox: '\\u2248',\n            thicksim: '\\u223C',\n            ThickSpace: '\\u205F\\u200A',\n            thinsp: '\\u2009',\n            ThinSpace: '\\u2009',\n            thkap: '\\u2248',\n            thksim: '\\u223C',\n            THORN: '\\u00DE',\n            thorn: '\\u00FE',\n            Tilde: '\\u223C',\n            tilde: '\\u02DC',\n            TildeEqual: '\\u2243',\n            TildeFullEqual: '\\u2245',\n            TildeTilde: '\\u2248',\n            times: '\\u00D7',\n            timesb: '\\u22A0',\n            timesbar: '\\u2A31',\n            timesd: '\\u2A30',\n            tint: '\\u222D',\n            toea: '\\u2928',\n            top: '\\u22A4',\n            topbot: '\\u2336',\n            topcir: '\\u2AF1',\n            Topf: '\\uD835\\uDD4B',\n            topf: '\\uD835\\uDD65',\n            topfork: '\\u2ADA',\n            tosa: '\\u2929',\n            tprime: '\\u2034',\n            TRADE: '\\u2122',\n            trade: '\\u2122',\n            triangle: '\\u25B5',\n            triangledown: '\\u25BF',\n            triangleleft: '\\u25C3',\n            trianglelefteq: '\\u22B4',\n            triangleq: '\\u225C',\n            triangleright: '\\u25B9',\n            trianglerighteq: '\\u22B5',\n            tridot: '\\u25EC',\n            trie: '\\u225C',\n            triminus: '\\u2A3A',\n            TripleDot: '\\u20DB',\n            triplus: '\\u2A39',\n            trisb: '\\u29CD',\n            tritime: '\\u2A3B',\n            trpezium: '\\u23E2',\n            Tscr: '\\uD835\\uDCAF',\n            tscr: '\\uD835\\uDCC9',\n            TScy: '\\u0426',\n            tscy: '\\u0446',\n            TSHcy: '\\u040B',\n            tshcy: '\\u045B',\n            Tstrok: '\\u0166',\n            tstrok: '\\u0167',\n            twixt: '\\u226C',\n            twoheadleftarrow: '\\u219E',\n            twoheadrightarrow: '\\u21A0',\n            Uacute: '\\u00DA',\n            uacute: '\\u00FA',\n            Uarr: '\\u219F',\n            uArr: '\\u21D1',\n            uarr: '\\u2191',\n            Uarrocir: '\\u2949',\n            Ubrcy: '\\u040E',\n            ubrcy: '\\u045E',\n            Ubreve: '\\u016C',\n            ubreve: '\\u016D',\n            Ucirc: '\\u00DB',\n            ucirc: '\\u00FB',\n            Ucy: '\\u0423',\n            ucy: '\\u0443',\n            udarr: '\\u21C5',\n            Udblac: '\\u0170',\n            udblac: '\\u0171',\n            udhar: '\\u296E',\n            ufisht: '\\u297E',\n            Ufr: '\\uD835\\uDD18',\n            ufr: '\\uD835\\uDD32',\n            Ugrave: '\\u00D9',\n            ugrave: '\\u00F9',\n            uHar: '\\u2963',\n            uharl: '\\u21BF',\n            uharr: '\\u21BE',\n            uhblk: '\\u2580',\n            ulcorn: '\\u231C',\n            ulcorner: '\\u231C',\n            ulcrop: '\\u230F',\n            ultri: '\\u25F8',\n            Umacr: '\\u016A',\n            umacr: '\\u016B',\n            uml: '\\u00A8',\n            UnderBar: '\\u005F',\n            UnderBrace: '\\u23DF',\n            UnderBracket: '\\u23B5',\n            UnderParenthesis: '\\u23DD',\n            Union: '\\u22C3',\n            UnionPlus: '\\u228E',\n            Uogon: '\\u0172',\n            uogon: '\\u0173',\n            Uopf: '\\uD835\\uDD4C',\n            uopf: '\\uD835\\uDD66',\n            UpArrow: '\\u2191',\n            Uparrow: '\\u21D1',\n            uparrow: '\\u2191',\n            UpArrowBar: '\\u2912',\n            UpArrowDownArrow: '\\u21C5',\n            UpDownArrow: '\\u2195',\n            Updownarrow: '\\u21D5',\n            updownarrow: '\\u2195',\n            UpEquilibrium: '\\u296E',\n            upharpoonleft: '\\u21BF',\n            upharpoonright: '\\u21BE',\n            uplus: '\\u228E',\n            UpperLeftArrow: '\\u2196',\n            UpperRightArrow: '\\u2197',\n            Upsi: '\\u03D2',\n            upsi: '\\u03C5',\n            upsih: '\\u03D2',\n            Upsilon: '\\u03A5',\n            upsilon: '\\u03C5',\n            UpTee: '\\u22A5',\n            UpTeeArrow: '\\u21A5',\n            upuparrows: '\\u21C8',\n            urcorn: '\\u231D',\n            urcorner: '\\u231D',\n            urcrop: '\\u230E',\n            Uring: '\\u016E',\n            uring: '\\u016F',\n            urtri: '\\u25F9',\n            Uscr: '\\uD835\\uDCB0',\n            uscr: '\\uD835\\uDCCA',\n            utdot: '\\u22F0',\n            Utilde: '\\u0168',\n            utilde: '\\u0169',\n            utri: '\\u25B5',\n            utrif: '\\u25B4',\n            uuarr: '\\u21C8',\n            Uuml: '\\u00DC',\n            uuml: '\\u00FC',\n            uwangle: '\\u29A7',\n            vangrt: '\\u299C',\n            varepsilon: '\\u03F5',\n            varkappa: '\\u03F0',\n            varnothing: '\\u2205',\n            varphi: '\\u03D5',\n            varpi: '\\u03D6',\n            varpropto: '\\u221D',\n            vArr: '\\u21D5',\n            varr: '\\u2195',\n            varrho: '\\u03F1',\n            varsigma: '\\u03C2',\n            varsubsetneq: '\\u228A\\uFE00',\n            varsubsetneqq: '\\u2ACB\\uFE00',\n            varsupsetneq: '\\u228B\\uFE00',\n            varsupsetneqq: '\\u2ACC\\uFE00',\n            vartheta: '\\u03D1',\n            vartriangleleft: '\\u22B2',\n            vartriangleright: '\\u22B3',\n            Vbar: '\\u2AEB',\n            vBar: '\\u2AE8',\n            vBarv: '\\u2AE9',\n            Vcy: '\\u0412',\n            vcy: '\\u0432',\n            VDash: '\\u22AB',\n            Vdash: '\\u22A9',\n            vDash: '\\u22A8',\n            vdash: '\\u22A2',\n            Vdashl: '\\u2AE6',\n            Vee: '\\u22C1',\n            vee: '\\u2228',\n            veebar: '\\u22BB',\n            veeeq: '\\u225A',\n            vellip: '\\u22EE',\n            Verbar: '\\u2016',\n            verbar: '\\u007C',\n            Vert: '\\u2016',\n            vert: '\\u007C',\n            VerticalBar: '\\u2223',\n            VerticalLine: '\\u007C',\n            VerticalSeparator: '\\u2758',\n            VerticalTilde: '\\u2240',\n            VeryThinSpace: '\\u200A',\n            Vfr: '\\uD835\\uDD19',\n            vfr: '\\uD835\\uDD33',\n            vltri: '\\u22B2',\n            vnsub: '\\u2282\\u20D2',\n            vnsup: '\\u2283\\u20D2',\n            Vopf: '\\uD835\\uDD4D',\n            vopf: '\\uD835\\uDD67',\n            vprop: '\\u221D',\n            vrtri: '\\u22B3',\n            Vscr: '\\uD835\\uDCB1',\n            vscr: '\\uD835\\uDCCB',\n            vsubnE: '\\u2ACB\\uFE00',\n            vsubne: '\\u228A\\uFE00',\n            vsupnE: '\\u2ACC\\uFE00',\n            vsupne: '\\u228B\\uFE00',\n            Vvdash: '\\u22AA',\n            vzigzag: '\\u299A',\n            Wcirc: '\\u0174',\n            wcirc: '\\u0175',\n            wedbar: '\\u2A5F',\n            Wedge: '\\u22C0',\n            wedge: '\\u2227',\n            wedgeq: '\\u2259',\n            weierp: '\\u2118',\n            Wfr: '\\uD835\\uDD1A',\n            wfr: '\\uD835\\uDD34',\n            Wopf: '\\uD835\\uDD4E',\n            wopf: '\\uD835\\uDD68',\n            wp: '\\u2118',\n            wr: '\\u2240',\n            wreath: '\\u2240',\n            Wscr: '\\uD835\\uDCB2',\n            wscr: '\\uD835\\uDCCC',\n            xcap: '\\u22C2',\n            xcirc: '\\u25EF',\n            xcup: '\\u22C3',\n            xdtri: '\\u25BD',\n            Xfr: '\\uD835\\uDD1B',\n            xfr: '\\uD835\\uDD35',\n            xhArr: '\\u27FA',\n            xharr: '\\u27F7',\n            Xi: '\\u039E',\n            xi: '\\u03BE',\n            xlArr: '\\u27F8',\n            xlarr: '\\u27F5',\n            xmap: '\\u27FC',\n            xnis: '\\u22FB',\n            xodot: '\\u2A00',\n            Xopf: '\\uD835\\uDD4F',\n            xopf: '\\uD835\\uDD69',\n            xoplus: '\\u2A01',\n            xotime: '\\u2A02',\n            xrArr: '\\u27F9',\n            xrarr: '\\u27F6',\n            Xscr: '\\uD835\\uDCB3',\n            xscr: '\\uD835\\uDCCD',\n            xsqcup: '\\u2A06',\n            xuplus: '\\u2A04',\n            xutri: '\\u25B3',\n            xvee: '\\u22C1',\n            xwedge: '\\u22C0',\n            Yacute: '\\u00DD',\n            yacute: '\\u00FD',\n            YAcy: '\\u042F',\n            yacy: '\\u044F',\n            Ycirc: '\\u0176',\n            ycirc: '\\u0177',\n            Ycy: '\\u042B',\n            ycy: '\\u044B',\n            yen: '\\u00A5',\n            Yfr: '\\uD835\\uDD1C',\n            yfr: '\\uD835\\uDD36',\n            YIcy: '\\u0407',\n            yicy: '\\u0457',\n            Yopf: '\\uD835\\uDD50',\n            yopf: '\\uD835\\uDD6A',\n            Yscr: '\\uD835\\uDCB4',\n            yscr: '\\uD835\\uDCCE',\n            YUcy: '\\u042E',\n            yucy: '\\u044E',\n            Yuml: '\\u0178',\n            yuml: '\\u00FF',\n            Zacute: '\\u0179',\n            zacute: '\\u017A',\n            Zcaron: '\\u017D',\n            zcaron: '\\u017E',\n            Zcy: '\\u0417',\n            zcy: '\\u0437',\n            Zdot: '\\u017B',\n            zdot: '\\u017C',\n            zeetrf: '\\u2128',\n            ZeroWidthSpace: '\\u200B',\n            Zeta: '\\u0396',\n            zeta: '\\u03B6',\n            Zfr: '\\u2128',\n            zfr: '\\uD835\\uDD37',\n            ZHcy: '\\u0416',\n            zhcy: '\\u0436',\n            zigrarr: '\\u21DD',\n            Zopf: '\\u2124',\n            zopf: '\\uD835\\uDD6B',\n            Zscr: '\\uD835\\uDCB5',\n            zscr: '\\uD835\\uDCCF',\n            zwj: '\\u200D',\n            zwnj: '\\u200C'\n        });\n\n        /**\n         * @deprecated use `HTML_ENTITIES` instead\n         * @see HTML_ENTITIES\n         */\n        exports.entityMap = exports.HTML_ENTITIES;\n    });\n    entities.XML_ENTITIES;\n    entities.HTML_ENTITIES;\n    entities.entityMap;\n\n    var NAMESPACE$1 = conventions.NAMESPACE;\n\n    //[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n    //[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n    //[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\n    var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\n    var nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\n    var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$');\n    //var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n    //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n    //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n    //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n    var S_TAG = 0; //tag name offerring\n    var S_ATTR = 1; //attr name offerring\n    var S_ATTR_SPACE = 2; //attr name end and space offer\n    var S_EQ = 3; //=space?\n    var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\n    var S_ATTR_END = 5; //attr value end and no space(quot end)\n    var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\n    var S_TAG_CLOSE = 7; //closed el<el />\n\n    /**\n     * Creates an error that will not be caught by XMLReader aka the SAX parser.\n     *\n     * @param {string} message\n     * @param {any?} locator Optional, can provide details about the location in the source\n     * @constructor\n     */\n    function ParseError$1(message, locator) {\n        this.message = message;\n        this.locator = locator;\n        if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$1);\n    }\n    ParseError$1.prototype = new Error();\n    ParseError$1.prototype.name = ParseError$1.name;\n    function XMLReader$1() {}\n    XMLReader$1.prototype = {\n        parse: function (source, defaultNSMap, entityMap) {\n            var domBuilder = this.domBuilder;\n            domBuilder.startDocument();\n            _copy(defaultNSMap, defaultNSMap = {});\n            parse$1(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n            domBuilder.endDocument();\n        }\n    };\n    function parse$1(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n        function fixedFromCharCode(code) {\n            // String.prototype.fromCharCode does not supports\n            // > 2 bytes unicode chars directly\n            if (code > 0xffff) {\n                code -= 0x10000;\n                var surrogate1 = 0xd800 + (code >> 10),\n                    surrogate2 = 0xdc00 + (code & 0x3ff);\n                return String.fromCharCode(surrogate1, surrogate2);\n            } else {\n                return String.fromCharCode(code);\n            }\n        }\n        function entityReplacer(a) {\n            var k = a.slice(1, -1);\n            if (Object.hasOwnProperty.call(entityMap, k)) {\n                return entityMap[k];\n            } else if (k.charAt(0) === '#') {\n                return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n            } else {\n                errorHandler.error('entity not found:' + a);\n                return a;\n            }\n        }\n        function appendText(end) {\n            //has some bugs\n            if (end > start) {\n                var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n                locator && position(start);\n                domBuilder.characters(xt, 0, end - start);\n                start = end;\n            }\n        }\n        function position(p, m) {\n            while (p >= lineEnd && (m = linePattern.exec(source))) {\n                lineStart = m.index;\n                lineEnd = lineStart + m[0].length;\n                locator.lineNumber++;\n                //console.log('line++:',locator,startPos,endPos)\n            }\n\n            locator.columnNumber = p - lineStart + 1;\n        }\n        var lineStart = 0;\n        var lineEnd = 0;\n        var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\n        var locator = domBuilder.locator;\n        var parseStack = [{\n            currentNSMap: defaultNSMapCopy\n        }];\n        var closeMap = {};\n        var start = 0;\n        while (true) {\n            try {\n                var tagStart = source.indexOf('<', start);\n                if (tagStart < 0) {\n                    if (!source.substr(start).match(/^\\s*$/)) {\n                        var doc = domBuilder.doc;\n                        var text = doc.createTextNode(source.substr(start));\n                        doc.appendChild(text);\n                        domBuilder.currentElement = text;\n                    }\n                    return;\n                }\n                if (tagStart > start) {\n                    appendText(tagStart);\n                }\n                switch (source.charAt(tagStart + 1)) {\n                    case '/':\n                        var end = source.indexOf('>', tagStart + 3);\n                        var tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n                        var config = parseStack.pop();\n                        if (end < 0) {\n                            tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\n                            errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\n                            end = tagStart + 1 + tagName.length;\n                        } else if (tagName.match(/\\s</)) {\n                            tagName = tagName.replace(/[\\s<].*/, '');\n                            errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\n                            end = tagStart + 1 + tagName.length;\n                        }\n                        var localNSMap = config.localNSMap;\n                        var endMatch = config.tagName == tagName;\n                        var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\n                        if (endIgnoreCaseMach) {\n                            domBuilder.endElement(config.uri, config.localName, tagName);\n                            if (localNSMap) {\n                                for (var prefix in localNSMap) {\n                                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                                        domBuilder.endPrefixMapping(prefix);\n                                    }\n                                }\n                            }\n                            if (!endMatch) {\n                                errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case\n                            }\n                        } else {\n                            parseStack.push(config);\n                        }\n                        end++;\n                        break;\n                    // end elment\n                    case '?':\n                        // <?...?>\n                        locator && position(tagStart);\n                        end = parseInstruction(source, tagStart, domBuilder);\n                        break;\n                    case '!':\n                        // <!doctype,<![CDATA,<!--\n                        locator && position(tagStart);\n                        end = parseDCC(source, tagStart, domBuilder, errorHandler);\n                        break;\n                    default:\n                        locator && position(tagStart);\n                        var el = new ElementAttributes();\n                        var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n                        //elStartEnd\n                        var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\n                        var len = el.length;\n                        if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n                            el.closed = true;\n                            if (!entityMap.nbsp) {\n                                errorHandler.warning('unclosed xml attribute');\n                            }\n                        }\n                        if (locator && len) {\n                            var locator2 = copyLocator(locator, {});\n                            //try{//attribute position fixed\n                            for (var i = 0; i < len; i++) {\n                                var a = el[i];\n                                position(a.offset);\n                                a.locator = copyLocator(locator, {});\n                            }\n                            domBuilder.locator = locator2;\n                            if (appendElement$1(el, domBuilder, currentNSMap)) {\n                                parseStack.push(el);\n                            }\n                            domBuilder.locator = locator;\n                        } else {\n                            if (appendElement$1(el, domBuilder, currentNSMap)) {\n                                parseStack.push(el);\n                            }\n                        }\n                        if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {\n                            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n                        } else {\n                            end++;\n                        }\n                }\n            } catch (e) {\n                if (e instanceof ParseError$1) {\n                    throw e;\n                }\n                errorHandler.error('element parse error: ' + e);\n                end = -1;\n            }\n            if (end > start) {\n                start = end;\n            } else {\n                //TODO: 这里有可能sax回退，有位置错误风险\n                appendText(Math.max(tagStart, start) + 1);\n            }\n        }\n    }\n    function copyLocator(f, t) {\n        t.lineNumber = f.lineNumber;\n        t.columnNumber = f.columnNumber;\n        return t;\n    }\n\n    /**\n     * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n     * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n     */\n    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\n        /**\n         * @param {string} qname\n         * @param {string} value\n         * @param {number} startIndex\n         */\n        function addAttribute(qname, value, startIndex) {\n            if (el.attributeNames.hasOwnProperty(qname)) {\n                errorHandler.fatalError('Attribute ' + qname + ' redefined');\n            }\n            el.addValue(qname,\n                // @see https://www.w3.org/TR/xml/#AVNormalize\n                // since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n                // - recursive replacement of (DTD) entity references\n                // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n                value.replace(/[\\t\\n\\r]/g, ' ').replace(/&#?\\w+;/g, entityReplacer), startIndex);\n        }\n        var attrName;\n        var value;\n        var p = ++start;\n        var s = S_TAG; //status\n        while (true) {\n            var c = source.charAt(p);\n            switch (c) {\n                case '=':\n                    if (s === S_ATTR) {\n                        //attrName\n                        attrName = source.slice(start, p);\n                        s = S_EQ;\n                    } else if (s === S_ATTR_SPACE) {\n                        s = S_EQ;\n                    } else {\n                        //fatalError: equal must after attrName or space after attrName\n                        throw new Error('attribute equal must after attrName'); // No known test case\n                    }\n\n                    break;\n                case '\\'':\n                case '\"':\n                    if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n                    ) {\n                        //equal\n                        if (s === S_ATTR) {\n                            errorHandler.warning('attribute value must after \"=\"');\n                            attrName = source.slice(start, p);\n                        }\n                        start = p + 1;\n                        p = source.indexOf(c, start);\n                        if (p > 0) {\n                            value = source.slice(start, p);\n                            addAttribute(attrName, value, start - 1);\n                            s = S_ATTR_END;\n                        } else {\n                            //fatalError: no end quot match\n                            throw new Error('attribute value no end \\'' + c + '\\' match');\n                        }\n                    } else if (s == S_ATTR_NOQUOT_VALUE) {\n                        value = source.slice(start, p);\n                        addAttribute(attrName, value, start);\n                        errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n                        start = p + 1;\n                        s = S_ATTR_END;\n                    } else {\n                        //fatalError: no equal before\n                        throw new Error('attribute value must after \"=\"'); // No known test case\n                    }\n\n                    break;\n                case '/':\n                    switch (s) {\n                        case S_TAG:\n                            el.setTagName(source.slice(start, p));\n                        case S_ATTR_END:\n                        case S_TAG_SPACE:\n                        case S_TAG_CLOSE:\n                            s = S_TAG_CLOSE;\n                            el.closed = true;\n                        case S_ATTR_NOQUOT_VALUE:\n                        case S_ATTR:\n                            break;\n                        case S_ATTR_SPACE:\n                            el.closed = true;\n                            break;\n                        //case S_EQ:\n                        default:\n                            throw new Error(\"attribute invalid close char('/')\");\n                        // No known test case\n                    }\n\n                    break;\n                case '':\n                    //end document\n                    errorHandler.error('unexpected end of input');\n                    if (s == S_TAG) {\n                        el.setTagName(source.slice(start, p));\n                    }\n                    return p;\n                case '>':\n                    switch (s) {\n                        case S_TAG:\n                            el.setTagName(source.slice(start, p));\n                        case S_ATTR_END:\n                        case S_TAG_SPACE:\n                        case S_TAG_CLOSE:\n                            break;\n                        //normal\n                        case S_ATTR_NOQUOT_VALUE: //Compatible state\n                        case S_ATTR:\n                            value = source.slice(start, p);\n                            if (value.slice(-1) === '/') {\n                                el.closed = true;\n                                value = value.slice(0, -1);\n                            }\n                        case S_ATTR_SPACE:\n                            if (s === S_ATTR_SPACE) {\n                                value = attrName;\n                            }\n                            if (s == S_ATTR_NOQUOT_VALUE) {\n                                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n                                addAttribute(attrName, value, start);\n                            } else {\n                                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {\n                                    errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n                                }\n                                addAttribute(value, value, start);\n                            }\n                            break;\n                        case S_EQ:\n                            throw new Error('attribute value missed!!');\n                    }\n                    //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n                    return p;\n                /*xml space '\\x20' | #x9 | #xD | #xA; */\n                case '\\u0080':\n                    c = ' ';\n                default:\n                    if (c <= ' ') {\n                        //space\n                        switch (s) {\n                            case S_TAG:\n                                el.setTagName(source.slice(start, p)); //tagName\n                                s = S_TAG_SPACE;\n                                break;\n                            case S_ATTR:\n                                attrName = source.slice(start, p);\n                                s = S_ATTR_SPACE;\n                                break;\n                            case S_ATTR_NOQUOT_VALUE:\n                                var value = source.slice(start, p);\n                                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n                                addAttribute(attrName, value, start);\n                            case S_ATTR_END:\n                                s = S_TAG_SPACE;\n                                break;\n                            //case S_TAG_SPACE:\n                            //case S_EQ:\n                            //case S_ATTR_SPACE:\n                            //\tvoid();break;\n                            //case S_TAG_CLOSE:\n                            //ignore warning\n                        }\n                    } else {\n                        //not space\n                        //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n                        //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n                        switch (s) {\n                            //case S_TAG:void();break;\n                            //case S_ATTR:void();break;\n                            //case S_ATTR_NOQUOT_VALUE:void();break;\n                            case S_ATTR_SPACE:\n                                el.tagName;\n                                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n                                    errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n                                }\n                                addAttribute(attrName, attrName, start);\n                                start = p;\n                                s = S_ATTR;\n                                break;\n                            case S_ATTR_END:\n                                errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n                            case S_TAG_SPACE:\n                                s = S_ATTR;\n                                start = p;\n                                break;\n                            case S_EQ:\n                                s = S_ATTR_NOQUOT_VALUE;\n                                start = p;\n                                break;\n                            case S_TAG_CLOSE:\n                                throw new Error(\"elements closed character '/' and '>' must be connected to\");\n                        }\n                    }\n            } //end outer switch\n            //console.log('p++',p)\n            p++;\n        }\n    }\n    /**\n     * @return true if has new namespace define\n     */\n    function appendElement$1(el, domBuilder, currentNSMap) {\n        var tagName = el.tagName;\n        var localNSMap = null;\n        //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n        var i = el.length;\n        while (i--) {\n            var a = el[i];\n            var qName = a.qName;\n            var value = a.value;\n            var nsp = qName.indexOf(':');\n            if (nsp > 0) {\n                var prefix = a.prefix = qName.slice(0, nsp);\n                var localName = qName.slice(nsp + 1);\n                var nsPrefix = prefix === 'xmlns' && localName;\n            } else {\n                localName = qName;\n                prefix = null;\n                nsPrefix = qName === 'xmlns' && '';\n            }\n            //can not set prefix,because prefix !== ''\n            a.localName = localName;\n            //prefix == null for no ns prefix attribute\n            if (nsPrefix !== false) {\n                //hack!!\n                if (localNSMap == null) {\n                    localNSMap = {};\n                    //console.log(currentNSMap,0)\n                    _copy(currentNSMap, currentNSMap = {});\n                    //console.log(currentNSMap,1)\n                }\n\n                currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n                a.uri = NAMESPACE$1.XMLNS;\n                domBuilder.startPrefixMapping(nsPrefix, value);\n            }\n        }\n        var i = el.length;\n        while (i--) {\n            a = el[i];\n            var prefix = a.prefix;\n            if (prefix) {\n                //no prefix attribute has no namespace\n                if (prefix === 'xml') {\n                    a.uri = NAMESPACE$1.XML;\n                }\n                if (prefix !== 'xmlns') {\n                    a.uri = currentNSMap[prefix || ''];\n\n                    //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n                }\n            }\n        }\n\n        var nsp = tagName.indexOf(':');\n        if (nsp > 0) {\n            prefix = el.prefix = tagName.slice(0, nsp);\n            localName = el.localName = tagName.slice(nsp + 1);\n        } else {\n            prefix = null; //important!!\n            localName = el.localName = tagName;\n        }\n        //no prefix element has default namespace\n        var ns = el.uri = currentNSMap[prefix || ''];\n        domBuilder.startElement(ns, localName, tagName, el);\n        //endPrefixMapping and startPrefixMapping have not any help for dom builder\n        //localNSMap = null\n        if (el.closed) {\n            domBuilder.endElement(ns, localName, tagName);\n            if (localNSMap) {\n                for (prefix in localNSMap) {\n                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                        domBuilder.endPrefixMapping(prefix);\n                    }\n                }\n            }\n        } else {\n            el.currentNSMap = currentNSMap;\n            el.localNSMap = localNSMap;\n            //parseStack.push(el);\n            return true;\n        }\n    }\n    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n        if (/^(?:script|textarea)$/i.test(tagName)) {\n            var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n            var text = source.substring(elStartEnd + 1, elEndStart);\n            if (/[&<]/.test(text)) {\n                if (/^script$/i.test(tagName)) {\n                    //if(!/\\]\\]>/.test(text)){\n                    //lexHandler.startCDATA();\n                    domBuilder.characters(text, 0, text.length);\n                    //lexHandler.endCDATA();\n                    return elEndStart;\n                    //}\n                } //}else{//text area\n                text = text.replace(/&#?\\w+;/g, entityReplacer);\n                domBuilder.characters(text, 0, text.length);\n                return elEndStart;\n                //}\n            }\n        }\n\n        return elStartEnd + 1;\n    }\n    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n        //if(tagName in closeMap){\n        var pos = closeMap[tagName];\n        if (pos == null) {\n            //console.log(tagName)\n            pos = source.lastIndexOf('</' + tagName + '>');\n            if (pos < elStartEnd) {\n                //忘记闭合\n                pos = source.lastIndexOf('</' + tagName);\n            }\n            closeMap[tagName] = pos;\n        }\n        return pos < elStartEnd;\n        //}\n    }\n\n    function _copy(source, target) {\n        for (var n in source) {\n            if (Object.prototype.hasOwnProperty.call(source, n)) {\n                target[n] = source[n];\n            }\n        }\n    }\n    function parseDCC(source, start, domBuilder, errorHandler) {\n        //sure start with '<!'\n        var next = source.charAt(start + 2);\n        switch (next) {\n            case '-':\n                if (source.charAt(start + 3) === '-') {\n                    var end = source.indexOf('-->', start + 4);\n                    //append comment source.substring(4,end)//<!--\n                    if (end > start) {\n                        domBuilder.comment(source, start + 4, end - start - 4);\n                        return end + 3;\n                    } else {\n                        errorHandler.error(\"Unclosed comment\");\n                        return -1;\n                    }\n                } else {\n                    //error\n                    return -1;\n                }\n            default:\n                if (source.substr(start + 3, 6) == 'CDATA[') {\n                    var end = source.indexOf(']]>', start + 9);\n                    domBuilder.startCDATA();\n                    domBuilder.characters(source, start + 9, end - start - 9);\n                    domBuilder.endCDATA();\n                    return end + 3;\n                }\n                //<!DOCTYPE\n                //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)\n                var matchs = split(source, start);\n                var len = matchs.length;\n                if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n                    var name = matchs[1][0];\n                    var pubid = false;\n                    var sysid = false;\n                    if (len > 3) {\n                        if (/^public$/i.test(matchs[2][0])) {\n                            pubid = matchs[3][0];\n                            sysid = len > 4 && matchs[4][0];\n                        } else if (/^system$/i.test(matchs[2][0])) {\n                            sysid = matchs[3][0];\n                        }\n                    }\n                    var lastMatch = matchs[len - 1];\n                    domBuilder.startDTD(name, pubid, sysid);\n                    domBuilder.endDTD();\n                    return lastMatch.index + lastMatch[0].length;\n                }\n        }\n        return -1;\n    }\n    function parseInstruction(source, start, domBuilder) {\n        var end = source.indexOf('?>', start);\n        if (end) {\n            var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n            if (match) {\n                match[0].length;\n                domBuilder.processingInstruction(match[1], match[2]);\n                return end + 2;\n            } else {\n                //error\n                return -1;\n            }\n        }\n        return -1;\n    }\n    function ElementAttributes() {\n        this.attributeNames = {};\n    }\n    ElementAttributes.prototype = {\n        setTagName: function (tagName) {\n            if (!tagNamePattern.test(tagName)) {\n                throw new Error('invalid tagName:' + tagName);\n            }\n            this.tagName = tagName;\n        },\n        addValue: function (qName, value, offset) {\n            if (!tagNamePattern.test(qName)) {\n                throw new Error('invalid attribute:' + qName);\n            }\n            this.attributeNames[qName] = this.length;\n            this[this.length++] = {\n                qName: qName,\n                value: value,\n                offset: offset\n            };\n        },\n        length: 0,\n        getLocalName: function (i) {\n            return this[i].localName;\n        },\n        getLocator: function (i) {\n            return this[i].locator;\n        },\n        getQName: function (i) {\n            return this[i].qName;\n        },\n        getURI: function (i) {\n            return this[i].uri;\n        },\n        getValue: function (i) {\n            return this[i].value;\n        }\n        //\t,getIndex:function(uri, localName)){\n        //\t\tif(localName){\n        //\n        //\t\t}else{\n        //\t\t\tvar qName = uri\n        //\t\t}\n        //\t},\n        //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n        //\tgetType:function(uri,localName){}\n        //\tgetType:function(i){},\n    };\n\n    function split(source, start) {\n        var match;\n        var buf = [];\n        var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n        reg.lastIndex = start;\n        reg.exec(source); //skip <\n        while (match = reg.exec(source)) {\n            buf.push(match);\n            if (match[1]) return buf;\n        }\n    }\n    var XMLReader_1 = XMLReader$1;\n    var ParseError_1 = ParseError$1;\n    var sax = {\n        XMLReader: XMLReader_1,\n        ParseError: ParseError_1\n    };\n\n    var DOMImplementation = dom.DOMImplementation;\n    var NAMESPACE = conventions.NAMESPACE;\n    var ParseError = sax.ParseError;\n    var XMLReader = sax.XMLReader;\n\n    /**\n     * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:\n     *\n     * > XML parsed entities are often stored in computer files which,\n     * > for editing convenience, are organized into lines.\n     * > These lines are typically separated by some combination\n     * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n     * >\n     * > To simplify the tasks of applications, the XML processor must behave\n     * > as if it normalized all line breaks in external parsed entities (including the document entity)\n     * > on input, before parsing, by translating all of the following to a single #xA character:\n     * >\n     * > 1. the two-character sequence #xD #xA\n     * > 2. the two-character sequence #xD #x85\n     * > 3. the single character #x85\n     * > 4. the single character #x2028\n     * > 5. any #xD character that is not immediately followed by #xA or #x85.\n     *\n     * @param {string} input\n     * @returns {string}\n     */\n    function normalizeLineEndings(input) {\n        return input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n    }\n\n    /**\n     * @typedef Locator\n     * @property {number} [columnNumber]\n     * @property {number} [lineNumber]\n     */\n\n    /**\n     * @typedef DOMParserOptions\n     * @property {DOMHandler} [domBuilder]\n     * @property {Function} [errorHandler]\n     * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing\n     * \t\t\t\t\t\tdefaults to `normalizeLineEndings`\n     * @property {Locator} [locator]\n     * @property {Record<string, string>} [xmlns]\n     *\n     * @see normalizeLineEndings\n     */\n\n    /**\n     * The DOMParser interface provides the ability to parse XML or HTML source code\n     * from a string into a DOM `Document`.\n     *\n     * _xmldom is different from the spec in that it allows an `options` parameter,\n     * to override the default behavior._\n     *\n     * @param {DOMParserOptions} [options]\n     * @constructor\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n     */\n    function DOMParser$1(options) {\n        this.options = options || {\n            locator: {}\n        };\n    }\n    DOMParser$1.prototype.parseFromString = function (source, mimeType) {\n        var options = this.options;\n        var sax = new XMLReader();\n        var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n        var errorHandler = options.errorHandler;\n        var locator = options.locator;\n        var defaultNSMap = options.xmlns || {};\n        var isHTML = /\\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;\n        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\n        if (locator) {\n            domBuilder.setDocumentLocator(locator);\n        }\n        sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n        sax.domBuilder = options.domBuilder || domBuilder;\n        if (isHTML) {\n            defaultNSMap[''] = NAMESPACE.HTML;\n        }\n        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n        var normalize = options.normalizeLineEndings || normalizeLineEndings;\n        if (source && typeof source === 'string') {\n            sax.parse(normalize(source), defaultNSMap, entityMap);\n        } else {\n            sax.errorHandler.error('invalid doc source');\n        }\n        return domBuilder.doc;\n    };\n    function buildErrorHandler(errorImpl, domBuilder, locator) {\n        if (!errorImpl) {\n            if (domBuilder instanceof DOMHandler) {\n                return domBuilder;\n            }\n            errorImpl = domBuilder;\n        }\n        var errorHandler = {};\n        var isCallback = errorImpl instanceof Function;\n        locator = locator || {};\n        function build(key) {\n            var fn = errorImpl[key];\n            if (!fn && isCallback) {\n                fn = errorImpl.length == 2 ? function (msg) {\n                    errorImpl(key, msg);\n                } : errorImpl;\n            }\n            errorHandler[key] = fn && function (msg) {\n                fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\n            } || function () {};\n        }\n        build('warning');\n        build('error');\n        build('fatalError');\n        return errorHandler;\n    }\n\n    //console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n    /**\n     * +ContentHandler+ErrorHandler\n     * +LexicalHandler+EntityResolver2\n     * -DeclHandler-DTDHandler\n     *\n     * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\n     * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\n     */\n    function DOMHandler() {\n        this.cdata = false;\n    }\n    function position(locator, node) {\n        node.lineNumber = locator.lineNumber;\n        node.columnNumber = locator.columnNumber;\n    }\n    /**\n     * @see org.xml.sax.ContentHandler#startDocument\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n     */\n    DOMHandler.prototype = {\n        startDocument: function () {\n            this.doc = new DOMImplementation().createDocument(null, null, null);\n            if (this.locator) {\n                this.doc.documentURI = this.locator.systemId;\n            }\n        },\n        startElement: function (namespaceURI, localName, qName, attrs) {\n            var doc = this.doc;\n            var el = doc.createElementNS(namespaceURI, qName || localName);\n            var len = attrs.length;\n            appendElement(this, el);\n            this.currentElement = el;\n            this.locator && position(this.locator, el);\n            for (var i = 0; i < len; i++) {\n                var namespaceURI = attrs.getURI(i);\n                var value = attrs.getValue(i);\n                var qName = attrs.getQName(i);\n                var attr = doc.createAttributeNS(namespaceURI, qName);\n                this.locator && position(attrs.getLocator(i), attr);\n                attr.value = attr.nodeValue = value;\n                el.setAttributeNode(attr);\n            }\n        },\n        endElement: function (namespaceURI, localName, qName) {\n            var current = this.currentElement;\n            current.tagName;\n            this.currentElement = current.parentNode;\n        },\n        startPrefixMapping: function (prefix, uri) {},\n        endPrefixMapping: function (prefix) {},\n        processingInstruction: function (target, data) {\n            var ins = this.doc.createProcessingInstruction(target, data);\n            this.locator && position(this.locator, ins);\n            appendElement(this, ins);\n        },\n        ignorableWhitespace: function (ch, start, length) {},\n        characters: function (chars, start, length) {\n            chars = _toString.apply(this, arguments);\n            //console.log(chars)\n            if (chars) {\n                if (this.cdata) {\n                    var charNode = this.doc.createCDATASection(chars);\n                } else {\n                    var charNode = this.doc.createTextNode(chars);\n                }\n                if (this.currentElement) {\n                    this.currentElement.appendChild(charNode);\n                } else if (/^\\s*$/.test(chars)) {\n                    this.doc.appendChild(charNode);\n                    //process xml\n                }\n\n                this.locator && position(this.locator, charNode);\n            }\n        },\n        skippedEntity: function (name) {},\n        endDocument: function () {\n            this.doc.normalize();\n        },\n        setDocumentLocator: function (locator) {\n            if (this.locator = locator) {\n                // && !('lineNumber' in locator)){\n                locator.lineNumber = 0;\n            }\n        },\n        //LexicalHandler\n        comment: function (chars, start, length) {\n            chars = _toString.apply(this, arguments);\n            var comm = this.doc.createComment(chars);\n            this.locator && position(this.locator, comm);\n            appendElement(this, comm);\n        },\n        startCDATA: function () {\n            //used in characters() methods\n            this.cdata = true;\n        },\n        endCDATA: function () {\n            this.cdata = false;\n        },\n        startDTD: function (name, publicId, systemId) {\n            var impl = this.doc.implementation;\n            if (impl && impl.createDocumentType) {\n                var dt = impl.createDocumentType(name, publicId, systemId);\n                this.locator && position(this.locator, dt);\n                appendElement(this, dt);\n                this.doc.doctype = dt;\n            }\n        },\n        /**\n         * @see org.xml.sax.ErrorHandler\n         * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n         */\n        warning: function (error) {\n            console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\n        },\n        error: function (error) {\n            console.error('[xmldom error]\\t' + error, _locator(this.locator));\n        },\n        fatalError: function (error) {\n            throw new ParseError(error, this.locator);\n        }\n    };\n    function _locator(l) {\n        if (l) {\n            return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n        }\n    }\n    function _toString(chars, start, length) {\n        if (typeof chars == 'string') {\n            return chars.substr(start, length);\n        } else {\n            //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n            if (chars.length >= start + length || start) {\n                return new java.lang.String(chars, start, length) + '';\n            }\n            return chars;\n        }\n    }\n\n    /*\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n   * used method of org.xml.sax.ext.LexicalHandler:\n   *  #comment(chars, start, length)\n   *  #startCDATA()\n   *  #endCDATA()\n   *  #startDTD(name, publicId, systemId)\n   *\n   *\n   * IGNORED method of org.xml.sax.ext.LexicalHandler:\n   *  #endDTD()\n   *  #startEntity(name)\n   *  #endEntity(name)\n   *\n   *\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n   * IGNORED method of org.xml.sax.ext.DeclHandler\n   * \t#attributeDecl(eName, aName, type, mode, value)\n   *  #elementDecl(name, model)\n   *  #externalEntityDecl(name, publicId, systemId)\n   *  #internalEntityDecl(name, value)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n   * IGNORED method of org.xml.sax.EntityResolver2\n   *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n   *  #resolveEntity(publicId, systemId)\n   *  #getExternalSubset(name, baseURI)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n   * IGNORED method of org.xml.sax.DTDHandler\n   *  #notationDecl(name, publicId, systemId) {};\n   *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n   */\n    \"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n        DOMHandler.prototype[key] = function () {\n            return null;\n        };\n    });\n\n    /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\n    function appendElement(hander, node) {\n        if (!hander.currentElement) {\n            hander.doc.appendChild(node);\n        } else {\n            hander.currentElement.appendChild(node);\n        }\n    } //appendChild and setAttributeNS are preformance key\n\n    var __DOMHandler = DOMHandler;\n    var normalizeLineEndings_1 = normalizeLineEndings;\n    var DOMParser_1 = DOMParser$1;\n    var domParser = {\n        __DOMHandler: __DOMHandler,\n        normalizeLineEndings: normalizeLineEndings_1,\n        DOMParser: DOMParser_1\n    };\n\n    var DOMParser = domParser.DOMParser;\n\n    /*! @name mpd-parser @version 1.3.0 @license Apache-2.0 */\n    const isObject = obj => {\n        return !!obj && typeof obj === 'object';\n    };\n    const merge$1 = (...objects) => {\n        return objects.reduce((result, source) => {\n            if (typeof source !== 'object') {\n                return result;\n            }\n            Object.keys(source).forEach(key => {\n                if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n                    result[key] = result[key].concat(source[key]);\n                } else if (isObject(result[key]) && isObject(source[key])) {\n                    result[key] = merge$1(result[key], source[key]);\n                } else {\n                    result[key] = source[key];\n                }\n            });\n            return result;\n        }, {});\n    };\n    const values = o => Object.keys(o).map(k => o[k]);\n    const range = (start, end) => {\n        const result = [];\n        for (let i = start; i < end; i++) {\n            result.push(i);\n        }\n        return result;\n    };\n    const flatten = lists => lists.reduce((x, y) => x.concat(y), []);\n    const from = list => {\n        if (!list.length) {\n            return [];\n        }\n        const result = [];\n        for (let i = 0; i < list.length; i++) {\n            result.push(list[i]);\n        }\n        return result;\n    };\n    const findIndexes = (l, key) => l.reduce((a, e, i) => {\n        if (e[key]) {\n            a.push(i);\n        }\n        return a;\n    }, []);\n    /**\n     * Returns a union of the included lists provided each element can be identified by a key.\n     *\n     * @param {Array} list - list of lists to get the union of\n     * @param {Function} keyFunction - the function to use as a key for each element\n     *\n     * @return {Array} the union of the arrays\n     */\n\n    const union = (lists, keyFunction) => {\n        return values(lists.reduce((acc, list) => {\n            list.forEach(el => {\n                acc[keyFunction(el)] = el;\n            });\n            return acc;\n        }, {}));\n    };\n    var errors = {\n        INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n        INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n        DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n        DASH_INVALID_XML: 'DASH_INVALID_XML',\n        NO_BASE_URL: 'NO_BASE_URL',\n        MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n        SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n        UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n    };\n\n    /**\n     * @typedef {Object} SingleUri\n     * @property {string} uri - relative location of segment\n     * @property {string} resolvedUri - resolved location of segment\n     * @property {Object} byterange - Object containing information on how to make byte range\n     *   requests following byte-range-spec per RFC2616.\n     * @property {String} byterange.length - length of range request\n     * @property {String} byterange.offset - byte offset of range request\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n     */\n\n    /**\n     * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n     * that conforms to how m3u8-parser is structured\n     *\n     * @see https://github.com/videojs/m3u8-parser\n     *\n     * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n     * @param {string} source - source url for segment\n     * @param {string} range - optional range used for range calls,\n     *   follows  RFC 2616, Clause 14.35.1\n     * @return {SingleUri} full segment information transformed into a format similar\n     *   to m3u8-parser\n     */\n\n    const urlTypeToSegment = ({\n                                  baseUrl = '',\n                                  source = '',\n                                  range = '',\n                                  indexRange = ''\n                              }) => {\n        const segment = {\n            uri: source,\n            resolvedUri: resolveUrl$1(baseUrl || '', source)\n        };\n        if (range || indexRange) {\n            const rangeStr = range ? range : indexRange;\n            const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n            let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n            let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n            if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n                startRange = Number(startRange);\n            }\n            if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n                endRange = Number(endRange);\n            }\n            let length;\n            if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n                length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n            } else {\n                length = endRange - startRange + 1;\n            }\n            if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n                length = Number(length);\n            } // byterange should be inclusive according to\n            // RFC 2616, Clause 14.35.1\n\n            segment.byterange = {\n                length,\n                offset: startRange\n            };\n        }\n        return segment;\n    };\n    const byteRangeToString = byterange => {\n        // `endRange` is one less than `offset + length` because the HTTP range\n        // header uses inclusive ranges\n        let endRange;\n        if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n            endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n        } else {\n            endRange = byterange.offset + byterange.length - 1;\n        }\n        return `${byterange.offset}-${endRange}`;\n    };\n\n    /**\n     * parse the end number attribue that can be a string\n     * number, or undefined.\n     *\n     * @param {string|number|undefined} endNumber\n     *        The end number attribute.\n     *\n     * @return {number|null}\n     *          The result of parsing the end number.\n     */\n\n    const parseEndNumber = endNumber => {\n        if (endNumber && typeof endNumber !== 'number') {\n            endNumber = parseInt(endNumber, 10);\n        }\n        if (isNaN(endNumber)) {\n            return null;\n        }\n        return endNumber;\n    };\n    /**\n     * Functions for calculating the range of available segments in static and dynamic\n     * manifests.\n     */\n\n    const segmentRange = {\n        /**\n         * Returns the entire range of available segments for a static MPD\n         *\n         * @param {Object} attributes\n         *        Inheritied MPD attributes\n         * @return {{ start: number, end: number }}\n         *         The start and end numbers for available segments\n         */\n        static(attributes) {\n            const {\n                duration,\n                timescale = 1,\n                sourceDuration,\n                periodDuration\n            } = attributes;\n            const endNumber = parseEndNumber(attributes.endNumber);\n            const segmentDuration = duration / timescale;\n            if (typeof endNumber === 'number') {\n                return {\n                    start: 0,\n                    end: endNumber\n                };\n            }\n            if (typeof periodDuration === 'number') {\n                return {\n                    start: 0,\n                    end: periodDuration / segmentDuration\n                };\n            }\n            return {\n                start: 0,\n                end: sourceDuration / segmentDuration\n            };\n        },\n        /**\n         * Returns the current live window range of available segments for a dynamic MPD\n         *\n         * @param {Object} attributes\n         *        Inheritied MPD attributes\n         * @return {{ start: number, end: number }}\n         *         The start and end numbers for available segments\n         */\n        dynamic(attributes) {\n            const {\n                NOW,\n                clientOffset,\n                availabilityStartTime,\n                timescale = 1,\n                duration,\n                periodStart = 0,\n                minimumUpdatePeriod = 0,\n                timeShiftBufferDepth = Infinity\n            } = attributes;\n            const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n            // after retrieving UTC server time.\n\n            const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n            // Convert the period start time to EPOCH.\n\n            const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n            const periodEndWC = now + minimumUpdatePeriod;\n            const periodDuration = periodEndWC - periodStartWC;\n            const segmentCount = Math.ceil(periodDuration * timescale / duration);\n            const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n            const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n            return {\n                start: Math.max(0, availableStart),\n                end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n            };\n        }\n    };\n    /**\n     * Maps a range of numbers to objects with information needed to build the corresponding\n     * segment list\n     *\n     * @name toSegmentsCallback\n     * @function\n     * @param {number} number\n     *        Number of the segment\n     * @param {number} index\n     *        Index of the number in the range list\n     * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n     *         Object with segment timing and duration info\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping a range of numbers to\n     * information needed to build the segment list.\n     *\n     * @param {Object} attributes\n     *        Inherited MPD attributes\n     * @return {toSegmentsCallback}\n     *         Callback map function\n     */\n\n    const toSegments = attributes => number => {\n        const {\n            duration,\n            timescale = 1,\n            periodStart,\n            startNumber = 1\n        } = attributes;\n        return {\n            number: startNumber + number,\n            duration: duration / timescale,\n            timeline: periodStart,\n            time: number * duration\n        };\n    };\n    /**\n     * Returns a list of objects containing segment timing and duration info used for\n     * building the list of segments. This uses the @duration attribute specified\n     * in the MPD manifest to derive the range of segments.\n     *\n     * @param {Object} attributes\n     *        Inherited MPD attributes\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseByDuration = attributes => {\n        const {\n            type,\n            duration,\n            timescale = 1,\n            periodDuration,\n            sourceDuration\n        } = attributes;\n        const {\n            start,\n            end\n        } = segmentRange[type](attributes);\n        const segments = range(start, end).map(toSegments(attributes));\n        if (type === 'static') {\n            const index = segments.length - 1; // section is either a period or the full source\n\n            const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n            segments[index].duration = sectionDuration - duration / timescale * index;\n        }\n        return segments;\n    };\n\n    /**\n     * Translates SegmentBase into a set of segments.\n     * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n     * node should be translated into segment.\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @return {Object.<Array>} list of segments\n     */\n\n    const segmentsFromBase = attributes => {\n        const {\n            baseUrl,\n            initialization = {},\n            sourceDuration,\n            indexRange = '',\n            periodStart,\n            presentationTime,\n            number = 0,\n            duration\n        } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n        if (!baseUrl) {\n            throw new Error(errors.NO_BASE_URL);\n        }\n        const initSegment = urlTypeToSegment({\n            baseUrl,\n            source: initialization.sourceURL,\n            range: initialization.range\n        });\n        const segment = urlTypeToSegment({\n            baseUrl,\n            source: baseUrl,\n            indexRange\n        });\n        segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n        // (since SegmentBase is only for one total segment)\n\n        if (duration) {\n            const segmentTimeInfo = parseByDuration(attributes);\n            if (segmentTimeInfo.length) {\n                segment.duration = segmentTimeInfo[0].duration;\n                segment.timeline = segmentTimeInfo[0].timeline;\n            }\n        } else if (sourceDuration) {\n            segment.duration = sourceDuration;\n            segment.timeline = periodStart;\n        } // If presentation time is provided, these segments are being generated by SIDX\n        // references, and should use the time provided. For the general case of SegmentBase,\n        // there should only be one segment in the period, so its presentation time is the same\n        // as its period start.\n\n        segment.presentationTime = presentationTime || periodStart;\n        segment.number = number;\n        return [segment];\n    };\n    /**\n     * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n     * according to the sidx information given.\n     *\n     * playlist.sidx has metadadata about the sidx where-as the sidx param\n     * is the parsed sidx box itself.\n     *\n     * @param {Object} playlist the playlist to update the sidx information for\n     * @param {Object} sidx the parsed sidx box\n     * @return {Object} the playlist object with the updated sidx information\n     */\n\n    const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n        // Retain init segment information\n        const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n        const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n        const timeline = playlist.timeline || 0;\n        const sidxByteRange = playlist.sidx.byterange;\n        const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n        const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n        const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n        const segments = [];\n        const type = playlist.endList ? 'static' : 'dynamic';\n        const periodStart = playlist.sidx.timeline;\n        let presentationTime = periodStart;\n        let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n        let startIndex; // eslint-disable-next-line\n\n        if (typeof sidx.firstOffset === 'bigint') {\n            startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n        } else {\n            startIndex = sidxEnd + sidx.firstOffset;\n        }\n        for (let i = 0; i < mediaReferences.length; i++) {\n            const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n            const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n            // this will be converted to seconds when generating segments\n\n            const duration = reference.subsegmentDuration; // should be an inclusive range\n\n            let endIndex; // eslint-disable-next-line\n\n            if (typeof startIndex === 'bigint') {\n                endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n            } else {\n                endIndex = startIndex + size - 1;\n            }\n            const indexRange = `${startIndex}-${endIndex}`;\n            const attributes = {\n                baseUrl,\n                timescale,\n                timeline,\n                periodStart,\n                presentationTime,\n                number,\n                duration,\n                sourceDuration,\n                indexRange,\n                type\n            };\n            const segment = segmentsFromBase(attributes)[0];\n            if (initSegment) {\n                segment.map = initSegment;\n            }\n            segments.push(segment);\n            if (typeof startIndex === 'bigint') {\n                startIndex += window.BigInt(size);\n            } else {\n                startIndex += size;\n            }\n            presentationTime += duration / timescale;\n            number++;\n        }\n        playlist.segments = segments;\n        return playlist;\n    };\n    const SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\n    const TIME_FUDGE = 1 / 60;\n    /**\n     * Given a list of timelineStarts, combines, dedupes, and sorts them.\n     *\n     * @param {TimelineStart[]} timelineStarts - list of timeline starts\n     *\n     * @return {TimelineStart[]} the combined and deduped timeline starts\n     */\n\n    const getUniqueTimelineStarts = timelineStarts => {\n        return union(timelineStarts, ({\n                                          timeline\n                                      }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n    };\n    /**\n     * Finds the playlist with the matching NAME attribute.\n     *\n     * @param {Array} playlists - playlists to search through\n     * @param {string} name - the NAME attribute to search for\n     *\n     * @return {Object|null} the matching playlist object, or null\n     */\n\n    const findPlaylistWithName = (playlists, name) => {\n        for (let i = 0; i < playlists.length; i++) {\n            if (playlists[i].attributes.NAME === name) {\n                return playlists[i];\n            }\n        }\n        return null;\n    };\n    /**\n     * Gets a flattened array of media group playlists.\n     *\n     * @param {Object} manifest - the main manifest object\n     *\n     * @return {Array} the media group playlists\n     */\n\n    const getMediaGroupPlaylists = manifest => {\n        let mediaGroupPlaylists = [];\n        forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n            mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n        });\n        return mediaGroupPlaylists;\n    };\n    /**\n     * Updates the playlist's media sequence numbers.\n     *\n     * @param {Object} config - options object\n     * @param {Object} config.playlist - the playlist to update\n     * @param {number} config.mediaSequence - the mediaSequence number to start with\n     */\n\n    const updateMediaSequenceForPlaylist = ({\n                                                playlist,\n                                                mediaSequence\n                                            }) => {\n        playlist.mediaSequence = mediaSequence;\n        playlist.segments.forEach((segment, index) => {\n            segment.number = playlist.mediaSequence + index;\n        });\n    };\n    /**\n     * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n     * and a complete list of timeline starts.\n     *\n     * If no matching playlist is found, only the discontinuity sequence number of the playlist\n     * will be updated.\n     *\n     * Since early available timelines are not supported, at least one segment must be present.\n     *\n     * @param {Object} config - options object\n     * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n     * @param {Object[]} newPlaylists - the new playlists to update\n     * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n     */\n\n    const updateSequenceNumbers = ({\n                                       oldPlaylists,\n                                       newPlaylists,\n                                       timelineStarts\n                                   }) => {\n        newPlaylists.forEach(playlist => {\n            playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n                                                                                    timeline\n                                                                                }) {\n                return timeline === playlist.timeline;\n            }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n            // (see ISO_23009-1-2012 5.3.5.2).\n            //\n            // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n            const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n            if (!oldPlaylist) {\n                // Since this is a new playlist, the media sequence values can start from 0 without\n                // consequence.\n                return;\n            } // TODO better support for live SIDX\n            //\n            // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n            // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n            // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n            // not supported when the SIDX properties change on refreshes.\n            //\n            // In the future, if support needs to be added, the merging logic here can be called\n            // after SIDX references are resolved. For now, exit early to prevent exceptions being\n            // thrown due to undefined references.\n\n            if (playlist.sidx) {\n                return;\n            } // Since we don't yet support early available timelines, we don't need to support\n            // playlists with no segments.\n\n            const firstNewSegment = playlist.segments[0];\n            const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n                return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n            }); // No matching segment from the old playlist means the entire playlist was refreshed.\n            // In this case the media sequence should account for this update, and the new segments\n            // should be marked as discontinuous from the prior content, since the last prior\n            // timeline was removed.\n\n            if (oldMatchingSegmentIndex === -1) {\n                updateMediaSequenceForPlaylist({\n                    playlist,\n                    mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n                });\n                playlist.segments[0].discontinuity = true;\n                playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n                //\n                // If the new playlist's timeline is the same as the last seen segment's timeline,\n                // then a discontinuity can be added to identify that there's potentially missing\n                // content. If there's no missing content, the discontinuity should still be rather\n                // harmless. It's possible that if segment durations are accurate enough, that the\n                // existence of a gap can be determined using the presentation times and durations,\n                // but if the segment timing info is off, it may introduce more problems than simply\n                // adding the discontinuity.\n                //\n                // If the new playlist's timeline is different from the last seen segment's timeline,\n                // then a discontinuity can be added to identify that this is the first seen segment\n                // of a new timeline. However, the logic at the start of this function that\n                // determined the disconinuity sequence by timeline index is now off by one (the\n                // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n                // we added it), so the disconinuity sequence must be decremented.\n                //\n                // A period may also have a duration of zero, so the case of no segments is handled\n                // here even though we don't yet support early available periods.\n\n                if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n                    playlist.discontinuitySequence--;\n                }\n                return;\n            } // If the first segment matched with a prior segment on a discontinuity (it's matching\n            // on the first segment of a period), then the discontinuitySequence shouldn't be the\n            // timeline's matching one, but instead should be the one prior, and the first segment\n            // of the new manifest should be marked with a discontinuity.\n            //\n            // The reason for this special case is that discontinuity sequence shows how many\n            // discontinuities have fallen off of the playlist, and discontinuities are marked on\n            // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n            // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n            // sequence, and that first segment is an indicator, but can be removed before that\n            // timeline is gone.\n\n            const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n            if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n                firstNewSegment.discontinuity = true;\n                playlist.discontinuityStarts.unshift(0);\n                playlist.discontinuitySequence--;\n            }\n            updateMediaSequenceForPlaylist({\n                playlist,\n                mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n            });\n        });\n    };\n    /**\n     * Given an old parsed manifest object and a new parsed manifest object, updates the\n     * sequence and timing values within the new manifest to ensure that it lines up with the\n     * old.\n     *\n     * @param {Array} oldManifest - the old main manifest object\n     * @param {Array} newManifest - the new main manifest object\n     *\n     * @return {Object} the updated new manifest object\n     */\n\n    const positionManifestOnTimeline = ({\n                                            oldManifest,\n                                            newManifest\n                                        }) => {\n        // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n        //\n        // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n        //\n        // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n        //\n        // Because of this change, and the difficulty of supporting periods with changing start\n        // times, periods with changing start times are not supported. This makes the logic much\n        // simpler, since periods with the same start time can be considerred the same period\n        // across refreshes.\n        //\n        // To give an example as to the difficulty of handling periods where the start time may\n        // change, if a single period manifest is refreshed with another manifest with a single\n        // period, and both the start and end times are increased, then the only way to determine\n        // if it's a new period or an old one that has changed is to look through the segments of\n        // each playlist and determine the presentation time bounds to find a match. In addition,\n        // if the period start changed to exceed the old period end, then there would be no\n        // match, and it would not be possible to determine whether the refreshed period is a new\n        // one or the old one.\n        const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n        const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n        // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n        // of properties are saved for each seen Period. Even long running live streams won't\n        // generate too many Periods, unless the stream is watched for decades. In the future,\n        // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n        // but it may not become an issue, and the additional info can be useful for debugging.\n\n        newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n        updateSequenceNumbers({\n            oldPlaylists,\n            newPlaylists,\n            timelineStarts: newManifest.timelineStarts\n        });\n        return newManifest;\n    };\n    const generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n    const mergeDiscontiguousPlaylists = playlists => {\n        // Break out playlists into groups based on their baseUrl\n        const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n            if (!acc[cur.attributes.baseUrl]) {\n                acc[cur.attributes.baseUrl] = [];\n            }\n            acc[cur.attributes.baseUrl].push(cur);\n            return acc;\n        }, {});\n        let allPlaylists = [];\n        Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n            const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n                // assuming playlist IDs are the same across periods\n                // TODO: handle multiperiod where representation sets are not the same\n                // across periods\n                const name = playlist.attributes.id + (playlist.attributes.lang || '');\n                if (!acc[name]) {\n                    // First Period\n                    acc[name] = playlist;\n                    acc[name].attributes.timelineStarts = [];\n                } else {\n                    // Subsequent Periods\n                    if (playlist.segments) {\n                        // first segment of subsequent periods signal a discontinuity\n                        if (playlist.segments[0]) {\n                            playlist.segments[0].discontinuity = true;\n                        }\n                        acc[name].segments.push(...playlist.segments);\n                    } // bubble up contentProtection, this assumes all DRM content\n                    // has the same contentProtection\n\n                    if (playlist.attributes.contentProtection) {\n                        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n                    }\n                }\n                acc[name].attributes.timelineStarts.push({\n                    // Although they represent the same number, it's important to have both to make it\n                    // compatible with HLS potentially having a similar attribute.\n                    start: playlist.attributes.periodStart,\n                    timeline: playlist.attributes.periodStart\n                });\n                return acc;\n            }, {}));\n            allPlaylists = allPlaylists.concat(mergedPlaylists);\n        });\n        return allPlaylists.map(playlist => {\n            playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n            return playlist;\n        });\n    };\n    const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n        const sidxKey = generateSidxKey(playlist.sidx);\n        const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n        if (sidxMatch) {\n            addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n        }\n        return playlist;\n    };\n    const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n        if (!Object.keys(sidxMapping).length) {\n            return playlists;\n        }\n        for (const i in playlists) {\n            playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n        }\n        return playlists;\n    };\n    const formatAudioPlaylist = ({\n                                     attributes,\n                                     segments,\n                                     sidx,\n                                     mediaSequence,\n                                     discontinuitySequence,\n                                     discontinuityStarts\n                                 }, isAudioOnly) => {\n        const playlist = {\n            attributes: {\n                NAME: attributes.id,\n                BANDWIDTH: attributes.bandwidth,\n                CODECS: attributes.codecs,\n                ['PROGRAM-ID']: 1\n            },\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: attributes.baseUrl || '',\n            targetDuration: attributes.duration,\n            discontinuitySequence,\n            discontinuityStarts,\n            timelineStarts: attributes.timelineStarts,\n            mediaSequence,\n            segments\n        };\n        if (attributes.contentProtection) {\n            playlist.contentProtection = attributes.contentProtection;\n        }\n        if (attributes.serviceLocation) {\n            playlist.attributes.serviceLocation = attributes.serviceLocation;\n        }\n        if (sidx) {\n            playlist.sidx = sidx;\n        }\n        if (isAudioOnly) {\n            playlist.attributes.AUDIO = 'audio';\n            playlist.attributes.SUBTITLES = 'subs';\n        }\n        return playlist;\n    };\n    const formatVttPlaylist = ({\n                                   attributes,\n                                   segments,\n                                   mediaSequence,\n                                   discontinuityStarts,\n                                   discontinuitySequence\n                               }) => {\n        if (typeof segments === 'undefined') {\n            // vtt tracks may use single file in BaseURL\n            segments = [{\n                uri: attributes.baseUrl,\n                timeline: attributes.periodStart,\n                resolvedUri: attributes.baseUrl || '',\n                duration: attributes.sourceDuration,\n                number: 0\n            }]; // targetDuration should be the same duration as the only segment\n\n            attributes.duration = attributes.sourceDuration;\n        }\n        const m3u8Attributes = {\n            NAME: attributes.id,\n            BANDWIDTH: attributes.bandwidth,\n            ['PROGRAM-ID']: 1\n        };\n        if (attributes.codecs) {\n            m3u8Attributes.CODECS = attributes.codecs;\n        }\n        const vttPlaylist = {\n            attributes: m3u8Attributes,\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: attributes.baseUrl || '',\n            targetDuration: attributes.duration,\n            timelineStarts: attributes.timelineStarts,\n            discontinuityStarts,\n            discontinuitySequence,\n            mediaSequence,\n            segments\n        };\n        if (attributes.serviceLocation) {\n            vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n        }\n        return vttPlaylist;\n    };\n    const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n        let mainPlaylist;\n        const formattedPlaylists = playlists.reduce((a, playlist) => {\n            const role = playlist.attributes.role && playlist.attributes.role.value || '';\n            const language = playlist.attributes.lang || '';\n            let label = playlist.attributes.label || 'main';\n            if (language && !playlist.attributes.label) {\n                const roleLabel = role ? ` (${role})` : '';\n                label = `${playlist.attributes.lang}${roleLabel}`;\n            }\n            if (!a[label]) {\n                a[label] = {\n                    language,\n                    autoselect: true,\n                    default: role === 'main',\n                    playlists: [],\n                    uri: ''\n                };\n            }\n            const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n            a[label].playlists.push(formatted);\n            if (typeof mainPlaylist === 'undefined' && role === 'main') {\n                mainPlaylist = playlist;\n                mainPlaylist.default = true;\n            }\n            return a;\n        }, {}); // if no playlists have role \"main\", mark the first as main\n\n        if (!mainPlaylist) {\n            const firstLabel = Object.keys(formattedPlaylists)[0];\n            formattedPlaylists[firstLabel].default = true;\n        }\n        return formattedPlaylists;\n    };\n    const organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n        return playlists.reduce((a, playlist) => {\n            const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n            if (!a[label]) {\n                a[label] = {\n                    language: label,\n                    default: false,\n                    autoselect: false,\n                    playlists: [],\n                    uri: ''\n                };\n            }\n            a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n            return a;\n        }, {});\n    };\n    const organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n        if (!svc) {\n            return svcObj;\n        }\n        svc.forEach(service => {\n            const {\n                channel,\n                language\n            } = service;\n            svcObj[language] = {\n                autoselect: false,\n                default: false,\n                instreamId: channel,\n                language\n            };\n            if (service.hasOwnProperty('aspectRatio')) {\n                svcObj[language].aspectRatio = service.aspectRatio;\n            }\n            if (service.hasOwnProperty('easyReader')) {\n                svcObj[language].easyReader = service.easyReader;\n            }\n            if (service.hasOwnProperty('3D')) {\n                svcObj[language]['3D'] = service['3D'];\n            }\n        });\n        return svcObj;\n    }, {});\n    const formatVideoPlaylist = ({\n                                     attributes,\n                                     segments,\n                                     sidx,\n                                     discontinuityStarts\n                                 }) => {\n        const playlist = {\n            attributes: {\n                NAME: attributes.id,\n                AUDIO: 'audio',\n                SUBTITLES: 'subs',\n                RESOLUTION: {\n                    width: attributes.width,\n                    height: attributes.height\n                },\n                CODECS: attributes.codecs,\n                BANDWIDTH: attributes.bandwidth,\n                ['PROGRAM-ID']: 1\n            },\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: attributes.baseUrl || '',\n            targetDuration: attributes.duration,\n            discontinuityStarts,\n            timelineStarts: attributes.timelineStarts,\n            segments\n        };\n        if (attributes.frameRate) {\n            playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n        }\n        if (attributes.contentProtection) {\n            playlist.contentProtection = attributes.contentProtection;\n        }\n        if (attributes.serviceLocation) {\n            playlist.attributes.serviceLocation = attributes.serviceLocation;\n        }\n        if (sidx) {\n            playlist.sidx = sidx;\n        }\n        return playlist;\n    };\n    const videoOnly = ({\n                           attributes\n                       }) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n    const audioOnly = ({\n                           attributes\n                       }) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n    const vttOnly = ({\n                         attributes\n                     }) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n    /**\n     * Contains start and timeline properties denoting a timeline start. For DASH, these will\n     * be the same number.\n     *\n     * @typedef {Object} TimelineStart\n     * @property {number} start - the start time of the timeline\n     * @property {number} timeline - the timeline number\n     */\n\n    /**\n     * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n     *\n     * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n     * DASH specific attribute used in constructing segment URI's from templates. However, from\n     * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n     * value, which should start at the original media sequence value (or 0) and increment by 1\n     * for each segment thereafter. Since DASH's `startNumber` values are independent per\n     * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n     * from a 0 mediaSequence value and increment from there.\n     *\n     * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n     * debugging and making sense of the manifest.\n     *\n     * For live playlists, to account for values increasing in manifests when periods are\n     * removed on refreshes, merging logic should be used to update the numbers to their\n     * appropriate values (to ensure they're sequential and increasing).\n     *\n     * @param {Object[]} playlists - the playlists to update\n     * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n     */\n\n    const addMediaSequenceValues = (playlists, timelineStarts) => {\n        // increment all segments sequentially\n        playlists.forEach(playlist => {\n            playlist.mediaSequence = 0;\n            playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n                                                                                    timeline\n                                                                                }) {\n                return timeline === playlist.timeline;\n            });\n            if (!playlist.segments) {\n                return;\n            }\n            playlist.segments.forEach((segment, index) => {\n                segment.number = index;\n            });\n        });\n    };\n    /**\n     * Given a media group object, flattens all playlists within the media group into a single\n     * array.\n     *\n     * @param {Object} mediaGroupObject - the media group object\n     *\n     * @return {Object[]}\n     *         The media group playlists\n     */\n\n    const flattenMediaGroupPlaylists = mediaGroupObject => {\n        if (!mediaGroupObject) {\n            return [];\n        }\n        return Object.keys(mediaGroupObject).reduce((acc, label) => {\n            const labelContents = mediaGroupObject[label];\n            return acc.concat(labelContents.playlists);\n        }, []);\n    };\n    const toM3u8 = ({\n                        dashPlaylists,\n                        locations,\n                        contentSteering,\n                        sidxMapping = {},\n                        previousManifest,\n                        eventStream\n                    }) => {\n        if (!dashPlaylists.length) {\n            return {};\n        } // grab all main manifest attributes\n\n        const {\n            sourceDuration: duration,\n            type,\n            suggestedPresentationDelay,\n            minimumUpdatePeriod\n        } = dashPlaylists[0].attributes;\n        const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n        const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n        const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n        const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n        const manifest = {\n            allowCache: true,\n            discontinuityStarts: [],\n            segments: [],\n            endList: true,\n            mediaGroups: {\n                AUDIO: {},\n                VIDEO: {},\n                ['CLOSED-CAPTIONS']: {},\n                SUBTITLES: {}\n            },\n            uri: '',\n            duration,\n            playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n        };\n        if (minimumUpdatePeriod >= 0) {\n            manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n        }\n        if (locations) {\n            manifest.locations = locations;\n        }\n        if (contentSteering) {\n            manifest.contentSteering = contentSteering;\n        }\n        if (type === 'dynamic') {\n            manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n        }\n        if (eventStream && eventStream.length > 0) {\n            manifest.eventStream = eventStream;\n        }\n        const isAudioOnly = manifest.playlists.length === 0;\n        const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n        const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n        const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n        const playlistTimelineStarts = formattedPlaylists.map(({\n                                                                   timelineStarts\n                                                               }) => timelineStarts);\n        manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n        addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n        if (organizedAudioGroup) {\n            manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n        }\n        if (organizedVttGroup) {\n            manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n        }\n        if (captions.length) {\n            manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n        }\n        if (previousManifest) {\n            return positionManifestOnTimeline({\n                oldManifest: previousManifest,\n                newManifest: manifest\n            });\n        }\n        return manifest;\n    };\n\n    /**\n     * Calculates the R (repetition) value for a live stream (for the final segment\n     * in a manifest where the r value is negative 1)\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {number} time\n     *        current time (typically the total time up until the final segment)\n     * @param {number} duration\n     *        duration property for the given <S />\n     *\n     * @return {number}\n     *        R value to reach the end of the given period\n     */\n    const getLiveRValue = (attributes, time, duration) => {\n        const {\n            NOW,\n            clientOffset,\n            availabilityStartTime,\n            timescale = 1,\n            periodStart = 0,\n            minimumUpdatePeriod = 0\n        } = attributes;\n        const now = (NOW + clientOffset) / 1000;\n        const periodStartWC = availabilityStartTime + periodStart;\n        const periodEndWC = now + minimumUpdatePeriod;\n        const periodDuration = periodEndWC - periodStartWC;\n        return Math.ceil((periodDuration * timescale - time) / duration);\n    };\n    /**\n     * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n     * timing and duration\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseByTimeline = (attributes, segmentTimeline) => {\n        const {\n            type,\n            minimumUpdatePeriod = 0,\n            media = '',\n            sourceDuration,\n            timescale = 1,\n            startNumber = 1,\n            periodStart: timeline\n        } = attributes;\n        const segments = [];\n        let time = -1;\n        for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n            const S = segmentTimeline[sIndex];\n            const duration = S.d;\n            const repeat = S.r || 0;\n            const segmentTime = S.t || 0;\n            if (time < 0) {\n                // first segment\n                time = segmentTime;\n            }\n            if (segmentTime && segmentTime > time) {\n                // discontinuity\n                // TODO: How to handle this type of discontinuity\n                // timeline++ here would treat it like HLS discontuity and content would\n                // get appended without gap\n                // E.G.\n                //  <S t=\"0\" d=\"1\" />\n                //  <S d=\"1\" />\n                //  <S d=\"1\" />\n                //  <S t=\"5\" d=\"1\" />\n                // would have $Time$ values of [0, 1, 2, 5]\n                // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n                // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n                // does the value of sourceDuration consider this when calculating arbitrary\n                // negative @r repeat value?\n                // E.G. Same elements as above with this added at the end\n                //  <S d=\"1\" r=\"-1\" />\n                //  with a sourceDuration of 10\n                // Would the 2 gaps be included in the time duration calculations resulting in\n                // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n                // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n                time = segmentTime;\n            }\n            let count;\n            if (repeat < 0) {\n                const nextS = sIndex + 1;\n                if (nextS === segmentTimeline.length) {\n                    // last segment\n                    if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n                        count = getLiveRValue(attributes, time, duration);\n                    } else {\n                        // TODO: This may be incorrect depending on conclusion of TODO above\n                        count = (sourceDuration * timescale - time) / duration;\n                    }\n                } else {\n                    count = (segmentTimeline[nextS].t - time) / duration;\n                }\n            } else {\n                count = repeat + 1;\n            }\n            const end = startNumber + segments.length + count;\n            let number = startNumber + segments.length;\n            while (number < end) {\n                segments.push({\n                    number,\n                    duration: duration / timescale,\n                    time,\n                    timeline\n                });\n                time += duration;\n                number++;\n            }\n        }\n        return segments;\n    };\n    const identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n    /**\n     * Replaces template identifiers with corresponding values. To be used as the callback\n     * for String.prototype.replace\n     *\n     * @name replaceCallback\n     * @function\n     * @param {string} match\n     *        Entire match of identifier\n     * @param {string} identifier\n     *        Name of matched identifier\n     * @param {string} format\n     *        Format tag string. Its presence indicates that padding is expected\n     * @param {string} width\n     *        Desired length of the replaced value. Values less than this width shall be left\n     *        zero padded\n     * @return {string}\n     *         Replacement for the matched identifier\n     */\n\n    /**\n     * Returns a function to be used as a callback for String.prototype.replace to replace\n     * template identifiers\n     *\n     * @param {Obect} values\n     *        Object containing values that shall be used to replace known identifiers\n     * @param {number} values.RepresentationID\n     *        Value of the Representation@id attribute\n     * @param {number} values.Number\n     *        Number of the corresponding segment\n     * @param {number} values.Bandwidth\n     *        Value of the Representation@bandwidth attribute.\n     * @param {number} values.Time\n     *        Timestamp value of the corresponding segment\n     * @return {replaceCallback}\n     *         Callback to be used with String.prototype.replace to replace identifiers\n     */\n\n    const identifierReplacement = values => (match, identifier, format, width) => {\n        if (match === '$$') {\n            // escape sequence\n            return '$';\n        }\n        if (typeof values[identifier] === 'undefined') {\n            return match;\n        }\n        const value = '' + values[identifier];\n        if (identifier === 'RepresentationID') {\n            // Format tag shall not be present with RepresentationID\n            return value;\n        }\n        if (!format) {\n            width = 1;\n        } else {\n            width = parseInt(width, 10);\n        }\n        if (value.length >= width) {\n            return value;\n        }\n        return `${new Array(width - value.length + 1).join('0')}${value}`;\n    };\n    /**\n     * Constructs a segment url from a template string\n     *\n     * @param {string} url\n     *        Template string to construct url from\n     * @param {Obect} values\n     *        Object containing values that shall be used to replace known identifiers\n     * @param {number} values.RepresentationID\n     *        Value of the Representation@id attribute\n     * @param {number} values.Number\n     *        Number of the corresponding segment\n     * @param {number} values.Bandwidth\n     *        Value of the Representation@bandwidth attribute.\n     * @param {number} values.Time\n     *        Timestamp value of the corresponding segment\n     * @return {string}\n     *         Segment url with identifiers replaced\n     */\n\n    const constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n    /**\n     * Generates a list of objects containing timing and duration information about each\n     * segment needed to generate segment uris and the complete segment object\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseTemplateInfo = (attributes, segmentTimeline) => {\n        if (!attributes.duration && !segmentTimeline) {\n            // if neither @duration or SegmentTimeline are present, then there shall be exactly\n            // one media segment\n            return [{\n                number: attributes.startNumber || 1,\n                duration: attributes.sourceDuration,\n                time: 0,\n                timeline: attributes.periodStart\n            }];\n        }\n        if (attributes.duration) {\n            return parseByDuration(attributes);\n        }\n        return parseByTimeline(attributes, segmentTimeline);\n    };\n    /**\n     * Generates a list of segments using information provided by the SegmentTemplate element\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {Object[]}\n     *         List of segment objects\n     */\n\n    const segmentsFromTemplate = (attributes, segmentTimeline) => {\n        const templateValues = {\n            RepresentationID: attributes.id,\n            Bandwidth: attributes.bandwidth || 0\n        };\n        const {\n            initialization = {\n                sourceURL: '',\n                range: ''\n            }\n        } = attributes;\n        const mapSegment = urlTypeToSegment({\n            baseUrl: attributes.baseUrl,\n            source: constructTemplateUrl(initialization.sourceURL, templateValues),\n            range: initialization.range\n        });\n        const segments = parseTemplateInfo(attributes, segmentTimeline);\n        return segments.map(segment => {\n            templateValues.Number = segment.number;\n            templateValues.Time = segment.time;\n            const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n            // - if timescale isn't present on any level, default to 1.\n\n            const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n            const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n            const presentationTime =\n                // Even if the @t attribute is not specified for the segment, segment.time is\n                // calculated in mpd-parser prior to this, so it's assumed to be available.\n                attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n            const map = {\n                uri,\n                timeline: segment.timeline,\n                duration: segment.duration,\n                resolvedUri: resolveUrl$1(attributes.baseUrl || '', uri),\n                map: mapSegment,\n                number: segment.number,\n                presentationTime\n            };\n            return map;\n        });\n    };\n\n    /**\n     * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n     * to an object that matches the output of a segment in videojs/mpd-parser\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @param {Object} segmentUrl\n     *   <SegmentURL> node to translate into a segment object\n     * @return {Object} translated segment object\n     */\n\n    const SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n        const {\n            baseUrl,\n            initialization = {}\n        } = attributes;\n        const initSegment = urlTypeToSegment({\n            baseUrl,\n            source: initialization.sourceURL,\n            range: initialization.range\n        });\n        const segment = urlTypeToSegment({\n            baseUrl,\n            source: segmentUrl.media,\n            range: segmentUrl.mediaRange\n        });\n        segment.map = initSegment;\n        return segment;\n    };\n    /**\n     * Generates a list of segments using information provided by the SegmentList element\n     * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n     * node should be translated into segment.\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {Object.<Array>} list of segments\n     */\n\n    const segmentsFromList = (attributes, segmentTimeline) => {\n        const {\n            duration,\n            segmentUrls = [],\n            periodStart\n        } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n        // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n        if (!duration && !segmentTimeline || duration && segmentTimeline) {\n            throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n        }\n        const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n        let segmentTimeInfo;\n        if (duration) {\n            segmentTimeInfo = parseByDuration(attributes);\n        }\n        if (segmentTimeline) {\n            segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n        }\n        const segments = segmentTimeInfo.map((segmentTime, index) => {\n            if (segmentUrlMap[index]) {\n                const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n                // - if timescale isn't present on any level, default to 1.\n\n                const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n                const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n                segment.timeline = segmentTime.timeline;\n                segment.duration = segmentTime.duration;\n                segment.number = segmentTime.number;\n                segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n                return segment;\n            } // Since we're mapping we should get rid of any blank segments (in case\n            // the given SegmentTimeline is handling for more elements than we have\n            // SegmentURLs for).\n        }).filter(segment => segment);\n        return segments;\n    };\n    const generateSegments = ({\n                                  attributes,\n                                  segmentInfo\n                              }) => {\n        let segmentAttributes;\n        let segmentsFn;\n        if (segmentInfo.template) {\n            segmentsFn = segmentsFromTemplate;\n            segmentAttributes = merge$1(attributes, segmentInfo.template);\n        } else if (segmentInfo.base) {\n            segmentsFn = segmentsFromBase;\n            segmentAttributes = merge$1(attributes, segmentInfo.base);\n        } else if (segmentInfo.list) {\n            segmentsFn = segmentsFromList;\n            segmentAttributes = merge$1(attributes, segmentInfo.list);\n        }\n        const segmentsInfo = {\n            attributes\n        };\n        if (!segmentsFn) {\n            return segmentsInfo;\n        }\n        const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n        // must be in seconds. Since we've generated the segment list, we no longer need\n        // @duration to be in @timescale units, so we can convert it here.\n\n        if (segmentAttributes.duration) {\n            const {\n                duration,\n                timescale = 1\n            } = segmentAttributes;\n            segmentAttributes.duration = duration / timescale;\n        } else if (segments.length) {\n            // if there is no @duration attribute, use the largest segment duration as\n            // as target duration\n            segmentAttributes.duration = segments.reduce((max, segment) => {\n                return Math.max(max, Math.ceil(segment.duration));\n            }, 0);\n        } else {\n            segmentAttributes.duration = 0;\n        }\n        segmentsInfo.attributes = segmentAttributes;\n        segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n        if (segmentInfo.base && segmentAttributes.indexRange) {\n            segmentsInfo.sidx = segments[0];\n            segmentsInfo.segments = [];\n        }\n        return segmentsInfo;\n    };\n    const toPlaylists = representations => representations.map(generateSegments);\n    const findChildren = (element, name) => from(element.childNodes).filter(({\n                                                                                 tagName\n                                                                             }) => tagName === name);\n    const getContent = element => element.textContent.trim();\n\n    /**\n     * Converts the provided string that may contain a division operation to a number.\n     *\n     * @param {string} value - the provided string value\n     *\n     * @return {number} the parsed string value\n     */\n    const parseDivisionValue = value => {\n        return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n    };\n    const parseDuration = str => {\n        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n        const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n        const SECONDS_IN_DAY = 24 * 60 * 60;\n        const SECONDS_IN_HOUR = 60 * 60;\n        const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n        const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n        const match = durationRegex.exec(str);\n        if (!match) {\n            return 0;\n        }\n        const [year, month, day, hour, minute, second] = match.slice(1);\n        return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n    };\n    const parseDate = str => {\n        // Date format without timezone according to ISO 8601\n        // YYY-MM-DDThh:mm:ss.ssssss\n        const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n        // expressed by ending with 'Z'\n\n        if (dateRegex.test(str)) {\n            str += 'Z';\n        }\n        return Date.parse(str);\n    };\n    const parsers = {\n        /**\n         * Specifies the duration of the entire Media Presentation. Format is a duration string\n         * as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        mediaPresentationDuration(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the Segment availability start time for all Segments referred to in this\n         * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n         * time. Format is a date string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The date as seconds from unix epoch\n         */\n        availabilityStartTime(value) {\n            return parseDate(value) / 1000;\n        },\n        /**\n         * Specifies the smallest period between potential changes to the MPD. Format is a\n         * duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        minimumUpdatePeriod(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the suggested presentation delay. Format is a\n         * duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        suggestedPresentationDelay(value) {\n            return parseDuration(value);\n        },\n        /**\n         * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         *\n         * @return {string}\n         *         The type as a string\n         */\n        type(value) {\n            return value;\n        },\n        /**\n         * Specifies the duration of the smallest time shifting buffer for any Representation\n         * in the MPD. Format is a duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        timeShiftBufferDepth(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n         * Format is a duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        start(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the width of the visual presentation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed width\n         */\n        width(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the height of the visual presentation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed height\n         */\n        height(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the bitrate of the representation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed bandwidth\n         */\n        bandwidth(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the frame rate of the representation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed frame rate\n         */\n        frameRate(value) {\n            return parseDivisionValue(value);\n        },\n        /**\n         * Specifies the number of the first Media Segment in this Representation in the Period\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed number\n         */\n        startNumber(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the timescale in units per seconds\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed timescale\n         */\n        timescale(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the presentationTimeOffset.\n         *\n         * @param {string} value\n         *        value of the attribute as a string\n         *\n         * @return {number}\n         *         The parsed presentationTimeOffset\n         */\n        presentationTimeOffset(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the constant approximate Segment duration\n         * NOTE: The <Period> element also contains an @duration attribute. This duration\n         *       specifies the duration of the Period. This attribute is currently not\n         *       supported by the rest of the parser, however we still check for it to prevent\n         *       errors.\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed duration\n         */\n        duration(value) {\n            const parsedValue = parseInt(value, 10);\n            if (isNaN(parsedValue)) {\n                return parseDuration(value);\n            }\n            return parsedValue;\n        },\n        /**\n         * Specifies the Segment duration, in units of the value of the @timescale.\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed duration\n         */\n        d(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the MPD start time, in @timescale units, the first Segment in the series\n         * starts relative to the beginning of the Period\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed time\n         */\n        t(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the repeat count of the number of following contiguous Segments with the\n         * same duration expressed by the value of @d\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed number\n         */\n        r(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the presentationTime.\n         *\n         * @param {string} value\n         *        value of the attribute as a string\n         *\n         * @return {number}\n         *         The parsed presentationTime\n         */\n        presentationTime(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Default parser for all other attributes. Acts as a no-op and just returns the value\n         * as a string\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {string}\n         *         Unparsed value\n         */\n        DEFAULT(value) {\n            return value;\n        }\n    };\n    /**\n     * Gets all the attributes and values of the provided node, parses attributes with known\n     * types, and returns an object with attribute names mapped to values.\n     *\n     * @param {Node} el\n     *        The node to parse attributes from\n     * @return {Object}\n     *         Object with all attributes of el parsed\n     */\n\n    const parseAttributes = el => {\n        if (!(el && el.attributes)) {\n            return {};\n        }\n        return from(el.attributes).reduce((a, e) => {\n            const parseFn = parsers[e.name] || parsers.DEFAULT;\n            a[e.name] = parseFn(e.value);\n            return a;\n        }, {});\n    };\n    const keySystemsMap = {\n        'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n        'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n        'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n        'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime',\n        // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme\n        'urn:mpeg:dash:mp4protection:2011': 'mp4protection'\n    };\n    /**\n     * Builds a list of urls that is the product of the reference urls and BaseURL values\n     *\n     * @param {Object[]} references\n     *        List of objects containing the reference URL as well as its attributes\n     * @param {Node[]} baseUrlElements\n     *        List of BaseURL nodes from the mpd\n     * @return {Object[]}\n     *         List of objects with resolved urls and attributes\n     */\n\n    const buildBaseUrls = (references, baseUrlElements) => {\n        if (!baseUrlElements.length) {\n            return references;\n        }\n        return flatten(references.map(function (reference) {\n            return baseUrlElements.map(function (baseUrlElement) {\n                const initialBaseUrl = getContent(baseUrlElement);\n                const resolvedBaseUrl = resolveUrl$1(reference.baseUrl, initialBaseUrl);\n                const finalBaseUrl = merge$1(parseAttributes(baseUrlElement), {\n                    baseUrl: resolvedBaseUrl\n                }); // If the URL is resolved, we want to get the serviceLocation from the reference\n                // assuming there is no serviceLocation on the initialBaseUrl\n\n                if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n                    finalBaseUrl.serviceLocation = reference.serviceLocation;\n                }\n                return finalBaseUrl;\n            });\n        }));\n    };\n    /**\n     * Contains all Segment information for its containing AdaptationSet\n     *\n     * @typedef {Object} SegmentInformation\n     * @property {Object|undefined} template\n     *           Contains the attributes for the SegmentTemplate node\n     * @property {Object[]|undefined} segmentTimeline\n     *           Contains a list of atrributes for each S node within the SegmentTimeline node\n     * @property {Object|undefined} list\n     *           Contains the attributes for the SegmentList node\n     * @property {Object|undefined} base\n     *           Contains the attributes for the SegmentBase node\n     */\n\n    /**\n     * Returns all available Segment information contained within the AdaptationSet node\n     *\n     * @param {Node} adaptationSet\n     *        The AdaptationSet node to get Segment information from\n     * @return {SegmentInformation}\n     *         The Segment information contained within the provided AdaptationSet\n     */\n\n    const getSegmentInformation = adaptationSet => {\n        const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n        const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n        const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge$1({\n            tag: 'SegmentURL'\n        }, parseAttributes(s)));\n        const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n        const segmentTimelineParentNode = segmentList || segmentTemplate;\n        const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n        const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n        const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n        // @initialization and an <Initialization> node.  @initialization can be templated,\n        // while the node can have a url and range specified.  If the <SegmentTemplate> has\n        // both @initialization and an <Initialization> subelement we opt to override with\n        // the node, as this interaction is not defined in the spec.\n\n        const template = segmentTemplate && parseAttributes(segmentTemplate);\n        if (template && segmentInitialization) {\n            template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n        } else if (template && template.initialization) {\n            // If it is @initialization we convert it to an object since this is the format that\n            // later functions will rely on for the initialization segment.  This is only valid\n            // for <SegmentTemplate>\n            template.initialization = {\n                sourceURL: template.initialization\n            };\n        }\n        const segmentInfo = {\n            template,\n            segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n            list: segmentList && merge$1(parseAttributes(segmentList), {\n                segmentUrls,\n                initialization: parseAttributes(segmentInitialization)\n            }),\n            base: segmentBase && merge$1(parseAttributes(segmentBase), {\n                initialization: parseAttributes(segmentInitialization)\n            })\n        };\n        Object.keys(segmentInfo).forEach(key => {\n            if (!segmentInfo[key]) {\n                delete segmentInfo[key];\n            }\n        });\n        return segmentInfo;\n    };\n    /**\n     * Contains Segment information and attributes needed to construct a Playlist object\n     * from a Representation\n     *\n     * @typedef {Object} RepresentationInformation\n     * @property {SegmentInformation} segmentInfo\n     *           Segment information for this Representation\n     * @property {Object} attributes\n     *           Inherited attributes for this Representation\n     */\n\n    /**\n     * Maps a Representation node to an object containing Segment information and attributes\n     *\n     * @name inheritBaseUrlsCallback\n     * @function\n     * @param {Node} representation\n     *        Representation node from the mpd\n     * @return {RepresentationInformation}\n     *         Representation information needed to construct a Playlist object\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping Representation nodes to\n     * Segment information and attributes using inherited BaseURL nodes.\n     *\n     * @param {Object} adaptationSetAttributes\n     *        Contains attributes inherited by the AdaptationSet\n     * @param {Object[]} adaptationSetBaseUrls\n     *        List of objects containing resolved base URLs and attributes\n     *        inherited by the AdaptationSet\n     * @param {SegmentInformation} adaptationSetSegmentInfo\n     *        Contains Segment information for the AdaptationSet\n     * @return {inheritBaseUrlsCallback}\n     *         Callback map function\n     */\n\n    const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n        const repBaseUrlElements = findChildren(representation, 'BaseURL');\n        const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n        const attributes = merge$1(adaptationSetAttributes, parseAttributes(representation));\n        const representationSegmentInfo = getSegmentInformation(representation);\n        return repBaseUrls.map(baseUrl => {\n            return {\n                segmentInfo: merge$1(adaptationSetSegmentInfo, representationSegmentInfo),\n                attributes: merge$1(attributes, baseUrl)\n            };\n        });\n    };\n    /**\n     * Tranforms a series of content protection nodes to\n     * an object containing pssh data by key system\n     *\n     * @param {Node[]} contentProtectionNodes\n     *        Content protection nodes\n     * @return {Object}\n     *        Object containing pssh data by key system\n     */\n\n    const generateKeySystemInformation = contentProtectionNodes => {\n        return contentProtectionNodes.reduce((acc, node) => {\n            const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n            // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n            // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n            // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n            if (attributes.schemeIdUri) {\n                attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n            }\n            const keySystem = keySystemsMap[attributes.schemeIdUri];\n            if (keySystem) {\n                acc[keySystem] = {\n                    attributes\n                };\n                const psshNode = findChildren(node, 'cenc:pssh')[0];\n                if (psshNode) {\n                    const pssh = getContent(psshNode);\n                    acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n                }\n            }\n            return acc;\n        }, {});\n    }; // defined in ANSI_SCTE 214-1 2016\n\n    const parseCaptionServiceMetadata = service => {\n        // 608 captions\n        if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n            const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n            return values.map(value => {\n                let channel;\n                let language; // default language to value\n\n                language = value;\n                if (/^CC\\d=/.test(value)) {\n                    [channel, language] = value.split('=');\n                } else if (/^CC\\d$/.test(value)) {\n                    channel = value;\n                }\n                return {\n                    channel,\n                    language\n                };\n            });\n        } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n            const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n            return values.map(value => {\n                const flags = {\n                    // service or channel number 1-63\n                    'channel': undefined,\n                    // language is a 3ALPHA per ISO 639.2/B\n                    // field is required\n                    'language': undefined,\n                    // BIT 1/0 or ?\n                    // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n                    'aspectRatio': 1,\n                    // BIT 1/0\n                    // easy reader flag indicated the text is tailed to the needs of beginning readers\n                    // default 0, or off\n                    'easyReader': 0,\n                    // BIT 1/0\n                    // If 3d metadata is present (CEA-708.1) then 1\n                    // default 0\n                    '3D': 0\n                };\n                if (/=/.test(value)) {\n                    const [channel, opts = ''] = value.split('=');\n                    flags.channel = channel;\n                    flags.language = value;\n                    opts.split(',').forEach(opt => {\n                        const [name, val] = opt.split(':');\n                        if (name === 'lang') {\n                            flags.language = val; // er for easyReadery\n                        } else if (name === 'er') {\n                            flags.easyReader = Number(val); // war for wide aspect ratio\n                        } else if (name === 'war') {\n                            flags.aspectRatio = Number(val);\n                        } else if (name === '3D') {\n                            flags['3D'] = Number(val);\n                        }\n                    });\n                } else {\n                    flags.language = value;\n                }\n                if (flags.channel) {\n                    flags.channel = 'SERVICE' + flags.channel;\n                }\n                return flags;\n            });\n        }\n    };\n    /**\n     * A map callback that will parse all event stream data for a collection of periods\n     * DASH ISO_IEC_23009 5.10.2.2\n     * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n     *\n     * @param {PeriodInformation} period object containing necessary period information\n     * @return a collection of parsed eventstream event objects\n     */\n\n    const toEventStream = period => {\n        // get and flatten all EventStreams tags and parse attributes and children\n        return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n            const eventStreamAttributes = parseAttributes(eventStream);\n            const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n            return findChildren(eventStream, 'Event').map(event => {\n                const eventAttributes = parseAttributes(event);\n                const presentationTime = eventAttributes.presentationTime || 0;\n                const timescale = eventStreamAttributes.timescale || 1;\n                const duration = eventAttributes.duration || 0;\n                const start = presentationTime / timescale + period.attributes.start;\n                return {\n                    schemeIdUri,\n                    value: eventStreamAttributes.value,\n                    id: eventAttributes.id,\n                    start,\n                    end: start + duration / timescale,\n                    messageData: getContent(event) || eventAttributes.messageData,\n                    contentEncoding: eventStreamAttributes.contentEncoding,\n                    presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n                };\n            });\n        }));\n    };\n    /**\n     * Maps an AdaptationSet node to a list of Representation information objects\n     *\n     * @name toRepresentationsCallback\n     * @function\n     * @param {Node} adaptationSet\n     *        AdaptationSet node from the mpd\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representaion information\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n     * Representation information objects\n     *\n     * @param {Object} periodAttributes\n     *        Contains attributes inherited by the Period\n     * @param {Object[]} periodBaseUrls\n     *        Contains list of objects with resolved base urls and attributes\n     *        inherited by the Period\n     * @param {string[]} periodSegmentInfo\n     *        Contains Segment Information at the period level\n     * @return {toRepresentationsCallback}\n     *         Callback map function\n     */\n\n    const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n        const adaptationSetAttributes = parseAttributes(adaptationSet);\n        const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n        const role = findChildren(adaptationSet, 'Role')[0];\n        const roleAttributes = {\n            role: parseAttributes(role)\n        };\n        let attrs = merge$1(periodAttributes, adaptationSetAttributes, roleAttributes);\n        const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n        const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n        if (captionServices) {\n            attrs = merge$1(attrs, {\n                captionServices\n            });\n        }\n        const label = findChildren(adaptationSet, 'Label')[0];\n        if (label && label.childNodes.length) {\n            const labelVal = label.childNodes[0].nodeValue.trim();\n            attrs = merge$1(attrs, {\n                label: labelVal\n            });\n        }\n        const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n        if (Object.keys(contentProtection).length) {\n            attrs = merge$1(attrs, {\n                contentProtection\n            });\n        }\n        const segmentInfo = getSegmentInformation(adaptationSet);\n        const representations = findChildren(adaptationSet, 'Representation');\n        const adaptationSetSegmentInfo = merge$1(periodSegmentInfo, segmentInfo);\n        return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n    };\n    /**\n     * Contains all period information for mapping nodes onto adaptation sets.\n     *\n     * @typedef {Object} PeriodInformation\n     * @property {Node} period.node\n     *           Period node from the mpd\n     * @property {Object} period.attributes\n     *           Parsed period attributes from node plus any added\n     */\n\n    /**\n     * Maps a PeriodInformation object to a list of Representation information objects for all\n     * AdaptationSet nodes contained within the Period.\n     *\n     * @name toAdaptationSetsCallback\n     * @function\n     * @param {PeriodInformation} period\n     *        Period object containing necessary period information\n     * @param {number} periodStart\n     *        Start time of the Period within the mpd\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representaion information\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n     * Representation information objects\n     *\n     * @param {Object} mpdAttributes\n     *        Contains attributes inherited by the mpd\n     * @param {Object[]} mpdBaseUrls\n     *        Contains list of objects with resolved base urls and attributes\n     *        inherited by the mpd\n     * @return {toAdaptationSetsCallback}\n     *         Callback map function\n     */\n\n    const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n        const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n        const periodAttributes = merge$1(mpdAttributes, {\n            periodStart: period.attributes.start\n        });\n        if (typeof period.attributes.duration === 'number') {\n            periodAttributes.periodDuration = period.attributes.duration;\n        }\n        const adaptationSets = findChildren(period.node, 'AdaptationSet');\n        const periodSegmentInfo = getSegmentInformation(period.node);\n        return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n    };\n    /**\n     * Tranforms an array of content steering nodes into an object\n     * containing CDN content steering information from the MPD manifest.\n     *\n     * For more information on the DASH spec for Content Steering parsing, see:\n     * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n     *\n     * @param {Node[]} contentSteeringNodes\n     *        Content steering nodes\n     * @param {Function} eventHandler\n     *        The event handler passed into the parser options to handle warnings\n     * @return {Object}\n     *        Object containing content steering data\n     */\n\n    const generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n        // If there are more than one ContentSteering tags, throw an error\n        if (contentSteeringNodes.length > 1) {\n            eventHandler({\n                type: 'warn',\n                message: 'The MPD manifest should contain no more than one ContentSteering tag'\n            });\n        } // Return a null value if there are no ContentSteering tags\n\n        if (!contentSteeringNodes.length) {\n            return null;\n        }\n        const infoFromContentSteeringTag = merge$1({\n            serverURL: getContent(contentSteeringNodes[0])\n        }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n        // to `false` if it doesn't exist\n\n        infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n        return infoFromContentSteeringTag;\n    };\n    /**\n     * Gets Period@start property for a given period.\n     *\n     * @param {Object} options\n     *        Options object\n     * @param {Object} options.attributes\n     *        Period attributes\n     * @param {Object} [options.priorPeriodAttributes]\n     *        Prior period attributes (if prior period is available)\n     * @param {string} options.mpdType\n     *        The MPD@type these periods came from\n     * @return {number|null}\n     *         The period start, or null if it's an early available period or error\n     */\n\n    const getPeriodStart = ({\n                                attributes,\n                                priorPeriodAttributes,\n                                mpdType\n                            }) => {\n        // Summary of period start time calculation from DASH spec section 5.3.2.1\n        //\n        // A period's start is the first period's start + time elapsed after playing all\n        // prior periods to this one. Periods continue one after the other in time (without\n        // gaps) until the end of the presentation.\n        //\n        // The value of Period@start should be:\n        // 1. if Period@start is present: value of Period@start\n        // 2. if previous period exists and it has @duration: previous Period@start +\n        //    previous Period@duration\n        // 3. if this is first period and MPD@type is 'static': 0\n        // 4. in all other cases, consider the period an \"early available period\" (note: not\n        //    currently supported)\n        // (1)\n        if (typeof attributes.start === 'number') {\n            return attributes.start;\n        } // (2)\n\n        if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n            return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n        } // (3)\n\n        if (!priorPeriodAttributes && mpdType === 'static') {\n            return 0;\n        } // (4)\n        // There is currently no logic for calculating the Period@start value if there is\n        // no Period@start or prior Period@start and Period@duration available. This is not made\n        // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n        // nothing about any other resolution strategies, it's implied. Thus, this case should\n        // be considered an early available period, or error, and null should suffice for both\n        // of those cases.\n\n        return null;\n    };\n    /**\n     * Traverses the mpd xml tree to generate a list of Representation information objects\n     * that have inherited attributes from parent nodes\n     *\n     * @param {Node} mpd\n     *        The root node of the mpd\n     * @param {Object} options\n     *        Available options for inheritAttributes\n     * @param {string} options.manifestUri\n     *        The uri source of the mpd\n     * @param {number} options.NOW\n     *        Current time per DASH IOP.  Default is current time in ms since epoch\n     * @param {number} options.clientOffset\n     *        Client time difference from NOW (in milliseconds)\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representation information\n     */\n\n    const inheritAttributes = (mpd, options = {}) => {\n        const {\n            manifestUri = '',\n            NOW = Date.now(),\n            clientOffset = 0,\n            // TODO: For now, we are expecting an eventHandler callback function\n            // to be passed into the mpd parser as an option.\n            // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n            // This will support new features including a standardized event handler.\n            // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n            // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n            eventHandler = function () {}\n        } = options;\n        const periodNodes = findChildren(mpd, 'Period');\n        if (!periodNodes.length) {\n            throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n        }\n        const locations = findChildren(mpd, 'Location');\n        const mpdAttributes = parseAttributes(mpd);\n        const mpdBaseUrls = buildBaseUrls([{\n            baseUrl: manifestUri\n        }], findChildren(mpd, 'BaseURL'));\n        const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n        mpdAttributes.type = mpdAttributes.type || 'static';\n        mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n        mpdAttributes.NOW = NOW;\n        mpdAttributes.clientOffset = clientOffset;\n        if (locations.length) {\n            mpdAttributes.locations = locations.map(getContent);\n        }\n        const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n        // adding properties that require looking at prior periods is to parse attributes and add\n        // missing ones before toAdaptationSets is called. If more such properties are added, it\n        // may be better to refactor toAdaptationSets.\n\n        periodNodes.forEach((node, index) => {\n            const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n            // for this period.\n\n            const priorPeriod = periods[index - 1];\n            attributes.start = getPeriodStart({\n                attributes,\n                priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n                mpdType: mpdAttributes.type\n            });\n            periods.push({\n                node,\n                attributes\n            });\n        });\n        return {\n            locations: mpdAttributes.locations,\n            contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n            // TODO: There are occurences where this `representationInfo` array contains undesired\n            // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n            // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n            // parent BaseURL and a child BaseURL, and the value does not resolve,\n            // we end up returning the child BaseURL multiple times.\n            // We need to determine a way to remove these duplicates in a safe way.\n            // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n            representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n            eventStream: flatten(periods.map(toEventStream))\n        };\n    };\n    const stringToMpdXml = manifestString => {\n        if (manifestString === '') {\n            throw new Error(errors.DASH_EMPTY_MANIFEST);\n        }\n        const parser = new DOMParser();\n        let xml;\n        let mpd;\n        try {\n            xml = parser.parseFromString(manifestString, 'application/xml');\n            mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n        } catch (e) {// ie 11 throws on invalid xml\n        }\n        if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n            throw new Error(errors.DASH_INVALID_XML);\n        }\n        return mpd;\n    };\n\n    /**\n     * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n     *\n     * @param {string} mpd\n     *        XML string of the MPD manifest\n     * @return {Object|null}\n     *         Attributes of UTCTiming node specified in the manifest. Null if none found\n     */\n\n    const parseUTCTimingScheme = mpd => {\n        const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n        if (!UTCTimingNode) {\n            return null;\n        }\n        const attributes = parseAttributes(UTCTimingNode);\n        switch (attributes.schemeIdUri) {\n            case 'urn:mpeg:dash:utc:http-head:2014':\n            case 'urn:mpeg:dash:utc:http-head:2012':\n                attributes.method = 'HEAD';\n                break;\n            case 'urn:mpeg:dash:utc:http-xsdate:2014':\n            case 'urn:mpeg:dash:utc:http-iso:2014':\n            case 'urn:mpeg:dash:utc:http-xsdate:2012':\n            case 'urn:mpeg:dash:utc:http-iso:2012':\n                attributes.method = 'GET';\n                break;\n            case 'urn:mpeg:dash:utc:direct:2014':\n            case 'urn:mpeg:dash:utc:direct:2012':\n                attributes.method = 'DIRECT';\n                attributes.value = Date.parse(attributes.value);\n                break;\n            case 'urn:mpeg:dash:utc:http-ntp:2014':\n            case 'urn:mpeg:dash:utc:ntp:2014':\n            case 'urn:mpeg:dash:utc:sntp:2014':\n            default:\n                throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n        }\n        return attributes;\n    };\n    /*\n   * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n   * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n   *\n   * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n   * parsed DASH manifest will have its media sequence and discontinuity sequence values\n   * updated to reflect its position relative to the prior manifest.\n   *\n   * @param {string} manifestString - the DASH manifest as a string\n   * @param {options} [options] - any options\n   *\n   * @return {Object} the manifest object\n   */\n\n    const parse = (manifestString, options = {}) => {\n        const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n        const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n        return toM3u8({\n            dashPlaylists: playlists,\n            locations: parsedManifestInfo.locations,\n            contentSteering: parsedManifestInfo.contentSteeringInfo,\n            sidxMapping: options.sidxMapping,\n            previousManifest: options.previousManifest,\n            eventStream: parsedManifestInfo.eventStream\n        });\n    };\n    /**\n     * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n     *\n     * @param {string} manifestString\n     *        XML string of the MPD manifest\n     * @return {Object|null}\n     *         Attributes of UTCTiming node specified in the manifest. Null if none found\n     */\n\n    const parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\n    var MAX_UINT32 = Math.pow(2, 32);\n    var getUint64$1 = function (uint8) {\n        var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n        var value;\n        if (dv.getBigUint64) {\n            value = dv.getBigUint64(0);\n            if (value < Number.MAX_SAFE_INTEGER) {\n                return Number(value);\n            }\n            return value;\n        }\n        return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);\n    };\n    var numbers = {\n        getUint64: getUint64$1,\n        MAX_UINT32: MAX_UINT32\n    };\n\n    var getUint64 = numbers.getUint64;\n    var parseSidx = function (data) {\n        var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n            result = {\n                version: data[0],\n                flags: new Uint8Array(data.subarray(1, 4)),\n                references: [],\n                referenceId: view.getUint32(4),\n                timescale: view.getUint32(8)\n            },\n            i = 12;\n        if (result.version === 0) {\n            result.earliestPresentationTime = view.getUint32(i);\n            result.firstOffset = view.getUint32(i + 4);\n            i += 8;\n        } else {\n            // read 64 bits\n            result.earliestPresentationTime = getUint64(data.subarray(i));\n            result.firstOffset = getUint64(data.subarray(i + 8));\n            i += 16;\n        }\n        i += 2; // reserved\n\n        var referenceCount = view.getUint16(i);\n        i += 2; // start of references\n\n        for (; referenceCount > 0; i += 12, referenceCount--) {\n            result.references.push({\n                referenceType: (data[i] & 0x80) >>> 7,\n                referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n                subsegmentDuration: view.getUint32(i + 4),\n                startsWithSap: !!(data[i + 8] & 0x80),\n                sapType: (data[i + 8] & 0x70) >>> 4,\n                sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n            });\n        }\n        return result;\n    };\n    var parseSidx_1 = parseSidx;\n\n    var ID3 = toUint8([0x49, 0x44, 0x33]);\n    var getId3Size = function getId3Size(bytes, offset) {\n        if (offset === void 0) {\n            offset = 0;\n        }\n        bytes = toUint8(bytes);\n        var flags = bytes[offset + 5];\n        var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\n        var footerPresent = (flags & 16) >> 4;\n        if (footerPresent) {\n            return returnSize + 20;\n        }\n        return returnSize + 10;\n    };\n    var getId3Offset = function getId3Offset(bytes, offset) {\n        if (offset === void 0) {\n            offset = 0;\n        }\n        bytes = toUint8(bytes);\n        if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {\n            offset: offset\n        })) {\n            return offset;\n        }\n        offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\n        // have multiple ID3 tag sections even though\n        // they should not.\n\n        return getId3Offset(bytes, offset);\n    };\n\n    var normalizePath$1 = function normalizePath(path) {\n        if (typeof path === 'string') {\n            return stringToBytes(path);\n        }\n        if (typeof path === 'number') {\n            return path;\n        }\n        return path;\n    };\n    var normalizePaths$1 = function normalizePaths(paths) {\n        if (!Array.isArray(paths)) {\n            return [normalizePath$1(paths)];\n        }\n        return paths.map(function (p) {\n            return normalizePath$1(p);\n        });\n    };\n    /**\n     * find any number of boxes by name given a path to it in an iso bmff\n     * such as mp4.\n     *\n     * @param {TypedArray} bytes\n     *        bytes for the iso bmff to search for boxes in\n     *\n     * @param {Uint8Array[]|string[]|string|Uint8Array} name\n     *        An array of paths or a single path representing the name\n     *        of boxes to search through in bytes. Paths may be\n     *        uint8 (character codes) or strings.\n     *\n     * @param {boolean} [complete=false]\n     *        Should we search only for complete boxes on the final path.\n     *        This is very useful when you do not want to get back partial boxes\n     *        in the case of streaming files.\n     *\n     * @return {Uint8Array[]}\n     *         An array of the end paths that we found.\n     */\n\n    var findBox = function findBox(bytes, paths, complete) {\n        if (complete === void 0) {\n            complete = false;\n        }\n        paths = normalizePaths$1(paths);\n        bytes = toUint8(bytes);\n        var results = [];\n        if (!paths.length) {\n            // short-circuit the search for empty paths\n            return results;\n        }\n        var i = 0;\n        while (i < bytes.length) {\n            var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n            var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n            if (size === 0) {\n                break;\n            }\n            var end = i + size;\n            if (end > bytes.length) {\n                // this box is bigger than the number of bytes we have\n                // and complete is set, we cannot find any more boxes.\n                if (complete) {\n                    break;\n                }\n                end = bytes.length;\n            }\n            var data = bytes.subarray(i + 8, end);\n            if (bytesMatch(type, paths[0])) {\n                if (paths.length === 1) {\n                    // this is the end of the path and we've found the box we were\n                    // looking for\n                    results.push(data);\n                } else {\n                    // recursively search for the next box along the path\n                    results.push.apply(results, findBox(data, paths.slice(1), complete));\n                }\n            }\n            i = end;\n        } // we've finished searching all of bytes\n\n        return results;\n    };\n\n    // https://matroska-org.github.io/libebml/specs.html\n    // https://www.matroska.org/technical/elements.html\n    // https://www.webmproject.org/docs/container/\n\n    var EBML_TAGS = {\n        EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n        DocType: toUint8([0x42, 0x82]),\n        Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n        SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n        Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n        Track: toUint8([0xAE]),\n        TrackNumber: toUint8([0xd7]),\n        DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n        TrackEntry: toUint8([0xAE]),\n        TrackType: toUint8([0x83]),\n        FlagDefault: toUint8([0x88]),\n        CodecID: toUint8([0x86]),\n        CodecPrivate: toUint8([0x63, 0xA2]),\n        VideoTrack: toUint8([0xe0]),\n        AudioTrack: toUint8([0xe1]),\n        // Not used yet, but will be used for live webm/mkv\n        // see https://www.matroska.org/technical/basics.html#block-structure\n        // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n        Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n        Timestamp: toUint8([0xE7]),\n        TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n        BlockGroup: toUint8([0xA0]),\n        BlockDuration: toUint8([0x9B]),\n        Block: toUint8([0xA1]),\n        SimpleBlock: toUint8([0xA3])\n    };\n    /**\n     * This is a simple table to determine the length\n     * of things in ebml. The length is one based (starts at 1,\n     * rather than zero) and for every zero bit before a one bit\n     * we add one to length. We also need this table because in some\n     * case we have to xor all the length bits from another value.\n     */\n\n    var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n    var getLength = function getLength(byte) {\n        var len = 1;\n        for (var i = 0; i < LENGTH_TABLE.length; i++) {\n            if (byte & LENGTH_TABLE[i]) {\n                break;\n            }\n            len++;\n        }\n        return len;\n    }; // length in ebml is stored in the first 4 to 8 bits\n    // of the first byte. 4 for the id length and 8 for the\n    // data size length. Length is measured by converting the number to binary\n    // then 1 + the number of zeros before a 1 is encountered starting\n    // from the left.\n\n    var getvint = function getvint(bytes, offset, removeLength, signed) {\n        if (removeLength === void 0) {\n            removeLength = true;\n        }\n        if (signed === void 0) {\n            signed = false;\n        }\n        var length = getLength(bytes[offset]);\n        var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n        // as they will be modified below to remove the dataSizeLen bits and we do not\n        // want to modify the original data. normally we could just call slice on\n        // uint8array but ie 11 does not support that...\n\n        if (removeLength) {\n            valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n            valueBytes[0] ^= LENGTH_TABLE[length - 1];\n        }\n        return {\n            length: length,\n            value: bytesToNumber(valueBytes, {\n                signed: signed\n            }),\n            bytes: valueBytes\n        };\n    };\n    var normalizePath = function normalizePath(path) {\n        if (typeof path === 'string') {\n            return path.match(/.{1,2}/g).map(function (p) {\n                return normalizePath(p);\n            });\n        }\n        if (typeof path === 'number') {\n            return numberToBytes(path);\n        }\n        return path;\n    };\n    var normalizePaths = function normalizePaths(paths) {\n        if (!Array.isArray(paths)) {\n            return [normalizePath(paths)];\n        }\n        return paths.map(function (p) {\n            return normalizePath(p);\n        });\n    };\n    var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n        if (offset >= bytes.length) {\n            return bytes.length;\n        }\n        var innerid = getvint(bytes, offset, false);\n        if (bytesMatch(id.bytes, innerid.bytes)) {\n            return offset;\n        }\n        var dataHeader = getvint(bytes, offset + innerid.length);\n        return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n    };\n    /**\n     * Notes on the EBLM format.\n     *\n     * EBLM uses \"vints\" tags. Every vint tag contains\n     * two parts\n     *\n     * 1. The length from the first byte. You get this by\n     *    converting the byte to binary and counting the zeros\n     *    before a 1. Then you add 1 to that. Examples\n     *    00011111 = length 4 because there are 3 zeros before a 1.\n     *    00100000 = length 3 because there are 2 zeros before a 1.\n     *    00000011 = length 7 because there are 6 zeros before a 1.\n     *\n     * 2. The bits used for length are removed from the first byte\n     *    Then all the bytes are merged into a value. NOTE: this\n     *    is not the case for id ebml tags as there id includes\n     *    length bits.\n     *\n     */\n\n    var findEbml = function findEbml(bytes, paths) {\n        paths = normalizePaths(paths);\n        bytes = toUint8(bytes);\n        var results = [];\n        if (!paths.length) {\n            return results;\n        }\n        var i = 0;\n        while (i < bytes.length) {\n            var id = getvint(bytes, i, false);\n            var dataHeader = getvint(bytes, i + id.length);\n            var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n            if (dataHeader.value === 0x7f) {\n                dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n                if (dataHeader.value !== bytes.length) {\n                    dataHeader.value -= dataStart;\n                }\n            }\n            var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n            var data = bytes.subarray(dataStart, dataEnd);\n            if (bytesMatch(paths[0], id.bytes)) {\n                if (paths.length === 1) {\n                    // this is the end of the paths and we've found the tag we were\n                    // looking for\n                    results.push(data);\n                } else {\n                    // recursively search for the next tag inside of the data\n                    // of this one\n                    results = results.concat(findEbml(data, paths.slice(1)));\n                }\n            }\n            var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n            i += totalLength;\n        }\n        return results;\n    }; // see https://www.matroska.org/technical/basics.html#block-structure\n\n    var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\n    var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\n    var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n    /**\n     * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n     * Sequence Payload\"\n     *\n     * @param data {Uint8Array} the bytes of a RBSP from a NAL\n     * unit\n     * @return {Uint8Array} the RBSP without any Emulation\n     * Prevention Bytes\n     */\n\n    var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n        var positions = [];\n        var i = 1; // Find all `Emulation Prevention Bytes`\n\n        while (i < bytes.length - 2) {\n            if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n                positions.push(i + 2);\n                i++;\n            }\n            i++;\n        } // If no Emulation Prevention Bytes were found just return the original\n        // array\n\n        if (positions.length === 0) {\n            return bytes;\n        } // Create a new array to hold the NAL unit data\n\n        var newLength = bytes.length - positions.length;\n        var newData = new Uint8Array(newLength);\n        var sourceIndex = 0;\n        for (i = 0; i < newLength; sourceIndex++, i++) {\n            if (sourceIndex === positions[0]) {\n                // Skip this byte\n                sourceIndex++; // Remove this position index\n\n                positions.shift();\n            }\n            newData[i] = bytes[sourceIndex];\n        }\n        return newData;\n    };\n    var findNal = function findNal(bytes, dataType, types, nalLimit) {\n        if (nalLimit === void 0) {\n            nalLimit = Infinity;\n        }\n        bytes = toUint8(bytes);\n        types = [].concat(types);\n        var i = 0;\n        var nalStart;\n        var nalsFound = 0; // keep searching until:\n        // we reach the end of bytes\n        // we reach the maximum number of nals they want to seach\n        // NOTE: that we disregard nalLimit when we have found the start\n        // of the nal we want so that we can find the end of the nal we want.\n\n        while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n            var nalOffset = void 0;\n            if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n                nalOffset = 4;\n            } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n                nalOffset = 3;\n            } // we are unsynced,\n            // find the next nal unit\n\n            if (!nalOffset) {\n                i++;\n                continue;\n            }\n            nalsFound++;\n            if (nalStart) {\n                return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n            }\n            var nalType = void 0;\n            if (dataType === 'h264') {\n                nalType = bytes[i + nalOffset] & 0x1f;\n            } else if (dataType === 'h265') {\n                nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n            }\n            if (types.indexOf(nalType) !== -1) {\n                nalStart = i + nalOffset;\n            } // nal header is 1 length for h264, and 2 for h265\n\n            i += nalOffset + (dataType === 'h264' ? 1 : 2);\n        }\n        return bytes.subarray(0, 0);\n    };\n    var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n        return findNal(bytes, 'h264', type, nalLimit);\n    };\n    var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n        return findNal(bytes, 'h265', type, nalLimit);\n    };\n\n    var CONSTANTS = {\n        // \"webm\" string literal in hex\n        'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n        // \"matroska\" string literal in hex\n        'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n        // \"fLaC\" string literal in hex\n        'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n        // \"OggS\" string literal in hex\n        'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n        // ac-3 sync byte, also works for ec-3 as that is simply a codec\n        // of ac-3\n        'ac3': toUint8([0x0b, 0x77]),\n        // \"RIFF\" string literal in hex used for wav and avi\n        'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n        // \"AVI\" string literal in hex\n        'avi': toUint8([0x41, 0x56, 0x49]),\n        // \"WAVE\" string literal in hex\n        'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n        // \"ftyp3g\" string literal in hex\n        '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n        // \"ftyp\" string literal in hex\n        'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n        // \"styp\" string literal in hex\n        'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n        // \"ftypqt\" string literal in hex\n        'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n        // moov string literal in hex\n        'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n        // moof string literal in hex\n        'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n    };\n    var _isLikely = {\n        aac: function aac(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, [0xFF, 0x10], {\n                offset: offset,\n                mask: [0xFF, 0x16]\n            });\n        },\n        mp3: function mp3(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, [0xFF, 0x02], {\n                offset: offset,\n                mask: [0xFF, 0x06]\n            });\n        },\n        webm: function webm(bytes) {\n            var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n            return bytesMatch(docType, CONSTANTS.webm);\n        },\n        mkv: function mkv(bytes) {\n            var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n            return bytesMatch(docType, CONSTANTS.matroska);\n        },\n        mp4: function mp4(bytes) {\n            // if this file is another base media file format, it is not mp4\n            if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n                return false;\n            } // if this file starts with a ftyp or styp box its mp4\n\n            if (bytesMatch(bytes, CONSTANTS.mp4, {\n                offset: 4\n            }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n                offset: 4\n            })) {\n                return true;\n            } // if this file starts with a moof/moov box its mp4\n\n            if (bytesMatch(bytes, CONSTANTS.moof, {\n                offset: 4\n            }) || bytesMatch(bytes, CONSTANTS.moov, {\n                offset: 4\n            })) {\n                return true;\n            }\n        },\n        mov: function mov(bytes) {\n            return bytesMatch(bytes, CONSTANTS.mov, {\n                offset: 4\n            });\n        },\n        '3gp': function gp(bytes) {\n            return bytesMatch(bytes, CONSTANTS['3gp'], {\n                offset: 4\n            });\n        },\n        ac3: function ac3(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, CONSTANTS.ac3, {\n                offset: offset\n            });\n        },\n        ts: function ts(bytes) {\n            if (bytes.length < 189 && bytes.length >= 1) {\n                return bytes[0] === 0x47;\n            }\n            var i = 0; // check the first 376 bytes for two matching sync bytes\n\n            while (i + 188 < bytes.length && i < 188) {\n                if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n                    return true;\n                }\n                i += 1;\n            }\n            return false;\n        },\n        flac: function flac(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, CONSTANTS.flac, {\n                offset: offset\n            });\n        },\n        ogg: function ogg(bytes) {\n            return bytesMatch(bytes, CONSTANTS.ogg);\n        },\n        avi: function avi(bytes) {\n            return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n                offset: 8\n            });\n        },\n        wav: function wav(bytes) {\n            return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n                offset: 8\n            });\n        },\n        'h264': function h264(bytes) {\n            // find seq_parameter_set_rbsp\n            return findH264Nal(bytes, 7, 3).length;\n        },\n        'h265': function h265(bytes) {\n            // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n            return findH265Nal(bytes, [32, 33], 3).length;\n        }\n    }; // get all the isLikely functions\n    // but make sure 'ts' is above h264 and h265\n    // but below everything else as it is the least specific\n\n    var isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n        .filter(function (t) {\n            return t !== 'ts' && t !== 'h264' && t !== 'h265';\n        }) // add it back to the bottom\n        .concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\n    isLikelyTypes.forEach(function (type) {\n        var isLikelyFn = _isLikely[type];\n        _isLikely[type] = function (bytes) {\n            return isLikelyFn(toUint8(bytes));\n        };\n    }); // export after wrapping\n\n    var isLikely = _isLikely; // A useful list of file signatures can be found here\n    // https://en.wikipedia.org/wiki/List_of_file_signatures\n\n    var detectContainerForBytes = function detectContainerForBytes(bytes) {\n        bytes = toUint8(bytes);\n        for (var i = 0; i < isLikelyTypes.length; i++) {\n            var type = isLikelyTypes[i];\n            if (isLikely[type](bytes)) {\n                return type;\n            }\n        }\n        return '';\n    }; // fmp4 is not a container\n\n    var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n        return findBox(bytes, ['moof']).length > 0;\n    };\n\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n    var ONE_SECOND_IN_TS = 90000,\n        // 90kHz clock\n        secondsToVideoTs,\n        secondsToAudioTs,\n        videoTsToSeconds,\n        audioTsToSeconds,\n        audioTsToVideoTs,\n        videoTsToAudioTs,\n        metadataTsToSeconds;\n    secondsToVideoTs = function (seconds) {\n        return seconds * ONE_SECOND_IN_TS;\n    };\n    secondsToAudioTs = function (seconds, sampleRate) {\n        return seconds * sampleRate;\n    };\n    videoTsToSeconds = function (timestamp) {\n        return timestamp / ONE_SECOND_IN_TS;\n    };\n    audioTsToSeconds = function (timestamp, sampleRate) {\n        return timestamp / sampleRate;\n    };\n    audioTsToVideoTs = function (timestamp, sampleRate) {\n        return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n    };\n    videoTsToAudioTs = function (timestamp, sampleRate) {\n        return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n    };\n\n    /**\n     * Adjust ID3 tag or caption timing information by the timeline pts values\n     * (if keepOriginalTimestamps is false) and convert to seconds\n     */\n    metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n        return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n    };\n    var clock = {\n        ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\n        secondsToVideoTs: secondsToVideoTs,\n        secondsToAudioTs: secondsToAudioTs,\n        videoTsToSeconds: videoTsToSeconds,\n        audioTsToSeconds: audioTsToSeconds,\n        audioTsToVideoTs: audioTsToVideoTs,\n        videoTsToAudioTs: videoTsToAudioTs,\n        metadataTsToSeconds: metadataTsToSeconds\n    };\n    var clock_1 = clock.ONE_SECOND_IN_TS;\n\n    /*! @name @videojs/http-streaming @version 3.10.0 @license Apache-2.0 */\n\n    /**\n     * @file resolve-url.js - Handling how URLs are resolved and manipulated\n     */\n    const resolveUrl = resolveUrl$1;\n    /**\n     * If the xhr request was redirected, return the responseURL, otherwise,\n     * return the original url.\n     *\n     * @api private\n     *\n     * @param  {string} url - an url being requested\n     * @param  {XMLHttpRequest} req - xhr request result\n     *\n     * @return {string}\n     */\n\n    const resolveManifestRedirect = (url, req) => {\n        // To understand how the responseURL below is set and generated:\n        // - https://fetch.spec.whatwg.org/#concept-response-url\n        // - https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\n        if (req && req.responseURL && url !== req.responseURL) {\n            return req.responseURL;\n        }\n        return url;\n    };\n    const logger = source => {\n        if (videojs.log.debug) {\n            return videojs.log.debug.bind(videojs, 'VHS:', `${source} >`);\n        }\n        return function () {};\n    };\n\n    /**\n     * Provides a compatibility layer between Video.js 7 and 8 API changes for VHS.\n     */\n    /**\n     * Delegates to videojs.obj.merge (Video.js 8) or\n     * videojs.mergeOptions (Video.js 7).\n     */\n\n    function merge(...args) {\n        const context = videojs.obj || videojs;\n        const fn = context.merge || context.mergeOptions;\n        return fn.apply(context, args);\n    }\n    /**\n     * Delegates to videojs.time.createTimeRanges (Video.js 8) or\n     * videojs.createTimeRanges (Video.js 7).\n     */\n\n    function createTimeRanges(...args) {\n        const context = videojs.time || videojs;\n        const fn = context.createTimeRanges || context.createTimeRanges;\n        return fn.apply(context, args);\n    }\n\n    /**\n     * ranges\n     *\n     * Utilities for working with TimeRanges.\n     *\n     */\n\n    const TIME_FUDGE_FACTOR = 1 / 30; // Comparisons between time values such as current time and the end of the buffered range\n    // can be misleading because of precision differences or when the current media has poorly\n    // aligned audio and video, which can cause values to be slightly off from what you would\n    // expect. This value is what we consider to be safe to use in such comparisons to account\n    // for these scenarios.\n\n    const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n    const filterRanges = function (timeRanges, predicate) {\n        const results = [];\n        let i;\n        if (timeRanges && timeRanges.length) {\n            // Search for ranges that match the predicate\n            for (i = 0; i < timeRanges.length; i++) {\n                if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n                    results.push([timeRanges.start(i), timeRanges.end(i)]);\n                }\n            }\n        }\n        return createTimeRanges(results);\n    };\n    /**\n     * Attempts to find the buffered TimeRange that contains the specified\n     * time.\n     *\n     * @param {TimeRanges} buffered - the TimeRanges object to query\n     * @param {number} time  - the time to filter on.\n     * @return {TimeRanges} a new TimeRanges object\n     */\n\n    const findRange = function (buffered, time) {\n        return filterRanges(buffered, function (start, end) {\n            return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;\n        });\n    };\n    /**\n     * Returns the TimeRanges that begin later than the specified time.\n     *\n     * @param {TimeRanges} timeRanges - the TimeRanges object to query\n     * @param {number} time - the time to filter on.\n     * @return {TimeRanges} a new TimeRanges object.\n     */\n\n    const findNextRange = function (timeRanges, time) {\n        return filterRanges(timeRanges, function (start) {\n            return start - TIME_FUDGE_FACTOR >= time;\n        });\n    };\n    /**\n     * Returns gaps within a list of TimeRanges\n     *\n     * @param {TimeRanges} buffered - the TimeRanges object\n     * @return {TimeRanges} a TimeRanges object of gaps\n     */\n\n    const findGaps = function (buffered) {\n        if (buffered.length < 2) {\n            return createTimeRanges();\n        }\n        const ranges = [];\n        for (let i = 1; i < buffered.length; i++) {\n            const start = buffered.end(i - 1);\n            const end = buffered.start(i);\n            ranges.push([start, end]);\n        }\n        return createTimeRanges(ranges);\n    };\n    /**\n     * Calculate the intersection of two TimeRanges\n     *\n     * @param {TimeRanges} bufferA\n     * @param {TimeRanges} bufferB\n     * @return {TimeRanges} The interesection of `bufferA` with `bufferB`\n     */\n\n    const bufferIntersection = function (bufferA, bufferB) {\n        let start = null;\n        let end = null;\n        let arity = 0;\n        const extents = [];\n        const ranges = [];\n        if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n            return createTimeRanges();\n        } // Handle the case where we have both buffers and create an\n        // intersection of the two\n\n        let count = bufferA.length; // A) Gather up all start and end times\n\n        while (count--) {\n            extents.push({\n                time: bufferA.start(count),\n                type: 'start'\n            });\n            extents.push({\n                time: bufferA.end(count),\n                type: 'end'\n            });\n        }\n        count = bufferB.length;\n        while (count--) {\n            extents.push({\n                time: bufferB.start(count),\n                type: 'start'\n            });\n            extents.push({\n                time: bufferB.end(count),\n                type: 'end'\n            });\n        } // B) Sort them by time\n\n        extents.sort(function (a, b) {\n            return a.time - b.time;\n        }); // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n\n        for (count = 0; count < extents.length; count++) {\n            if (extents[count].type === 'start') {\n                arity++; // D) If arity is ever incremented to 2 we are entering an\n                //    overlapping range\n\n                if (arity === 2) {\n                    start = extents[count].time;\n                }\n            } else if (extents[count].type === 'end') {\n                arity--; // E) If arity is ever decremented to 1 we leaving an\n                //    overlapping range\n\n                if (arity === 1) {\n                    end = extents[count].time;\n                }\n            } // F) Record overlapping ranges\n\n            if (start !== null && end !== null) {\n                ranges.push([start, end]);\n                start = null;\n                end = null;\n            }\n        }\n        return createTimeRanges(ranges);\n    };\n    /**\n     * Gets a human readable string for a TimeRange\n     *\n     * @param {TimeRange} range\n     * @return {string} a human readable string\n     */\n\n    const printableRange = range => {\n        const strArr = [];\n        if (!range || !range.length) {\n            return '';\n        }\n        for (let i = 0; i < range.length; i++) {\n            strArr.push(range.start(i) + ' => ' + range.end(i));\n        }\n        return strArr.join(', ');\n    };\n    /**\n     * Calculates the amount of time left in seconds until the player hits the end of the\n     * buffer and causes a rebuffer\n     *\n     * @param {TimeRange} buffered\n     *        The state of the buffer\n     * @param {Numnber} currentTime\n     *        The current time of the player\n     * @param {number} playbackRate\n     *        The current playback rate of the player. Defaults to 1.\n     * @return {number}\n     *         Time until the player has to start rebuffering in seconds.\n     * @function timeUntilRebuffer\n     */\n\n    const timeUntilRebuffer = function (buffered, currentTime, playbackRate = 1) {\n        const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n        return (bufferedEnd - currentTime) / playbackRate;\n    };\n    /**\n     * Converts a TimeRanges object into an array representation\n     *\n     * @param {TimeRanges} timeRanges\n     * @return {Array}\n     */\n\n    const timeRangesToArray = timeRanges => {\n        const timeRangesList = [];\n        for (let i = 0; i < timeRanges.length; i++) {\n            timeRangesList.push({\n                start: timeRanges.start(i),\n                end: timeRanges.end(i)\n            });\n        }\n        return timeRangesList;\n    };\n    /**\n     * Determines if two time range objects are different.\n     *\n     * @param {TimeRange} a\n     *        the first time range object to check\n     *\n     * @param {TimeRange} b\n     *        the second time range object to check\n     *\n     * @return {Boolean}\n     *         Whether the time range objects differ\n     */\n\n    const isRangeDifferent = function (a, b) {\n        // same object\n        if (a === b) {\n            return false;\n        } // one or the other is undefined\n\n        if (!a && b || !b && a) {\n            return true;\n        } // length is different\n\n        if (a.length !== b.length) {\n            return true;\n        } // see if any start/end pair is different\n\n        for (let i = 0; i < a.length; i++) {\n            if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {\n                return true;\n            }\n        } // if the length and every pair is the same\n        // this is the same time range\n\n        return false;\n    };\n    const lastBufferedEnd = function (a) {\n        if (!a || !a.length || !a.end) {\n            return;\n        }\n        return a.end(a.length - 1);\n    };\n    /**\n     * A utility function to add up the amount of time in a timeRange\n     * after a specified startTime.\n     * ie:[[0, 10], [20, 40], [50, 60]] with a startTime 0\n     *     would return 40 as there are 40s seconds after 0 in the timeRange\n     *\n     * @param {TimeRange} range\n     *        The range to check against\n     * @param {number} startTime\n     *        The time in the time range that you should start counting from\n     *\n     * @return {number}\n     *          The number of seconds in the buffer passed the specified time.\n     */\n\n    const timeAheadOf = function (range, startTime) {\n        let time = 0;\n        if (!range || !range.length) {\n            return time;\n        }\n        for (let i = 0; i < range.length; i++) {\n            const start = range.start(i);\n            const end = range.end(i); // startTime is after this range entirely\n\n            if (startTime > end) {\n                continue;\n            } // startTime is within this range\n\n            if (startTime > start && startTime <= end) {\n                time += end - startTime;\n                continue;\n            } // startTime is before this range.\n\n            time += end - start;\n        }\n        return time;\n    };\n\n    /**\n     * @file playlist.js\n     *\n     * Playlist related utilities.\n     */\n    /**\n     * Get the duration of a segment, with special cases for\n     * llhls segments that do not have a duration yet.\n     *\n     * @param {Object} playlist\n     *        the playlist that the segment belongs to.\n     * @param {Object} segment\n     *        the segment to get a duration for.\n     *\n     * @return {number}\n     *          the segment duration\n     */\n\n    const segmentDurationWithParts = (playlist, segment) => {\n        // if this isn't a preload segment\n        // then we will have a segment duration that is accurate.\n        if (!segment.preload) {\n            return segment.duration;\n        } // otherwise we have to add up parts and preload hints\n        // to get an up to date duration.\n\n        let result = 0;\n        (segment.parts || []).forEach(function (p) {\n            result += p.duration;\n        }); // for preload hints we have to use partTargetDuration\n        // as they won't even have a duration yet.\n\n        (segment.preloadHints || []).forEach(function (p) {\n            if (p.type === 'PART') {\n                result += playlist.partTargetDuration;\n            }\n        });\n        return result;\n    };\n    /**\n     * A function to get a combined list of parts and segments with durations\n     * and indexes.\n     *\n     * @param {Playlist} playlist the playlist to get the list for.\n     *\n     * @return {Array} The part/segment list.\n     */\n\n    const getPartsAndSegments = playlist => (playlist.segments || []).reduce((acc, segment, si) => {\n        if (segment.parts) {\n            segment.parts.forEach(function (part, pi) {\n                acc.push({\n                    duration: part.duration,\n                    segmentIndex: si,\n                    partIndex: pi,\n                    part,\n                    segment\n                });\n            });\n        } else {\n            acc.push({\n                duration: segment.duration,\n                segmentIndex: si,\n                partIndex: null,\n                segment,\n                part: null\n            });\n        }\n        return acc;\n    }, []);\n    const getLastParts = media => {\n        const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];\n        return lastSegment && lastSegment.parts || [];\n    };\n    const getKnownPartCount = ({\n                                   preloadSegment\n                               }) => {\n        if (!preloadSegment) {\n            return;\n        }\n        const {\n            parts,\n            preloadHints\n        } = preloadSegment;\n        let partCount = (preloadHints || []).reduce((count, hint) => count + (hint.type === 'PART' ? 1 : 0), 0);\n        partCount += parts && parts.length ? parts.length : 0;\n        return partCount;\n    };\n    /**\n     * Get the number of seconds to delay from the end of a\n     * live playlist.\n     *\n     * @param {Playlist} main the main playlist\n     * @param {Playlist} media the media playlist\n     * @return {number} the hold back in seconds.\n     */\n\n    const liveEdgeDelay = (main, media) => {\n        if (media.endList) {\n            return 0;\n        } // dash suggestedPresentationDelay trumps everything\n\n        if (main && main.suggestedPresentationDelay) {\n            return main.suggestedPresentationDelay;\n        }\n        const hasParts = getLastParts(media).length > 0; // look for \"part\" delays from ll-hls first\n\n        if (hasParts && media.serverControl && media.serverControl.partHoldBack) {\n            return media.serverControl.partHoldBack;\n        } else if (hasParts && media.partTargetDuration) {\n            return media.partTargetDuration * 3; // finally look for full segment delays\n        } else if (media.serverControl && media.serverControl.holdBack) {\n            return media.serverControl.holdBack;\n        } else if (media.targetDuration) {\n            return media.targetDuration * 3;\n        }\n        return 0;\n    };\n    /**\n     * walk backward until we find a duration we can use\n     * or return a failure\n     *\n     * @param {Playlist} playlist the playlist to walk through\n     * @param {Number} endSequence the mediaSequence to stop walking on\n     */\n\n    const backwardDuration = function (playlist, endSequence) {\n        let result = 0;\n        let i = endSequence - playlist.mediaSequence; // if a start time is available for segment immediately following\n        // the interval, use it\n\n        let segment = playlist.segments[i]; // Walk backward until we find the latest segment with timeline\n        // information that is earlier than endSequence\n\n        if (segment) {\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: segment.start,\n                    precise: true\n                };\n            }\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: segment.end - segment.duration,\n                    precise: true\n                };\n            }\n        }\n        while (i--) {\n            segment = playlist.segments[i];\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: result + segment.end,\n                    precise: true\n                };\n            }\n            result += segmentDurationWithParts(playlist, segment);\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: result + segment.start,\n                    precise: true\n                };\n            }\n        }\n        return {\n            result,\n            precise: false\n        };\n    };\n    /**\n     * walk forward until we find a duration we can use\n     * or return a failure\n     *\n     * @param {Playlist} playlist the playlist to walk through\n     * @param {number} endSequence the mediaSequence to stop walking on\n     */\n\n    const forwardDuration = function (playlist, endSequence) {\n        let result = 0;\n        let segment;\n        let i = endSequence - playlist.mediaSequence; // Walk forward until we find the earliest segment with timeline\n        // information\n\n        for (; i < playlist.segments.length; i++) {\n            segment = playlist.segments[i];\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: segment.start - result,\n                    precise: true\n                };\n            }\n            result += segmentDurationWithParts(playlist, segment);\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: segment.end - result,\n                    precise: true\n                };\n            }\n        } // indicate we didn't find a useful duration estimate\n\n        return {\n            result: -1,\n            precise: false\n        };\n    };\n    /**\n     * Calculate the media duration from the segments associated with a\n     * playlist. The duration of a subinterval of the available segments\n     * may be calculated by specifying an end index.\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} endSequence an exclusive upper boundary\n     * for the playlist.  Defaults to playlist length.\n     * @param {number} expired the amount of time that has dropped\n     * off the front of the playlist in a live scenario\n     * @return {number} the duration between the first available segment\n     * and end index.\n     */\n\n    const intervalDuration = function (playlist, endSequence, expired) {\n        if (typeof endSequence === 'undefined') {\n            endSequence = playlist.mediaSequence + playlist.segments.length;\n        }\n        if (endSequence < playlist.mediaSequence) {\n            return 0;\n        } // do a backward walk to estimate the duration\n\n        const backward = backwardDuration(playlist, endSequence);\n        if (backward.precise) {\n            // if we were able to base our duration estimate on timing\n            // information provided directly from the Media Source, return\n            // it\n            return backward.result;\n        } // walk forward to see if a precise duration estimate can be made\n        // that way\n\n        const forward = forwardDuration(playlist, endSequence);\n        if (forward.precise) {\n            // we found a segment that has been buffered and so it's\n            // position is known precisely\n            return forward.result;\n        } // return the less-precise, playlist-based duration estimate\n\n        return backward.result + expired;\n    };\n    /**\n     * Calculates the duration of a playlist. If a start and end index\n     * are specified, the duration will be for the subset of the media\n     * timeline between those two indices. The total duration for live\n     * playlists is always Infinity.\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} endSequence an exclusive upper\n     * boundary for the playlist. Defaults to the playlist media\n     * sequence number plus its length.\n     * @param {number=} expired the amount of time that has\n     * dropped off the front of the playlist in a live scenario\n     * @return {number} the duration between the start index and end\n     * index.\n     */\n\n    const duration = function (playlist, endSequence, expired) {\n        if (!playlist) {\n            return 0;\n        }\n        if (typeof expired !== 'number') {\n            expired = 0;\n        } // if a slice of the total duration is not requested, use\n        // playlist-level duration indicators when they're present\n\n        if (typeof endSequence === 'undefined') {\n            // if present, use the duration specified in the playlist\n            if (playlist.totalDuration) {\n                return playlist.totalDuration;\n            } // duration should be Infinity for live playlists\n\n            if (!playlist.endList) {\n                return window.Infinity;\n            }\n        } // calculate the total duration based on the segment durations\n\n        return intervalDuration(playlist, endSequence, expired);\n    };\n    /**\n     * Calculate the time between two indexes in the current playlist\n     * neight the start- nor the end-index need to be within the current\n     * playlist in which case, the targetDuration of the playlist is used\n     * to approximate the durations of the segments\n     *\n     * @param {Array} options.durationList list to iterate over for durations.\n     * @param {number} options.defaultDuration duration to use for elements before or after the durationList\n     * @param {number} options.startIndex partsAndSegments index to start\n     * @param {number} options.endIndex partsAndSegments index to end.\n     * @return {number} the number of seconds between startIndex and endIndex\n     */\n\n    const sumDurations = function ({\n                                       defaultDuration,\n                                       durationList,\n                                       startIndex,\n                                       endIndex\n                                   }) {\n        let durations = 0;\n        if (startIndex > endIndex) {\n            [startIndex, endIndex] = [endIndex, startIndex];\n        }\n        if (startIndex < 0) {\n            for (let i = startIndex; i < Math.min(0, endIndex); i++) {\n                durations += defaultDuration;\n            }\n            startIndex = 0;\n        }\n        for (let i = startIndex; i < endIndex; i++) {\n            durations += durationList[i].duration;\n        }\n        return durations;\n    };\n    /**\n     * Calculates the playlist end time\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} expired the amount of time that has\n     *                  dropped off the front of the playlist in a live scenario\n     * @param {boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n     *                        playlist end calculation should consider the safe live end\n     *                        (truncate the playlist end by three segments). This is normally\n     *                        used for calculating the end of the playlist's seekable range.\n     *                        This takes into account the value of liveEdgePadding.\n     *                        Setting liveEdgePadding to 0 is equivalent to setting this to false.\n     * @param {number} liveEdgePadding a number indicating how far from the end of the playlist we should be in seconds.\n     *                 If this is provided, it is used in the safe live end calculation.\n     *                 Setting useSafeLiveEnd=false or liveEdgePadding=0 are equivalent.\n     *                 Corresponds to suggestedPresentationDelay in DASH manifests.\n     * @return {number} the end time of playlist\n     * @function playlistEnd\n     */\n\n    const playlistEnd = function (playlist, expired, useSafeLiveEnd, liveEdgePadding) {\n        if (!playlist || !playlist.segments) {\n            return null;\n        }\n        if (playlist.endList) {\n            return duration(playlist);\n        }\n        if (expired === null) {\n            return null;\n        }\n        expired = expired || 0;\n        let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);\n        if (useSafeLiveEnd) {\n            liveEdgePadding = typeof liveEdgePadding === 'number' ? liveEdgePadding : liveEdgeDelay(null, playlist);\n            lastSegmentEndTime -= liveEdgePadding;\n        } // don't return a time less than zero\n\n        return Math.max(0, lastSegmentEndTime);\n    };\n    /**\n     * Calculates the interval of time that is currently seekable in a\n     * playlist. The returned time ranges are relative to the earliest\n     * moment in the specified playlist that is still available. A full\n     * seekable implementation for live streams would need to offset\n     * these values by the duration of content that has expired from the\n     * stream.\n     *\n     * @param {Object} playlist a media playlist object\n     * dropped off the front of the playlist in a live scenario\n     * @param {number=} expired the amount of time that has\n     * dropped off the front of the playlist in a live scenario\n     * @param {number} liveEdgePadding how far from the end of the playlist we should be in seconds.\n     *        Corresponds to suggestedPresentationDelay in DASH manifests.\n     * @return {TimeRanges} the periods of time that are valid targets\n     * for seeking\n     */\n\n    const seekable = function (playlist, expired, liveEdgePadding) {\n        const useSafeLiveEnd = true;\n        const seekableStart = expired || 0;\n        let seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);\n        if (seekableEnd === null) {\n            return createTimeRanges();\n        } // Clamp seekable end since it can not be less than the seekable start\n\n        if (seekableEnd < seekableStart) {\n            seekableEnd = seekableStart;\n        }\n        return createTimeRanges(seekableStart, seekableEnd);\n    };\n    /**\n     * Determine the index and estimated starting time of the segment that\n     * contains a specified playback position in a media playlist.\n     *\n     * @param {Object} options.playlist the media playlist to query\n     * @param {number} options.currentTime The number of seconds since the earliest\n     * possible position to determine the containing segment for\n     * @param {number} options.startTime the time when the segment/part starts\n     * @param {number} options.startingSegmentIndex the segment index to start looking at.\n     * @param {number?} [options.startingPartIndex] the part index to look at within the segment.\n     *\n     * @return {Object} an object with partIndex, segmentIndex, and startTime.\n     */\n\n    const getMediaInfoForTime = function ({\n                                              playlist,\n                                              currentTime,\n                                              startingSegmentIndex,\n                                              startingPartIndex,\n                                              startTime,\n                                              exactManifestTimings\n                                          }) {\n        let time = currentTime - startTime;\n        const partsAndSegments = getPartsAndSegments(playlist);\n        let startIndex = 0;\n        for (let i = 0; i < partsAndSegments.length; i++) {\n            const partAndSegment = partsAndSegments[i];\n            if (startingSegmentIndex !== partAndSegment.segmentIndex) {\n                continue;\n            } // skip this if part index does not match.\n\n            if (typeof startingPartIndex === 'number' && typeof partAndSegment.partIndex === 'number' && startingPartIndex !== partAndSegment.partIndex) {\n                continue;\n            }\n            startIndex = i;\n            break;\n        }\n        if (time < 0) {\n            // Walk backward from startIndex in the playlist, adding durations\n            // until we find a segment that contains `time` and return it\n            if (startIndex > 0) {\n                for (let i = startIndex - 1; i >= 0; i--) {\n                    const partAndSegment = partsAndSegments[i];\n                    time += partAndSegment.duration;\n                    if (exactManifestTimings) {\n                        if (time < 0) {\n                            continue;\n                        }\n                    } else if (time + TIME_FUDGE_FACTOR <= 0) {\n                        continue;\n                    }\n                    return {\n                        partIndex: partAndSegment.partIndex,\n                        segmentIndex: partAndSegment.segmentIndex,\n                        startTime: startTime - sumDurations({\n                            defaultDuration: playlist.targetDuration,\n                            durationList: partsAndSegments,\n                            startIndex,\n                            endIndex: i\n                        })\n                    };\n                }\n            } // We were unable to find a good segment within the playlist\n            // so select the first segment\n\n            return {\n                partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n                segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n                startTime: currentTime\n            };\n        } // When startIndex is negative, we first walk forward to first segment\n        // adding target durations. If we \"run out of time\" before getting to\n        // the first segment, return the first segment\n\n        if (startIndex < 0) {\n            for (let i = startIndex; i < 0; i++) {\n                time -= playlist.targetDuration;\n                if (time < 0) {\n                    return {\n                        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n                        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n                        startTime: currentTime\n                    };\n                }\n            }\n            startIndex = 0;\n        } // Walk forward from startIndex in the playlist, subtracting durations\n        // until we find a segment that contains `time` and return it\n\n        for (let i = startIndex; i < partsAndSegments.length; i++) {\n            const partAndSegment = partsAndSegments[i];\n            time -= partAndSegment.duration;\n            const canUseFudgeFactor = partAndSegment.duration > TIME_FUDGE_FACTOR;\n            const isExactlyAtTheEnd = time === 0;\n            const isExtremelyCloseToTheEnd = canUseFudgeFactor && time + TIME_FUDGE_FACTOR >= 0;\n            if (isExactlyAtTheEnd || isExtremelyCloseToTheEnd) {\n                // 1) We are exactly at the end of the current segment.\n                // 2) We are extremely close to the end of the current segment (The difference is less than  1 / 30).\n                //    We may encounter this situation when\n                //    we don't have exact match between segment duration info in the manifest and the actual duration of the segment\n                //    For example:\n                //    We appended 3 segments 10 seconds each, meaning we should have 30 sec buffered,\n                //    but we the actual buffered is 29.99999\n                //\n                // In both cases:\n                // if we passed current time -> it means that we already played current segment\n                // if we passed buffered.end -> it means that this segment is already loaded and buffered\n                // we should select the next segment if we have one:\n                if (i !== partsAndSegments.length - 1) {\n                    continue;\n                }\n            }\n            if (exactManifestTimings) {\n                if (time > 0) {\n                    continue;\n                }\n            } else if (time - TIME_FUDGE_FACTOR >= 0) {\n                continue;\n            }\n            return {\n                partIndex: partAndSegment.partIndex,\n                segmentIndex: partAndSegment.segmentIndex,\n                startTime: startTime + sumDurations({\n                    defaultDuration: playlist.targetDuration,\n                    durationList: partsAndSegments,\n                    startIndex,\n                    endIndex: i\n                })\n            };\n        } // We are out of possible candidates so load the last one...\n\n        return {\n            segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,\n            partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,\n            startTime: currentTime\n        };\n    };\n    /**\n     * Check whether the playlist is excluded or not.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is excluded or not\n     * @function isExcluded\n     */\n\n    const isExcluded = function (playlist) {\n        return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n    };\n    /**\n     * Check whether the playlist is compatible with current playback configuration or has\n     * been excluded permanently for being incompatible.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is incompatible or not\n     * @function isIncompatible\n     */\n\n    const isIncompatible = function (playlist) {\n        return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n    };\n    /**\n     * Check whether the playlist is enabled or not.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is enabled or not\n     * @function isEnabled\n     */\n\n    const isEnabled = function (playlist) {\n        const excluded = isExcluded(playlist);\n        return !playlist.disabled && !excluded;\n    };\n    /**\n     * Check whether the playlist has been manually disabled through the representations api.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is disabled manually or not\n     * @function isDisabled\n     */\n\n    const isDisabled = function (playlist) {\n        return playlist.disabled;\n    };\n    /**\n     * Returns whether the current playlist is an AES encrypted HLS stream\n     *\n     * @return {boolean} true if it's an AES encrypted HLS stream\n     */\n\n    const isAes = function (media) {\n        for (let i = 0; i < media.segments.length; i++) {\n            if (media.segments[i].key) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Checks if the playlist has a value for the specified attribute\n     *\n     * @param {string} attr\n     *        Attribute to check for\n     * @param {Object} playlist\n     *        The media playlist object\n     * @return {boolean}\n     *         Whether the playlist contains a value for the attribute or not\n     * @function hasAttribute\n     */\n\n    const hasAttribute = function (attr, playlist) {\n        return playlist.attributes && playlist.attributes[attr];\n    };\n    /**\n     * Estimates the time required to complete a segment download from the specified playlist\n     *\n     * @param {number} segmentDuration\n     *        Duration of requested segment\n     * @param {number} bandwidth\n     *        Current measured bandwidth of the player\n     * @param {Object} playlist\n     *        The media playlist object\n     * @param {number=} bytesReceived\n     *        Number of bytes already received for the request. Defaults to 0\n     * @return {number|NaN}\n     *         The estimated time to request the segment. NaN if bandwidth information for\n     *         the given playlist is unavailable\n     * @function estimateSegmentRequestTime\n     */\n\n    const estimateSegmentRequestTime = function (segmentDuration, bandwidth, playlist, bytesReceived = 0) {\n        if (!hasAttribute('BANDWIDTH', playlist)) {\n            return NaN;\n        }\n        const size = segmentDuration * playlist.attributes.BANDWIDTH;\n        return (size - bytesReceived * 8) / bandwidth;\n    };\n    /*\n   * Returns whether the current playlist is the lowest rendition\n   *\n   * @return {Boolean} true if on lowest rendition\n   */\n\n    const isLowestEnabledRendition = (main, media) => {\n        if (main.playlists.length === 1) {\n            return true;\n        }\n        const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n        return main.playlists.filter(playlist => {\n            if (!isEnabled(playlist)) {\n                return false;\n            }\n            return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n        }).length === 0;\n    };\n    const playlistMatch = (a, b) => {\n        // both playlits are null\n        // or only one playlist is non-null\n        // no match\n        if (!a && !b || !a && b || a && !b) {\n            return false;\n        } // playlist objects are the same, match\n\n        if (a === b) {\n            return true;\n        } // first try to use id as it should be the most\n        // accurate\n\n        if (a.id && b.id && a.id === b.id) {\n            return true;\n        } // next try to use reslovedUri as it should be the\n        // second most accurate.\n\n        if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {\n            return true;\n        } // finally try to use uri as it should be accurate\n        // but might miss a few cases for relative uris\n\n        if (a.uri && b.uri && a.uri === b.uri) {\n            return true;\n        }\n        return false;\n    };\n    const someAudioVariant = function (main, callback) {\n        const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};\n        let found = false;\n        for (const groupName in AUDIO) {\n            for (const label in AUDIO[groupName]) {\n                found = callback(AUDIO[groupName][label]);\n                if (found) {\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        return !!found;\n    };\n    const isAudioOnly = main => {\n        // we are audio only if we have no main playlists but do\n        // have media group playlists.\n        if (!main || !main.playlists || !main.playlists.length) {\n            // without audio variants or playlists this\n            // is not an audio only main.\n            const found = someAudioVariant(main, variant => variant.playlists && variant.playlists.length || variant.uri);\n            return found;\n        } // if every playlist has only an audio codec it is audio only\n\n        for (let i = 0; i < main.playlists.length; i++) {\n            const playlist = main.playlists[i];\n            const CODECS = playlist.attributes && playlist.attributes.CODECS; // all codecs are audio, this is an audio playlist.\n\n            if (CODECS && CODECS.split(',').every(c => isAudioCodec(c))) {\n                continue;\n            } // playlist is in an audio group it is audio only\n\n            const found = someAudioVariant(main, variant => playlistMatch(playlist, variant));\n            if (found) {\n                continue;\n            } // if we make it here this playlist isn't audio and we\n            // are not audio only\n\n            return false;\n        } // if we make it past every playlist without returning, then\n        // this is an audio only playlist.\n\n        return true;\n    }; // exports\n\n    var Playlist = {\n        liveEdgeDelay,\n        duration,\n        seekable,\n        getMediaInfoForTime,\n        isEnabled,\n        isDisabled,\n        isExcluded,\n        isIncompatible,\n        playlistEnd,\n        isAes,\n        hasAttribute,\n        estimateSegmentRequestTime,\n        isLowestEnabledRendition,\n        isAudioOnly,\n        playlistMatch,\n        segmentDurationWithParts\n    };\n    const {\n        log\n    } = videojs;\n    const createPlaylistID = (index, uri) => {\n        return `${index}-${uri}`;\n    }; // default function for creating a group id\n\n    const groupID = (type, group, label) => {\n        return `placeholder-uri-${type}-${group}-${label}`;\n    };\n    /**\n     * Parses a given m3u8 playlist\n     *\n     * @param {Function} [onwarn]\n     *        a function to call when the parser triggers a warning event.\n     * @param {Function} [oninfo]\n     *        a function to call when the parser triggers an info event.\n     * @param {string} manifestString\n     *        The downloaded manifest string\n     * @param {Object[]} [customTagParsers]\n     *        An array of custom tag parsers for the m3u8-parser instance\n     * @param {Object[]} [customTagMappers]\n     *        An array of custom tag mappers for the m3u8-parser instance\n     * @param {boolean} [llhls]\n     *        Whether to keep ll-hls features in the manifest after parsing.\n     * @return {Object}\n     *         The manifest object\n     */\n\n    const parseManifest = ({\n                               onwarn,\n                               oninfo,\n                               manifestString,\n                               customTagParsers = [],\n                               customTagMappers = [],\n                               llhls\n                           }) => {\n        const parser = new Parser();\n        if (onwarn) {\n            parser.on('warn', onwarn);\n        }\n        if (oninfo) {\n            parser.on('info', oninfo);\n        }\n        customTagParsers.forEach(customParser => parser.addParser(customParser));\n        customTagMappers.forEach(mapper => parser.addTagMapper(mapper));\n        parser.push(manifestString);\n        parser.end();\n        const manifest = parser.manifest; // remove llhls features from the parsed manifest\n        // if we don't want llhls support.\n\n        if (!llhls) {\n            ['preloadSegment', 'skip', 'serverControl', 'renditionReports', 'partInf', 'partTargetDuration'].forEach(function (k) {\n                if (manifest.hasOwnProperty(k)) {\n                    delete manifest[k];\n                }\n            });\n            if (manifest.segments) {\n                manifest.segments.forEach(function (segment) {\n                    ['parts', 'preloadHints'].forEach(function (k) {\n                        if (segment.hasOwnProperty(k)) {\n                            delete segment[k];\n                        }\n                    });\n                });\n            }\n        }\n        if (!manifest.targetDuration) {\n            let targetDuration = 10;\n            if (manifest.segments && manifest.segments.length) {\n                targetDuration = manifest.segments.reduce((acc, s) => Math.max(acc, s.duration), 0);\n            }\n            if (onwarn) {\n                onwarn({\n                    message: `manifest has no targetDuration defaulting to ${targetDuration}`\n                });\n            }\n            manifest.targetDuration = targetDuration;\n        }\n        const parts = getLastParts(manifest);\n        if (parts.length && !manifest.partTargetDuration) {\n            const partTargetDuration = parts.reduce((acc, p) => Math.max(acc, p.duration), 0);\n            if (onwarn) {\n                onwarn({\n                    message: `manifest has no partTargetDuration defaulting to ${partTargetDuration}`\n                });\n                log.error('LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.');\n            }\n            manifest.partTargetDuration = partTargetDuration;\n        }\n        return manifest;\n    };\n    /**\n     * Loops through all supported media groups in main and calls the provided\n     * callback for each group\n     *\n     * @param {Object} main\n     *        The parsed main manifest object\n     * @param {Function} callback\n     *        Callback to call for each media group\n     */\n\n    const forEachMediaGroup = (main, callback) => {\n        if (!main.mediaGroups) {\n            return;\n        }\n        ['AUDIO', 'SUBTITLES'].forEach(mediaType => {\n            if (!main.mediaGroups[mediaType]) {\n                return;\n            }\n            for (const groupKey in main.mediaGroups[mediaType]) {\n                for (const labelKey in main.mediaGroups[mediaType][groupKey]) {\n                    const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];\n                    callback(mediaProperties, mediaType, groupKey, labelKey);\n                }\n            }\n        });\n    };\n    /**\n     * Adds properties and attributes to the playlist to keep consistent functionality for\n     * playlists throughout VHS.\n     *\n     * @param {Object} config\n     *        Arguments object\n     * @param {Object} config.playlist\n     *        The media playlist\n     * @param {string} [config.uri]\n     *        The uri to the media playlist (if media playlist is not from within a main\n     *        playlist)\n     * @param {string} id\n     *        ID to use for the playlist\n     */\n\n    const setupMediaPlaylist = ({\n                                    playlist,\n                                    uri,\n                                    id\n                                }) => {\n        playlist.id = id;\n        playlist.playlistErrors_ = 0;\n        if (uri) {\n            // For media playlists, m3u8-parser does not have access to a URI, as HLS media\n            // playlists do not contain their own source URI, but one is needed for consistency in\n            // VHS.\n            playlist.uri = uri;\n        } // For HLS main playlists, even though certain attributes MUST be defined, the\n        // stream may still be played without them.\n        // For HLS media playlists, m3u8-parser does not attach an attributes object to the\n        // manifest.\n        //\n        // To avoid undefined reference errors through the project, and make the code easier\n        // to write/read, add an empty attributes object for these cases.\n\n        playlist.attributes = playlist.attributes || {};\n    };\n    /**\n     * Adds ID, resolvedUri, and attributes properties to each playlist of the main, where\n     * necessary. In addition, creates playlist IDs for each playlist and adds playlist ID to\n     * playlist references to the playlists array.\n     *\n     * @param {Object} main\n     *        The main playlist\n     */\n\n    const setupMediaPlaylists = main => {\n        let i = main.playlists.length;\n        while (i--) {\n            const playlist = main.playlists[i];\n            setupMediaPlaylist({\n                playlist,\n                id: createPlaylistID(i, playlist.uri)\n            });\n            playlist.resolvedUri = resolveUrl(main.uri, playlist.uri);\n            main.playlists[playlist.id] = playlist; // URI reference added for backwards compatibility\n\n            main.playlists[playlist.uri] = playlist; // Although the spec states an #EXT-X-STREAM-INF tag MUST have a BANDWIDTH attribute,\n            // the stream can be played without it. Although an attributes property may have been\n            // added to the playlist to prevent undefined references, issue a warning to fix the\n            // manifest.\n\n            if (!playlist.attributes.BANDWIDTH) {\n                log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n            }\n        }\n    };\n    /**\n     * Adds resolvedUri properties to each media group.\n     *\n     * @param {Object} main\n     *        The main playlist\n     */\n\n    const resolveMediaGroupUris = main => {\n        forEachMediaGroup(main, properties => {\n            if (properties.uri) {\n                properties.resolvedUri = resolveUrl(main.uri, properties.uri);\n            }\n        });\n    };\n    /**\n     * Creates a main playlist wrapper to insert a sole media playlist into.\n     *\n     * @param {Object} media\n     *        Media playlist\n     * @param {string} uri\n     *        The media URI\n     *\n     * @return {Object}\n     *         main playlist\n     */\n\n    const mainForMedia = (media, uri) => {\n        const id = createPlaylistID(0, uri);\n        const main = {\n            mediaGroups: {\n                'AUDIO': {},\n                'VIDEO': {},\n                'CLOSED-CAPTIONS': {},\n                'SUBTITLES': {}\n            },\n            uri: window.location.href,\n            resolvedUri: window.location.href,\n            playlists: [{\n                uri,\n                id,\n                resolvedUri: uri,\n                // m3u8-parser does not attach an attributes property to media playlists so make\n                // sure that the property is attached to avoid undefined reference errors\n                attributes: {}\n            }]\n        }; // set up ID reference\n\n        main.playlists[id] = main.playlists[0]; // URI reference added for backwards compatibility\n\n        main.playlists[uri] = main.playlists[0];\n        return main;\n    };\n    /**\n     * Does an in-place update of the main manifest to add updated playlist URI references\n     * as well as other properties needed by VHS that aren't included by the parser.\n     *\n     * @param {Object} main\n     *        main manifest object\n     * @param {string} uri\n     *        The source URI\n     * @param {function} createGroupID\n     *        A function to determine how to create the groupID for mediaGroups\n     */\n\n    const addPropertiesToMain = (main, uri, createGroupID = groupID) => {\n        main.uri = uri;\n        for (let i = 0; i < main.playlists.length; i++) {\n            if (!main.playlists[i].uri) {\n                // Set up phony URIs for the playlists since playlists are referenced by their URIs\n                // throughout VHS, but some formats (e.g., DASH) don't have external URIs\n                // TODO: consider adding dummy URIs in mpd-parser\n                const phonyUri = `placeholder-uri-${i}`;\n                main.playlists[i].uri = phonyUri;\n            }\n        }\n        const audioOnlyMain = isAudioOnly(main);\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            // add a playlist array under properties\n            if (!properties.playlists || !properties.playlists.length) {\n                // If the manifest is audio only and this media group does not have a uri, check\n                // if the media group is located in the main list of playlists. If it is, don't add\n                // placeholder properties as it shouldn't be considered an alternate audio track.\n                if (audioOnlyMain && mediaType === 'AUDIO' && !properties.uri) {\n                    for (let i = 0; i < main.playlists.length; i++) {\n                        const p = main.playlists[i];\n                        if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {\n                            return;\n                        }\n                    }\n                }\n                properties.playlists = [_extends$1({}, properties)];\n            }\n            properties.playlists.forEach(function (p, i) {\n                const groupId = createGroupID(mediaType, groupKey, labelKey, p);\n                const id = createPlaylistID(i, groupId);\n                if (p.uri) {\n                    p.resolvedUri = p.resolvedUri || resolveUrl(main.uri, p.uri);\n                } else {\n                    // DEPRECATED, this has been added to prevent a breaking change.\n                    // previously we only ever had a single media group playlist, so\n                    // we mark the first playlist uri without prepending the index as we used to\n                    // ideally we would do all of the playlists the same way.\n                    p.uri = i === 0 ? groupId : id; // don't resolve a placeholder uri to an absolute url, just use\n                    // the placeholder again\n\n                    p.resolvedUri = p.uri;\n                }\n                p.id = p.id || id; // add an empty attributes object, all playlists are\n                // expected to have this.\n\n                p.attributes = p.attributes || {}; // setup ID and URI references (URI for backwards compatibility)\n\n                main.playlists[p.id] = p;\n                main.playlists[p.uri] = p;\n            });\n        });\n        setupMediaPlaylists(main);\n        resolveMediaGroupUris(main);\n    };\n    class DateRangesStorage {\n        constructor() {\n            this.offset_ = null;\n            this.pendingDateRanges_ = new Map();\n            this.processedDateRanges_ = new Map();\n        }\n        setOffset(segments = []) {\n            // already set\n            if (this.offset_ !== null) {\n                return;\n            } // no segment to process\n\n            if (!segments.length) {\n                return;\n            }\n            const [firstSegment] = segments; // no program date time\n\n            if (firstSegment.programDateTime === undefined) {\n                return;\n            } // Set offset as ProgramDateTime for the very first segment of the very first playlist load:\n\n            this.offset_ = firstSegment.programDateTime / 1000;\n        }\n        setPendingDateRanges(dateRanges = []) {\n            if (!dateRanges.length) {\n                return;\n            }\n            const [dateRange] = dateRanges;\n            const startTime = dateRange.startDate.getTime();\n            this.trimProcessedDateRanges_(startTime);\n            this.pendingDateRanges_ = dateRanges.reduce((map, pendingDateRange) => {\n                map.set(pendingDateRange.id, pendingDateRange);\n                return map;\n            }, new Map());\n        }\n        processDateRange(dateRange) {\n            this.pendingDateRanges_.delete(dateRange.id);\n            this.processedDateRanges_.set(dateRange.id, dateRange);\n        }\n        getDateRangesToProcess() {\n            if (this.offset_ === null) {\n                return [];\n            }\n            const dateRangeClasses = {};\n            const dateRangesToProcess = [];\n            this.pendingDateRanges_.forEach((dateRange, id) => {\n                if (this.processedDateRanges_.has(id)) {\n                    return;\n                }\n                dateRange.startTime = dateRange.startDate.getTime() / 1000 - this.offset_;\n                dateRange.processDateRange = () => this.processDateRange(dateRange);\n                dateRangesToProcess.push(dateRange);\n                if (!dateRange.class) {\n                    return;\n                }\n                if (dateRangeClasses[dateRange.class]) {\n                    const length = dateRangeClasses[dateRange.class].push(dateRange);\n                    dateRange.classListIndex = length - 1;\n                } else {\n                    dateRangeClasses[dateRange.class] = [dateRange];\n                    dateRange.classListIndex = 0;\n                }\n            });\n            for (const dateRange of dateRangesToProcess) {\n                const classList = dateRangeClasses[dateRange.class] || [];\n                if (dateRange.endDate) {\n                    dateRange.endTime = dateRange.endDate.getTime() / 1000 - this.offset_;\n                } else if (dateRange.endOnNext && classList[dateRange.classListIndex + 1]) {\n                    dateRange.endTime = classList[dateRange.classListIndex + 1].startTime;\n                } else if (dateRange.duration) {\n                    dateRange.endTime = dateRange.startTime + dateRange.duration;\n                } else if (dateRange.plannedDuration) {\n                    dateRange.endTime = dateRange.startTime + dateRange.plannedDuration;\n                } else {\n                    dateRange.endTime = dateRange.startTime;\n                }\n            }\n            return dateRangesToProcess;\n        }\n        trimProcessedDateRanges_(startTime) {\n            const copy = new Map(this.processedDateRanges_);\n            copy.forEach((dateRange, id) => {\n                if (dateRange.startDate.getTime() < startTime) {\n                    this.processedDateRanges_.delete(id);\n                }\n            });\n        }\n    }\n    const {\n        EventTarget: EventTarget$1\n    } = videojs;\n    const addLLHLSQueryDirectives = (uri, media) => {\n        if (media.endList || !media.serverControl) {\n            return uri;\n        }\n        const parameters = {};\n        if (media.serverControl.canBlockReload) {\n            const {\n                preloadSegment\n            } = media; // next msn is a zero based value, length is not.\n\n            let nextMSN = media.mediaSequence + media.segments.length; // If preload segment has parts then it is likely\n            // that we are going to request a part of that preload segment.\n            // the logic below is used to determine that.\n\n            if (preloadSegment) {\n                const parts = preloadSegment.parts || []; // _HLS_part is a zero based index\n\n                const nextPart = getKnownPartCount(media) - 1; // if nextPart is > -1 and not equal to just the\n                // length of parts, then we know we had part preload hints\n                // and we need to add the _HLS_part= query\n\n                if (nextPart > -1 && nextPart !== parts.length - 1) {\n                    // add existing parts to our preload hints\n                    // eslint-disable-next-line\n                    parameters._HLS_part = nextPart;\n                } // this if statement makes sure that we request the msn\n                // of the preload segment if:\n                // 1. the preload segment had parts (and was not yet a full segment)\n                //    but was added to our segments array\n                // 2. the preload segment had preload hints for parts that are not in\n                //    the manifest yet.\n                // in all other cases we want the segment after the preload segment\n                // which will be given by using media.segments.length because it is 1 based\n                // rather than 0 based.\n\n                if (nextPart > -1 || parts.length) {\n                    nextMSN--;\n                }\n            } // add _HLS_msn= in front of any _HLS_part query\n            // eslint-disable-next-line\n\n            parameters._HLS_msn = nextMSN;\n        }\n        if (media.serverControl && media.serverControl.canSkipUntil) {\n            // add _HLS_skip= infront of all other queries.\n            // eslint-disable-next-line\n            parameters._HLS_skip = media.serverControl.canSkipDateranges ? 'v2' : 'YES';\n        }\n        if (Object.keys(parameters).length) {\n            const parsedUri = new window.URL(uri);\n            ['_HLS_skip', '_HLS_msn', '_HLS_part'].forEach(function (name) {\n                if (!parameters.hasOwnProperty(name)) {\n                    return;\n                }\n                parsedUri.searchParams.set(name, parameters[name]);\n            });\n            uri = parsedUri.toString();\n        }\n        return uri;\n    };\n    /**\n     * Returns a new segment object with properties and\n     * the parts array merged.\n     *\n     * @param {Object} a the old segment\n     * @param {Object} b the new segment\n     *\n     * @return {Object} the merged segment\n     */\n\n    const updateSegment = (a, b) => {\n        if (!a) {\n            return b;\n        }\n        const result = merge(a, b); // if only the old segment has preload hints\n        // and the new one does not, remove preload hints.\n\n        if (a.preloadHints && !b.preloadHints) {\n            delete result.preloadHints;\n        } // if only the old segment has parts\n        // then the parts are no longer valid\n\n        if (a.parts && !b.parts) {\n            delete result.parts; // if both segments have parts\n            // copy part propeties from the old segment\n            // to the new one.\n        } else if (a.parts && b.parts) {\n            for (let i = 0; i < b.parts.length; i++) {\n                if (a.parts && a.parts[i]) {\n                    result.parts[i] = merge(a.parts[i], b.parts[i]);\n                }\n            }\n        } // set skipped to false for segments that have\n        // have had information merged from the old segment.\n\n        if (!a.skipped && b.skipped) {\n            result.skipped = false;\n        } // set preload to false for segments that have\n        // had information added in the new segment.\n\n        if (a.preload && !b.preload) {\n            result.preload = false;\n        }\n        return result;\n    };\n    /**\n     * Returns a new array of segments that is the result of merging\n     * properties from an older list of segments onto an updated\n     * list. No properties on the updated playlist will be ovewritten.\n     *\n     * @param {Array} original the outdated list of segments\n     * @param {Array} update the updated list of segments\n     * @param {number=} offset the index of the first update\n     * segment in the original segment list. For non-live playlists,\n     * this should always be zero and does not need to be\n     * specified. For live playlists, it should be the difference\n     * between the media sequence numbers in the original and updated\n     * playlists.\n     * @return {Array} a list of merged segment objects\n     */\n\n    const updateSegments = (original, update, offset) => {\n        const oldSegments = original.slice();\n        const newSegments = update.slice();\n        offset = offset || 0;\n        const result = [];\n        let currentMap;\n        for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {\n            const oldSegment = oldSegments[newIndex + offset];\n            const newSegment = newSegments[newIndex];\n            if (oldSegment) {\n                currentMap = oldSegment.map || currentMap;\n                result.push(updateSegment(oldSegment, newSegment));\n            } else {\n                // carry over map to new segment if it is missing\n                if (currentMap && !newSegment.map) {\n                    newSegment.map = currentMap;\n                }\n                result.push(newSegment);\n            }\n        }\n        return result;\n    };\n    const resolveSegmentUris = (segment, baseUri) => {\n        // preloadSegment will not have a uri at all\n        // as the segment isn't actually in the manifest yet, only parts\n        if (!segment.resolvedUri && segment.uri) {\n            segment.resolvedUri = resolveUrl(baseUri, segment.uri);\n        }\n        if (segment.key && !segment.key.resolvedUri) {\n            segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\n        }\n        if (segment.map && !segment.map.resolvedUri) {\n            segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\n        }\n        if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {\n            segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);\n        }\n        if (segment.parts && segment.parts.length) {\n            segment.parts.forEach(p => {\n                if (p.resolvedUri) {\n                    return;\n                }\n                p.resolvedUri = resolveUrl(baseUri, p.uri);\n            });\n        }\n        if (segment.preloadHints && segment.preloadHints.length) {\n            segment.preloadHints.forEach(p => {\n                if (p.resolvedUri) {\n                    return;\n                }\n                p.resolvedUri = resolveUrl(baseUri, p.uri);\n            });\n        }\n    };\n    const getAllSegments = function (media) {\n        const segments = media.segments || [];\n        const preloadSegment = media.preloadSegment; // a preloadSegment with only preloadHints is not currently\n        // a usable segment, only include a preloadSegment that has\n        // parts.\n\n        if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {\n            // if preloadHints has a MAP that means that the\n            // init segment is going to change. We cannot use any of the parts\n            // from this preload segment.\n            if (preloadSegment.preloadHints) {\n                for (let i = 0; i < preloadSegment.preloadHints.length; i++) {\n                    if (preloadSegment.preloadHints[i].type === 'MAP') {\n                        return segments;\n                    }\n                }\n            } // set the duration for our preload segment to target duration.\n\n            preloadSegment.duration = media.targetDuration;\n            preloadSegment.preload = true;\n            segments.push(preloadSegment);\n        }\n        return segments;\n    }; // consider the playlist unchanged if the playlist object is the same or\n    // the number of segments is equal, the media sequence number is unchanged,\n    // and this playlist hasn't become the end of the playlist\n\n    const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;\n    /**\n     * Returns a new main playlist that is the result of merging an\n     * updated media playlist into the original version. If the\n     * updated media playlist does not match any of the playlist\n     * entries in the original main playlist, null is returned.\n     *\n     * @param {Object} main a parsed main M3U8 object\n     * @param {Object} media a parsed media M3U8 object\n     * @return {Object} a new object that represents the original\n     * main playlist with the updated media playlist merged in, or\n     * null if the merge produced no change.\n     */\n\n    const updateMain$1 = (main, newMedia, unchangedCheck = isPlaylistUnchanged) => {\n        const result = merge(main, {});\n        const oldMedia = result.playlists[newMedia.id];\n        if (!oldMedia) {\n            return null;\n        }\n        if (unchangedCheck(oldMedia, newMedia)) {\n            return null;\n        }\n        newMedia.segments = getAllSegments(newMedia);\n        const mergedPlaylist = merge(oldMedia, newMedia); // always use the new media's preload segment\n\n        if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {\n            delete mergedPlaylist.preloadSegment;\n        } // if the update could overlap existing segment information, merge the two segment lists\n\n        if (oldMedia.segments) {\n            if (newMedia.skip) {\n                newMedia.segments = newMedia.segments || []; // add back in objects for skipped segments, so that we merge\n                // old properties into the new segments\n\n                for (let i = 0; i < newMedia.skip.skippedSegments; i++) {\n                    newMedia.segments.unshift({\n                        skipped: true\n                    });\n                }\n            }\n            mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);\n        } // resolve any segment URIs to prevent us from having to do it later\n\n        mergedPlaylist.segments.forEach(segment => {\n            resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n        }); // TODO Right now in the playlists array there are two references to each playlist, one\n        // that is referenced by index, and one by URI. The index reference may no longer be\n        // necessary.\n\n        for (let i = 0; i < result.playlists.length; i++) {\n            if (result.playlists[i].id === newMedia.id) {\n                result.playlists[i] = mergedPlaylist;\n            }\n        }\n        result.playlists[newMedia.id] = mergedPlaylist; // URI reference added for backwards compatibility\n\n        result.playlists[newMedia.uri] = mergedPlaylist; // update media group playlist references.\n\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            if (!properties.playlists) {\n                return;\n            }\n            for (let i = 0; i < properties.playlists.length; i++) {\n                if (newMedia.id === properties.playlists[i].id) {\n                    properties.playlists[i] = mergedPlaylist;\n                }\n            }\n        });\n        return result;\n    };\n    /**\n     * Calculates the time to wait before refreshing a live playlist\n     *\n     * @param {Object} media\n     *        The current media\n     * @param {boolean} update\n     *        True if there were any updates from the last refresh, false otherwise\n     * @return {number}\n     *         The time in ms to wait before refreshing the live playlist\n     */\n\n    const refreshDelay = (media, update) => {\n        const segments = media.segments || [];\n        const lastSegment = segments[segments.length - 1];\n        const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];\n        const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;\n        if (update && lastDuration) {\n            return lastDuration * 1000;\n        } // if the playlist is unchanged since the last reload or last segment duration\n        // cannot be determined, try again after half the target duration\n\n        return (media.partTargetDuration || media.targetDuration || 10) * 500;\n    };\n    /**\n     * Load a playlist from a remote location\n     *\n     * @class PlaylistLoader\n     * @extends Stream\n     * @param {string|Object} src url or object of manifest\n     * @param {boolean} withCredentials the withCredentials xhr option\n     * @class\n     */\n\n    class PlaylistLoader extends EventTarget$1 {\n        constructor(src, vhs, options = {}) {\n            super();\n            if (!src) {\n                throw new Error('A non-empty playlist URL or object is required');\n            }\n            this.logger_ = logger('PlaylistLoader');\n            const {\n                withCredentials = false\n            } = options;\n            this.src = src;\n            this.vhs_ = vhs;\n            this.withCredentials = withCredentials;\n            this.addDateRangesToTextTrack_ = options.addDateRangesToTextTrack;\n            const vhsOptions = vhs.options_;\n            this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];\n            this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];\n            this.llhls = vhsOptions && vhsOptions.llhls;\n            this.dateRangesStorage_ = new DateRangesStorage(); // initialize the loader state\n\n            this.state = 'HAVE_NOTHING'; // live playlist staleness timeout\n\n            this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);\n            this.on('mediaupdatetimeout', this.handleMediaupdatetimeout_);\n            this.on('loadedplaylist', this.handleLoadedPlaylist_.bind(this));\n        }\n        handleLoadedPlaylist_() {\n            const mediaPlaylist = this.media();\n            if (!mediaPlaylist) {\n                return;\n            }\n            this.dateRangesStorage_.setOffset(mediaPlaylist.segments);\n            this.dateRangesStorage_.setPendingDateRanges(mediaPlaylist.dateRanges);\n            const availableDateRanges = this.dateRangesStorage_.getDateRangesToProcess();\n            if (!availableDateRanges.length || !this.addDateRangesToTextTrack_) {\n                return;\n            }\n            this.addDateRangesToTextTrack_(availableDateRanges);\n        }\n        handleMediaupdatetimeout_() {\n            if (this.state !== 'HAVE_METADATA') {\n                // only refresh the media playlist if no other activity is going on\n                return;\n            }\n            const media = this.media();\n            let uri = resolveUrl(this.main.uri, media.uri);\n            if (this.llhls) {\n                uri = addLLHLSQueryDirectives(uri, media);\n            }\n            this.state = 'HAVE_CURRENT_METADATA';\n            this.request = this.vhs_.xhr({\n                uri,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                if (error) {\n                    return this.playlistRequestError(this.request, this.media(), 'HAVE_METADATA');\n                }\n                this.haveMetadata({\n                    playlistString: this.request.responseText,\n                    url: this.media().uri,\n                    id: this.media().id\n                });\n            });\n        }\n        playlistRequestError(xhr, playlist, startingState) {\n            const {\n                uri,\n                id\n            } = playlist; // any in-flight request is now finished\n\n            this.request = null;\n            if (startingState) {\n                this.state = startingState;\n            }\n            this.error = {\n                playlist: this.main.playlists[id],\n                status: xhr.status,\n                message: `HLS playlist request error at URL: ${uri}.`,\n                responseText: xhr.responseText,\n                code: xhr.status >= 500 ? 4 : 2\n            };\n            this.trigger('error');\n        }\n        parseManifest_({\n                           url,\n                           manifestString\n                       }) {\n            return parseManifest({\n                onwarn: ({\n                             message\n                         }) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),\n                oninfo: ({\n                             message\n                         }) => this.logger_(`m3u8-parser info for ${url}: ${message}`),\n                manifestString,\n                customTagParsers: this.customTagParsers,\n                customTagMappers: this.customTagMappers,\n                llhls: this.llhls\n            });\n        }\n        /**\n         * Update the playlist loader's state in response to a new or updated playlist.\n         *\n         * @param {string} [playlistString]\n         *        Playlist string (if playlistObject is not provided)\n         * @param {Object} [playlistObject]\n         *        Playlist object (if playlistString is not provided)\n         * @param {string} url\n         *        URL of playlist\n         * @param {string} id\n         *        ID to use for playlist\n         */\n\n        haveMetadata({\n                         playlistString,\n                         playlistObject,\n                         url,\n                         id\n                     }) {\n            // any in-flight request is now finished\n            this.request = null;\n            this.state = 'HAVE_METADATA';\n            const playlist = playlistObject || this.parseManifest_({\n                url,\n                manifestString: playlistString\n            });\n            playlist.lastRequest = Date.now();\n            setupMediaPlaylist({\n                playlist,\n                uri: url,\n                id\n            }); // merge this playlist into the main manifest\n\n            const update = updateMain$1(this.main, playlist);\n            this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;\n            this.pendingMedia_ = null;\n            if (update) {\n                this.main = update;\n                this.media_ = this.main.playlists[id];\n            } else {\n                this.trigger('playlistunchanged');\n            }\n            this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));\n            this.trigger('loadedplaylist');\n        }\n        /**\n         * Abort any outstanding work and clean up.\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.stopRequest();\n            window.clearTimeout(this.mediaUpdateTimeout);\n            window.clearTimeout(this.finalRenditionTimeout);\n            this.dateRangesStorage_ = new DateRangesStorage();\n            this.off();\n        }\n        stopRequest() {\n            if (this.request) {\n                const oldRequest = this.request;\n                this.request = null;\n                oldRequest.onreadystatechange = null;\n                oldRequest.abort();\n            }\n        }\n        /**\n         * When called without any arguments, returns the currently\n         * active media playlist. When called with a single argument,\n         * triggers the playlist loader to asynchronously switch to the\n         * specified media playlist. Calling this method while the\n         * loader is in the HAVE_NOTHING causes an error to be emitted\n         * but otherwise has no effect.\n         *\n         * @param {Object=} playlist the parsed media playlist\n         * object to switch to\n         * @param {boolean=} shouldDelay whether we should delay the request by half target duration\n         *\n         * @return {Playlist} the current loaded media\n         */\n\n        media(playlist, shouldDelay) {\n            // getter\n            if (!playlist) {\n                return this.media_;\n            } // setter\n\n            if (this.state === 'HAVE_NOTHING') {\n                throw new Error('Cannot switch media playlist from ' + this.state);\n            } // find the playlist object if the target playlist has been\n            // specified by URI\n\n            if (typeof playlist === 'string') {\n                if (!this.main.playlists[playlist]) {\n                    throw new Error('Unknown playlist URI: ' + playlist);\n                }\n                playlist = this.main.playlists[playlist];\n            }\n            window.clearTimeout(this.finalRenditionTimeout);\n            if (shouldDelay) {\n                const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5 * 1000;\n                this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);\n                return;\n            }\n            const startingState = this.state;\n            const mediaChange = !this.media_ || playlist.id !== this.media_.id;\n            const mainPlaylistRef = this.main.playlists[playlist.id]; // switch to fully loaded playlists immediately\n\n            if (mainPlaylistRef && mainPlaylistRef.endList ||\n                // handle the case of a playlist object (e.g., if using vhs-json with a resolved\n                // media playlist or, for the case of demuxed audio, a resolved audio media group)\n                playlist.endList && playlist.segments.length) {\n                // abort outstanding playlist requests\n                if (this.request) {\n                    this.request.onreadystatechange = null;\n                    this.request.abort();\n                    this.request = null;\n                }\n                this.state = 'HAVE_METADATA';\n                this.media_ = playlist; // trigger media change if the active media has been updated\n\n                if (mediaChange) {\n                    this.trigger('mediachanging');\n                    if (startingState === 'HAVE_MAIN_MANIFEST') {\n                        // The initial playlist was a main manifest, and the first media selected was\n                        // also provided (in the form of a resolved playlist object) as part of the\n                        // source object (rather than just a URL). Therefore, since the media playlist\n                        // doesn't need to be requested, loadedmetadata won't trigger as part of the\n                        // normal flow, and needs an explicit trigger here.\n                        this.trigger('loadedmetadata');\n                    } else {\n                        this.trigger('mediachange');\n                    }\n                }\n                return;\n            } // We update/set the timeout here so that live playlists\n            // that are not a media change will \"start\" the loader as expected.\n            // We expect that this function will start the media update timeout\n            // cycle again. This also prevents a playlist switch failure from\n            // causing us to stall during live.\n\n            this.updateMediaUpdateTimeout_(refreshDelay(playlist, true)); // switching to the active playlist is a no-op\n\n            if (!mediaChange) {\n                return;\n            }\n            this.state = 'SWITCHING_MEDIA'; // there is already an outstanding playlist request\n\n            if (this.request) {\n                if (playlist.resolvedUri === this.request.url) {\n                    // requesting to switch to the same playlist multiple times\n                    // has no effect after the first\n                    return;\n                }\n                this.request.onreadystatechange = null;\n                this.request.abort();\n                this.request = null;\n            } // request the new playlist\n\n            if (this.media_) {\n                this.trigger('mediachanging');\n            }\n            this.pendingMedia_ = playlist;\n            this.request = this.vhs_.xhr({\n                uri: playlist.resolvedUri,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                playlist.lastRequest = Date.now();\n                playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);\n                if (error) {\n                    return this.playlistRequestError(this.request, playlist, startingState);\n                }\n                this.haveMetadata({\n                    playlistString: req.responseText,\n                    url: playlist.uri,\n                    id: playlist.id\n                }); // fire loadedmetadata the first time a media playlist is loaded\n\n                if (startingState === 'HAVE_MAIN_MANIFEST') {\n                    this.trigger('loadedmetadata');\n                } else {\n                    this.trigger('mediachange');\n                }\n            });\n        }\n        /**\n         * pause loading of the playlist\n         */\n\n        pause() {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            }\n            this.stopRequest();\n            if (this.state === 'HAVE_NOTHING') {\n                // If we pause the loader before any data has been retrieved, its as if we never\n                // started, so reset to an unstarted state.\n                this.started = false;\n            } // Need to restore state now that no activity is happening\n\n            if (this.state === 'SWITCHING_MEDIA') {\n                // if the loader was in the process of switching media, it should either return to\n                // HAVE_MAIN_MANIFEST or HAVE_METADATA depending on if the loader has loaded a media\n                // playlist yet. This is determined by the existence of loader.media_\n                if (this.media_) {\n                    this.state = 'HAVE_METADATA';\n                } else {\n                    this.state = 'HAVE_MAIN_MANIFEST';\n                }\n            } else if (this.state === 'HAVE_CURRENT_METADATA') {\n                this.state = 'HAVE_METADATA';\n            }\n        }\n        /**\n         * start loading of the playlist\n         */\n\n        load(shouldDelay) {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            }\n            const media = this.media();\n            if (shouldDelay) {\n                const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5 * 1000;\n                this.mediaUpdateTimeout = window.setTimeout(() => {\n                    this.mediaUpdateTimeout = null;\n                    this.load();\n                }, delay);\n                return;\n            }\n            if (!this.started) {\n                this.start();\n                return;\n            }\n            if (media && !media.endList) {\n                this.trigger('mediaupdatetimeout');\n            } else {\n                this.trigger('loadedplaylist');\n            }\n        }\n        updateMediaUpdateTimeout_(delay) {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            } // we only have use mediaupdatetimeout for live playlists.\n\n            if (!this.media() || this.media().endList) {\n                return;\n            }\n            this.mediaUpdateTimeout = window.setTimeout(() => {\n                this.mediaUpdateTimeout = null;\n                this.trigger('mediaupdatetimeout');\n                this.updateMediaUpdateTimeout_(delay);\n            }, delay);\n        }\n        /**\n         * start loading of the playlist\n         */\n\n        start() {\n            this.started = true;\n            if (typeof this.src === 'object') {\n                // in the case of an entirely constructed manifest object (meaning there's no actual\n                // manifest on a server), default the uri to the page's href\n                if (!this.src.uri) {\n                    this.src.uri = window.location.href;\n                } // resolvedUri is added on internally after the initial request. Since there's no\n                // request for pre-resolved manifests, add on resolvedUri here.\n\n                this.src.resolvedUri = this.src.uri; // Since a manifest object was passed in as the source (instead of a URL), the first\n                // request can be skipped (since the top level of the manifest, at a minimum, is\n                // already available as a parsed manifest object). However, if the manifest object\n                // represents a main playlist, some media playlists may need to be resolved before\n                // the starting segment list is available. Therefore, go directly to setup of the\n                // initial playlist, and let the normal flow continue from there.\n                //\n                // Note that the call to setup is asynchronous, as other sections of VHS may assume\n                // that the first request is asynchronous.\n\n                setTimeout(() => {\n                    this.setupInitialPlaylist(this.src);\n                }, 0);\n                return;\n            } // request the specified URL\n\n            this.request = this.vhs_.xhr({\n                uri: this.src,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                } // clear the loader's request reference\n\n                this.request = null;\n                if (error) {\n                    this.error = {\n                        status: req.status,\n                        message: `HLS playlist request error at URL: ${this.src}.`,\n                        responseText: req.responseText,\n                        // MEDIA_ERR_NETWORK\n                        code: 2\n                    };\n                    if (this.state === 'HAVE_NOTHING') {\n                        this.started = false;\n                    }\n                    return this.trigger('error');\n                }\n                this.src = resolveManifestRedirect(this.src, req);\n                const manifest = this.parseManifest_({\n                    manifestString: req.responseText,\n                    url: this.src\n                });\n                this.setupInitialPlaylist(manifest);\n            });\n        }\n        srcUri() {\n            return typeof this.src === 'string' ? this.src : this.src.uri;\n        }\n        /**\n         * Given a manifest object that's either a main or media playlist, trigger the proper\n         * events and set the state of the playlist loader.\n         *\n         * If the manifest object represents a main playlist, `loadedplaylist` will be\n         * triggered to allow listeners to select a playlist. If none is selected, the loader\n         * will default to the first one in the playlists array.\n         *\n         * If the manifest object represents a media playlist, `loadedplaylist` will be\n         * triggered followed by `loadedmetadata`, as the only available playlist is loaded.\n         *\n         * In the case of a media playlist, a main playlist object wrapper with one playlist\n         * will be created so that all logic can handle playlists in the same fashion (as an\n         * assumed manifest object schema).\n         *\n         * @param {Object} manifest\n         *        The parsed manifest object\n         */\n\n        setupInitialPlaylist(manifest) {\n            this.state = 'HAVE_MAIN_MANIFEST';\n            if (manifest.playlists) {\n                this.main = manifest;\n                addPropertiesToMain(this.main, this.srcUri()); // If the initial main playlist has playlists wtih segments already resolved,\n                // then resolve URIs in advance, as they are usually done after a playlist request,\n                // which may not happen if the playlist is resolved.\n\n                manifest.playlists.forEach(playlist => {\n                    playlist.segments = getAllSegments(playlist);\n                    playlist.segments.forEach(segment => {\n                        resolveSegmentUris(segment, playlist.resolvedUri);\n                    });\n                });\n                this.trigger('loadedplaylist');\n                if (!this.request) {\n                    // no media playlist was specifically selected so start\n                    // from the first listed one\n                    this.media(this.main.playlists[0]);\n                }\n                return;\n            } // In order to support media playlists passed in as vhs-json, the case where the uri\n            // is not provided as part of the manifest should be considered, and an appropriate\n            // default used.\n\n            const uri = this.srcUri() || window.location.href;\n            this.main = mainForMedia(manifest, uri);\n            this.haveMetadata({\n                playlistObject: manifest,\n                url: uri,\n                id: this.main.playlists[0].id\n            });\n            this.trigger('loadedmetadata');\n        }\n        /**\n         * Updates or deletes a preexisting pathway clone.\n         * Ensures that all playlists related to the old pathway clone are\n         * either updated or deleted.\n         *\n         * @param {Object} clone On update, the pathway clone object for the newly updated pathway clone.\n         *        On delete, the old pathway clone object to be deleted.\n         * @param {boolean} isUpdate True if the pathway is to be updated,\n         *        false if it is meant to be deleted.\n         */\n\n        updateOrDeleteClone(clone, isUpdate) {\n            const main = this.main;\n            const pathway = clone.ID;\n            let i = main.playlists.length; // Iterate backwards through the playlist so we can remove playlists if necessary.\n\n            while (i--) {\n                const p = main.playlists[i];\n                if (p.attributes['PATHWAY-ID'] === pathway) {\n                    const oldPlaylistUri = p.resolvedUri;\n                    const oldPlaylistId = p.id; // update the indexed playlist and add new playlists by ID and URI\n\n                    if (isUpdate) {\n                        const newPlaylistUri = this.createCloneURI_(p.resolvedUri, clone);\n                        const newPlaylistId = createPlaylistID(pathway, newPlaylistUri);\n                        const attributes = this.createCloneAttributes_(pathway, p.attributes);\n                        const updatedPlaylist = this.createClonePlaylist_(p, newPlaylistId, clone, attributes);\n                        main.playlists[i] = updatedPlaylist;\n                        main.playlists[newPlaylistId] = updatedPlaylist;\n                        main.playlists[newPlaylistUri] = updatedPlaylist;\n                    } else {\n                        // Remove the indexed playlist.\n                        main.playlists.splice(i, 1);\n                    } // Remove playlists by the old ID and URI.\n\n                    delete main.playlists[oldPlaylistId];\n                    delete main.playlists[oldPlaylistUri];\n                }\n            }\n            this.updateOrDeleteCloneMedia(clone, isUpdate);\n        }\n        /**\n         * Updates or deletes media data based on the pathway clone object.\n         * Due to the complexity of the media groups and playlists, in all cases\n         * we remove all of the old media groups and playlists.\n         * On updates, we then create new media groups and playlists based on the\n         * new pathway clone object.\n         *\n         * @param {Object} clone The pathway clone object for the newly updated pathway clone.\n         * @param {boolean} isUpdate True if the pathway is to be updated,\n         *        false if it is meant to be deleted.\n         */\n\n        updateOrDeleteCloneMedia(clone, isUpdate) {\n            const main = this.main;\n            const id = clone.ID;\n            ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(mediaType => {\n                if (!main.mediaGroups[mediaType] || !main.mediaGroups[mediaType][id]) {\n                    return;\n                }\n                for (const groupKey in main.mediaGroups[mediaType]) {\n                    // Remove all media playlists for the media group for this pathway clone.\n                    if (groupKey === id) {\n                        for (const labelKey in main.mediaGroups[mediaType][groupKey]) {\n                            const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];\n                            oldMedia.playlists.forEach((p, i) => {\n                                const oldMediaPlaylist = main.playlists[p.id];\n                                const oldPlaylistId = oldMediaPlaylist.id;\n                                const oldPlaylistUri = oldMediaPlaylist.resolvedUri;\n                                delete main.playlists[oldPlaylistId];\n                                delete main.playlists[oldPlaylistUri];\n                            });\n                        } // Delete the old media group.\n\n                        delete main.mediaGroups[mediaType][groupKey];\n                    }\n                }\n            }); // Create the new media groups and playlists if there is an update.\n\n            if (isUpdate) {\n                this.createClonedMediaGroups_(clone);\n            }\n        }\n        /**\n         * Given a pathway clone object, clones all necessary playlists.\n         *\n         * @param {Object} clone The pathway clone object.\n         * @param {Object} basePlaylist The original playlist to clone from.\n         */\n\n        addClonePathway(clone, basePlaylist = {}) {\n            const main = this.main;\n            const index = main.playlists.length;\n            const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);\n            const playlistId = createPlaylistID(clone.ID, uri);\n            const attributes = this.createCloneAttributes_(clone.ID, basePlaylist.attributes);\n            const playlist = this.createClonePlaylist_(basePlaylist, playlistId, clone, attributes);\n            main.playlists[index] = playlist; // add playlist by ID and URI\n\n            main.playlists[playlistId] = playlist;\n            main.playlists[uri] = playlist;\n            this.createClonedMediaGroups_(clone);\n        }\n        /**\n         * Given a pathway clone object we create clones of all media.\n         * In this function, all necessary information and updated playlists\n         * are added to the `mediaGroup` object.\n         * Playlists are also added to the `playlists` array so the media groups\n         * will be properly linked.\n         *\n         * @param {Object} clone The pathway clone object.\n         */\n\n        createClonedMediaGroups_(clone) {\n            const id = clone.ID;\n            const baseID = clone['BASE-ID'];\n            const main = this.main;\n            ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(mediaType => {\n                // If the media type doesn't exist, or there is already a clone, skip\n                // to the next media type.\n                if (!main.mediaGroups[mediaType] || main.mediaGroups[mediaType][id]) {\n                    return;\n                }\n                for (const groupKey in main.mediaGroups[mediaType]) {\n                    if (groupKey === baseID) {\n                        // Create the group.\n                        main.mediaGroups[mediaType][id] = {};\n                    } else {\n                        // There is no need to iterate over label keys in this case.\n                        continue;\n                    }\n                    for (const labelKey in main.mediaGroups[mediaType][groupKey]) {\n                        const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];\n                        main.mediaGroups[mediaType][id][labelKey] = _extends$1({}, oldMedia);\n                        const newMedia = main.mediaGroups[mediaType][id][labelKey]; // update URIs on the media\n\n                        const newUri = this.createCloneURI_(oldMedia.resolvedUri, clone);\n                        newMedia.resolvedUri = newUri;\n                        newMedia.uri = newUri; // Reset playlists in the new media group.\n\n                        newMedia.playlists = []; // Create new playlists in the newly cloned media group.\n\n                        oldMedia.playlists.forEach((p, i) => {\n                            const oldMediaPlaylist = main.playlists[p.id];\n                            const group = groupID(mediaType, id, labelKey);\n                            const newPlaylistID = createPlaylistID(id, group); // Check to see if it already exists\n\n                            if (oldMediaPlaylist && !main.playlists[newPlaylistID]) {\n                                const newMediaPlaylist = this.createClonePlaylist_(oldMediaPlaylist, newPlaylistID, clone);\n                                const newPlaylistUri = newMediaPlaylist.resolvedUri;\n                                main.playlists[newPlaylistID] = newMediaPlaylist;\n                                main.playlists[newPlaylistUri] = newMediaPlaylist;\n                            }\n                            newMedia.playlists[i] = this.createClonePlaylist_(p, newPlaylistID, clone);\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Using the original playlist to be cloned, and the pathway clone object\n         * information, we create a new playlist.\n         *\n         * @param {Object} basePlaylist  The original playlist to be cloned from.\n         * @param {string} id The desired id of the newly cloned playlist.\n         * @param {Object} clone The pathway clone object.\n         * @param {Object} attributes An optional object to populate the `attributes` property in the playlist.\n         *\n         * @return {Object} The combined cloned playlist.\n         */\n\n        createClonePlaylist_(basePlaylist, id, clone, attributes) {\n            const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);\n            const newProps = {\n                resolvedUri: uri,\n                uri,\n                id\n            }; // Remove all segments from previous playlist in the clone.\n\n            if (basePlaylist.segments) {\n                newProps.segments = [];\n            }\n            if (attributes) {\n                newProps.attributes = attributes;\n            }\n            return merge(basePlaylist, newProps);\n        }\n        /**\n         * Generates an updated URI for a cloned pathway based on the original\n         * pathway's URI and the paramaters from the pathway clone object in the\n         * content steering server response.\n         *\n         * @param {string} baseUri URI to be updated in the cloned pathway.\n         * @param {Object} clone The pathway clone object.\n         *\n         * @return {string} The updated URI for the cloned pathway.\n         */\n\n        createCloneURI_(baseURI, clone) {\n            const uri = new URL(baseURI);\n            uri.hostname = clone['URI-REPLACEMENT'].HOST;\n            const params = clone['URI-REPLACEMENT'].PARAMS; // Add params to the cloned URL.\n\n            for (const key of Object.keys(params)) {\n                uri.searchParams.set(key, params[key]);\n            }\n            return uri.href;\n        }\n        /**\n         * Helper function to create the attributes needed for the new clone.\n         * This mainly adds the necessary media attributes.\n         *\n         * @param {string} id The pathway clone object ID.\n         * @param {Object} oldAttributes The old attributes to compare to.\n         * @return {Object} The new attributes to add to the playlist.\n         */\n\n        createCloneAttributes_(id, oldAttributes) {\n            const attributes = {\n                ['PATHWAY-ID']: id\n            };\n            ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(mediaType => {\n                if (oldAttributes[mediaType]) {\n                    attributes[mediaType] = id;\n                }\n            });\n            return attributes;\n        }\n        /**\n         * Returns the key ID set from a playlist\n         *\n         * @param {playlist} playlist to fetch the key ID set from.\n         * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.\n         */\n\n        getKeyIdSet(playlist) {\n            if (playlist.contentProtection) {\n                const keyIds = new Set();\n                for (const keysystem in playlist.contentProtection) {\n                    const keyId = playlist.contentProtection[keysystem].attributes.keyId;\n                    if (keyId) {\n                        keyIds.add(keyId.toLowerCase());\n                    }\n                }\n                return keyIds;\n            }\n        }\n    }\n\n    /**\n     * @file xhr.js\n     */\n    const {\n        xhr: videojsXHR\n    } = videojs;\n    const callbackWrapper = function (request, error, response, callback) {\n        const reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;\n        if (!error && reqResponse) {\n            request.responseTime = Date.now();\n            request.roundTripTime = request.responseTime - request.requestTime;\n            request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n            if (!request.bandwidth) {\n                request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n            }\n        }\n        if (response.headers) {\n            request.responseHeaders = response.headers;\n        } // videojs.xhr now uses a specific code on the error\n        // object to signal that a request has timed out instead\n        // of setting a boolean on the request object\n\n        if (error && error.code === 'ETIMEDOUT') {\n            request.timedout = true;\n        } // videojs.xhr no longer considers status codes outside of 200 and 0\n        // (for file uris) to be errors, but the old XHR did, so emulate that\n        // behavior. Status 206 may be used in response to byterange requests.\n\n        if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n            error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n        }\n        callback(error, request);\n    };\n    /**\n     * Iterates over the request hooks Set and calls them in order\n     *\n     * @param {Set} hooks the hook Set to iterate over\n     * @param {Object} options the request options to pass to the xhr wrapper\n     * @return the callback hook function return value, the modified or new options Object.\n     */\n\n    const callAllRequestHooks = (requestSet, options) => {\n        if (!requestSet || !requestSet.size) {\n            return;\n        }\n        let newOptions = options;\n        requestSet.forEach(requestCallback => {\n            newOptions = requestCallback(newOptions);\n        });\n        return newOptions;\n    };\n    /**\n     * Iterates over the response hooks Set and calls them in order.\n     *\n     * @param {Set} hooks the hook Set to iterate over\n     * @param {Object} request the xhr request object\n     * @param {Object} error the xhr error object\n     * @param {Object} response the xhr response object\n     */\n\n    const callAllResponseHooks = (responseSet, request, error, response) => {\n        if (!responseSet || !responseSet.size) {\n            return;\n        }\n        responseSet.forEach(responseCallback => {\n            responseCallback(request, error, response);\n        });\n    };\n    const xhrFactory = function () {\n        const xhr = function XhrFunction(options, callback) {\n            // Add a default timeout\n            options = merge({\n                timeout: 45e3\n            }, options); // Allow an optional user-specified function to modify the option\n            // object before we construct the xhr request\n            // TODO: Remove beforeRequest in the next major release.\n\n            const beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest; // onRequest and onResponse hooks as a Set, at either the player or global level.\n            // TODO: new Set added here for beforeRequest alias. Remove this when beforeRequest is removed.\n\n            const _requestCallbackSet = XhrFunction._requestCallbackSet || videojs.Vhs.xhr._requestCallbackSet || new Set();\n            const _responseCallbackSet = XhrFunction._responseCallbackSet || videojs.Vhs.xhr._responseCallbackSet;\n            if (beforeRequest && typeof beforeRequest === 'function') {\n                videojs.log.warn('beforeRequest is deprecated, use onRequest instead.');\n                _requestCallbackSet.add(beforeRequest);\n            } // Use the standard videojs.xhr() method unless `videojs.Vhs.xhr` has been overriden\n            // TODO: switch back to videojs.Vhs.xhr.name === 'XhrFunction' when we drop IE11\n\n            const xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr; // call all registered onRequest hooks, assign new options.\n\n            const beforeRequestOptions = callAllRequestHooks(_requestCallbackSet, options); // Remove the beforeRequest function from the hooks set so stale beforeRequest functions are not called.\n\n            _requestCallbackSet.delete(beforeRequest); // xhrMethod will call XMLHttpRequest.open and XMLHttpRequest.send\n\n            const request = xhrMethod(beforeRequestOptions || options, function (error, response) {\n                // call all registered onResponse hooks\n                callAllResponseHooks(_responseCallbackSet, request, error, response);\n                return callbackWrapper(request, error, response, callback);\n            });\n            const originalAbort = request.abort;\n            request.abort = function () {\n                request.aborted = true;\n                return originalAbort.apply(request, arguments);\n            };\n            request.uri = options.uri;\n            request.requestTime = Date.now();\n            return request;\n        };\n        xhr.original = true;\n        return xhr;\n    };\n    /**\n     * Turns segment byterange into a string suitable for use in\n     * HTTP Range requests\n     *\n     * @param {Object} byterange - an object with two values defining the start and end\n     *                             of a byte-range\n     */\n\n    const byterangeStr = function (byterange) {\n        // `byterangeEnd` is one less than `offset + length` because the HTTP range\n        // header uses inclusive ranges\n        let byterangeEnd;\n        const byterangeStart = byterange.offset;\n        if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n            byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n        } else {\n            byterangeEnd = byterange.offset + byterange.length - 1;\n        }\n        return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n    };\n    /**\n     * Defines headers for use in the xhr request for a particular segment.\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     */\n\n    const segmentXhrHeaders = function (segment) {\n        const headers = {};\n        if (segment.byterange) {\n            headers.Range = byterangeStr(segment.byterange);\n        }\n        return headers;\n    };\n\n    /**\n     * @file bin-utils.js\n     */\n\n    /**\n     * convert a TimeRange to text\n     *\n     * @param {TimeRange} range the timerange to use for conversion\n     * @param {number} i the iterator on the range to convert\n     * @return {string} the range in string format\n     */\n\n    const textRange = function (range, i) {\n        return range.start(i) + '-' + range.end(i);\n    };\n    /**\n     * format a number as hex string\n     *\n     * @param {number} e The number\n     * @param {number} i the iterator\n     * @return {string} the hex formatted number as a string\n     */\n\n    const formatHexString = function (e, i) {\n        const value = e.toString(16);\n        return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n    };\n    const formatAsciiString = function (e) {\n        if (e >= 0x20 && e < 0x7e) {\n            return String.fromCharCode(e);\n        }\n        return '.';\n    };\n    /**\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n     *\n     * @param {Object} message\n     *        Object of properties and values to send to the web worker\n     * @return {Object}\n     *         Modified message with TypedArray values expanded\n     * @function createTransferableMessage\n     */\n\n    const createTransferableMessage = function (message) {\n        const transferable = {};\n        Object.keys(message).forEach(key => {\n            const value = message[key];\n            if (isArrayBufferView(value)) {\n                transferable[key] = {\n                    bytes: value.buffer,\n                    byteOffset: value.byteOffset,\n                    byteLength: value.byteLength\n                };\n            } else {\n                transferable[key] = value;\n            }\n        });\n        return transferable;\n    };\n    /**\n     * Returns a unique string identifier for a media initialization\n     * segment.\n     *\n     * @param {Object} initSegment\n     *        the init segment object.\n     *\n     * @return {string} the generated init segment id\n     */\n\n    const initSegmentId = function (initSegment) {\n        const byterange = initSegment.byterange || {\n            length: Infinity,\n            offset: 0\n        };\n        return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n    };\n    /**\n     * Returns a unique string identifier for a media segment key.\n     *\n     * @param {Object} key the encryption key\n     * @return {string} the unique id for the media segment key.\n     */\n\n    const segmentKeyId = function (key) {\n        return key.resolvedUri;\n    };\n    /**\n     * utils to help dump binary data to the console\n     *\n     * @param {Array|TypedArray} data\n     *        data to dump to a string\n     *\n     * @return {string} the data as a hex string.\n     */\n\n    const hexDump = data => {\n        const bytes = Array.prototype.slice.call(data);\n        const step = 16;\n        let result = '';\n        let hex;\n        let ascii;\n        for (let j = 0; j < bytes.length / step; j++) {\n            hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n            ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n            result += hex + ' ' + ascii + '\\n';\n        }\n        return result;\n    };\n    const tagDump = ({\n                         bytes\n                     }) => hexDump(bytes);\n    const textRanges = ranges => {\n        let result = '';\n        let i;\n        for (i = 0; i < ranges.length; i++) {\n            result += textRange(ranges, i) + ' ';\n        }\n        return result;\n    };\n    var utils = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createTransferableMessage: createTransferableMessage,\n        initSegmentId: initSegmentId,\n        segmentKeyId: segmentKeyId,\n        hexDump: hexDump,\n        tagDump: tagDump,\n        textRanges: textRanges\n    });\n\n    // TODO handle fmp4 case where the timing info is accurate and doesn't involve transmux\n    // 25% was arbitrarily chosen, and may need to be refined over time.\n\n    const SEGMENT_END_FUDGE_PERCENT = 0.25;\n    /**\n     * Converts a player time (any time that can be gotten/set from player.currentTime(),\n     * e.g., any time within player.seekable().start(0) to player.seekable().end(0)) to a\n     * program time (any time referencing the real world (e.g., EXT-X-PROGRAM-DATE-TIME)).\n     *\n     * The containing segment is required as the EXT-X-PROGRAM-DATE-TIME serves as an \"anchor\n     * point\" (a point where we have a mapping from program time to player time, with player\n     * time being the post transmux start of the segment).\n     *\n     * For more details, see [this doc](../../docs/program-time-from-player-time.md).\n     *\n     * @param {number} playerTime the player time\n     * @param {Object} segment the segment which contains the player time\n     * @return {Date} program time\n     */\n\n    const playerTimeToProgramTime = (playerTime, segment) => {\n        if (!segment.dateTimeObject) {\n            // Can't convert without an \"anchor point\" for the program time (i.e., a time that can\n            // be used to map the start of a segment with a real world time).\n            return null;\n        }\n        const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;\n        const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart; // get the start of the content from before old content is prepended\n\n        const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;\n        const offsetFromSegmentStart = playerTime - startOfSegment;\n        return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);\n    };\n    const originalSegmentVideoDuration = videoTimingInfo => {\n        return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;\n    };\n    /**\n     * Finds a segment that contains the time requested given as an ISO-8601 string. The\n     * returned segment might be an estimate or an accurate match.\n     *\n     * @param {string} programTime The ISO-8601 programTime to find a match for\n     * @param {Object} playlist A playlist object to search within\n     */\n\n    const findSegmentForProgramTime = (programTime, playlist) => {\n        // Assumptions:\n        //  - verifyProgramDateTimeTags has already been run\n        //  - live streams have been started\n        let dateTimeObject;\n        try {\n            dateTimeObject = new Date(programTime);\n        } catch (e) {\n            return null;\n        }\n        if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n            return null;\n        }\n        let segment = playlist.segments[0];\n        if (dateTimeObject < new Date(segment.dateTimeObject)) {\n            // Requested time is before stream start.\n            return null;\n        }\n        for (let i = 0; i < playlist.segments.length - 1; i++) {\n            segment = playlist.segments[i];\n            const nextSegmentStart = new Date(playlist.segments[i + 1].dateTimeObject);\n            if (dateTimeObject < nextSegmentStart) {\n                break;\n            }\n        }\n        const lastSegment = playlist.segments[playlist.segments.length - 1];\n        const lastSegmentStart = lastSegment.dateTimeObject;\n        const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;\n        const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);\n        if (dateTimeObject > lastSegmentEnd) {\n            // Beyond the end of the stream, or our best guess of the end of the stream.\n            return null;\n        }\n        if (dateTimeObject > new Date(lastSegmentStart)) {\n            segment = lastSegment;\n        }\n        return {\n            segment,\n            estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),\n            // Although, given that all segments have accurate date time objects, the segment\n            // selected should be accurate, unless the video has been transmuxed at some point\n            // (determined by the presence of the videoTimingInfo object), the segment's \"player\n            // time\" (the start time in the player) can't be considered accurate.\n            type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n        };\n    };\n    /**\n     * Finds a segment that contains the given player time(in seconds).\n     *\n     * @param {number} time The player time to find a match for\n     * @param {Object} playlist A playlist object to search within\n     */\n\n    const findSegmentForPlayerTime = (time, playlist) => {\n        // Assumptions:\n        // - there will always be a segment.duration\n        // - we can start from zero\n        // - segments are in time order\n        if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n            return null;\n        }\n        let segmentEnd = 0;\n        let segment;\n        for (let i = 0; i < playlist.segments.length; i++) {\n            segment = playlist.segments[i]; // videoTimingInfo is set after the segment is downloaded and transmuxed, and\n            // should contain the most accurate values we have for the segment's player times.\n            //\n            // Use the accurate transmuxedPresentationEnd value if it is available, otherwise fall\n            // back to an estimate based on the manifest derived (inaccurate) segment.duration, to\n            // calculate an end value.\n\n            segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;\n            if (time <= segmentEnd) {\n                break;\n            }\n        }\n        const lastSegment = playlist.segments[playlist.segments.length - 1];\n        if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {\n            // The time requested is beyond the stream end.\n            return null;\n        }\n        if (time > segmentEnd) {\n            // The time is within or beyond the last segment.\n            //\n            // Check to see if the time is beyond a reasonable guess of the end of the stream.\n            if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {\n                // Technically, because the duration value is only an estimate, the time may still\n                // exist in the last segment, however, there isn't enough information to make even\n                // a reasonable estimate.\n                return null;\n            }\n            segment = lastSegment;\n        }\n        return {\n            segment,\n            estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,\n            // Because videoTimingInfo is only set after transmux, it is the only way to get\n            // accurate timing values.\n            type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n        };\n    };\n    /**\n     * Gives the offset of the comparisonTimestamp from the programTime timestamp in seconds.\n     * If the offset returned is positive, the programTime occurs after the\n     * comparisonTimestamp.\n     * If the offset is negative, the programTime occurs before the comparisonTimestamp.\n     *\n     * @param {string} comparisonTimeStamp An ISO-8601 timestamp to compare against\n     * @param {string} programTime The programTime as an ISO-8601 string\n     * @return {number} offset\n     */\n\n    const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {\n        let segmentDateTime;\n        let programDateTime;\n        try {\n            segmentDateTime = new Date(comparisonTimeStamp);\n            programDateTime = new Date(programTime);\n        } catch (e) {// TODO handle error\n        }\n        const segmentTimeEpoch = segmentDateTime.getTime();\n        const programTimeEpoch = programDateTime.getTime();\n        return (programTimeEpoch - segmentTimeEpoch) / 1000;\n    };\n    /**\n     * Checks that all segments in this playlist have programDateTime tags.\n     *\n     * @param {Object} playlist A playlist object\n     */\n\n    const verifyProgramDateTimeTags = playlist => {\n        if (!playlist.segments || playlist.segments.length === 0) {\n            return false;\n        }\n        for (let i = 0; i < playlist.segments.length; i++) {\n            const segment = playlist.segments[i];\n            if (!segment.dateTimeObject) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Returns the programTime of the media given a playlist and a playerTime.\n     * The playlist must have programDateTime tags for a programDateTime tag to be returned.\n     * If the segments containing the time requested have not been buffered yet, an estimate\n     * may be returned to the callback.\n     *\n     * @param {Object} args\n     * @param {Object} args.playlist A playlist object to search within\n     * @param {number} time A playerTime in seconds\n     * @param {Function} callback(err, programTime)\n     * @return {string} err.message A detailed error message\n     * @return {Object} programTime\n     * @return {number} programTime.mediaSeconds The streamTime in seconds\n     * @return {string} programTime.programDateTime The programTime as an ISO-8601 String\n     */\n\n    const getProgramTime = ({\n                                playlist,\n                                time = undefined,\n                                callback\n                            }) => {\n        if (!callback) {\n            throw new Error('getProgramTime: callback must be provided');\n        }\n        if (!playlist || time === undefined) {\n            return callback({\n                message: 'getProgramTime: playlist and time must be provided'\n            });\n        }\n        const matchedSegment = findSegmentForPlayerTime(time, playlist);\n        if (!matchedSegment) {\n            return callback({\n                message: 'valid programTime was not found'\n            });\n        }\n        if (matchedSegment.type === 'estimate') {\n            return callback({\n                message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',\n                seekTime: matchedSegment.estimatedStart\n            });\n        }\n        const programTimeObject = {\n            mediaSeconds: time\n        };\n        const programTime = playerTimeToProgramTime(time, matchedSegment.segment);\n        if (programTime) {\n            programTimeObject.programDateTime = programTime.toISOString();\n        }\n        return callback(null, programTimeObject);\n    };\n    /**\n     * Seeks in the player to a time that matches the given programTime ISO-8601 string.\n     *\n     * @param {Object} args\n     * @param {string} args.programTime A programTime to seek to as an ISO-8601 String\n     * @param {Object} args.playlist A playlist to look within\n     * @param {number} args.retryCount The number of times to try for an accurate seek. Default is 2.\n     * @param {Function} args.seekTo A method to perform a seek\n     * @param {boolean} args.pauseAfterSeek Whether to end in a paused state after seeking. Default is true.\n     * @param {Object} args.tech The tech to seek on\n     * @param {Function} args.callback(err, newTime) A callback to return the new time to\n     * @return {string} err.message A detailed error message\n     * @return {number} newTime The exact time that was seeked to in seconds\n     */\n\n    const seekToProgramTime = ({\n                                   programTime,\n                                   playlist,\n                                   retryCount = 2,\n                                   seekTo,\n                                   pauseAfterSeek = true,\n                                   tech,\n                                   callback\n                               }) => {\n        if (!callback) {\n            throw new Error('seekToProgramTime: callback must be provided');\n        }\n        if (typeof programTime === 'undefined' || !playlist || !seekTo) {\n            return callback({\n                message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'\n            });\n        }\n        if (!playlist.endList && !tech.hasStarted_) {\n            return callback({\n                message: 'player must be playing a live stream to start buffering'\n            });\n        }\n        if (!verifyProgramDateTimeTags(playlist)) {\n            return callback({\n                message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri\n            });\n        }\n        const matchedSegment = findSegmentForProgramTime(programTime, playlist); // no match\n\n        if (!matchedSegment) {\n            return callback({\n                message: `${programTime} was not found in the stream`\n            });\n        }\n        const segment = matchedSegment.segment;\n        const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);\n        if (matchedSegment.type === 'estimate') {\n            // we've run out of retries\n            if (retryCount === 0) {\n                return callback({\n                    message: `${programTime} is not buffered yet. Try again`\n                });\n            }\n            seekTo(matchedSegment.estimatedStart + mediaOffset);\n            tech.one('seeked', () => {\n                seekToProgramTime({\n                    programTime,\n                    playlist,\n                    retryCount: retryCount - 1,\n                    seekTo,\n                    pauseAfterSeek,\n                    tech,\n                    callback\n                });\n            });\n            return;\n        } // Since the segment.start value is determined from the buffered end or ending time\n        // of the prior segment, the seekToTime doesn't need to account for any transmuxer\n        // modifications.\n\n        const seekToTime = segment.start + mediaOffset;\n        const seekedCallback = () => {\n            return callback(null, tech.currentTime());\n        }; // listen for seeked event\n\n        tech.one('seeked', seekedCallback); // pause before seeking as video.js will restore this state\n\n        if (pauseAfterSeek) {\n            tech.pause();\n        }\n        seekTo(seekToTime);\n    };\n\n    // which will only happen if the request is complete.\n\n    const callbackOnCompleted = (request, cb) => {\n        if (request.readyState === 4) {\n            return cb();\n        }\n        return;\n    };\n    const containerRequest = (uri, xhr, cb) => {\n        let bytes = [];\n        let id3Offset;\n        let finished = false;\n        const endRequestAndCallback = function (err, req, type, _bytes) {\n            req.abort();\n            finished = true;\n            return cb(err, req, type, _bytes);\n        };\n        const progressListener = function (error, request) {\n            if (finished) {\n                return;\n            }\n            if (error) {\n                return endRequestAndCallback(error, request, '', bytes);\n            } // grap the new part of content that was just downloaded\n\n            const newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length); // add that onto bytes\n\n            bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));\n            id3Offset = id3Offset || getId3Offset(bytes); // we need at least 10 bytes to determine a type\n            // or we need at least two bytes after an id3Offset\n\n            if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            }\n            const type = detectContainerForBytes(bytes); // if this looks like a ts segment but we don't have enough data\n            // to see the second sync byte, wait until we have enough data\n            // before declaring it ts\n\n            if (type === 'ts' && bytes.length < 188) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            } // this may be an unsynced ts segment\n            // wait for 376 bytes before detecting no container\n\n            if (!type && bytes.length < 376) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            }\n            return endRequestAndCallback(null, request, type, bytes);\n        };\n        const options = {\n            uri,\n            beforeSend(request) {\n                // this forces the browser to pass the bytes to us unprocessed\n                request.overrideMimeType('text/plain; charset=x-user-defined');\n                request.addEventListener('progress', function ({\n                                                                   total,\n                                                                   loaded\n                                                               }) {\n                    return callbackWrapper(request, null, {\n                        statusCode: request.status\n                    }, progressListener);\n                });\n            }\n        };\n        const request = xhr(options, function (error, response) {\n            return callbackWrapper(request, error, response, progressListener);\n        });\n        return request;\n    };\n    const {\n        EventTarget\n    } = videojs;\n    const dashPlaylistUnchanged = function (a, b) {\n        if (!isPlaylistUnchanged(a, b)) {\n            return false;\n        } // for dash the above check will often return true in scenarios where\n        // the playlist actually has changed because mediaSequence isn't a\n        // dash thing, and we often set it to 1. So if the playlists have the same amount\n        // of segments we return true.\n        // So for dash we need to make sure that the underlying segments are different.\n        // if sidx changed then the playlists are different.\n\n        if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {\n            return false;\n        } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {\n            return false;\n        } // one or the other does not have segments\n        // there was a change.\n\n        if (a.segments && !b.segments || !a.segments && b.segments) {\n            return false;\n        } // neither has segments nothing changed\n\n        if (!a.segments && !b.segments) {\n            return true;\n        } // check segments themselves\n\n        for (let i = 0; i < a.segments.length; i++) {\n            const aSegment = a.segments[i];\n            const bSegment = b.segments[i]; // if uris are different between segments there was a change\n\n            if (aSegment.uri !== bSegment.uri) {\n                return false;\n            } // neither segment has a byterange, there will be no byterange change.\n\n            if (!aSegment.byterange && !bSegment.byterange) {\n                continue;\n            }\n            const aByterange = aSegment.byterange;\n            const bByterange = bSegment.byterange; // if byterange only exists on one of the segments, there was a change.\n\n            if (aByterange && !bByterange || !aByterange && bByterange) {\n                return false;\n            } // if both segments have byterange with different offsets, there was a change.\n\n            if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {\n                return false;\n            }\n        } // if everything was the same with segments, this is the same playlist.\n\n        return true;\n    };\n    /**\n     * Use the representation IDs from the mpd object to create groupIDs, the NAME is set to mandatory representation\n     * ID in the parser. This allows for continuous playout across periods with the same representation IDs\n     * (continuous periods as defined in DASH-IF 3.2.12). This is assumed in the mpd-parser as well. If we want to support\n     * periods without continuous playback this function may need modification as well as the parser.\n     */\n\n    const dashGroupId = (type, group, label, playlist) => {\n        // If the manifest somehow does not have an ID (non-dash compliant), use the label.\n        const playlistId = playlist.attributes.NAME || label;\n        return `placeholder-uri-${type}-${group}-${playlistId}`;\n    };\n    /**\n     * Parses the main XML string and updates playlist URI references.\n     *\n     * @param {Object} config\n     *        Object of arguments\n     * @param {string} config.mainXml\n     *        The mpd XML\n     * @param {string} config.srcUrl\n     *        The mpd URL\n     * @param {Date} config.clientOffset\n     *         A time difference between server and client\n     * @param {Object} config.sidxMapping\n     *        SIDX mappings for moof/mdat URIs and byte ranges\n     * @return {Object}\n     *         The parsed mpd manifest object\n     */\n\n    const parseMainXml = ({\n                              mainXml,\n                              srcUrl,\n                              clientOffset,\n                              sidxMapping,\n                              previousManifest\n                          }) => {\n        const manifest = parse(mainXml, {\n            manifestUri: srcUrl,\n            clientOffset,\n            sidxMapping,\n            previousManifest\n        });\n        addPropertiesToMain(manifest, srcUrl, dashGroupId);\n        return manifest;\n    };\n    /**\n     * Removes any mediaGroup labels that no longer exist in the newMain\n     *\n     * @param {Object} update\n     *         The previous mpd object being updated\n     * @param {Object} newMain\n     *         The new mpd object\n     */\n\n    const removeOldMediaGroupLabels = (update, newMain) => {\n        forEachMediaGroup(update, (properties, type, group, label) => {\n            if (!(label in newMain.mediaGroups[type][group])) {\n                delete update.mediaGroups[type][group][label];\n            }\n        });\n    };\n    /**\n     * Returns a new main manifest that is the result of merging an updated main manifest\n     * into the original version.\n     *\n     * @param {Object} oldMain\n     *        The old parsed mpd object\n     * @param {Object} newMain\n     *        The updated parsed mpd object\n     * @return {Object}\n     *         A new object representing the original main manifest with the updated media\n     *         playlists merged in\n     */\n\n    const updateMain = (oldMain, newMain, sidxMapping) => {\n        let noChanges = true;\n        let update = merge(oldMain, {\n            // These are top level properties that can be updated\n            duration: newMain.duration,\n            minimumUpdatePeriod: newMain.minimumUpdatePeriod,\n            timelineStarts: newMain.timelineStarts\n        }); // First update the playlists in playlist list\n\n        for (let i = 0; i < newMain.playlists.length; i++) {\n            const playlist = newMain.playlists[i];\n            if (playlist.sidx) {\n                const sidxKey = generateSidxKey(playlist.sidx); // add sidx segments to the playlist if we have all the sidx info already\n\n                if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {\n                    addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);\n                }\n            }\n            const playlistUpdate = updateMain$1(update, playlist, dashPlaylistUnchanged);\n            if (playlistUpdate) {\n                update = playlistUpdate;\n                noChanges = false;\n            }\n        } // Then update media group playlists\n\n        forEachMediaGroup(newMain, (properties, type, group, label) => {\n            if (properties.playlists && properties.playlists.length) {\n                const id = properties.playlists[0].id;\n                const playlistUpdate = updateMain$1(update, properties.playlists[0], dashPlaylistUnchanged);\n                if (playlistUpdate) {\n                    update = playlistUpdate; // add new mediaGroup label if it doesn't exist and assign the new mediaGroup.\n\n                    if (!(label in update.mediaGroups[type][group])) {\n                        update.mediaGroups[type][group][label] = properties;\n                    } // update the playlist reference within media groups\n\n                    update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];\n                    noChanges = false;\n                }\n            }\n        }); // remove mediaGroup labels and references that no longer exist in the newMain\n\n        removeOldMediaGroupLabels(update, newMain);\n        if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n            noChanges = false;\n        }\n        if (noChanges) {\n            return null;\n        }\n        return update;\n    }; // SIDX should be equivalent if the URI and byteranges of the SIDX match.\n    // If the SIDXs have maps, the two maps should match,\n    // both `a` and `b` missing SIDXs is considered matching.\n    // If `a` or `b` but not both have a map, they aren't matching.\n\n    const equivalentSidx = (a, b) => {\n        const neitherMap = Boolean(!a.map && !b.map);\n        const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);\n        return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;\n    }; // exported for testing\n\n    const compareSidxEntry = (playlists, oldSidxMapping) => {\n        const newSidxMapping = {};\n        for (const id in playlists) {\n            const playlist = playlists[id];\n            const currentSidxInfo = playlist.sidx;\n            if (currentSidxInfo) {\n                const key = generateSidxKey(currentSidxInfo);\n                if (!oldSidxMapping[key]) {\n                    break;\n                }\n                const savedSidxInfo = oldSidxMapping[key].sidxInfo;\n                if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {\n                    newSidxMapping[key] = oldSidxMapping[key];\n                }\n            }\n        }\n        return newSidxMapping;\n    };\n    /**\n     *  A function that filters out changed items as they need to be requested separately.\n     *\n     *  The method is exported for testing\n     *\n     *  @param {Object} main the parsed mpd XML returned via mpd-parser\n     *  @param {Object} oldSidxMapping the SIDX to compare against\n     */\n\n    const filterChangedSidxMappings = (main, oldSidxMapping) => {\n        const videoSidx = compareSidxEntry(main.playlists, oldSidxMapping);\n        let mediaGroupSidx = videoSidx;\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            if (properties.playlists && properties.playlists.length) {\n                const playlists = properties.playlists;\n                mediaGroupSidx = merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));\n            }\n        });\n        return mediaGroupSidx;\n    };\n    class DashPlaylistLoader extends EventTarget {\n        // DashPlaylistLoader must accept either a src url or a playlist because subsequent\n        // playlist loader setups from media groups will expect to be able to pass a playlist\n        // (since there aren't external URLs to media playlists with DASH)\n        constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {\n            super();\n            this.mainPlaylistLoader_ = mainPlaylistLoader || this;\n            if (!mainPlaylistLoader) {\n                this.isMain_ = true;\n            }\n            const {\n                withCredentials = false\n            } = options;\n            this.vhs_ = vhs;\n            this.withCredentials = withCredentials;\n            this.addMetadataToTextTrack = options.addMetadataToTextTrack;\n            if (!srcUrlOrPlaylist) {\n                throw new Error('A non-empty playlist URL or object is required');\n            } // event naming?\n\n            this.on('minimumUpdatePeriod', () => {\n                this.refreshXml_();\n            }); // live playlist staleness timeout\n\n            this.on('mediaupdatetimeout', () => {\n                this.refreshMedia_(this.media().id);\n            });\n            this.state = 'HAVE_NOTHING';\n            this.loadedPlaylists_ = {};\n            this.logger_ = logger('DashPlaylistLoader'); // initialize the loader state\n            // The mainPlaylistLoader will be created with a string\n\n            if (this.isMain_) {\n                this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist; // TODO: reset sidxMapping between period changes\n                // once multi-period is refactored\n\n                this.mainPlaylistLoader_.sidxMapping_ = {};\n            } else {\n                this.childPlaylist_ = srcUrlOrPlaylist;\n            }\n        }\n        requestErrored_(err, request, startingState) {\n            // disposed\n            if (!this.request) {\n                return true;\n            } // pending request is cleared\n\n            this.request = null;\n            if (err) {\n                // use the provided error object or create one\n                // based on the request/response\n                this.error = typeof err === 'object' && !(err instanceof Error) ? err : {\n                    status: request.status,\n                    message: 'DASH request error at URL: ' + request.uri,\n                    response: request.response,\n                    // MEDIA_ERR_NETWORK\n                    code: 2\n                };\n                if (startingState) {\n                    this.state = startingState;\n                }\n                this.trigger('error');\n                return true;\n            }\n        }\n        /**\n         * Verify that the container of the sidx segment can be parsed\n         * and if it can, get and parse that segment.\n         */\n\n        addSidxSegments_(playlist, startingState, cb) {\n            const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx); // playlist lacks sidx or sidx segments were added to this playlist already.\n\n            if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {\n                // keep this function async\n                this.mediaRequest_ = window.setTimeout(() => cb(false), 0);\n                return;\n            } // resolve the segment URL relative to the playlist\n\n            const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);\n            const fin = (err, request) => {\n                if (this.requestErrored_(err, request, startingState)) {\n                    return;\n                }\n                const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;\n                let sidx;\n                try {\n                    sidx = parseSidx_1(toUint8(request.response).subarray(8));\n                } catch (e) {\n                    // sidx parsing failed.\n                    this.requestErrored_(e, request, startingState);\n                    return;\n                }\n                sidxMapping[sidxKey] = {\n                    sidxInfo: playlist.sidx,\n                    sidx\n                };\n                addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);\n                return cb(true);\n            };\n            this.request = containerRequest(uri, this.vhs_.xhr, (err, request, container, bytes) => {\n                if (err) {\n                    return fin(err, request);\n                }\n                if (!container || container !== 'mp4') {\n                    return fin({\n                        status: request.status,\n                        message: `Unsupported ${container || 'unknown'} container type for sidx segment at URL: ${uri}`,\n                        // response is just bytes in this case\n                        // but we really don't want to return that.\n                        response: '',\n                        playlist,\n                        internal: true,\n                        playlistExclusionDuration: Infinity,\n                        // MEDIA_ERR_NETWORK\n                        code: 2\n                    }, request);\n                } // if we already downloaded the sidx bytes in the container request, use them\n\n                const {\n                    offset,\n                    length\n                } = playlist.sidx.byterange;\n                if (bytes.length >= length + offset) {\n                    return fin(err, {\n                        response: bytes.subarray(offset, offset + length),\n                        status: request.status,\n                        uri: request.uri\n                    });\n                } // otherwise request sidx bytes\n\n                this.request = this.vhs_.xhr({\n                    uri,\n                    responseType: 'arraybuffer',\n                    headers: segmentXhrHeaders({\n                        byterange: playlist.sidx.byterange\n                    })\n                }, fin);\n            });\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.stopRequest();\n            this.loadedPlaylists_ = {};\n            window.clearTimeout(this.minimumUpdatePeriodTimeout_);\n            window.clearTimeout(this.mediaRequest_);\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            this.mediaRequest_ = null;\n            this.minimumUpdatePeriodTimeout_ = null;\n            if (this.mainPlaylistLoader_.createMupOnMedia_) {\n                this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n                this.mainPlaylistLoader_.createMupOnMedia_ = null;\n            }\n            this.off();\n        }\n        hasPendingRequest() {\n            return this.request || this.mediaRequest_;\n        }\n        stopRequest() {\n            if (this.request) {\n                const oldRequest = this.request;\n                this.request = null;\n                oldRequest.onreadystatechange = null;\n                oldRequest.abort();\n            }\n        }\n        media(playlist) {\n            // getter\n            if (!playlist) {\n                return this.media_;\n            } // setter\n\n            if (this.state === 'HAVE_NOTHING') {\n                throw new Error('Cannot switch media playlist from ' + this.state);\n            }\n            const startingState = this.state; // find the playlist object if the target playlist has been specified by URI\n\n            if (typeof playlist === 'string') {\n                if (!this.mainPlaylistLoader_.main.playlists[playlist]) {\n                    throw new Error('Unknown playlist URI: ' + playlist);\n                }\n                playlist = this.mainPlaylistLoader_.main.playlists[playlist];\n            }\n            const mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to previously loaded playlists immediately\n\n            if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {\n                this.state = 'HAVE_METADATA';\n                this.media_ = playlist; // trigger media change if the active media has been updated\n\n                if (mediaChange) {\n                    this.trigger('mediachanging');\n                    this.trigger('mediachange');\n                }\n                return;\n            } // switching to the active playlist is a no-op\n\n            if (!mediaChange) {\n                return;\n            } // switching from an already loaded playlist\n\n            if (this.media_) {\n                this.trigger('mediachanging');\n            }\n            this.addSidxSegments_(playlist, startingState, sidxChanged => {\n                // everything is ready just continue to haveMetadata\n                this.haveMetadata({\n                    startingState,\n                    playlist\n                });\n            });\n        }\n        haveMetadata({\n                         startingState,\n                         playlist\n                     }) {\n            this.state = 'HAVE_METADATA';\n            this.loadedPlaylists_[playlist.id] = playlist;\n            this.mediaRequest_ = null; // This will trigger loadedplaylist\n\n            this.refreshMedia_(playlist.id); // fire loadedmetadata the first time a media playlist is loaded\n            // to resolve setup of media groups\n\n            if (startingState === 'HAVE_MAIN_MANIFEST') {\n                this.trigger('loadedmetadata');\n            } else {\n                // trigger media change if the active media has been updated\n                this.trigger('mediachange');\n            }\n        }\n        pause() {\n            if (this.mainPlaylistLoader_.createMupOnMedia_) {\n                this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n                this.mainPlaylistLoader_.createMupOnMedia_ = null;\n            }\n            this.stopRequest();\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            if (this.isMain_) {\n                window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);\n                this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;\n            }\n            if (this.state === 'HAVE_NOTHING') {\n                // If we pause the loader before any data has been retrieved, its as if we never\n                // started, so reset to an unstarted state.\n                this.started = false;\n            }\n        }\n        load(isFinalRendition) {\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            const media = this.media();\n            if (isFinalRendition) {\n                const delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n                this.mediaUpdateTimeout = window.setTimeout(() => this.load(), delay);\n                return;\n            } // because the playlists are internal to the manifest, load should either load the\n            // main manifest, or do nothing but trigger an event\n\n            if (!this.started) {\n                this.start();\n                return;\n            }\n            if (media && !media.endList) {\n                // Check to see if this is the main loader and the MUP was cleared (this happens\n                // when the loader was paused). `media` should be set at this point since one is always\n                // set during `start()`.\n                if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {\n                    // Trigger minimumUpdatePeriod to refresh the main manifest\n                    this.trigger('minimumUpdatePeriod'); // Since there was no prior minimumUpdatePeriodTimeout it should be recreated\n\n                    this.updateMinimumUpdatePeriodTimeout_();\n                }\n                this.trigger('mediaupdatetimeout');\n            } else {\n                this.trigger('loadedplaylist');\n            }\n        }\n        start() {\n            this.started = true; // We don't need to request the main manifest again\n            // Call this asynchronously to match the xhr request behavior below\n\n            if (!this.isMain_) {\n                this.mediaRequest_ = window.setTimeout(() => this.haveMain_(), 0);\n                return;\n            }\n            this.requestMain_((req, mainChanged) => {\n                this.haveMain_();\n                if (!this.hasPendingRequest() && !this.media_) {\n                    this.media(this.mainPlaylistLoader_.main.playlists[0]);\n                }\n            });\n        }\n        requestMain_(cb) {\n            this.request = this.vhs_.xhr({\n                uri: this.mainPlaylistLoader_.srcUrl,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                if (this.requestErrored_(error, req)) {\n                    if (this.state === 'HAVE_NOTHING') {\n                        this.started = false;\n                    }\n                    return;\n                }\n                const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;\n                this.mainPlaylistLoader_.mainXml_ = req.responseText;\n                if (req.responseHeaders && req.responseHeaders.date) {\n                    this.mainLoaded_ = Date.parse(req.responseHeaders.date);\n                } else {\n                    this.mainLoaded_ = Date.now();\n                }\n                this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);\n                if (mainChanged) {\n                    this.handleMain_();\n                    this.syncClientServerClock_(() => {\n                        return cb(req, mainChanged);\n                    });\n                    return;\n                }\n                return cb(req, mainChanged);\n            });\n        }\n        /**\n         * Parses the main xml for UTCTiming node to sync the client clock to the server\n         * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\n         *\n         * @param {Function} done\n         *        Function to call when clock sync has completed\n         */\n\n        syncClientServerClock_(done) {\n            const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_); // No UTCTiming element found in the mpd. Use Date header from mpd request as the\n            // server clock\n\n            if (utcTiming === null) {\n                this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n                return done();\n            }\n            if (utcTiming.method === 'DIRECT') {\n                this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();\n                return done();\n            }\n            this.request = this.vhs_.xhr({\n                uri: resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),\n                method: utcTiming.method,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                if (error) {\n                    // sync request failed, fall back to using date header from mpd\n                    // TODO: log warning\n                    this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n                    return done();\n                }\n                let serverTime;\n                if (utcTiming.method === 'HEAD') {\n                    if (!req.responseHeaders || !req.responseHeaders.date) {\n                        // expected date header not preset, fall back to using date header from mpd\n                        // TODO: log warning\n                        serverTime = this.mainLoaded_;\n                    } else {\n                        serverTime = Date.parse(req.responseHeaders.date);\n                    }\n                } else {\n                    serverTime = Date.parse(req.responseText);\n                }\n                this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();\n                done();\n            });\n        }\n        haveMain_() {\n            this.state = 'HAVE_MAIN_MANIFEST';\n            if (this.isMain_) {\n                // We have the main playlist at this point, so\n                // trigger this to allow PlaylistController\n                // to make an initial playlist selection\n                this.trigger('loadedplaylist');\n            } else if (!this.media_) {\n                // no media playlist was specifically selected so select\n                // the one the child playlist loader was created with\n                this.media(this.childPlaylist_);\n            }\n        }\n        handleMain_() {\n            // clear media request\n            this.mediaRequest_ = null;\n            const oldMain = this.mainPlaylistLoader_.main;\n            let newMain = parseMainXml({\n                mainXml: this.mainPlaylistLoader_.mainXml_,\n                srcUrl: this.mainPlaylistLoader_.srcUrl,\n                clientOffset: this.mainPlaylistLoader_.clientOffset_,\n                sidxMapping: this.mainPlaylistLoader_.sidxMapping_,\n                previousManifest: oldMain\n            }); // if we have an old main to compare the new main against\n\n            if (oldMain) {\n                newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);\n            } // only update main if we have a new main\n\n            this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;\n            const location = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];\n            if (location && location !== this.mainPlaylistLoader_.srcUrl) {\n                this.mainPlaylistLoader_.srcUrl = location;\n            }\n            if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n                this.updateMinimumUpdatePeriodTimeout_();\n            }\n            this.addEventStreamToMetadataTrack_(newMain);\n            return Boolean(newMain);\n        }\n        updateMinimumUpdatePeriodTimeout_() {\n            const mpl = this.mainPlaylistLoader_; // cancel any pending creation of mup on media\n            // a new one will be added if needed.\n\n            if (mpl.createMupOnMedia_) {\n                mpl.off('loadedmetadata', mpl.createMupOnMedia_);\n                mpl.createMupOnMedia_ = null;\n            } // clear any pending timeouts\n\n            if (mpl.minimumUpdatePeriodTimeout_) {\n                window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);\n                mpl.minimumUpdatePeriodTimeout_ = null;\n            }\n            let mup = mpl.main && mpl.main.minimumUpdatePeriod; // If the minimumUpdatePeriod has a value of 0, that indicates that the current\n            // MPD has no future validity, so a new one will need to be acquired when new\n            // media segments are to be made available. Thus, we use the target duration\n            // in this case\n\n            if (mup === 0) {\n                if (mpl.media()) {\n                    mup = mpl.media().targetDuration * 1000;\n                } else {\n                    mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;\n                    mpl.one('loadedmetadata', mpl.createMupOnMedia_);\n                }\n            } // if minimumUpdatePeriod is invalid or <= zero, which\n            // can happen when a live video becomes VOD. skip timeout\n            // creation.\n\n            if (typeof mup !== 'number' || mup <= 0) {\n                if (mup < 0) {\n                    this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);\n                }\n                return;\n            }\n            this.createMUPTimeout_(mup);\n        }\n        createMUPTimeout_(mup) {\n            const mpl = this.mainPlaylistLoader_;\n            mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(() => {\n                mpl.minimumUpdatePeriodTimeout_ = null;\n                mpl.trigger('minimumUpdatePeriod');\n                mpl.createMUPTimeout_(mup);\n            }, mup);\n        }\n        /**\n         * Sends request to refresh the main xml and updates the parsed main manifest\n         */\n\n        refreshXml_() {\n            this.requestMain_((req, mainChanged) => {\n                if (!mainChanged) {\n                    return;\n                }\n                if (this.media_) {\n                    this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];\n                } // This will filter out updated sidx info from the mapping\n\n                this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);\n                this.addSidxSegments_(this.media(), this.state, sidxChanged => {\n                    // TODO: do we need to reload the current playlist?\n                    this.refreshMedia_(this.media().id);\n                });\n            });\n        }\n        /**\n         * Refreshes the media playlist by re-parsing the main xml and updating playlist\n         * references. If this is an alternate loader, the updated parsed manifest is retrieved\n         * from the main loader.\n         */\n\n        refreshMedia_(mediaID) {\n            if (!mediaID) {\n                throw new Error('refreshMedia_ must take a media id');\n            } // for main we have to reparse the main xml\n            // to re-create segments based on current timing values\n            // which may change media. We only skip updating the main manifest\n            // if this is the first time this.media_ is being set.\n            // as main was just parsed in that case.\n\n            if (this.media_ && this.isMain_) {\n                this.handleMain_();\n            }\n            const playlists = this.mainPlaylistLoader_.main.playlists;\n            const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];\n            if (mediaChanged) {\n                this.media_ = playlists[mediaID];\n            } else {\n                this.trigger('playlistunchanged');\n            }\n            if (!this.mediaUpdateTimeout) {\n                const createMediaUpdateTimeout = () => {\n                    if (this.media().endList) {\n                        return;\n                    }\n                    this.mediaUpdateTimeout = window.setTimeout(() => {\n                        this.trigger('mediaupdatetimeout');\n                        createMediaUpdateTimeout();\n                    }, refreshDelay(this.media(), Boolean(mediaChanged)));\n                };\n                createMediaUpdateTimeout();\n            }\n            this.trigger('loadedplaylist');\n        }\n        /**\n         * Takes eventstream data from a parsed DASH manifest and adds it to the metadata text track.\n         *\n         * @param {manifest} newMain the newly parsed manifest\n         */\n\n        addEventStreamToMetadataTrack_(newMain) {\n            // Only add new event stream metadata if we have a new manifest.\n            if (newMain && this.mainPlaylistLoader_.main.eventStream) {\n                // convert EventStream to ID3-like data.\n                const metadataArray = this.mainPlaylistLoader_.main.eventStream.map(eventStreamNode => {\n                    return {\n                        cueTime: eventStreamNode.start,\n                        frames: [{\n                            data: eventStreamNode.messageData\n                        }]\n                    };\n                });\n                this.addMetadataToTextTrack('EventStream', metadataArray, this.mainPlaylistLoader_.main.duration);\n            }\n        }\n        /**\n         * Returns the key ID set from a playlist\n         *\n         * @param {playlist} playlist to fetch the key ID set from.\n         * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.\n         */\n\n        getKeyIdSet(playlist) {\n            if (playlist.contentProtection) {\n                const keyIds = new Set();\n                for (const keysystem in playlist.contentProtection) {\n                    const defaultKID = playlist.contentProtection[keysystem].attributes['cenc:default_KID'];\n                    if (defaultKID) {\n                        // DASH keyIds are separated by dashes.\n                        keyIds.add(defaultKID.replace(/-/g, '').toLowerCase());\n                    }\n                }\n                return keyIds;\n            }\n        }\n    }\n    var Config = {\n        GOAL_BUFFER_LENGTH: 30,\n        MAX_GOAL_BUFFER_LENGTH: 60,\n        BACK_BUFFER_LENGTH: 30,\n        GOAL_BUFFER_LENGTH_RATE: 1,\n        // 0.5 MB/s\n        INITIAL_BANDWIDTH: 4194304,\n        // A fudge factor to apply to advertised playlist bitrates to account for\n        // temporary flucations in client bandwidth\n        BANDWIDTH_VARIANCE: 1.2,\n        // How much of the buffer must be filled before we consider upswitching\n        BUFFER_LOW_WATER_LINE: 0,\n        MAX_BUFFER_LOW_WATER_LINE: 30,\n        // TODO: Remove this when experimentalBufferBasedABR is removed\n        EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,\n        BUFFER_LOW_WATER_LINE_RATE: 1,\n        // If the buffer is greater than the high water line, we won't switch down\n        BUFFER_HIGH_WATER_LINE: 30\n    };\n    const stringToArrayBuffer = string => {\n        const view = new Uint8Array(new ArrayBuffer(string.length));\n        for (let i = 0; i < string.length; i++) {\n            view[i] = string.charCodeAt(i);\n        }\n        return view.buffer;\n    };\n\n    /* global Blob, BlobBuilder, Worker */\n    // unify worker interface\n    const browserWorkerPolyFill = function (workerObj) {\n        // node only supports on/off\n        workerObj.on = workerObj.addEventListener;\n        workerObj.off = workerObj.removeEventListener;\n        return workerObj;\n    };\n    const createObjectURL = function (str) {\n        try {\n            return URL.createObjectURL(new Blob([str], {\n                type: 'application/javascript'\n            }));\n        } catch (e) {\n            const blob = new BlobBuilder();\n            blob.append(str);\n            return URL.createObjectURL(blob.getBlob());\n        }\n    };\n    const factory = function (code) {\n        return function () {\n            const objectUrl = createObjectURL(code);\n            const worker = browserWorkerPolyFill(new Worker(objectUrl));\n            worker.objURL = objectUrl;\n            const terminate = worker.terminate;\n            worker.on = worker.addEventListener;\n            worker.off = worker.removeEventListener;\n            worker.terminate = function () {\n                URL.revokeObjectURL(objectUrl);\n                return terminate.call(this);\n            };\n            return worker;\n        };\n    };\n    const transform = function (code) {\n        return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};\\n` + 'browserWorkerPolyFill(self);\\n' + code;\n    };\n    const getWorkerString = function (fn) {\n        return fn.toString().replace(/^function.+?{/, '').slice(0, -1);\n    };\n\n    /* rollup-plugin-worker-factory start for worker!/home/runner/work/http-streaming/http-streaming/src/transmuxer-worker.js */\n    const workerCode$1 = transform(getWorkerString(function () {\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A lightweight readable stream implemention that handles event dispatching.\n         * Objects that inherit from streams should call init in their constructors.\n         */\n\n        var Stream$8 = function () {\n            this.init = function () {\n                var listeners = {};\n                /**\n                 * Add a listener for a specified event type.\n                 * @param type {string} the event name\n                 * @param listener {function} the callback to be invoked when an event of\n                 * the specified type occurs\n                 */\n\n                this.on = function (type, listener) {\n                    if (!listeners[type]) {\n                        listeners[type] = [];\n                    }\n                    listeners[type] = listeners[type].concat(listener);\n                };\n                /**\n                 * Remove a listener for a specified event type.\n                 * @param type {string} the event name\n                 * @param listener {function} a function previously registered for this\n                 * type of event through `on`\n                 */\n\n                this.off = function (type, listener) {\n                    var index;\n                    if (!listeners[type]) {\n                        return false;\n                    }\n                    index = listeners[type].indexOf(listener);\n                    listeners[type] = listeners[type].slice();\n                    listeners[type].splice(index, 1);\n                    return index > -1;\n                };\n                /**\n                 * Trigger an event of the specified type on this stream. Any additional\n                 * arguments to this function are passed as parameters to event listeners.\n                 * @param type {string} the event name\n                 */\n\n                this.trigger = function (type) {\n                    var callbacks, i, length, args;\n                    callbacks = listeners[type];\n                    if (!callbacks) {\n                        return;\n                    } // Slicing the arguments on every invocation of this method\n                    // can add a significant amount of overhead. Avoid the\n                    // intermediate object creation for the common case of a\n                    // single callback argument\n\n                    if (arguments.length === 2) {\n                        length = callbacks.length;\n                        for (i = 0; i < length; ++i) {\n                            callbacks[i].call(this, arguments[1]);\n                        }\n                    } else {\n                        args = [];\n                        i = arguments.length;\n                        for (i = 1; i < arguments.length; ++i) {\n                            args.push(arguments[i]);\n                        }\n                        length = callbacks.length;\n                        for (i = 0; i < length; ++i) {\n                            callbacks[i].apply(this, args);\n                        }\n                    }\n                };\n                /**\n                 * Destroys the stream and cleans up.\n                 */\n\n                this.dispose = function () {\n                    listeners = {};\n                };\n            };\n        };\n        /**\n         * Forwards all `data` events on this stream to the destination stream. The\n         * destination stream should provide a method `push` to receive the data\n         * events as they arrive.\n         * @param destination {stream} the stream that will receive all `data` events\n         * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n         *                            when the current stream emits a 'done' event\n         * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n         */\n\n        Stream$8.prototype.pipe = function (destination) {\n            this.on('data', function (data) {\n                destination.push(data);\n            });\n            this.on('done', function (flushSource) {\n                destination.flush(flushSource);\n            });\n            this.on('partialdone', function (flushSource) {\n                destination.partialFlush(flushSource);\n            });\n            this.on('endedtimeline', function (flushSource) {\n                destination.endTimeline(flushSource);\n            });\n            this.on('reset', function (flushSource) {\n                destination.reset(flushSource);\n            });\n            return destination;\n        }; // Default stream functions that are expected to be overridden to perform\n        // actual work. These are provided by the prototype as a sort of no-op\n        // implementation so that we don't have to check for their existence in the\n        // `pipe` function above.\n\n        Stream$8.prototype.push = function (data) {\n            this.trigger('data', data);\n        };\n        Stream$8.prototype.flush = function (flushSource) {\n            this.trigger('done', flushSource);\n        };\n        Stream$8.prototype.partialFlush = function (flushSource) {\n            this.trigger('partialdone', flushSource);\n        };\n        Stream$8.prototype.endTimeline = function (flushSource) {\n            this.trigger('endedtimeline', flushSource);\n        };\n        Stream$8.prototype.reset = function (flushSource) {\n            this.trigger('reset', flushSource);\n        };\n        var stream = Stream$8;\n        var MAX_UINT32$1 = Math.pow(2, 32);\n        var getUint64$3 = function (uint8) {\n            var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n            var value;\n            if (dv.getBigUint64) {\n                value = dv.getBigUint64(0);\n                if (value < Number.MAX_SAFE_INTEGER) {\n                    return Number(value);\n                }\n                return value;\n            }\n            return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n        };\n        var numbers = {\n            getUint64: getUint64$3,\n            MAX_UINT32: MAX_UINT32$1\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Functions that generate fragmented MP4s suitable for use with Media\n         * Source Extensions.\n         */\n\n        var MAX_UINT32 = numbers.MAX_UINT32;\n        var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n        (function () {\n            var i;\n            types = {\n                avc1: [],\n                // codingname\n                avcC: [],\n                btrt: [],\n                dinf: [],\n                dref: [],\n                esds: [],\n                ftyp: [],\n                hdlr: [],\n                mdat: [],\n                mdhd: [],\n                mdia: [],\n                mfhd: [],\n                minf: [],\n                moof: [],\n                moov: [],\n                mp4a: [],\n                // codingname\n                mvex: [],\n                mvhd: [],\n                pasp: [],\n                sdtp: [],\n                smhd: [],\n                stbl: [],\n                stco: [],\n                stsc: [],\n                stsd: [],\n                stsz: [],\n                stts: [],\n                styp: [],\n                tfdt: [],\n                tfhd: [],\n                traf: [],\n                trak: [],\n                trun: [],\n                trex: [],\n                tkhd: [],\n                vmhd: []\n            }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n            // don't throw an error\n\n            if (typeof Uint8Array === 'undefined') {\n                return;\n            }\n            for (i in types) {\n                if (types.hasOwnProperty(i)) {\n                    types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n                }\n            }\n            MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n            AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n            MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n            VIDEO_HDLR = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0x76, 0x69, 0x64, 0x65,\n                // handler_type: 'vide'\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n            ]);\n\n            AUDIO_HDLR = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0x73, 0x6f, 0x75, 0x6e,\n                // handler_type: 'soun'\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n            ]);\n\n            HDLR_TYPES = {\n                video: VIDEO_HDLR,\n                audio: AUDIO_HDLR\n            };\n            DREF = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x01,\n                // entry_count\n                0x00, 0x00, 0x00, 0x0c,\n                // entry_size\n                0x75, 0x72, 0x6c, 0x20,\n                // 'url' type\n                0x00,\n                // version 0\n                0x00, 0x00, 0x01 // entry_flags\n            ]);\n\n            SMHD = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00,\n                // balance, 0 means centered\n                0x00, 0x00 // reserved\n            ]);\n\n            STCO = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00 // entry_count\n            ]);\n\n            STSC = STCO;\n            STSZ = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // sample_size\n                0x00, 0x00, 0x00, 0x00 // sample_count\n            ]);\n\n            STTS = STCO;\n            VMHD = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x01,\n                // flags\n                0x00, 0x00,\n                // graphicsmode\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n            ]);\n        })();\n\n        box = function (type) {\n            var payload = [],\n                size = 0,\n                i,\n                result,\n                view;\n            for (i = 1; i < arguments.length; i++) {\n                payload.push(arguments[i]);\n            }\n            i = payload.length; // calculate the total size we need to allocate\n\n            while (i--) {\n                size += payload[i].byteLength;\n            }\n            result = new Uint8Array(size + 8);\n            view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n            view.setUint32(0, result.byteLength);\n            result.set(type, 4); // copy the payload into the result\n\n            for (i = 0, size = 8; i < payload.length; i++) {\n                result.set(payload[i], size);\n                size += payload[i].byteLength;\n            }\n            return result;\n        };\n        dinf = function () {\n            return box(types.dinf, box(types.dref, DREF));\n        };\n        esds = function (track) {\n            return box(types.esds, new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                // ES_Descriptor\n                0x03,\n                // tag, ES_DescrTag\n                0x19,\n                // length\n                0x00, 0x00,\n                // ES_ID\n                0x00,\n                // streamDependenceFlag, URL_flag, reserved, streamPriority\n                // DecoderConfigDescriptor\n                0x04,\n                // tag, DecoderConfigDescrTag\n                0x11,\n                // length\n                0x40,\n                // object type\n                0x15,\n                // streamType\n                0x00, 0x06, 0x00,\n                // bufferSizeDB\n                0x00, 0x00, 0xda, 0xc0,\n                // maxBitrate\n                0x00, 0x00, 0xda, 0xc0,\n                // avgBitrate\n                // DecoderSpecificInfo\n                0x05,\n                // tag, DecoderSpecificInfoTag\n                0x02,\n                // length\n                // ISO/IEC 14496-3, AudioSpecificConfig\n                // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n                track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n            ]));\n        };\n\n        ftyp = function () {\n            return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n        };\n        hdlr = function (type) {\n            return box(types.hdlr, HDLR_TYPES[type]);\n        };\n        mdat = function (data) {\n            return box(types.mdat, data);\n        };\n        mdhd = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x02,\n                // creation_time\n                0x00, 0x00, 0x00, 0x03,\n                // modification_time\n                0x00, 0x01, 0x5f, 0x90,\n                // timescale, 90,000 \"ticks\" per second\n                track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF,\n                // duration\n                0x55, 0xc4,\n                // 'und' language (undetermined)\n                0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n            // defined. The sample rate can be parsed out of an ADTS header, for\n            // instance.\n\n            if (track.samplerate) {\n                result[12] = track.samplerate >>> 24 & 0xFF;\n                result[13] = track.samplerate >>> 16 & 0xFF;\n                result[14] = track.samplerate >>> 8 & 0xFF;\n                result[15] = track.samplerate & 0xFF;\n            }\n            return box(types.mdhd, result);\n        };\n        mdia = function (track) {\n            return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n        };\n        mfhd = function (sequenceNumber) {\n            return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n                // flags\n                (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n            ]));\n        };\n\n        minf = function (track) {\n            return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n        };\n        moof = function (sequenceNumber, tracks) {\n            var trackFragments = [],\n                i = tracks.length; // build traf boxes for each track fragment\n\n            while (i--) {\n                trackFragments[i] = traf(tracks[i]);\n            }\n            return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n        };\n        /**\n         * Returns a movie box.\n         * @param tracks {array} the tracks associated with this movie\n         * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n         */\n\n        moov = function (tracks) {\n            var i = tracks.length,\n                boxes = [];\n            while (i--) {\n                boxes[i] = trak(tracks[i]);\n            }\n            return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n        };\n        mvex = function (tracks) {\n            var i = tracks.length,\n                boxes = [];\n            while (i--) {\n                boxes[i] = trex(tracks[i]);\n            }\n            return box.apply(null, [types.mvex].concat(boxes));\n        };\n        mvhd = function (duration) {\n            var bytes = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x01,\n                // creation_time\n                0x00, 0x00, 0x00, 0x02,\n                // modification_time\n                0x00, 0x01, 0x5f, 0x90,\n                // timescale, 90,000 \"ticks\" per second\n                (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF,\n                // duration\n                0x00, 0x01, 0x00, 0x00,\n                // 1.0 rate\n                0x01, 0x00,\n                // 1.0 volume\n                0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n                // transformation: unity matrix\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0xff, 0xff, 0xff, 0xff // next_track_ID\n            ]);\n\n            return box(types.mvhd, bytes);\n        };\n        sdtp = function (track) {\n            var samples = track.samples || [],\n                bytes = new Uint8Array(4 + samples.length),\n                flags,\n                i; // leave the full box header (4 bytes) all zero\n            // write the sample table\n\n            for (i = 0; i < samples.length; i++) {\n                flags = samples[i].flags;\n                bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n            }\n            return box(types.sdtp, bytes);\n        };\n        stbl = function (track) {\n            return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n        };\n        (function () {\n            var videoSample, audioSample;\n            stsd = function (track) {\n                return box(types.stsd, new Uint8Array([0x00,\n                    // version 0\n                    0x00, 0x00, 0x00,\n                    // flags\n                    0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n            };\n            videoSample = function (track) {\n                var sps = track.sps || [],\n                    pps = track.pps || [],\n                    sequenceParameterSets = [],\n                    pictureParameterSets = [],\n                    i,\n                    avc1Box; // assemble the SPSs\n\n                for (i = 0; i < sps.length; i++) {\n                    sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n                    sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n                    sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n                } // assemble the PPSs\n\n                for (i = 0; i < pps.length; i++) {\n                    pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n                    pictureParameterSets.push(pps[i].byteLength & 0xFF);\n                    pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n                }\n                avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // data_reference_index\n                    0x00, 0x00,\n                    // pre_defined\n                    0x00, 0x00,\n                    // reserved\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // pre_defined\n                    (track.width & 0xff00) >> 8, track.width & 0xff,\n                    // width\n                    (track.height & 0xff00) >> 8, track.height & 0xff,\n                    // height\n                    0x00, 0x48, 0x00, 0x00,\n                    // horizresolution\n                    0x00, 0x48, 0x00, 0x00,\n                    // vertresolution\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // frame_count\n                    0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // compressorname\n                    0x00, 0x18,\n                    // depth = 24\n                    0x11, 0x11 // pre_defined = -1\n                ]), box(types.avcC, new Uint8Array([0x01,\n                    // configurationVersion\n                    track.profileIdc,\n                    // AVCProfileIndication\n                    track.profileCompatibility,\n                    // profile_compatibility\n                    track.levelIdc,\n                    // AVCLevelIndication\n                    0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n                ].concat([sps.length],\n                    // numOfSequenceParameterSets\n                    sequenceParameterSets,\n                    // \"SPS\"\n                    [pps.length],\n                    // numOfPictureParameterSets\n                    pictureParameterSets // \"PPS\"\n                ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n                    // bufferSizeDB\n                    0x00, 0x2d, 0xc6, 0xc0,\n                    // maxBitrate\n                    0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n                ]))];\n\n                if (track.sarRatio) {\n                    var hSpacing = track.sarRatio[0],\n                        vSpacing = track.sarRatio[1];\n                    avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n                }\n                return box.apply(null, avc1Box);\n            };\n            audioSample = function (track) {\n                return box(types.mp4a, new Uint8Array([\n                    // SampleEntry, ISO/IEC 14496-12\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // data_reference_index\n                    // AudioSampleEntry, ISO/IEC 14496-12\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff,\n                    // channelcount\n                    (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff,\n                    // samplesize\n                    0x00, 0x00,\n                    // pre_defined\n                    0x00, 0x00,\n                    // reserved\n                    (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n                    // MP4AudioSampleEntry, ISO/IEC 14496-14\n                ]), esds(track));\n            };\n        })();\n        tkhd = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x07,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // creation_time\n                0x00, 0x00, 0x00, 0x00,\n                // modification_time\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF,\n                // duration\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00,\n                // layer\n                0x00, 0x00,\n                // alternate_group\n                0x01, 0x00,\n                // non-audio track volume\n                0x00, 0x00,\n                // reserved\n                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n                // transformation: unity matrix\n                (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00,\n                // width\n                (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n            ]);\n\n            return box(types.tkhd, result);\n        };\n        /**\n         * Generate a track fragment (traf) box. A traf box collects metadata\n         * about tracks in a movie fragment (moof) box.\n         */\n\n        traf = function (track) {\n            var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n            trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x3a,\n                // flags\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x01,\n                // sample_description_index\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_duration\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_size\n                0x00, 0x00, 0x00, 0x00 // default_sample_flags\n            ]));\n\n            upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n            lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n            trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01,\n                // version 1\n                0x00, 0x00, 0x00,\n                // flags\n                // baseMediaDecodeTime\n                upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n            // the containing moof to the first payload byte of the associated\n            // mdat\n\n            dataOffset = 32 +\n                // tfhd\n                20 +\n                // tfdt\n                8 +\n                // traf header\n                16 +\n                // mfhd\n                8 +\n                // moof header\n                8; // mdat header\n            // audio tracks require less metadata\n\n            if (track.type === 'audio') {\n                trackFragmentRun = trun$1(track, dataOffset);\n                return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n            } // video tracks should contain an independent and disposable samples\n            // box (sdtp)\n            // generate one and adjust offsets to match\n\n            sampleDependencyTable = sdtp(track);\n            trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n            return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n        };\n        /**\n         * Generate a track box.\n         * @param track {object} a track definition\n         * @return {Uint8Array} the track box\n         */\n\n        trak = function (track) {\n            track.duration = track.duration || 0xffffffff;\n            return box(types.trak, tkhd(track), mdia(track));\n        };\n        trex = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x01,\n                // default_sample_description_index\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_duration\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_size\n                0x00, 0x01, 0x00, 0x01 // default_sample_flags\n            ]); // the last two bytes of default_sample_flags is the sample\n            // degradation priority, a hint about the importance of this sample\n            // relative to others. Lower the degradation priority for all sample\n            // types other than video.\n\n            if (track.type !== 'video') {\n                result[result.length - 1] = 0x00;\n            }\n            return box(types.trex, result);\n        };\n        (function () {\n            var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n            // duration is present for the first sample, it will be present for\n            // all subsequent samples.\n            // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n            trunHeader = function (samples, offset) {\n                var durationPresent = 0,\n                    sizePresent = 0,\n                    flagsPresent = 0,\n                    compositionTimeOffset = 0; // trun flag constants\n\n                if (samples.length) {\n                    if (samples[0].duration !== undefined) {\n                        durationPresent = 0x1;\n                    }\n                    if (samples[0].size !== undefined) {\n                        sizePresent = 0x2;\n                    }\n                    if (samples[0].flags !== undefined) {\n                        flagsPresent = 0x4;\n                    }\n                    if (samples[0].compositionTimeOffset !== undefined) {\n                        compositionTimeOffset = 0x8;\n                    }\n                }\n                return [0x00,\n                    // version 0\n                    0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01,\n                    // flags\n                    (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF,\n                    // sample_count\n                    (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n                ];\n            };\n\n            videoTrun = function (track, offset) {\n                var bytesOffest, bytes, header, samples, sample, i;\n                samples = track.samples || [];\n                offset += 8 + 12 + 16 * samples.length;\n                header = trunHeader(samples, offset);\n                bytes = new Uint8Array(header.length + samples.length * 16);\n                bytes.set(header);\n                bytesOffest = header.length;\n                for (i = 0; i < samples.length; i++) {\n                    sample = samples[i];\n                    bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n                    bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n                    bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n                    bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n                    bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n                    bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n                }\n\n                return box(types.trun, bytes);\n            };\n            audioTrun = function (track, offset) {\n                var bytes, bytesOffest, header, samples, sample, i;\n                samples = track.samples || [];\n                offset += 8 + 12 + 8 * samples.length;\n                header = trunHeader(samples, offset);\n                bytes = new Uint8Array(header.length + samples.length * 8);\n                bytes.set(header);\n                bytesOffest = header.length;\n                for (i = 0; i < samples.length; i++) {\n                    sample = samples[i];\n                    bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n                    bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n                }\n\n                return box(types.trun, bytes);\n            };\n            trun$1 = function (track, offset) {\n                if (track.type === 'audio') {\n                    return audioTrun(track, offset);\n                }\n                return videoTrun(track, offset);\n            };\n        })();\n        var mp4Generator = {\n            ftyp: ftyp,\n            mdat: mdat,\n            moof: moof,\n            moov: moov,\n            initSegment: function (tracks) {\n                var fileType = ftyp(),\n                    movie = moov(tracks),\n                    result;\n                result = new Uint8Array(fileType.byteLength + movie.byteLength);\n                result.set(fileType);\n                result.set(movie, fileType.byteLength);\n                return result;\n            }\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n            // composed of the nal units that make up that frame\n            // Also keep track of cummulative data about the frame from the nal units such\n            // as the frame duration, starting pts, etc.\n\n        var groupNalsIntoFrames = function (nalUnits) {\n                var i,\n                    currentNal,\n                    currentFrame = [],\n                    frames = []; // TODO added for LHLS, make sure this is OK\n\n                frames.byteLength = 0;\n                frames.nalCount = 0;\n                frames.duration = 0;\n                currentFrame.byteLength = 0;\n                for (i = 0; i < nalUnits.length; i++) {\n                    currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n                    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n                        // Since the very first nal unit is expected to be an AUD\n                        // only push to the frames array when currentFrame is not empty\n                        if (currentFrame.length) {\n                            currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n                            frames.byteLength += currentFrame.byteLength;\n                            frames.nalCount += currentFrame.length;\n                            frames.duration += currentFrame.duration;\n                            frames.push(currentFrame);\n                        }\n                        currentFrame = [currentNal];\n                        currentFrame.byteLength = currentNal.data.byteLength;\n                        currentFrame.pts = currentNal.pts;\n                        currentFrame.dts = currentNal.dts;\n                    } else {\n                        // Specifically flag key frames for ease of use later\n                        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n                            currentFrame.keyFrame = true;\n                        }\n                        currentFrame.duration = currentNal.dts - currentFrame.dts;\n                        currentFrame.byteLength += currentNal.data.byteLength;\n                        currentFrame.push(currentNal);\n                    }\n                } // For the last frame, use the duration of the previous frame if we\n                // have nothing better to go on\n\n                if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n                    currentFrame.duration = frames[frames.length - 1].duration;\n                } // Push the final frame\n                // TODO added for LHLS, make sure this is OK\n\n                frames.byteLength += currentFrame.byteLength;\n                frames.nalCount += currentFrame.length;\n                frames.duration += currentFrame.duration;\n                frames.push(currentFrame);\n                return frames;\n            }; // Convert an array of frames into an array of Gop with each Gop being composed\n        // of the frames that make up that Gop\n        // Also keep track of cummulative data about the Gop from the frames such as the\n        // Gop duration, starting pts, etc.\n\n        var groupFramesIntoGops = function (frames) {\n            var i,\n                currentFrame,\n                currentGop = [],\n                gops = []; // We must pre-set some of the values on the Gop since we\n            // keep running totals of these values\n\n            currentGop.byteLength = 0;\n            currentGop.nalCount = 0;\n            currentGop.duration = 0;\n            currentGop.pts = frames[0].pts;\n            currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n            gops.byteLength = 0;\n            gops.nalCount = 0;\n            gops.duration = 0;\n            gops.pts = frames[0].pts;\n            gops.dts = frames[0].dts;\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                if (currentFrame.keyFrame) {\n                    // Since the very first frame is expected to be an keyframe\n                    // only push to the gops array when currentGop is not empty\n                    if (currentGop.length) {\n                        gops.push(currentGop);\n                        gops.byteLength += currentGop.byteLength;\n                        gops.nalCount += currentGop.nalCount;\n                        gops.duration += currentGop.duration;\n                    }\n                    currentGop = [currentFrame];\n                    currentGop.nalCount = currentFrame.length;\n                    currentGop.byteLength = currentFrame.byteLength;\n                    currentGop.pts = currentFrame.pts;\n                    currentGop.dts = currentFrame.dts;\n                    currentGop.duration = currentFrame.duration;\n                } else {\n                    currentGop.duration += currentFrame.duration;\n                    currentGop.nalCount += currentFrame.length;\n                    currentGop.byteLength += currentFrame.byteLength;\n                    currentGop.push(currentFrame);\n                }\n            }\n            if (gops.length && currentGop.duration <= 0) {\n                currentGop.duration = gops[gops.length - 1].duration;\n            }\n            gops.byteLength += currentGop.byteLength;\n            gops.nalCount += currentGop.nalCount;\n            gops.duration += currentGop.duration; // push the final Gop\n\n            gops.push(currentGop);\n            return gops;\n        };\n        /*\n     * Search for the first keyframe in the GOPs and throw away all frames\n     * until that keyframe. Then extend the duration of the pulled keyframe\n     * and pull the PTS and DTS of the keyframe so that it covers the time\n     * range of the frames that were disposed.\n     *\n     * @param {Array} gops video GOPs\n     * @returns {Array} modified video GOPs\n     */\n\n        var extendFirstKeyFrame = function (gops) {\n            var currentGop;\n            if (!gops[0][0].keyFrame && gops.length > 1) {\n                // Remove the first GOP\n                currentGop = gops.shift();\n                gops.byteLength -= currentGop.byteLength;\n                gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n                // first gop to cover the time period of the\n                // frames we just removed\n\n                gops[0][0].dts = currentGop.dts;\n                gops[0][0].pts = currentGop.pts;\n                gops[0][0].duration += currentGop.duration;\n            }\n            return gops;\n        };\n        /**\n         * Default sample object\n         * see ISO/IEC 14496-12:2012, section 8.6.4.3\n         */\n\n        var createDefaultSample = function () {\n            return {\n                size: 0,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradationPriority: 0,\n                    isNonSyncSample: 1\n                }\n            };\n        };\n        /*\n     * Collates information from a video frame into an object for eventual\n     * entry into an MP4 sample table.\n     *\n     * @param {Object} frame the video frame\n     * @param {Number} dataOffset the byte offset to position the sample\n     * @return {Object} object containing sample table info for a frame\n     */\n\n        var sampleForFrame = function (frame, dataOffset) {\n            var sample = createDefaultSample();\n            sample.dataOffset = dataOffset;\n            sample.compositionTimeOffset = frame.pts - frame.dts;\n            sample.duration = frame.duration;\n            sample.size = 4 * frame.length; // Space for nal unit size\n\n            sample.size += frame.byteLength;\n            if (frame.keyFrame) {\n                sample.flags.dependsOn = 2;\n                sample.flags.isNonSyncSample = 0;\n            }\n            return sample;\n        }; // generate the track's sample table from an array of gops\n\n        var generateSampleTable$1 = function (gops, baseDataOffset) {\n            var h,\n                i,\n                sample,\n                currentGop,\n                currentFrame,\n                dataOffset = baseDataOffset || 0,\n                samples = [];\n            for (h = 0; h < gops.length; h++) {\n                currentGop = gops[h];\n                for (i = 0; i < currentGop.length; i++) {\n                    currentFrame = currentGop[i];\n                    sample = sampleForFrame(currentFrame, dataOffset);\n                    dataOffset += sample.size;\n                    samples.push(sample);\n                }\n            }\n            return samples;\n        }; // generate the track's raw mdat data from an array of gops\n\n        var concatenateNalData = function (gops) {\n            var h,\n                i,\n                j,\n                currentGop,\n                currentFrame,\n                currentNal,\n                dataOffset = 0,\n                nalsByteLength = gops.byteLength,\n                numberOfNals = gops.nalCount,\n                totalByteLength = nalsByteLength + 4 * numberOfNals,\n                data = new Uint8Array(totalByteLength),\n                view = new DataView(data.buffer); // For each Gop..\n\n            for (h = 0; h < gops.length; h++) {\n                currentGop = gops[h]; // For each Frame..\n\n                for (i = 0; i < currentGop.length; i++) {\n                    currentFrame = currentGop[i]; // For each NAL..\n\n                    for (j = 0; j < currentFrame.length; j++) {\n                        currentNal = currentFrame[j];\n                        view.setUint32(dataOffset, currentNal.data.byteLength);\n                        dataOffset += 4;\n                        data.set(currentNal.data, dataOffset);\n                        dataOffset += currentNal.data.byteLength;\n                    }\n                }\n            }\n            return data;\n        }; // generate the track's sample table from a frame\n\n        var generateSampleTableForFrame = function (frame, baseDataOffset) {\n            var sample,\n                dataOffset = baseDataOffset || 0,\n                samples = [];\n            sample = sampleForFrame(frame, dataOffset);\n            samples.push(sample);\n            return samples;\n        }; // generate the track's raw mdat data from a frame\n\n        var concatenateNalDataForFrame = function (frame) {\n            var i,\n                currentNal,\n                dataOffset = 0,\n                nalsByteLength = frame.byteLength,\n                numberOfNals = frame.length,\n                totalByteLength = nalsByteLength + 4 * numberOfNals,\n                data = new Uint8Array(totalByteLength),\n                view = new DataView(data.buffer); // For each NAL..\n\n            for (i = 0; i < frame.length; i++) {\n                currentNal = frame[i];\n                view.setUint32(dataOffset, currentNal.data.byteLength);\n                dataOffset += 4;\n                data.set(currentNal.data, dataOffset);\n                dataOffset += currentNal.data.byteLength;\n            }\n            return data;\n        };\n        var frameUtils$1 = {\n            groupNalsIntoFrames: groupNalsIntoFrames,\n            groupFramesIntoGops: groupFramesIntoGops,\n            extendFirstKeyFrame: extendFirstKeyFrame,\n            generateSampleTable: generateSampleTable$1,\n            concatenateNalData: concatenateNalData,\n            generateSampleTableForFrame: generateSampleTableForFrame,\n            concatenateNalDataForFrame: concatenateNalDataForFrame\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var highPrefix = [33, 16, 5, 32, 164, 27];\n        var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n        var zeroFill = function (count) {\n            var a = [];\n            while (count--) {\n                a.push(0);\n            }\n            return a;\n        };\n        var makeTable = function (metaTable) {\n            return Object.keys(metaTable).reduce(function (obj, key) {\n                obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n                    return arr.concat(part);\n                }, []));\n                return obj;\n            }, {});\n        };\n        var silence;\n        var silence_1 = function () {\n            if (!silence) {\n                // Frames-of-silence to use for filling in missing AAC frames\n                var coneOfSilence = {\n                    96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n                    88200: [highPrefix, [231], zeroFill(170), [56]],\n                    64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n                    48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n                    44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n                    32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n                    24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n                    16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n                    12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n                    11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n                    8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n                };\n                silence = makeTable(coneOfSilence);\n            }\n            return silence;\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ONE_SECOND_IN_TS$4 = 90000,\n            // 90kHz clock\n            secondsToVideoTs,\n            secondsToAudioTs,\n            videoTsToSeconds,\n            audioTsToSeconds,\n            audioTsToVideoTs,\n            videoTsToAudioTs,\n            metadataTsToSeconds;\n        secondsToVideoTs = function (seconds) {\n            return seconds * ONE_SECOND_IN_TS$4;\n        };\n        secondsToAudioTs = function (seconds, sampleRate) {\n            return seconds * sampleRate;\n        };\n        videoTsToSeconds = function (timestamp) {\n            return timestamp / ONE_SECOND_IN_TS$4;\n        };\n        audioTsToSeconds = function (timestamp, sampleRate) {\n            return timestamp / sampleRate;\n        };\n        audioTsToVideoTs = function (timestamp, sampleRate) {\n            return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n        };\n        videoTsToAudioTs = function (timestamp, sampleRate) {\n            return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n        };\n        /**\n         * Adjust ID3 tag or caption timing information by the timeline pts values\n         * (if keepOriginalTimestamps is false) and convert to seconds\n         */\n\n        metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n            return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n        };\n        var clock$2 = {\n            ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,\n            secondsToVideoTs: secondsToVideoTs,\n            secondsToAudioTs: secondsToAudioTs,\n            videoTsToSeconds: videoTsToSeconds,\n            audioTsToSeconds: audioTsToSeconds,\n            audioTsToVideoTs: audioTsToVideoTs,\n            videoTsToAudioTs: videoTsToAudioTs,\n            metadataTsToSeconds: metadataTsToSeconds\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var coneOfSilence = silence_1;\n        var clock$1 = clock$2;\n        /**\n         * Sum the `byteLength` properties of the data in each AAC frame\n         */\n\n        var sumFrameByteLengths = function (array) {\n            var i,\n                currentObj,\n                sum = 0; // sum the byteLength's all each nal unit in the frame\n\n            for (i = 0; i < array.length; i++) {\n                currentObj = array[i];\n                sum += currentObj.data.byteLength;\n            }\n            return sum;\n        }; // Possibly pad (prefix) the audio track with silence if appending this track\n        // would lead to the introduction of a gap in the audio buffer\n\n        var prefixWithSilence = function (track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n            var baseMediaDecodeTimeTs,\n                frameDuration = 0,\n                audioGapDuration = 0,\n                audioFillFrameCount = 0,\n                audioFillDuration = 0,\n                silentFrame,\n                i,\n                firstFrame;\n            if (!frames.length) {\n                return;\n            }\n            baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n            frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n            if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n                // insert the shortest possible amount (audio gap or audio to video gap)\n                audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n                audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n                audioFillDuration = audioFillFrameCount * frameDuration;\n            } // don't attempt to fill gaps smaller than a single frame or larger\n            // than a half second\n\n            if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) {\n                return;\n            }\n            silentFrame = coneOfSilence()[track.samplerate];\n            if (!silentFrame) {\n                // we don't have a silent frame pregenerated for the sample rate, so use a frame\n                // from the content instead\n                silentFrame = frames[0].data;\n            }\n            for (i = 0; i < audioFillFrameCount; i++) {\n                firstFrame = frames[0];\n                frames.splice(0, 0, {\n                    data: silentFrame,\n                    dts: firstFrame.dts - frameDuration,\n                    pts: firstFrame.pts - frameDuration\n                });\n            }\n            track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));\n            return audioFillDuration;\n        }; // If the audio segment extends before the earliest allowed dts\n        // value, remove AAC frames until starts at or after the earliest\n        // allowed DTS so that we don't end up with a negative baseMedia-\n        // DecodeTime for the audio track\n\n        var trimAdtsFramesByEarliestDts = function (adtsFrames, track, earliestAllowedDts) {\n            if (track.minSegmentDts >= earliestAllowedDts) {\n                return adtsFrames;\n            } // We will need to recalculate the earliest segment Dts\n\n            track.minSegmentDts = Infinity;\n            return adtsFrames.filter(function (currentFrame) {\n                // If this is an allowed frame, keep it and record it's Dts\n                if (currentFrame.dts >= earliestAllowedDts) {\n                    track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n                    track.minSegmentPts = track.minSegmentDts;\n                    return true;\n                } // Otherwise, discard it\n\n                return false;\n            });\n        }; // generate the track's raw mdat data from an array of frames\n\n        var generateSampleTable = function (frames) {\n            var i,\n                currentFrame,\n                samples = [];\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                samples.push({\n                    size: currentFrame.data.byteLength,\n                    duration: 1024 // For AAC audio, all samples contain 1024 samples\n                });\n            }\n\n            return samples;\n        }; // generate the track's sample table from an array of frames\n\n        var concatenateFrameData = function (frames) {\n            var i,\n                currentFrame,\n                dataOffset = 0,\n                data = new Uint8Array(sumFrameByteLengths(frames));\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                data.set(currentFrame.data, dataOffset);\n                dataOffset += currentFrame.data.byteLength;\n            }\n            return data;\n        };\n        var audioFrameUtils$1 = {\n            prefixWithSilence: prefixWithSilence,\n            trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n            generateSampleTable: generateSampleTable,\n            concatenateFrameData: concatenateFrameData\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;\n        /**\n         * Store information about the start and end of the track and the\n         * duration for each frame/sample we process in order to calculate\n         * the baseMediaDecodeTime\n         */\n\n        var collectDtsInfo = function (track, data) {\n            if (typeof data.pts === 'number') {\n                if (track.timelineStartInfo.pts === undefined) {\n                    track.timelineStartInfo.pts = data.pts;\n                }\n                if (track.minSegmentPts === undefined) {\n                    track.minSegmentPts = data.pts;\n                } else {\n                    track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n                }\n                if (track.maxSegmentPts === undefined) {\n                    track.maxSegmentPts = data.pts;\n                } else {\n                    track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n                }\n            }\n            if (typeof data.dts === 'number') {\n                if (track.timelineStartInfo.dts === undefined) {\n                    track.timelineStartInfo.dts = data.dts;\n                }\n                if (track.minSegmentDts === undefined) {\n                    track.minSegmentDts = data.dts;\n                } else {\n                    track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n                }\n                if (track.maxSegmentDts === undefined) {\n                    track.maxSegmentDts = data.dts;\n                } else {\n                    track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n                }\n            }\n        };\n        /**\n         * Clear values used to calculate the baseMediaDecodeTime between\n         * tracks\n         */\n\n        var clearDtsInfo = function (track) {\n            delete track.minSegmentDts;\n            delete track.maxSegmentDts;\n            delete track.minSegmentPts;\n            delete track.maxSegmentPts;\n        };\n        /**\n         * Calculate the track's baseMediaDecodeTime based on the earliest\n         * DTS the transmuxer has ever seen and the minimum DTS for the\n         * current track\n         * @param track {object} track metadata configuration\n         * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        var calculateTrackBaseMediaDecodeTime = function (track, keepOriginalTimestamps) {\n            var baseMediaDecodeTime,\n                scale,\n                minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n            if (!keepOriginalTimestamps) {\n                minSegmentDts -= track.timelineStartInfo.dts;\n            } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n            // we want the start of the first segment to be placed\n\n            baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n            baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n            baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n            if (track.type === 'audio') {\n                // Audio has a different clock equal to the sampling_rate so we need to\n                // scale the PTS values into the clock rate of the track\n                scale = track.samplerate / ONE_SECOND_IN_TS$3;\n                baseMediaDecodeTime *= scale;\n                baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n            }\n            return baseMediaDecodeTime;\n        };\n        var trackDecodeInfo$1 = {\n            clearDtsInfo: clearDtsInfo,\n            calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n            collectDtsInfo: collectDtsInfo\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band caption information from a video elementary\n         * stream. Captions must follow the CEA-708 standard for injection\n         * into an MPEG-2 transport streams.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n         */\n            // payload type field to indicate how they are to be\n            // interpreted. CEAS-708 caption content is always transmitted with\n            // payload type 0x04.\n\n        var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n            RBSP_TRAILING_BITS = 128;\n        /**\n         * Parse a supplemental enhancement information (SEI) NAL unit.\n         * Stops parsing once a message of type ITU T T35 has been found.\n         *\n         * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n         * @return {object} the parsed SEI payload\n         * @see Rec. ITU-T H.264, 7.3.2.3.1\n         */\n\n        var parseSei = function (bytes) {\n            var i = 0,\n                result = {\n                    payloadType: -1,\n                    payloadSize: 0\n                },\n                payloadType = 0,\n                payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n            while (i < bytes.byteLength) {\n                // stop once we have hit the end of the sei_rbsp\n                if (bytes[i] === RBSP_TRAILING_BITS) {\n                    break;\n                } // Parse payload type\n\n                while (bytes[i] === 0xFF) {\n                    payloadType += 255;\n                    i++;\n                }\n                payloadType += bytes[i++]; // Parse payload size\n\n                while (bytes[i] === 0xFF) {\n                    payloadSize += 255;\n                    i++;\n                }\n                payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n                // there can only ever be one caption message in a frame's sei\n\n                if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n                    var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n                    if (userIdentifier === 'GA94') {\n                        result.payloadType = payloadType;\n                        result.payloadSize = payloadSize;\n                        result.payload = bytes.subarray(i, i + payloadSize);\n                        break;\n                    } else {\n                        result.payload = void 0;\n                    }\n                } // skip the payload and parse the next message\n\n                i += payloadSize;\n                payloadType = 0;\n                payloadSize = 0;\n            }\n            return result;\n        }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n        var parseUserData = function (sei) {\n            // itu_t_t35_contry_code must be 181 (United States) for\n            // captions\n            if (sei.payload[0] !== 181) {\n                return null;\n            } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n            if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n                return null;\n            } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n            if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n                return null;\n            } // finally, user_data_type_code should be 0x03 for caption data\n\n            if (sei.payload[7] !== 0x03) {\n                return null;\n            } // return the user_data_type_structure and strip the trailing\n            // marker bits\n\n            return sei.payload.subarray(8, sei.payload.length - 1);\n        }; // see CEA-708-D, section 4.4\n\n        var parseCaptionPackets = function (pts, userData) {\n            var results = [],\n                i,\n                count,\n                offset,\n                data; // if this is just filler, return immediately\n\n            if (!(userData[0] & 0x40)) {\n                return results;\n            } // parse out the cc_data_1 and cc_data_2 fields\n\n            count = userData[0] & 0x1f;\n            for (i = 0; i < count; i++) {\n                offset = i * 3;\n                data = {\n                    type: userData[offset + 2] & 0x03,\n                    pts: pts\n                }; // capture cc data when cc_valid is 1\n\n                if (userData[offset + 2] & 0x04) {\n                    data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n                    results.push(data);\n                }\n            }\n            return results;\n        };\n        var discardEmulationPreventionBytes$1 = function (data) {\n            var length = data.byteLength,\n                emulationPreventionBytesPositions = [],\n                i = 1,\n                newLength,\n                newData; // Find all `Emulation Prevention Bytes`\n\n            while (i < length - 2) {\n                if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n                    emulationPreventionBytesPositions.push(i + 2);\n                    i += 2;\n                } else {\n                    i++;\n                }\n            } // If no Emulation Prevention Bytes were found just return the original\n            // array\n\n            if (emulationPreventionBytesPositions.length === 0) {\n                return data;\n            } // Create a new array to hold the NAL unit data\n\n            newLength = length - emulationPreventionBytesPositions.length;\n            newData = new Uint8Array(newLength);\n            var sourceIndex = 0;\n            for (i = 0; i < newLength; sourceIndex++, i++) {\n                if (sourceIndex === emulationPreventionBytesPositions[0]) {\n                    // Skip this byte\n                    sourceIndex++; // Remove this position index\n\n                    emulationPreventionBytesPositions.shift();\n                }\n                newData[i] = data[sourceIndex];\n            }\n            return newData;\n        }; // exports\n\n        var captionPacketParser = {\n            parseSei: parseSei,\n            parseUserData: parseUserData,\n            parseCaptionPackets: parseCaptionPackets,\n            discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n            USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band caption information from a video elementary\n         * stream. Captions must follow the CEA-708 standard for injection\n         * into an MPEG-2 transport streams.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n         */\n            // Link To Transport\n            // -----------------\n\n        var Stream$7 = stream;\n        var cea708Parser = captionPacketParser;\n        var CaptionStream$2 = function (options) {\n            options = options || {};\n            CaptionStream$2.prototype.init.call(this); // parse708captions flag, default to true\n\n            this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n            this.captionPackets_ = [];\n            this.ccStreams_ = [new Cea608Stream(0, 0),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(0, 1),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(1, 0),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n            ];\n\n            if (this.parse708captions_) {\n                this.cc708Stream_ = new Cea708Stream({\n                    captionServices: options.captionServices\n                }); // eslint-disable-line no-use-before-define\n            }\n\n            this.reset(); // forward data and done events from CCs to this CaptionStream\n\n            this.ccStreams_.forEach(function (cc) {\n                cc.on('data', this.trigger.bind(this, 'data'));\n                cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n                cc.on('done', this.trigger.bind(this, 'done'));\n            }, this);\n            if (this.parse708captions_) {\n                this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n                this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n                this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n            }\n        };\n        CaptionStream$2.prototype = new Stream$7();\n        CaptionStream$2.prototype.push = function (event) {\n            var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n            if (event.nalUnitType !== 'sei_rbsp') {\n                return;\n            } // parse the sei\n\n            sei = cea708Parser.parseSei(event.escapedRBSP); // no payload data, skip\n\n            if (!sei.payload) {\n                return;\n            } // ignore everything but user_data_registered_itu_t_t35\n\n            if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n                return;\n            } // parse out the user data payload\n\n            userData = cea708Parser.parseUserData(sei); // ignore unrecognized userData\n\n            if (!userData) {\n                return;\n            } // Sometimes, the same segment # will be downloaded twice. To stop the\n            // caption data from being processed twice, we track the latest dts we've\n            // received and ignore everything with a dts before that. However, since\n            // data for a specific dts can be split across packets on either side of\n            // a segment boundary, we need to make sure we *don't* ignore the packets\n            // from the *next* segment that have dts === this.latestDts_. By constantly\n            // tracking the number of packets received with dts === this.latestDts_, we\n            // know how many should be ignored once we start receiving duplicates.\n\n            if (event.dts < this.latestDts_) {\n                // We've started getting older data, so set the flag.\n                this.ignoreNextEqualDts_ = true;\n                return;\n            } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n                this.numSameDts_--;\n                if (!this.numSameDts_) {\n                    // We've received the last duplicate packet, time to start processing again\n                    this.ignoreNextEqualDts_ = false;\n                }\n                return;\n            } // parse out CC data packets and save them for later\n\n            newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n            this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n            if (this.latestDts_ !== event.dts) {\n                this.numSameDts_ = 0;\n            }\n            this.numSameDts_++;\n            this.latestDts_ = event.dts;\n        };\n        CaptionStream$2.prototype.flushCCStreams = function (flushType) {\n            this.ccStreams_.forEach(function (cc) {\n                return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n            }, this);\n        };\n        CaptionStream$2.prototype.flushStream = function (flushType) {\n            // make sure we actually parsed captions before proceeding\n            if (!this.captionPackets_.length) {\n                this.flushCCStreams(flushType);\n                return;\n            } // In Chrome, the Array#sort function is not stable so add a\n            // presortIndex that we can use to ensure we get a stable-sort\n\n            this.captionPackets_.forEach(function (elem, idx) {\n                elem.presortIndex = idx;\n            }); // sort caption byte-pairs based on their PTS values\n\n            this.captionPackets_.sort(function (a, b) {\n                if (a.pts === b.pts) {\n                    return a.presortIndex - b.presortIndex;\n                }\n                return a.pts - b.pts;\n            });\n            this.captionPackets_.forEach(function (packet) {\n                if (packet.type < 2) {\n                    // Dispatch packet to the right Cea608Stream\n                    this.dispatchCea608Packet(packet);\n                } else {\n                    // Dispatch packet to the Cea708Stream\n                    this.dispatchCea708Packet(packet);\n                }\n            }, this);\n            this.captionPackets_.length = 0;\n            this.flushCCStreams(flushType);\n        };\n        CaptionStream$2.prototype.flush = function () {\n            return this.flushStream('flush');\n        }; // Only called if handling partial data\n\n        CaptionStream$2.prototype.partialFlush = function () {\n            return this.flushStream('partialFlush');\n        };\n        CaptionStream$2.prototype.reset = function () {\n            this.latestDts_ = null;\n            this.ignoreNextEqualDts_ = false;\n            this.numSameDts_ = 0;\n            this.activeCea608Channel_ = [null, null];\n            this.ccStreams_.forEach(function (ccStream) {\n                ccStream.reset();\n            });\n        }; // From the CEA-608 spec:\n\n        /*\n     * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n     * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n     * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n     * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n     * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n     * to switch to captioning or Text.\n    */\n        // With that in mind, we ignore any data between an XDS control code and a\n        // subsequent closed-captioning control code.\n\n        CaptionStream$2.prototype.dispatchCea608Packet = function (packet) {\n            // NOTE: packet.type is the CEA608 field\n            if (this.setsTextOrXDSActive(packet)) {\n                this.activeCea608Channel_[packet.type] = null;\n            } else if (this.setsChannel1Active(packet)) {\n                this.activeCea608Channel_[packet.type] = 0;\n            } else if (this.setsChannel2Active(packet)) {\n                this.activeCea608Channel_[packet.type] = 1;\n            }\n            if (this.activeCea608Channel_[packet.type] === null) {\n                // If we haven't received anything to set the active channel, or the\n                // packets are Text/XDS data, discard the data; we don't want jumbled\n                // captions\n                return;\n            }\n            this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n        };\n        CaptionStream$2.prototype.setsChannel1Active = function (packet) {\n            return (packet.ccData & 0x7800) === 0x1000;\n        };\n        CaptionStream$2.prototype.setsChannel2Active = function (packet) {\n            return (packet.ccData & 0x7800) === 0x1800;\n        };\n        CaptionStream$2.prototype.setsTextOrXDSActive = function (packet) {\n            return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n        };\n        CaptionStream$2.prototype.dispatchCea708Packet = function (packet) {\n            if (this.parse708captions_) {\n                this.cc708Stream_.push(packet);\n            }\n        }; // ----------------------\n        // Session to Application\n        // ----------------------\n        // This hash maps special and extended character codes to their\n        // proper Unicode equivalent. The first one-byte key is just a\n        // non-standard character code. The two-byte keys that follow are\n        // the extended CEA708 character codes, along with the preceding\n        // 0x10 extended character byte to distinguish these codes from\n        // non-extended character codes. Every CEA708 character code that\n        // is not in this object maps directly to a standard unicode\n        // character code.\n        // The transparent space and non-breaking transparent space are\n        // technically not fully supported since there is no code to\n        // make them transparent, so they have normal non-transparent\n        // stand-ins.\n        // The special closed caption (CC) character isn't a standard\n        // unicode character, so a fairly similar unicode character was\n        // chosen in it's place.\n\n        var CHARACTER_TRANSLATION_708 = {\n            0x7f: 0x266a,\n            // ♪\n            0x1020: 0x20,\n            // Transparent Space\n            0x1021: 0xa0,\n            // Nob-breaking Transparent Space\n            0x1025: 0x2026,\n            // …\n            0x102a: 0x0160,\n            // Š\n            0x102c: 0x0152,\n            // Œ\n            0x1030: 0x2588,\n            // █\n            0x1031: 0x2018,\n            // ‘\n            0x1032: 0x2019,\n            // ’\n            0x1033: 0x201c,\n            // “\n            0x1034: 0x201d,\n            // ”\n            0x1035: 0x2022,\n            // •\n            0x1039: 0x2122,\n            // ™\n            0x103a: 0x0161,\n            // š\n            0x103c: 0x0153,\n            // œ\n            0x103d: 0x2120,\n            // ℠\n            0x103f: 0x0178,\n            // Ÿ\n            0x1076: 0x215b,\n            // ⅛\n            0x1077: 0x215c,\n            // ⅜\n            0x1078: 0x215d,\n            // ⅝\n            0x1079: 0x215e,\n            // ⅞\n            0x107a: 0x23d0,\n            // ⏐\n            0x107b: 0x23a4,\n            // ⎤\n            0x107c: 0x23a3,\n            // ⎣\n            0x107d: 0x23af,\n            // ⎯\n            0x107e: 0x23a6,\n            // ⎦\n            0x107f: 0x23a1,\n            // ⎡\n            0x10a0: 0x3138 // ㄸ (CC char)\n        };\n\n        var get708CharFromCode = function (code) {\n            var newCode = CHARACTER_TRANSLATION_708[code] || code;\n            if (code & 0x1000 && code === newCode) {\n                // Invalid extended code\n                return '';\n            }\n            return String.fromCharCode(newCode);\n        };\n        var within708TextBlock = function (b) {\n            return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n        };\n        var Cea708Window = function (windowNum) {\n            this.windowNum = windowNum;\n            this.reset();\n        };\n        Cea708Window.prototype.reset = function () {\n            this.clearText();\n            this.pendingNewLine = false;\n            this.winAttr = {};\n            this.penAttr = {};\n            this.penLoc = {};\n            this.penColor = {}; // These default values are arbitrary,\n            // defineWindow will usually override them\n\n            this.visible = 0;\n            this.rowLock = 0;\n            this.columnLock = 0;\n            this.priority = 0;\n            this.relativePositioning = 0;\n            this.anchorVertical = 0;\n            this.anchorHorizontal = 0;\n            this.anchorPoint = 0;\n            this.rowCount = 1;\n            this.virtualRowCount = this.rowCount + 1;\n            this.columnCount = 41;\n            this.windowStyle = 0;\n            this.penStyle = 0;\n        };\n        Cea708Window.prototype.getText = function () {\n            return this.rows.join('\\n');\n        };\n        Cea708Window.prototype.clearText = function () {\n            this.rows = [''];\n            this.rowIdx = 0;\n        };\n        Cea708Window.prototype.newLine = function (pts) {\n            if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n                this.beforeRowOverflow(pts);\n            }\n            if (this.rows.length > 0) {\n                this.rows.push('');\n                this.rowIdx++;\n            } // Show all virtual rows since there's no visible scrolling\n\n            while (this.rows.length > this.virtualRowCount) {\n                this.rows.shift();\n                this.rowIdx--;\n            }\n        };\n        Cea708Window.prototype.isEmpty = function () {\n            if (this.rows.length === 0) {\n                return true;\n            } else if (this.rows.length === 1) {\n                return this.rows[0] === '';\n            }\n            return false;\n        };\n        Cea708Window.prototype.addText = function (text) {\n            this.rows[this.rowIdx] += text;\n        };\n        Cea708Window.prototype.backspace = function () {\n            if (!this.isEmpty()) {\n                var row = this.rows[this.rowIdx];\n                this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n            }\n        };\n        var Cea708Service = function (serviceNum, encoding, stream) {\n            this.serviceNum = serviceNum;\n            this.text = '';\n            this.currentWindow = new Cea708Window(-1);\n            this.windows = [];\n            this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n            if (typeof encoding === 'string') {\n                this.createTextDecoder(encoding);\n            }\n        };\n        /**\n         * Initialize service windows\n         * Must be run before service use\n         *\n         * @param  {Integer}  pts               PTS value\n         * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n         */\n\n        Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n            this.startPts = pts;\n            for (var win = 0; win < 8; win++) {\n                this.windows[win] = new Cea708Window(win);\n                if (typeof beforeRowOverflow === 'function') {\n                    this.windows[win].beforeRowOverflow = beforeRowOverflow;\n                }\n            }\n        };\n        /**\n         * Set current window of service to be affected by commands\n         *\n         * @param  {Integer} windowNum Window number\n         */\n\n        Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n            this.currentWindow = this.windows[windowNum];\n        };\n        /**\n         * Try to create a TextDecoder if it is natively supported\n         */\n\n        Cea708Service.prototype.createTextDecoder = function (encoding) {\n            if (typeof TextDecoder === 'undefined') {\n                this.stream.trigger('log', {\n                    level: 'warn',\n                    message: 'The `encoding` option is unsupported without TextDecoder support'\n                });\n            } else {\n                try {\n                    this.textDecoder_ = new TextDecoder(encoding);\n                } catch (error) {\n                    this.stream.trigger('log', {\n                        level: 'warn',\n                        message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n                    });\n                }\n            }\n        };\n        var Cea708Stream = function (options) {\n            options = options || {};\n            Cea708Stream.prototype.init.call(this);\n            var self = this;\n            var captionServices = options.captionServices || {};\n            var captionServiceEncodings = {};\n            var serviceProps; // Get service encodings from captionServices option block\n\n            Object.keys(captionServices).forEach(serviceName => {\n                serviceProps = captionServices[serviceName];\n                if (/^SERVICE/.test(serviceName)) {\n                    captionServiceEncodings[serviceName] = serviceProps.encoding;\n                }\n            });\n            this.serviceEncodings = captionServiceEncodings;\n            this.current708Packet = null;\n            this.services = {};\n            this.push = function (packet) {\n                if (packet.type === 3) {\n                    // 708 packet start\n                    self.new708Packet();\n                    self.add708Bytes(packet);\n                } else {\n                    if (self.current708Packet === null) {\n                        // This should only happen at the start of a file if there's no packet start.\n                        self.new708Packet();\n                    }\n                    self.add708Bytes(packet);\n                }\n            };\n        };\n        Cea708Stream.prototype = new Stream$7();\n        /**\n         * Push current 708 packet, create new 708 packet.\n         */\n\n        Cea708Stream.prototype.new708Packet = function () {\n            if (this.current708Packet !== null) {\n                this.push708Packet();\n            }\n            this.current708Packet = {\n                data: [],\n                ptsVals: []\n            };\n        };\n        /**\n         * Add pts and both bytes from packet into current 708 packet.\n         */\n\n        Cea708Stream.prototype.add708Bytes = function (packet) {\n            var data = packet.ccData;\n            var byte0 = data >>> 8;\n            var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n            // that service blocks will always line up with byte pairs.\n\n            this.current708Packet.ptsVals.push(packet.pts);\n            this.current708Packet.data.push(byte0);\n            this.current708Packet.data.push(byte1);\n        };\n        /**\n         * Parse completed 708 packet into service blocks and push each service block.\n         */\n\n        Cea708Stream.prototype.push708Packet = function () {\n            var packet708 = this.current708Packet;\n            var packetData = packet708.data;\n            var serviceNum = null;\n            var blockSize = null;\n            var i = 0;\n            var b = packetData[i++];\n            packet708.seq = b >> 6;\n            packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n            for (; i < packetData.length; i++) {\n                b = packetData[i++];\n                serviceNum = b >> 5;\n                blockSize = b & 0x1f; // 0b00011111\n\n                if (serviceNum === 7 && blockSize > 0) {\n                    // Extended service num\n                    b = packetData[i++];\n                    serviceNum = b;\n                }\n                this.pushServiceBlock(serviceNum, i, blockSize);\n                if (blockSize > 0) {\n                    i += blockSize - 1;\n                }\n            }\n        };\n        /**\n         * Parse service block, execute commands, read text.\n         *\n         * Note: While many of these commands serve important purposes,\n         * many others just parse out the parameters or attributes, but\n         * nothing is done with them because this is not a full and complete\n         * implementation of the entire 708 spec.\n         *\n         * @param  {Integer} serviceNum Service number\n         * @param  {Integer} start      Start index of the 708 packet data\n         * @param  {Integer} size       Block size\n         */\n\n        Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n            var b;\n            var i = start;\n            var packetData = this.current708Packet.data;\n            var service = this.services[serviceNum];\n            if (!service) {\n                service = this.initService(serviceNum, i);\n            }\n            for (; i < start + size && i < packetData.length; i++) {\n                b = packetData[i];\n                if (within708TextBlock(b)) {\n                    i = this.handleText(i, service);\n                } else if (b === 0x18) {\n                    i = this.multiByteCharacter(i, service);\n                } else if (b === 0x10) {\n                    i = this.extendedCommands(i, service);\n                } else if (0x80 <= b && b <= 0x87) {\n                    i = this.setCurrentWindow(i, service);\n                } else if (0x98 <= b && b <= 0x9f) {\n                    i = this.defineWindow(i, service);\n                } else if (b === 0x88) {\n                    i = this.clearWindows(i, service);\n                } else if (b === 0x8c) {\n                    i = this.deleteWindows(i, service);\n                } else if (b === 0x89) {\n                    i = this.displayWindows(i, service);\n                } else if (b === 0x8a) {\n                    i = this.hideWindows(i, service);\n                } else if (b === 0x8b) {\n                    i = this.toggleWindows(i, service);\n                } else if (b === 0x97) {\n                    i = this.setWindowAttributes(i, service);\n                } else if (b === 0x90) {\n                    i = this.setPenAttributes(i, service);\n                } else if (b === 0x91) {\n                    i = this.setPenColor(i, service);\n                } else if (b === 0x92) {\n                    i = this.setPenLocation(i, service);\n                } else if (b === 0x8f) {\n                    service = this.reset(i, service);\n                } else if (b === 0x08) {\n                    // BS: Backspace\n                    service.currentWindow.backspace();\n                } else if (b === 0x0c) {\n                    // FF: Form feed\n                    service.currentWindow.clearText();\n                } else if (b === 0x0d) {\n                    // CR: Carriage return\n                    service.currentWindow.pendingNewLine = true;\n                } else if (b === 0x0e) {\n                    // HCR: Horizontal carriage return\n                    service.currentWindow.clearText();\n                } else if (b === 0x8d) {\n                    // DLY: Delay, nothing to do\n                    i++;\n                } else ;\n            }\n        };\n        /**\n         * Execute an extended command\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.extendedCommands = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            if (within708TextBlock(b)) {\n                i = this.handleText(i, service, {\n                    isExtended: true\n                });\n            }\n            return i;\n        };\n        /**\n         * Get PTS value of a given byte index\n         *\n         * @param  {Integer} byteIndex  Index of the byte\n         * @return {Integer}            PTS\n         */\n\n        Cea708Stream.prototype.getPts = function (byteIndex) {\n            // There's 1 pts value per 2 bytes\n            return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n        };\n        /**\n         * Initializes a service\n         *\n         * @param  {Integer} serviceNum Service number\n         * @return {Service}            Initialized service object\n         */\n\n        Cea708Stream.prototype.initService = function (serviceNum, i) {\n            var serviceName = 'SERVICE' + serviceNum;\n            var self = this;\n            var serviceName;\n            var encoding;\n            if (serviceName in this.serviceEncodings) {\n                encoding = this.serviceEncodings[serviceName];\n            }\n            this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n            this.services[serviceNum].init(this.getPts(i), function (pts) {\n                self.flushDisplayed(pts, self.services[serviceNum]);\n            });\n            return this.services[serviceNum];\n        };\n        /**\n         * Execute text writing to current window\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.handleText = function (i, service, options) {\n            var isExtended = options && options.isExtended;\n            var isMultiByte = options && options.isMultiByte;\n            var packetData = this.current708Packet.data;\n            var extended = isExtended ? 0x1000 : 0x0000;\n            var currentByte = packetData[i];\n            var nextByte = packetData[i + 1];\n            var win = service.currentWindow;\n            var char;\n            var charCodeArray; // Converts an array of bytes to a unicode hex string.\n\n            function toHexString(byteArray) {\n                return byteArray.map(byte => {\n                    return ('0' + (byte & 0xFF).toString(16)).slice(-2);\n                }).join('');\n            }\n            if (isMultiByte) {\n                charCodeArray = [currentByte, nextByte];\n                i++;\n            } else {\n                charCodeArray = [currentByte];\n            } // Use the TextDecoder if one was created for this service\n\n            if (service.textDecoder_ && !isExtended) {\n                char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n            } else {\n                // We assume any multi-byte char without a decoder is unicode.\n                if (isMultiByte) {\n                    const unicode = toHexString(charCodeArray); // Takes a unicode hex string and creates a single character.\n\n                    char = String.fromCharCode(parseInt(unicode, 16));\n                } else {\n                    char = get708CharFromCode(extended | currentByte);\n                }\n            }\n            if (win.pendingNewLine && !win.isEmpty()) {\n                win.newLine(this.getPts(i));\n            }\n            win.pendingNewLine = false;\n            win.addText(char);\n            return i;\n        };\n        /**\n         * Handle decoding of multibyte character\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var firstByte = packetData[i + 1];\n            var secondByte = packetData[i + 2];\n            if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n                i = this.handleText(++i, service, {\n                    isMultiByte: true\n                });\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the CW# command.\n         *\n         * Set the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var windowNum = b & 0x07;\n            service.setCurrentWindow(windowNum);\n            return i;\n        };\n        /**\n         * Parse and execute the DF# command.\n         *\n         * Define a window and set it as the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.defineWindow = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var windowNum = b & 0x07;\n            service.setCurrentWindow(windowNum);\n            var win = service.currentWindow;\n            b = packetData[++i];\n            win.visible = (b & 0x20) >> 5; // v\n\n            win.rowLock = (b & 0x10) >> 4; // rl\n\n            win.columnLock = (b & 0x08) >> 3; // cl\n\n            win.priority = b & 0x07; // p\n\n            b = packetData[++i];\n            win.relativePositioning = (b & 0x80) >> 7; // rp\n\n            win.anchorVertical = b & 0x7f; // av\n\n            b = packetData[++i];\n            win.anchorHorizontal = b; // ah\n\n            b = packetData[++i];\n            win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n            win.rowCount = b & 0x0f; // rc\n\n            b = packetData[++i];\n            win.columnCount = b & 0x3f; // cc\n\n            b = packetData[++i];\n            win.windowStyle = (b & 0x38) >> 3; // ws\n\n            win.penStyle = b & 0x07; // ps\n            // The spec says there are (rowCount+1) \"virtual rows\"\n\n            win.virtualRowCount = win.rowCount + 1;\n            return i;\n        };\n        /**\n         * Parse and execute the SWA command.\n         *\n         * Set attributes of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var winAttr = service.currentWindow.winAttr;\n            b = packetData[++i];\n            winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n            winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n            winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n            winAttr.fillBlue = b & 0x03; // fb\n\n            b = packetData[++i];\n            winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n            winAttr.borderRed = (b & 0x30) >> 4; // br\n\n            winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n            winAttr.borderBlue = b & 0x03; // bb\n\n            b = packetData[++i];\n            winAttr.borderType += (b & 0x80) >> 5; // bt\n\n            winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n            winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n            winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n            winAttr.justify = b & 0x03; // j\n\n            b = packetData[++i];\n            winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n            winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n            winAttr.displayEffect = b & 0x03; // de\n\n            return i;\n        };\n        /**\n         * Gather text from all displayed windows and push a caption to output.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         */\n\n        Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n            var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n            // display text in the correct order, but sample files so far have not shown any issue.\n\n            for (var winId = 0; winId < 8; winId++) {\n                if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n                    displayedText.push(service.windows[winId].getText());\n                }\n            }\n            service.endPts = pts;\n            service.text = displayedText.join('\\n\\n');\n            this.pushCaption(service);\n            service.startPts = pts;\n        };\n        /**\n         * Push a caption to output if the caption contains text.\n         *\n         * @param  {Service} service  The service object to be affected\n         */\n\n        Cea708Stream.prototype.pushCaption = function (service) {\n            if (service.text !== '') {\n                this.trigger('data', {\n                    startPts: service.startPts,\n                    endPts: service.endPts,\n                    text: service.text,\n                    stream: 'cc708_' + service.serviceNum\n                });\n                service.text = '';\n                service.startPts = service.endPts;\n            }\n        };\n        /**\n         * Parse and execute the DSW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.displayWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible = 1;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the HDW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.hideWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible = 0;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the TGW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.toggleWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible ^= 1;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the CLW command.\n         *\n         * Clear text of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.clearWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].clearText();\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the DLW command.\n         *\n         * Re-initialize windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.deleteWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].reset();\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the SPA command.\n         *\n         * Set pen attributes of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenAttributes = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penAttr = service.currentWindow.penAttr;\n            b = packetData[++i];\n            penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n            penAttr.offset = (b & 0x0c) >> 2; // o\n\n            penAttr.penSize = b & 0x03; // s\n\n            b = packetData[++i];\n            penAttr.italics = (b & 0x80) >> 7; // i\n\n            penAttr.underline = (b & 0x40) >> 6; // u\n\n            penAttr.edgeType = (b & 0x38) >> 3; // et\n\n            penAttr.fontStyle = b & 0x07; // fs\n\n            return i;\n        };\n        /**\n         * Parse and execute the SPC command.\n         *\n         * Set pen color of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenColor = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penColor = service.currentWindow.penColor;\n            b = packetData[++i];\n            penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n            penColor.fgRed = (b & 0x30) >> 4; // fr\n\n            penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n            penColor.fgBlue = b & 0x03; // fb\n\n            b = packetData[++i];\n            penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n            penColor.bgRed = (b & 0x30) >> 4; // br\n\n            penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n            penColor.bgBlue = b & 0x03; // bb\n\n            b = packetData[++i];\n            penColor.edgeRed = (b & 0x30) >> 4; // er\n\n            penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n            penColor.edgeBlue = b & 0x03; // eb\n\n            return i;\n        };\n        /**\n         * Parse and execute the SPL command.\n         *\n         * Set pen location of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenLocation = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n            service.currentWindow.pendingNewLine = true;\n            b = packetData[++i];\n            penLoc.row = b & 0x0f; // r\n\n            b = packetData[++i];\n            penLoc.column = b & 0x3f; // c\n\n            return i;\n        };\n        /**\n         * Execute the RST command.\n         *\n         * Reset service to a clean slate. Re-initialize.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Service}          Re-initialized service\n         */\n\n        Cea708Stream.prototype.reset = function (i, service) {\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            return this.initService(service.serviceNum, i);\n        }; // This hash maps non-ASCII, special, and extended character codes to their\n        // proper Unicode equivalent. The first keys that are only a single byte\n        // are the non-standard ASCII characters, which simply map the CEA608 byte\n        // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n        // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n        // can be performed regardless of the field and data channel on which the\n        // character code was received.\n\n        var CHARACTER_TRANSLATION = {\n            0x2a: 0xe1,\n            // á\n            0x5c: 0xe9,\n            // é\n            0x5e: 0xed,\n            // í\n            0x5f: 0xf3,\n            // ó\n            0x60: 0xfa,\n            // ú\n            0x7b: 0xe7,\n            // ç\n            0x7c: 0xf7,\n            // ÷\n            0x7d: 0xd1,\n            // Ñ\n            0x7e: 0xf1,\n            // ñ\n            0x7f: 0x2588,\n            // █\n            0x0130: 0xae,\n            // ®\n            0x0131: 0xb0,\n            // °\n            0x0132: 0xbd,\n            // ½\n            0x0133: 0xbf,\n            // ¿\n            0x0134: 0x2122,\n            // ™\n            0x0135: 0xa2,\n            // ¢\n            0x0136: 0xa3,\n            // £\n            0x0137: 0x266a,\n            // ♪\n            0x0138: 0xe0,\n            // à\n            0x0139: 0xa0,\n            //\n            0x013a: 0xe8,\n            // è\n            0x013b: 0xe2,\n            // â\n            0x013c: 0xea,\n            // ê\n            0x013d: 0xee,\n            // î\n            0x013e: 0xf4,\n            // ô\n            0x013f: 0xfb,\n            // û\n            0x0220: 0xc1,\n            // Á\n            0x0221: 0xc9,\n            // É\n            0x0222: 0xd3,\n            // Ó\n            0x0223: 0xda,\n            // Ú\n            0x0224: 0xdc,\n            // Ü\n            0x0225: 0xfc,\n            // ü\n            0x0226: 0x2018,\n            // ‘\n            0x0227: 0xa1,\n            // ¡\n            0x0228: 0x2a,\n            // *\n            0x0229: 0x27,\n            // '\n            0x022a: 0x2014,\n            // —\n            0x022b: 0xa9,\n            // ©\n            0x022c: 0x2120,\n            // ℠\n            0x022d: 0x2022,\n            // •\n            0x022e: 0x201c,\n            // “\n            0x022f: 0x201d,\n            // ”\n            0x0230: 0xc0,\n            // À\n            0x0231: 0xc2,\n            // Â\n            0x0232: 0xc7,\n            // Ç\n            0x0233: 0xc8,\n            // È\n            0x0234: 0xca,\n            // Ê\n            0x0235: 0xcb,\n            // Ë\n            0x0236: 0xeb,\n            // ë\n            0x0237: 0xce,\n            // Î\n            0x0238: 0xcf,\n            // Ï\n            0x0239: 0xef,\n            // ï\n            0x023a: 0xd4,\n            // Ô\n            0x023b: 0xd9,\n            // Ù\n            0x023c: 0xf9,\n            // ù\n            0x023d: 0xdb,\n            // Û\n            0x023e: 0xab,\n            // «\n            0x023f: 0xbb,\n            // »\n            0x0320: 0xc3,\n            // Ã\n            0x0321: 0xe3,\n            // ã\n            0x0322: 0xcd,\n            // Í\n            0x0323: 0xcc,\n            // Ì\n            0x0324: 0xec,\n            // ì\n            0x0325: 0xd2,\n            // Ò\n            0x0326: 0xf2,\n            // ò\n            0x0327: 0xd5,\n            // Õ\n            0x0328: 0xf5,\n            // õ\n            0x0329: 0x7b,\n            // {\n            0x032a: 0x7d,\n            // }\n            0x032b: 0x5c,\n            // \\\n            0x032c: 0x5e,\n            // ^\n            0x032d: 0x5f,\n            // _\n            0x032e: 0x7c,\n            // |\n            0x032f: 0x7e,\n            // ~\n            0x0330: 0xc4,\n            // Ä\n            0x0331: 0xe4,\n            // ä\n            0x0332: 0xd6,\n            // Ö\n            0x0333: 0xf6,\n            // ö\n            0x0334: 0xdf,\n            // ß\n            0x0335: 0xa5,\n            // ¥\n            0x0336: 0xa4,\n            // ¤\n            0x0337: 0x2502,\n            // │\n            0x0338: 0xc5,\n            // Å\n            0x0339: 0xe5,\n            // å\n            0x033a: 0xd8,\n            // Ø\n            0x033b: 0xf8,\n            // ø\n            0x033c: 0x250c,\n            // ┌\n            0x033d: 0x2510,\n            // ┐\n            0x033e: 0x2514,\n            // └\n            0x033f: 0x2518 // ┘\n        };\n\n        var getCharFromCode = function (code) {\n            if (code === null) {\n                return '';\n            }\n            code = CHARACTER_TRANSLATION[code] || code;\n            return String.fromCharCode(code);\n        }; // the index of the last row in a CEA-608 display buffer\n\n        var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n        // getting it through bit logic.\n\n        var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n        // cells. The \"bottom\" row is the last element in the outer array.\n        // We keep track of positioning information as we go by storing the\n        // number of indentations and the tab offset in this buffer.\n\n        var createDisplayBuffer = function () {\n            var result = [],\n                i = BOTTOM_ROW + 1;\n            while (i--) {\n                result.push({\n                    text: '',\n                    indent: 0,\n                    offset: 0\n                });\n            }\n            return result;\n        };\n        var Cea608Stream = function (field, dataChannel) {\n            Cea608Stream.prototype.init.call(this);\n            this.field_ = field || 0;\n            this.dataChannel_ = dataChannel || 0;\n            this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n            this.setConstants();\n            this.reset();\n            this.push = function (packet) {\n                var data, swap, char0, char1, text; // remove the parity bits\n\n                data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n                if (data === this.lastControlCode_) {\n                    this.lastControlCode_ = null;\n                    return;\n                } // Store control codes\n\n                if ((data & 0xf000) === 0x1000) {\n                    this.lastControlCode_ = data;\n                } else if (data !== this.PADDING_) {\n                    this.lastControlCode_ = null;\n                }\n                char0 = data >>> 8;\n                char1 = data & 0xff;\n                if (data === this.PADDING_) {\n                    return;\n                } else if (data === this.RESUME_CAPTION_LOADING_) {\n                    this.mode_ = 'popOn';\n                } else if (data === this.END_OF_CAPTION_) {\n                    // If an EOC is received while in paint-on mode, the displayed caption\n                    // text should be swapped to non-displayed memory as if it was a pop-on\n                    // caption. Because of that, we should explicitly switch back to pop-on\n                    // mode\n                    this.mode_ = 'popOn';\n                    this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n                    this.flushDisplayed(packet.pts); // flip memory\n\n                    swap = this.displayed_;\n                    this.displayed_ = this.nonDisplayed_;\n                    this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n                    this.startPts_ = packet.pts;\n                } else if (data === this.ROLL_UP_2_ROWS_) {\n                    this.rollUpRows_ = 2;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.ROLL_UP_3_ROWS_) {\n                    this.rollUpRows_ = 3;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.ROLL_UP_4_ROWS_) {\n                    this.rollUpRows_ = 4;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.CARRIAGE_RETURN_) {\n                    this.clearFormatting(packet.pts);\n                    this.flushDisplayed(packet.pts);\n                    this.shiftRowsUp_();\n                    this.startPts_ = packet.pts;\n                } else if (data === this.BACKSPACE_) {\n                    if (this.mode_ === 'popOn') {\n                        this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);\n                    } else {\n                        this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);\n                    }\n                } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n                    this.flushDisplayed(packet.pts);\n                    this.displayed_ = createDisplayBuffer();\n                } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n                    this.nonDisplayed_ = createDisplayBuffer();\n                } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n                    if (this.mode_ !== 'paintOn') {\n                        // NOTE: This should be removed when proper caption positioning is\n                        // implemented\n                        this.flushDisplayed(packet.pts);\n                        this.displayed_ = createDisplayBuffer();\n                    }\n                    this.mode_ = 'paintOn';\n                    this.startPts_ = packet.pts; // Append special characters to caption text\n                } else if (this.isSpecialCharacter(char0, char1)) {\n                    // Bitmask char0 so that we can apply character transformations\n                    // regardless of field and data channel.\n                    // Then byte-shift to the left and OR with char1 so we can pass the\n                    // entire character code to `getCharFromCode`.\n                    char0 = (char0 & 0x03) << 8;\n                    text = getCharFromCode(char0 | char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_++; // Append extended characters to caption text\n                } else if (this.isExtCharacter(char0, char1)) {\n                    // Extended characters always follow their \"non-extended\" equivalents.\n                    // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n                    // decoders are supposed to drop the \"è\", while compliant decoders\n                    // backspace the \"e\" and insert \"è\".\n                    // Delete the previous character\n                    if (this.mode_ === 'popOn') {\n                        this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);\n                    } else {\n                        this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);\n                    } // Bitmask char0 so that we can apply character transformations\n                    // regardless of field and data channel.\n                    // Then byte-shift to the left and OR with char1 so we can pass the\n                    // entire character code to `getCharFromCode`.\n\n                    char0 = (char0 & 0x03) << 8;\n                    text = getCharFromCode(char0 | char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_++; // Process mid-row codes\n                } else if (this.isMidRowCode(char0, char1)) {\n                    // Attributes are not additive, so clear all formatting\n                    this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n                    // should be replaced with spaces, so add one now\n\n                    this[this.mode_](packet.pts, ' ');\n                    this.column_++;\n                    if ((char1 & 0xe) === 0xe) {\n                        this.addFormatting(packet.pts, ['i']);\n                    }\n                    if ((char1 & 0x1) === 0x1) {\n                        this.addFormatting(packet.pts, ['u']);\n                    } // Detect offset control codes and adjust cursor\n                } else if (this.isOffsetControlCode(char0, char1)) {\n                    // Cursor position is set by indent PAC (see below) in 4-column\n                    // increments, with an additional offset code of 1-3 to reach any\n                    // of the 32 columns specified by CEA-608. So all we need to do\n                    // here is increment the column cursor by the given offset.\n                    const offset = char1 & 0x03; // For an offest value 1-3, set the offset for that caption\n                    // in the non-displayed array.\n\n                    this.nonDisplayed_[this.row_].offset = offset;\n                    this.column_ += offset; // Detect PACs (Preamble Address Codes)\n                } else if (this.isPAC(char0, char1)) {\n                    // There's no logic for PAC -> row mapping, so we have to just\n                    // find the row code in an array and use its index :(\n                    var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n                    if (this.mode_ === 'rollUp') {\n                        // This implies that the base row is incorrectly set.\n                        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n                        // of roll-up rows set.\n                        if (row - this.rollUpRows_ + 1 < 0) {\n                            row = this.rollUpRows_ - 1;\n                        }\n                        this.setRollUp(packet.pts, row);\n                    }\n                    if (row !== this.row_) {\n                        // formatting is only persistent for current row\n                        this.clearFormatting(packet.pts);\n                        this.row_ = row;\n                    } // All PACs can apply underline, so detect and apply\n                    // (All odd-numbered second bytes set underline)\n\n                    if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n                        this.addFormatting(packet.pts, ['u']);\n                    }\n                    if ((data & 0x10) === 0x10) {\n                        // We've got an indent level code. Each successive even number\n                        // increments the column cursor by 4, so we can get the desired\n                        // column position by bit-shifting to the right (to get n/2)\n                        // and multiplying by 4.\n                        const indentations = (data & 0xe) >> 1;\n                        this.column_ = indentations * 4; // add to the number of indentations for positioning\n\n                        this.nonDisplayed_[this.row_].indent += indentations;\n                    }\n                    if (this.isColorPAC(char1)) {\n                        // it's a color code, though we only support white, which\n                        // can be either normal or italicized. white italics can be\n                        // either 0x4e or 0x6e depending on the row, so we just\n                        // bitwise-and with 0xe to see if italics should be turned on\n                        if ((char1 & 0xe) === 0xe) {\n                            this.addFormatting(packet.pts, ['i']);\n                        }\n                    } // We have a normal character in char0, and possibly one in char1\n                } else if (this.isNormalChar(char0)) {\n                    if (char1 === 0x00) {\n                        char1 = null;\n                    }\n                    text = getCharFromCode(char0);\n                    text += getCharFromCode(char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_ += text.length;\n                } // finish data processing\n            };\n        };\n\n        Cea608Stream.prototype = new Stream$7(); // Trigger a cue point that captures the current state of the\n        // display buffer\n\n        Cea608Stream.prototype.flushDisplayed = function (pts) {\n            const logWarning = index => {\n                this.trigger('log', {\n                    level: 'warn',\n                    message: 'Skipping a malformed 608 caption at index ' + index + '.'\n                });\n            };\n            const content = [];\n            this.displayed_.forEach((row, i) => {\n                if (row && row.text && row.text.length) {\n                    try {\n                        // remove spaces from the start and end of the string\n                        row.text = row.text.trim();\n                    } catch (e) {\n                        // Ordinarily, this shouldn't happen. However, caption\n                        // parsing errors should not throw exceptions and\n                        // break playback.\n                        logWarning(i);\n                    } // See the below link for more details on the following fields:\n                    // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n\n                    if (row.text.length) {\n                        content.push({\n                            // The text to be displayed in the caption from this specific row, with whitespace removed.\n                            text: row.text,\n                            // Value between 1 and 15 representing the PAC row used to calculate line height.\n                            line: i + 1,\n                            // A number representing the indent position by percentage (CEA-608 PAC indent code).\n                            // The value will be a number between 10 and 80. Offset is used to add an aditional\n                            // value to the position if necessary.\n                            position: 10 + Math.min(70, row.indent * 10) + row.offset * 2.5\n                        });\n                    }\n                } else if (row === undefined || row === null) {\n                    logWarning(i);\n                }\n            });\n            if (content.length) {\n                this.trigger('data', {\n                    startPts: this.startPts_,\n                    endPts: pts,\n                    content,\n                    stream: this.name_\n                });\n            }\n        };\n        /**\n         * Zero out the data, used for startup and on seek\n         */\n\n        Cea608Stream.prototype.reset = function () {\n            this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n            // actually display captions. If a caption is shifted to a row\n            // with a lower index than this, it is cleared from the display\n            // buffer\n\n            this.topRow_ = 0;\n            this.startPts_ = 0;\n            this.displayed_ = createDisplayBuffer();\n            this.nonDisplayed_ = createDisplayBuffer();\n            this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n            this.column_ = 0;\n            this.row_ = BOTTOM_ROW;\n            this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n            this.formatting_ = [];\n        };\n        /**\n         * Sets up control code and related constants for this instance\n         */\n\n        Cea608Stream.prototype.setConstants = function () {\n            // The following attributes have these uses:\n            // ext_ :    char0 for mid-row codes, and the base for extended\n            //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n            //           extended codes)\n            // control_: char0 for control codes, except byte-shifted to the\n            //           left so that we can do this.control_ | CONTROL_CODE\n            // offset_:  char0 for tab offset codes\n            //\n            // It's also worth noting that control codes, and _only_ control codes,\n            // differ between field 1 and field2. Field 2 control codes are always\n            // their field 1 value plus 1. That's why there's the \"| field\" on the\n            // control value.\n            if (this.dataChannel_ === 0) {\n                this.BASE_ = 0x10;\n                this.EXT_ = 0x11;\n                this.CONTROL_ = (0x14 | this.field_) << 8;\n                this.OFFSET_ = 0x17;\n            } else if (this.dataChannel_ === 1) {\n                this.BASE_ = 0x18;\n                this.EXT_ = 0x19;\n                this.CONTROL_ = (0x1c | this.field_) << 8;\n                this.OFFSET_ = 0x1f;\n            } // Constants for the LSByte command codes recognized by Cea608Stream. This\n            // list is not exhaustive. For a more comprehensive listing and semantics see\n            // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n            // Padding\n\n            this.PADDING_ = 0x0000; // Pop-on Mode\n\n            this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n            this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n            this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n            this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n            this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n            this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n            this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n            this.BACKSPACE_ = this.CONTROL_ | 0x21;\n            this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n            this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n        };\n        /**\n         * Detects if the 2-byte packet data is a special character\n         *\n         * Special characters have a second byte in the range 0x30 to 0x3f,\n         * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n         * data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an special character\n         */\n\n        Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n            return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n        };\n        /**\n         * Detects if the 2-byte packet data is an extended character\n         *\n         * Extended characters have a second byte in the range 0x20 to 0x3f,\n         * with the first byte being 0x12 or 0x13 (for data channel 1) or\n         * 0x1a or 0x1b (for data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an extended character\n         */\n\n        Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n            return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n        };\n        /**\n         * Detects if the 2-byte packet is a mid-row code\n         *\n         * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n         * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n         * channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are a mid-row code\n         */\n\n        Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n            return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n        };\n        /**\n         * Detects if the 2-byte packet is an offset control code\n         *\n         * Offset control codes have a second byte in the range 0x21 to 0x23,\n         * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n         * data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an offset control code\n         */\n\n        Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n            return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n        };\n        /**\n         * Detects if the 2-byte packet is a Preamble Address Code\n         *\n         * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n         * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n         * range 0x40 to 0x7f.\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are a PAC\n         */\n\n        Cea608Stream.prototype.isPAC = function (char0, char1) {\n            return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n        };\n        /**\n         * Detects if a packet's second byte is in the range of a PAC color code\n         *\n         * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n         * 0x60 to 0x6f.\n         *\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the byte is a color PAC\n         */\n\n        Cea608Stream.prototype.isColorPAC = function (char1) {\n            return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n        };\n        /**\n         * Detects if a single byte is in the range of a normal character\n         *\n         * Normal text bytes are in the range 0x20 to 0x7f.\n         *\n         * @param  {Integer} char  The byte\n         * @return {Boolean}       Whether the byte is a normal character\n         */\n\n        Cea608Stream.prototype.isNormalChar = function (char) {\n            return char >= 0x20 && char <= 0x7f;\n        };\n        /**\n         * Configures roll-up\n         *\n         * @param  {Integer} pts         Current PTS\n         * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n         *                               a new position\n         */\n\n        Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n            // Reset the base row to the bottom row when switching modes\n            if (this.mode_ !== 'rollUp') {\n                this.row_ = BOTTOM_ROW;\n                this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n                this.flushDisplayed(pts);\n                this.nonDisplayed_ = createDisplayBuffer();\n                this.displayed_ = createDisplayBuffer();\n            }\n            if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n                // move currently displayed captions (up or down) to the new base row\n                for (var i = 0; i < this.rollUpRows_; i++) {\n                    this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n                    this.displayed_[this.row_ - i] = {\n                        text: '',\n                        indent: 0,\n                        offset: 0\n                    };\n                }\n            }\n            if (newBaseRow === undefined) {\n                newBaseRow = this.row_;\n            }\n            this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n        }; // Adds the opening HTML tag for the passed character to the caption text,\n        // and keeps track of it for later closing\n\n        Cea608Stream.prototype.addFormatting = function (pts, format) {\n            this.formatting_ = this.formatting_.concat(format);\n            var text = format.reduce(function (text, format) {\n                return text + '<' + format + '>';\n            }, '');\n            this[this.mode_](pts, text);\n        }; // Adds HTML closing tags for current formatting to caption text and\n        // clears remembered formatting\n\n        Cea608Stream.prototype.clearFormatting = function (pts) {\n            if (!this.formatting_.length) {\n                return;\n            }\n            var text = this.formatting_.reverse().reduce(function (text, format) {\n                return text + '</' + format + '>';\n            }, '');\n            this.formatting_ = [];\n            this[this.mode_](pts, text);\n        }; // Mode Implementations\n\n        Cea608Stream.prototype.popOn = function (pts, text) {\n            var baseRow = this.nonDisplayed_[this.row_].text; // buffer characters\n\n            baseRow += text;\n            this.nonDisplayed_[this.row_].text = baseRow;\n        };\n        Cea608Stream.prototype.rollUp = function (pts, text) {\n            var baseRow = this.displayed_[this.row_].text;\n            baseRow += text;\n            this.displayed_[this.row_].text = baseRow;\n        };\n        Cea608Stream.prototype.shiftRowsUp_ = function () {\n            var i; // clear out inactive rows\n\n            for (i = 0; i < this.topRow_; i++) {\n                this.displayed_[i] = {\n                    text: '',\n                    indent: 0,\n                    offset: 0\n                };\n            }\n            for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n                this.displayed_[i] = {\n                    text: '',\n                    indent: 0,\n                    offset: 0\n                };\n            } // shift displayed rows up\n\n            for (i = this.topRow_; i < this.row_; i++) {\n                this.displayed_[i] = this.displayed_[i + 1];\n            } // clear out the bottom row\n\n            this.displayed_[this.row_] = {\n                text: '',\n                indent: 0,\n                offset: 0\n            };\n        };\n        Cea608Stream.prototype.paintOn = function (pts, text) {\n            var baseRow = this.displayed_[this.row_].text;\n            baseRow += text;\n            this.displayed_[this.row_].text = baseRow;\n        }; // exports\n\n        var captionStream = {\n            CaptionStream: CaptionStream$2,\n            Cea608Stream: Cea608Stream,\n            Cea708Stream: Cea708Stream\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var streamTypes = {\n            H264_STREAM_TYPE: 0x1B,\n            ADTS_STREAM_TYPE: 0x0F,\n            METADATA_STREAM_TYPE: 0x15\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Accepts program elementary stream (PES) data events and corrects\n         * decode and presentation time stamps to account for a rollover\n         * of the 33 bit value.\n         */\n\n        var Stream$6 = stream;\n        var MAX_TS = 8589934592;\n        var RO_THRESH = 4294967296;\n        var TYPE_SHARED = 'shared';\n        var handleRollover$1 = function (value, reference) {\n            var direction = 1;\n            if (value > reference) {\n                // If the current timestamp value is greater than our reference timestamp and we detect a\n                // timestamp rollover, this means the roll over is happening in the opposite direction.\n                // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n                // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n                // rollover point. In loading this segment, the timestamp values will be very large,\n                // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n                // the time stamp to be `value - 2^33`.\n                direction = -1;\n            } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n            // cause an incorrect adjustment.\n\n            while (Math.abs(reference - value) > RO_THRESH) {\n                value += direction * MAX_TS;\n            }\n            return value;\n        };\n        var TimestampRolloverStream$1 = function (type) {\n            var lastDTS, referenceDTS;\n            TimestampRolloverStream$1.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n            // video and audio. We could use `undefined` here, but having a string\n            // makes debugging a little clearer.\n\n            this.type_ = type || TYPE_SHARED;\n            this.push = function (data) {\n                /**\n                 * Rollover stream expects data from elementary stream.\n                 * Elementary stream can push forward 2 types of data\n                 * - Parsed Video/Audio/Timed-metadata PES (packetized elementary stream) packets\n                 * - Tracks metadata from PMT (Program Map Table)\n                 * Rollover stream expects pts/dts info to be available, since it stores lastDTS\n                 * We should ignore non-PES packets since they may override lastDTS to undefined.\n                 * lastDTS is important to signal the next segments\n                 * about rollover from the previous segments.\n                 */\n                if (data.type === 'metadata') {\n                    this.trigger('data', data);\n                    return;\n                } // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n                // streams will only accept data that matches their type.\n\n                if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n                    return;\n                }\n                if (referenceDTS === undefined) {\n                    referenceDTS = data.dts;\n                }\n                data.dts = handleRollover$1(data.dts, referenceDTS);\n                data.pts = handleRollover$1(data.pts, referenceDTS);\n                lastDTS = data.dts;\n                this.trigger('data', data);\n            };\n            this.flush = function () {\n                referenceDTS = lastDTS;\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n            this.discontinuity = function () {\n                referenceDTS = void 0;\n                lastDTS = void 0;\n            };\n            this.reset = function () {\n                this.discontinuity();\n                this.trigger('reset');\n            };\n        };\n        TimestampRolloverStream$1.prototype = new Stream$6();\n        var timestampRolloverStream = {\n            TimestampRolloverStream: TimestampRolloverStream$1,\n            handleRollover: handleRollover$1\n        }; // Once IE11 support is dropped, this function should be removed.\n\n        var typedArrayIndexOf$1 = (typedArray, element, fromIndex) => {\n            if (!typedArray) {\n                return -1;\n            }\n            var currentIndex = fromIndex;\n            for (; currentIndex < typedArray.length; currentIndex++) {\n                if (typedArray[currentIndex] === element) {\n                    return currentIndex;\n                }\n            }\n            return -1;\n        };\n        var typedArray = {\n            typedArrayIndexOf: typedArrayIndexOf$1\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Tools for parsing ID3 frame data\n         * @see http://id3.org/id3v2.3.0\n         */\n\n        var typedArrayIndexOf = typedArray.typedArrayIndexOf,\n            // Frames that allow different types of text encoding contain a text\n            // encoding description byte [ID3v2.4.0 section 4.]\n            textEncodingDescriptionByte = {\n                Iso88591: 0x00,\n                // ISO-8859-1, terminated with \\0.\n                Utf16: 0x01,\n                // UTF-16 encoded Unicode BOM, terminated with \\0\\0\n                Utf16be: 0x02,\n                // UTF-16BE encoded Unicode, without BOM, terminated with \\0\\0\n                Utf8: 0x03 // UTF-8 encoded Unicode, terminated with \\0\n            },\n            // return a percent-encoded representation of the specified byte range\n            // @see http://en.wikipedia.org/wiki/Percent-encoding\n            percentEncode$1 = function (bytes, start, end) {\n                var i,\n                    result = '';\n                for (i = start; i < end; i++) {\n                    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n                }\n                return result;\n            },\n            // return the string representation of the specified byte range,\n            // interpreted as UTf-8.\n            parseUtf8 = function (bytes, start, end) {\n                return decodeURIComponent(percentEncode$1(bytes, start, end));\n            },\n            // return the string representation of the specified byte range,\n            // interpreted as ISO-8859-1.\n            parseIso88591$1 = function (bytes, start, end) {\n                return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n            },\n            parseSyncSafeInteger$1 = function (data) {\n                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n            },\n            frameParsers = {\n                'APIC': function (frame) {\n                    var i = 1,\n                        mimeTypeEndIndex,\n                        descriptionEndIndex,\n                        LINK_MIME_TYPE = '-->';\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    } // parsing fields [ID3v2.4.0 section 4.14.]\n\n                    mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);\n                    if (mimeTypeEndIndex < 0) {\n                        // malformed frame\n                        return;\n                    } // parsing Mime type field (terminated with \\0)\n\n                    frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);\n                    i = mimeTypeEndIndex + 1; // parsing 1-byte Picture Type field\n\n                    frame.pictureType = frame.data[i];\n                    i++;\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);\n                    if (descriptionEndIndex < 0) {\n                        // malformed frame\n                        return;\n                    } // parsing Description field (terminated with \\0)\n\n                    frame.description = parseUtf8(frame.data, i, descriptionEndIndex);\n                    i = descriptionEndIndex + 1;\n                    if (frame.mimeType === LINK_MIME_TYPE) {\n                        // parsing Picture Data field as URL (always represented as ISO-8859-1 [ID3v2.4.0 section 4.])\n                        frame.url = parseIso88591$1(frame.data, i, frame.data.length);\n                    } else {\n                        // parsing Picture Data field as binary data\n                        frame.pictureData = frame.data.subarray(i, frame.data.length);\n                    }\n                },\n                'T*': function (frame) {\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    } // parse text field, do not include null terminator in the frame value\n                    // frames that allow different types of encoding contain terminated text [ID3v2.4.0 section 4.]\n\n                    frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\\0*$/, ''); // text information frames supports multiple strings, stored as a terminator separated list [ID3v2.4.0 section 4.2.]\n\n                    frame.values = frame.value.split('\\0');\n                },\n                'TXXX': function (frame) {\n                    var descriptionEndIndex;\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    }\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n                    if (descriptionEndIndex === -1) {\n                        return;\n                    } // parse the text fields\n\n                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // do not include the null terminator in the tag value\n                    // frames that allow different types of encoding contain terminated text\n                    // [ID3v2.4.0 section 4.]\n\n                    frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0*$/, '');\n                    frame.data = frame.value;\n                },\n                'W*': function (frame) {\n                    // parse URL field; URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n                    // if the value is followed by a string termination all the following information should be ignored [ID3v2.4.0 section 4.3]\n                    frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\\0.*$/, '');\n                },\n                'WXXX': function (frame) {\n                    var descriptionEndIndex;\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    }\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n                    if (descriptionEndIndex === -1) {\n                        return;\n                    } // parse the description and URL fields\n\n                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n                    // if the value is followed by a string termination all the following information\n                    // should be ignored [ID3v2.4.0 section 4.3]\n\n                    frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0.*$/, '');\n                },\n                'PRIV': function (frame) {\n                    var i;\n                    for (i = 0; i < frame.data.length; i++) {\n                        if (frame.data[i] === 0) {\n                            // parse the description and URL fields\n                            frame.owner = parseIso88591$1(frame.data, 0, i);\n                            break;\n                        }\n                    }\n                    frame.privateData = frame.data.subarray(i + 1);\n                    frame.data = frame.privateData;\n                }\n            };\n        var parseId3Frames$1 = function (data) {\n            var frameSize,\n                frameHeader,\n                frameStart = 10,\n                tagSize = 0,\n                frames = []; // If we don't have enough data for a header, 10 bytes,\n            // or 'ID3' in the first 3 bytes this is not a valid ID3 tag.\n\n            if (data.length < 10 || data[0] !== 'I'.charCodeAt(0) || data[1] !== 'D'.charCodeAt(0) || data[2] !== '3'.charCodeAt(0)) {\n                return;\n            } // the frame size is transmitted as a 28-bit integer in the\n            // last four bytes of the ID3 header.\n            // The most significant bit of each byte is dropped and the\n            // results concatenated to recover the actual value.\n\n            tagSize = parseSyncSafeInteger$1(data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n            // convenient for our comparisons to include it\n\n            tagSize += 10; // check bit 6 of byte 5 for the extended header flag.\n\n            var hasExtendedHeader = data[5] & 0x40;\n            if (hasExtendedHeader) {\n                // advance the frame start past the extended header\n                frameStart += 4; // header size field\n\n                frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));\n                tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20)); // clip any padding off the end\n            } // parse one or more ID3 frames\n            // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n            do {\n                // determine the number of bytes in this frame\n                frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));\n                if (frameSize < 1) {\n                    break;\n                }\n                frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);\n                var frame = {\n                    id: frameHeader,\n                    data: data.subarray(frameStart + 10, frameStart + frameSize + 10)\n                };\n                frame.key = frame.id; // parse frame values\n\n                if (frameParsers[frame.id]) {\n                    // use frame specific parser\n                    frameParsers[frame.id](frame);\n                } else if (frame.id[0] === 'T') {\n                    // use text frame generic parser\n                    frameParsers['T*'](frame);\n                } else if (frame.id[0] === 'W') {\n                    // use URL link frame generic parser\n                    frameParsers['W*'](frame);\n                }\n                frames.push(frame);\n                frameStart += 10; // advance past the frame header\n\n                frameStart += frameSize; // advance past the frame body\n            } while (frameStart < tagSize);\n            return frames;\n        };\n        var parseId3 = {\n            parseId3Frames: parseId3Frames$1,\n            parseSyncSafeInteger: parseSyncSafeInteger$1,\n            frameParsers: frameParsers\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Accepts program elementary stream (PES) data events and parses out\n         * ID3 metadata from them, if present.\n         * @see http://id3.org/id3v2.3.0\n         */\n\n        var Stream$5 = stream,\n            StreamTypes$3 = streamTypes,\n            id3 = parseId3,\n            MetadataStream;\n        MetadataStream = function (options) {\n            var settings = {\n                    // the bytes of the program-level descriptor field in MP2T\n                    // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n                    // program element descriptors\"\n                    descriptor: options && options.descriptor\n                },\n                // the total size in bytes of the ID3 tag being parsed\n                tagSize = 0,\n                // tag data that is not complete enough to be parsed\n                buffer = [],\n                // the total number of bytes currently in the buffer\n                bufferSize = 0,\n                i;\n            MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n            // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n            this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);\n            if (settings.descriptor) {\n                for (i = 0; i < settings.descriptor.length; i++) {\n                    this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n                }\n            }\n            this.push = function (chunk) {\n                var tag, frameStart, frameSize, frame, i, frameHeader;\n                if (chunk.type !== 'timed-metadata') {\n                    return;\n                } // if data_alignment_indicator is set in the PES header,\n                // we must have the start of a new ID3 tag. Assume anything\n                // remaining in the buffer was malformed and throw it out\n\n                if (chunk.dataAlignmentIndicator) {\n                    bufferSize = 0;\n                    buffer.length = 0;\n                } // ignore events that don't look like ID3 data\n\n                if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n                    this.trigger('log', {\n                        level: 'warn',\n                        message: 'Skipping unrecognized metadata packet'\n                    });\n                    return;\n                } // add this chunk to the data we've collected so far\n\n                buffer.push(chunk);\n                bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n                if (buffer.length === 1) {\n                    // the frame size is transmitted as a 28-bit integer in the\n                    // last four bytes of the ID3 header.\n                    // The most significant bit of each byte is dropped and the\n                    // results concatenated to recover the actual value.\n                    tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n                    // convenient for our comparisons to include it\n\n                    tagSize += 10;\n                } // if the entire frame has not arrived, wait for more data\n\n                if (bufferSize < tagSize) {\n                    return;\n                } // collect the entire frame so it can be parsed\n\n                tag = {\n                    data: new Uint8Array(tagSize),\n                    frames: [],\n                    pts: buffer[0].pts,\n                    dts: buffer[0].dts\n                };\n                for (i = 0; i < tagSize;) {\n                    tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n                    i += buffer[0].data.byteLength;\n                    bufferSize -= buffer[0].data.byteLength;\n                    buffer.shift();\n                } // find the start of the first frame and the end of the tag\n\n                frameStart = 10;\n                if (tag.data[5] & 0x40) {\n                    // advance the frame start past the extended header\n                    frameStart += 4; // header size field\n\n                    frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14)); // clip any padding off the end\n\n                    tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));\n                } // parse one or more ID3 frames\n                // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n                do {\n                    // determine the number of bytes in this frame\n                    frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n                    if (frameSize < 1) {\n                        this.trigger('log', {\n                            level: 'warn',\n                            message: 'Malformed ID3 frame encountered. Skipping remaining metadata parsing.'\n                        }); // If the frame is malformed, don't parse any further frames but allow previous valid parsed frames\n                        // to be sent along.\n\n                        break;\n                    }\n                    frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n                    frame = {\n                        id: frameHeader,\n                        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n                    };\n                    frame.key = frame.id; // parse frame values\n\n                    if (id3.frameParsers[frame.id]) {\n                        // use frame specific parser\n                        id3.frameParsers[frame.id](frame);\n                    } else if (frame.id[0] === 'T') {\n                        // use text frame generic parser\n                        id3.frameParsers['T*'](frame);\n                    } else if (frame.id[0] === 'W') {\n                        // use URL link frame generic parser\n                        id3.frameParsers['W*'](frame);\n                    } // handle the special PRIV frame used to indicate the start\n                    // time for raw AAC data\n\n                    if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n                        var d = frame.data,\n                            size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                        size *= 4;\n                        size += d[7] & 0x03;\n                        frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n                        // on the value of this frame\n                        // we couldn't have known the appropriate pts and dts before\n                        // parsing this ID3 tag so set those values now\n\n                        if (tag.pts === undefined && tag.dts === undefined) {\n                            tag.pts = frame.timeStamp;\n                            tag.dts = frame.timeStamp;\n                        }\n                        this.trigger('timestamp', frame);\n                    }\n                    tag.frames.push(frame);\n                    frameStart += 10; // advance past the frame header\n\n                    frameStart += frameSize; // advance past the frame body\n                } while (frameStart < tagSize);\n                this.trigger('data', tag);\n            };\n        };\n        MetadataStream.prototype = new Stream$5();\n        var metadataStream = MetadataStream;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based mp2t to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream$4 = stream,\n            CaptionStream$1 = captionStream,\n            StreamTypes$2 = streamTypes,\n            TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n        var TransportPacketStream, TransportParseStream, ElementaryStream; // constants\n\n        var MP2T_PACKET_LENGTH$1 = 188,\n            // bytes\n            SYNC_BYTE$1 = 0x47;\n        /**\n         * Splits an incoming stream of binary data into MPEG-2 Transport\n         * Stream packets.\n         */\n\n        TransportPacketStream = function () {\n            var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n                bytesInBuffer = 0;\n            TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n            /**\n             * Split a stream of data into M2TS packets\n             **/\n\n            this.push = function (bytes) {\n                var startIndex = 0,\n                    endIndex = MP2T_PACKET_LENGTH$1,\n                    everything; // If there are bytes remaining from the last segment, prepend them to the\n                // bytes that were pushed in\n\n                if (bytesInBuffer) {\n                    everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n                    everything.set(buffer.subarray(0, bytesInBuffer));\n                    everything.set(bytes, bytesInBuffer);\n                    bytesInBuffer = 0;\n                } else {\n                    everything = bytes;\n                } // While we have enough data for a packet\n\n                while (endIndex < everything.byteLength) {\n                    // Look for a pair of start and end sync bytes in the data..\n                    if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n                        // We found a packet so emit it and jump one whole packet forward in\n                        // the stream\n                        this.trigger('data', everything.subarray(startIndex, endIndex));\n                        startIndex += MP2T_PACKET_LENGTH$1;\n                        endIndex += MP2T_PACKET_LENGTH$1;\n                        continue;\n                    } // If we get here, we have somehow become de-synchronized and we need to step\n                    // forward one byte at a time until we find a pair of sync bytes that denote\n                    // a packet\n\n                    startIndex++;\n                    endIndex++;\n                } // If there was some data left over at the end of the segment that couldn't\n                // possibly be a whole packet, keep it because it might be the start of a packet\n                // that continues in the next segment\n\n                if (startIndex < everything.byteLength) {\n                    buffer.set(everything.subarray(startIndex), 0);\n                    bytesInBuffer = everything.byteLength - startIndex;\n                }\n            };\n            /**\n             * Passes identified M2TS packets to the TransportParseStream to be parsed\n             **/\n\n            this.flush = function () {\n                // If the buffer contains a whole packet when we are being flushed, emit it\n                // and empty the buffer. Otherwise hold onto the data because it may be\n                // important for decoding the next segment\n                if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n                    this.trigger('data', buffer);\n                    bytesInBuffer = 0;\n                }\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n            this.reset = function () {\n                bytesInBuffer = 0;\n                this.trigger('reset');\n            };\n        };\n        TransportPacketStream.prototype = new Stream$4();\n        /**\n         * Accepts an MP2T TransportPacketStream and emits data events with parsed\n         * forms of the individual transport stream packets.\n         */\n\n        TransportParseStream = function () {\n            var parsePsi, parsePat, parsePmt, self;\n            TransportParseStream.prototype.init.call(this);\n            self = this;\n            this.packetsWaitingForPmt = [];\n            this.programMapTable = undefined;\n            parsePsi = function (payload, psi) {\n                var offset = 0; // PSI packets may be split into multiple sections and those\n                // sections may be split into multiple packets. If a PSI\n                // section starts in this packet, the payload_unit_start_indicator\n                // will be true and the first byte of the payload will indicate\n                // the offset from the current position to the start of the\n                // section.\n\n                if (psi.payloadUnitStartIndicator) {\n                    offset += payload[offset] + 1;\n                }\n                if (psi.type === 'pat') {\n                    parsePat(payload.subarray(offset), psi);\n                } else {\n                    parsePmt(payload.subarray(offset), psi);\n                }\n            };\n            parsePat = function (payload, pat) {\n                pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n                pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n                // skip the PSI header and parse the first PMT entry\n\n                self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n                pat.pmtPid = self.pmtPid;\n            };\n            /**\n             * Parse out the relevant fields of a Program Map Table (PMT).\n             * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n             * packet. The first byte in this array should be the table_id\n             * field.\n             * @param pmt {object} the object that should be decorated with\n             * fields parsed from the PMT.\n             */\n\n            parsePmt = function (payload, pmt) {\n                var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n                // take effect. We don't believe this should ever be the case\n                // for HLS but we'll ignore \"forward\" PMT declarations if we see\n                // them. Future PMT declarations have the current_next_indicator\n                // set to zero.\n\n                if (!(payload[5] & 0x01)) {\n                    return;\n                } // overwrite any existing program map table\n\n                self.programMapTable = {\n                    video: null,\n                    audio: null,\n                    'timed-metadata': {}\n                }; // the mapping table ends at the end of the current section\n\n                sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n                tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n                // long the program info descriptors are\n\n                programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n                offset = 12 + programInfoLength;\n                while (offset < tableEnd) {\n                    var streamType = payload[offset];\n                    var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n                    // TODO: should this be done for metadata too? for now maintain behavior of\n                    //       multiple metadata streams\n\n                    if (streamType === StreamTypes$2.H264_STREAM_TYPE && self.programMapTable.video === null) {\n                        self.programMapTable.video = pid;\n                    } else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n                        self.programMapTable.audio = pid;\n                    } else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) {\n                        // map pid to stream type for metadata streams\n                        self.programMapTable['timed-metadata'][pid] = streamType;\n                    } // move to the next table entry\n                    // skip past the elementary stream descriptors, if present\n\n                    offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n                } // record the map on the packet as well\n\n                pmt.programMapTable = self.programMapTable;\n            };\n            /**\n             * Deliver a new MP2T packet to the next stream in the pipeline.\n             */\n\n            this.push = function (packet) {\n                var result = {},\n                    offset = 4;\n                result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n                result.pid = packet[1] & 0x1f;\n                result.pid <<= 8;\n                result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n                // fifth byte of the TS packet header. The adaptation field is\n                // used to add stuffing to PES packets that don't fill a complete\n                // TS packet, and to specify some forms of timing and control data\n                // that we do not currently use.\n\n                if ((packet[3] & 0x30) >>> 4 > 0x01) {\n                    offset += packet[offset] + 1;\n                } // parse the rest of the packet based on the type\n\n                if (result.pid === 0) {\n                    result.type = 'pat';\n                    parsePsi(packet.subarray(offset), result);\n                    this.trigger('data', result);\n                } else if (result.pid === this.pmtPid) {\n                    result.type = 'pmt';\n                    parsePsi(packet.subarray(offset), result);\n                    this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n                    while (this.packetsWaitingForPmt.length) {\n                        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n                    }\n                } else if (this.programMapTable === undefined) {\n                    // When we have not seen a PMT yet, defer further processing of\n                    // PES packets until one has been parsed\n                    this.packetsWaitingForPmt.push([packet, offset, result]);\n                } else {\n                    this.processPes_(packet, offset, result);\n                }\n            };\n            this.processPes_ = function (packet, offset, result) {\n                // set the appropriate stream type\n                if (result.pid === this.programMapTable.video) {\n                    result.streamType = StreamTypes$2.H264_STREAM_TYPE;\n                } else if (result.pid === this.programMapTable.audio) {\n                    result.streamType = StreamTypes$2.ADTS_STREAM_TYPE;\n                } else {\n                    // if not video or audio, it is timed-metadata or unknown\n                    // if unknown, streamType will be undefined\n                    result.streamType = this.programMapTable['timed-metadata'][result.pid];\n                }\n                result.type = 'pes';\n                result.data = packet.subarray(offset);\n                this.trigger('data', result);\n            };\n        };\n        TransportParseStream.prototype = new Stream$4();\n        TransportParseStream.STREAM_TYPES = {\n            h264: 0x1b,\n            adts: 0x0f\n        };\n        /**\n         * Reconsistutes program elementary stream (PES) packets from parsed\n         * transport stream packets. That is, if you pipe an\n         * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n         * events will be events which capture the bytes for individual PES\n         * packets plus relevant metadata that has been extracted from the\n         * container.\n         */\n\n        ElementaryStream = function () {\n            var self = this,\n                segmentHadPmt = false,\n                // PES packet fragments\n                video = {\n                    data: [],\n                    size: 0\n                },\n                audio = {\n                    data: [],\n                    size: 0\n                },\n                timedMetadata = {\n                    data: [],\n                    size: 0\n                },\n                programMapTable,\n                parsePes = function (payload, pes) {\n                    var ptsDtsFlags;\n                    const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n                    pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n                    // that are frame data that is continuing from the previous fragment. This\n                    // is to check that the pes data is the start of a new pes payload\n\n                    if (startPrefix !== 1) {\n                        return;\n                    } // get the packet length, this will be 0 for video\n\n                    pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n                    pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n                    // and a DTS value. Determine what combination of values is\n                    // available to work with.\n\n                    ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n                    // performs all bitwise operations on 32-bit integers but javascript\n                    // supports a much greater range (52-bits) of integer using standard\n                    // mathematical operations.\n                    // We construct a 31-bit value using bitwise operators over the 31\n                    // most significant bits and then multiply by 4 (equal to a left-shift\n                    // of 2) before we add the final 2 least significant bits of the\n                    // timestamp (equal to an OR.)\n\n                    if (ptsDtsFlags & 0xC0) {\n                        // the PTS and DTS are not written out directly. For information\n                        // on how they are encoded, see\n                        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n                        pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n                        pes.pts *= 4; // Left shift by 2\n\n                        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n                        pes.dts = pes.pts;\n                        if (ptsDtsFlags & 0x40) {\n                            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n                            pes.dts *= 4; // Left shift by 2\n\n                            pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n                        }\n                    } // the data section starts immediately after the PES header.\n                    // pes_header_data_length specifies the number of header bytes\n                    // that follow the last byte of the field.\n\n                    pes.data = payload.subarray(9 + payload[8]);\n                },\n                /**\n                 * Pass completely parsed PES packets to the next stream in the pipeline\n                 **/\n                flushStream = function (stream, type, forceFlush) {\n                    var packetData = new Uint8Array(stream.size),\n                        event = {\n                            type: type\n                        },\n                        i = 0,\n                        offset = 0,\n                        packetFlushable = false,\n                        fragment; // do nothing if there is not enough buffered data for a complete\n                    // PES header\n\n                    if (!stream.data.length || stream.size < 9) {\n                        return;\n                    }\n                    event.trackId = stream.data[0].pid; // reassemble the packet\n\n                    for (i = 0; i < stream.data.length; i++) {\n                        fragment = stream.data[i];\n                        packetData.set(fragment.data, offset);\n                        offset += fragment.data.byteLength;\n                    } // parse assembled packet's PES header\n\n                    parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n                    // check that there is enough stream data to fill the packet\n\n                    packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n                    if (forceFlush || packetFlushable) {\n                        stream.size = 0;\n                        stream.data.length = 0;\n                    } // only emit packets that are complete. this is to avoid assembling\n                    // incomplete PES packets due to poor segmentation\n\n                    if (packetFlushable) {\n                        self.trigger('data', event);\n                    }\n                };\n            ElementaryStream.prototype.init.call(this);\n            /**\n             * Identifies M2TS packet types and parses PES packets using metadata\n             * parsed from the PMT\n             **/\n\n            this.push = function (data) {\n                ({\n                    pat: function () {// we have to wait for the PMT to arrive as well before we\n                        // have any meaningful metadata\n                    },\n                    pes: function () {\n                        var stream, streamType;\n                        switch (data.streamType) {\n                            case StreamTypes$2.H264_STREAM_TYPE:\n                                stream = video;\n                                streamType = 'video';\n                                break;\n                            case StreamTypes$2.ADTS_STREAM_TYPE:\n                                stream = audio;\n                                streamType = 'audio';\n                                break;\n                            case StreamTypes$2.METADATA_STREAM_TYPE:\n                                stream = timedMetadata;\n                                streamType = 'timed-metadata';\n                                break;\n                            default:\n                                // ignore unknown stream types\n                                return;\n                        } // if a new packet is starting, we can flush the completed\n                        // packet\n\n                        if (data.payloadUnitStartIndicator) {\n                            flushStream(stream, streamType, true);\n                        } // buffer this fragment until we are sure we've received the\n                        // complete payload\n\n                        stream.data.push(data);\n                        stream.size += data.data.byteLength;\n                    },\n                    pmt: function () {\n                        var event = {\n                            type: 'metadata',\n                            tracks: []\n                        };\n                        programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n                        if (programMapTable.video !== null) {\n                            event.tracks.push({\n                                timelineStartInfo: {\n                                    baseMediaDecodeTime: 0\n                                },\n                                id: +programMapTable.video,\n                                codec: 'avc',\n                                type: 'video'\n                            });\n                        }\n                        if (programMapTable.audio !== null) {\n                            event.tracks.push({\n                                timelineStartInfo: {\n                                    baseMediaDecodeTime: 0\n                                },\n                                id: +programMapTable.audio,\n                                codec: 'adts',\n                                type: 'audio'\n                            });\n                        }\n                        segmentHadPmt = true;\n                        self.trigger('data', event);\n                    }\n                })[data.type]();\n            };\n            this.reset = function () {\n                video.size = 0;\n                video.data.length = 0;\n                audio.size = 0;\n                audio.data.length = 0;\n                this.trigger('reset');\n            };\n            /**\n             * Flush any remaining input. Video PES packets may be of variable\n             * length. Normally, the start of a new video packet can trigger the\n             * finalization of the previous packet. That is not possible if no\n             * more video is forthcoming, however. In that case, some other\n             * mechanism (like the end of the file) has to be employed. When it is\n             * clear that no additional data is forthcoming, calling this method\n             * will flush the buffered packets.\n             */\n\n            this.flushStreams_ = function () {\n                // !!THIS ORDER IS IMPORTANT!!\n                // video first then audio\n                flushStream(video, 'video');\n                flushStream(audio, 'audio');\n                flushStream(timedMetadata, 'timed-metadata');\n            };\n            this.flush = function () {\n                // if on flush we haven't had a pmt emitted\n                // and we have a pmt to emit. emit the pmt\n                // so that we trigger a trackinfo downstream.\n                if (!segmentHadPmt && programMapTable) {\n                    var pmt = {\n                        type: 'metadata',\n                        tracks: []\n                    }; // translate audio and video streams to tracks\n\n                    if (programMapTable.video !== null) {\n                        pmt.tracks.push({\n                            timelineStartInfo: {\n                                baseMediaDecodeTime: 0\n                            },\n                            id: +programMapTable.video,\n                            codec: 'avc',\n                            type: 'video'\n                        });\n                    }\n                    if (programMapTable.audio !== null) {\n                        pmt.tracks.push({\n                            timelineStartInfo: {\n                                baseMediaDecodeTime: 0\n                            },\n                            id: +programMapTable.audio,\n                            codec: 'adts',\n                            type: 'audio'\n                        });\n                    }\n                    self.trigger('data', pmt);\n                }\n                segmentHadPmt = false;\n                this.flushStreams_();\n                this.trigger('done');\n            };\n        };\n        ElementaryStream.prototype = new Stream$4();\n        var m2ts$1 = {\n            PAT_PID: 0x0000,\n            MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n            TransportPacketStream: TransportPacketStream,\n            TransportParseStream: TransportParseStream,\n            ElementaryStream: ElementaryStream,\n            TimestampRolloverStream: TimestampRolloverStream,\n            CaptionStream: CaptionStream$1.CaptionStream,\n            Cea608Stream: CaptionStream$1.Cea608Stream,\n            Cea708Stream: CaptionStream$1.Cea708Stream,\n            MetadataStream: metadataStream\n        };\n        for (var type in StreamTypes$2) {\n            if (StreamTypes$2.hasOwnProperty(type)) {\n                m2ts$1[type] = StreamTypes$2[type];\n            }\n        }\n        var m2ts_1 = m2ts$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var Stream$3 = stream;\n        var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;\n        var AdtsStream$1;\n        var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n        /*\n     * Accepts a ElementaryStream and emits data events with parsed\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\n     * format is unpacked and re-emitted as AAC frames.\n     *\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n     */\n\n        AdtsStream$1 = function (handlePartialSegments) {\n            var buffer,\n                frameNum = 0;\n            AdtsStream$1.prototype.init.call(this);\n            this.skipWarn_ = function (start, end) {\n                this.trigger('log', {\n                    level: 'warn',\n                    message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`\n                });\n            };\n            this.push = function (packet) {\n                var i = 0,\n                    frameLength,\n                    protectionSkipBytes,\n                    oldBuffer,\n                    sampleCount,\n                    adtsFrameDuration;\n                if (!handlePartialSegments) {\n                    frameNum = 0;\n                }\n                if (packet.type !== 'audio') {\n                    // ignore non-audio data\n                    return;\n                } // Prepend any data in the buffer to the input data so that we can parse\n                // aac frames the cross a PES packet boundary\n\n                if (buffer && buffer.length) {\n                    oldBuffer = buffer;\n                    buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n                    buffer.set(oldBuffer);\n                    buffer.set(packet.data, oldBuffer.byteLength);\n                } else {\n                    buffer = packet.data;\n                } // unpack any ADTS frames which have been fully received\n                // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n                var skip; // We use i + 7 here because we want to be able to parse the entire header.\n                // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n                while (i + 7 < buffer.length) {\n                    // Look for the start of an ADTS header..\n                    if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n                        if (typeof skip !== 'number') {\n                            skip = i;\n                        } // If a valid header was not found,  jump one forward and attempt to\n                        // find a valid ADTS header starting at the next byte\n\n                        i++;\n                        continue;\n                    }\n                    if (typeof skip === 'number') {\n                        this.skipWarn_(skip, i);\n                        skip = null;\n                    } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n                    // end of the ADTS header\n\n                    protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n                    // end of the sync sequence\n                    // NOTE: frame length includes the size of the header\n\n                    frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n                    sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n                    adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n                    // then we have to wait for more data\n\n                    if (buffer.byteLength - i < frameLength) {\n                        break;\n                    } // Otherwise, deliver the complete AAC frame\n\n                    this.trigger('data', {\n                        pts: packet.pts + frameNum * adtsFrameDuration,\n                        dts: packet.dts + frameNum * adtsFrameDuration,\n                        sampleCount: sampleCount,\n                        audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n                        channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n                        samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n                        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n                        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n                        samplesize: 16,\n                        // data is the frame without it's header\n                        data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n                    });\n                    frameNum++;\n                    i += frameLength;\n                }\n                if (typeof skip === 'number') {\n                    this.skipWarn_(skip, i);\n                    skip = null;\n                } // remove processed bytes from the buffer.\n\n                buffer = buffer.subarray(i);\n            };\n            this.flush = function () {\n                frameNum = 0;\n                this.trigger('done');\n            };\n            this.reset = function () {\n                buffer = void 0;\n                this.trigger('reset');\n            };\n            this.endTimeline = function () {\n                buffer = void 0;\n                this.trigger('endedtimeline');\n            };\n        };\n        AdtsStream$1.prototype = new Stream$3();\n        var adts = AdtsStream$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ExpGolomb$1;\n        /**\n         * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n         * scheme used by h264.\n         */\n\n        ExpGolomb$1 = function (workingData) {\n            var\n                // the number of bytes left to examine in workingData\n                workingBytesAvailable = workingData.byteLength,\n                // the current word being examined\n                workingWord = 0,\n                // :uint\n                // the number of bits left to examine in the current word\n                workingBitsAvailable = 0; // :uint;\n            // ():uint\n\n            this.length = function () {\n                return 8 * workingBytesAvailable;\n            }; // ():uint\n\n            this.bitsAvailable = function () {\n                return 8 * workingBytesAvailable + workingBitsAvailable;\n            }; // ():void\n\n            this.loadWord = function () {\n                var position = workingData.byteLength - workingBytesAvailable,\n                    workingBytes = new Uint8Array(4),\n                    availableBytes = Math.min(4, workingBytesAvailable);\n                if (availableBytes === 0) {\n                    throw new Error('no bytes available');\n                }\n                workingBytes.set(workingData.subarray(position, position + availableBytes));\n                workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n                workingBitsAvailable = availableBytes * 8;\n                workingBytesAvailable -= availableBytes;\n            }; // (count:int):void\n\n            this.skipBits = function (count) {\n                var skipBytes; // :int\n\n                if (workingBitsAvailable > count) {\n                    workingWord <<= count;\n                    workingBitsAvailable -= count;\n                } else {\n                    count -= workingBitsAvailable;\n                    skipBytes = Math.floor(count / 8);\n                    count -= skipBytes * 8;\n                    workingBytesAvailable -= skipBytes;\n                    this.loadWord();\n                    workingWord <<= count;\n                    workingBitsAvailable -= count;\n                }\n            }; // (size:int):uint\n\n            this.readBits = function (size) {\n                var bits = Math.min(workingBitsAvailable, size),\n                    // :uint\n                    valu = workingWord >>> 32 - bits; // :uint\n                // if size > 31, handle error\n\n                workingBitsAvailable -= bits;\n                if (workingBitsAvailable > 0) {\n                    workingWord <<= bits;\n                } else if (workingBytesAvailable > 0) {\n                    this.loadWord();\n                }\n                bits = size - bits;\n                if (bits > 0) {\n                    return valu << bits | this.readBits(bits);\n                }\n                return valu;\n            }; // ():uint\n\n            this.skipLeadingZeros = function () {\n                var leadingZeroCount; // :uint\n\n                for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n                    if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n                        // the first bit of working word is 1\n                        workingWord <<= leadingZeroCount;\n                        workingBitsAvailable -= leadingZeroCount;\n                        return leadingZeroCount;\n                    }\n                } // we exhausted workingWord and still have not found a 1\n\n                this.loadWord();\n                return leadingZeroCount + this.skipLeadingZeros();\n            }; // ():void\n\n            this.skipUnsignedExpGolomb = function () {\n                this.skipBits(1 + this.skipLeadingZeros());\n            }; // ():void\n\n            this.skipExpGolomb = function () {\n                this.skipBits(1 + this.skipLeadingZeros());\n            }; // ():uint\n\n            this.readUnsignedExpGolomb = function () {\n                var clz = this.skipLeadingZeros(); // :uint\n\n                return this.readBits(clz + 1) - 1;\n            }; // ():int\n\n            this.readExpGolomb = function () {\n                var valu = this.readUnsignedExpGolomb(); // :int\n\n                if (0x01 & valu) {\n                    // the number is odd if the low order bit is set\n                    return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n                }\n\n                return -1 * (valu >>> 1); // divide by two then make it negative\n            }; // Some convenience functions\n            // :Boolean\n\n            this.readBoolean = function () {\n                return this.readBits(1) === 1;\n            }; // ():int\n\n            this.readUnsignedByte = function () {\n                return this.readBits(8);\n            };\n            this.loadWord();\n        };\n        var expGolomb = ExpGolomb$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var Stream$2 = stream;\n        var ExpGolomb = expGolomb;\n        var H264Stream$1, NalByteStream;\n        var PROFILES_WITH_OPTIONAL_SPS_DATA;\n        /**\n         * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n         */\n\n        NalByteStream = function () {\n            var syncPoint = 0,\n                i,\n                buffer;\n            NalByteStream.prototype.init.call(this);\n            /*\n       * Scans a byte stream and triggers a data event with the NAL units found.\n       * @param {Object} data Event received from H264Stream\n       * @param {Uint8Array} data.data The h264 byte stream to be scanned\n       *\n       * @see H264Stream.push\n       */\n\n            this.push = function (data) {\n                var swapBuffer;\n                if (!buffer) {\n                    buffer = data.data;\n                } else {\n                    swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n                    swapBuffer.set(buffer);\n                    swapBuffer.set(data.data, buffer.byteLength);\n                    buffer = swapBuffer;\n                }\n                var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n                // scan for NAL unit boundaries\n                // a match looks like this:\n                // 0 0 1 .. NAL .. 0 0 1\n                // ^ sync point        ^ i\n                // or this:\n                // 0 0 1 .. NAL .. 0 0 0\n                // ^ sync point        ^ i\n                // advance the sync point to a NAL start, if necessary\n\n                for (; syncPoint < len - 3; syncPoint++) {\n                    if (buffer[syncPoint + 2] === 1) {\n                        // the sync point is properly aligned\n                        i = syncPoint + 5;\n                        break;\n                    }\n                }\n                while (i < len) {\n                    // look at the current byte to determine if we've hit the end of\n                    // a NAL unit boundary\n                    switch (buffer[i]) {\n                        case 0:\n                            // skip past non-sync sequences\n                            if (buffer[i - 1] !== 0) {\n                                i += 2;\n                                break;\n                            } else if (buffer[i - 2] !== 0) {\n                                i++;\n                                break;\n                            } // deliver the NAL unit if it isn't empty\n\n                            if (syncPoint + 3 !== i - 2) {\n                                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n                            } // drop trailing zeroes\n\n                            do {\n                                i++;\n                            } while (buffer[i] !== 1 && i < len);\n                            syncPoint = i - 2;\n                            i += 3;\n                            break;\n                        case 1:\n                            // skip past non-sync sequences\n                            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n                                i += 3;\n                                break;\n                            } // deliver the NAL unit\n\n                            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n                            syncPoint = i - 2;\n                            i += 3;\n                            break;\n                        default:\n                            // the current byte isn't a one or zero, so it cannot be part\n                            // of a sync sequence\n                            i += 3;\n                            break;\n                    }\n                } // filter out the NAL units that were delivered\n\n                buffer = buffer.subarray(syncPoint);\n                i -= syncPoint;\n                syncPoint = 0;\n            };\n            this.reset = function () {\n                buffer = null;\n                syncPoint = 0;\n                this.trigger('reset');\n            };\n            this.flush = function () {\n                // deliver the last buffered NAL unit\n                if (buffer && buffer.byteLength > 3) {\n                    this.trigger('data', buffer.subarray(syncPoint + 3));\n                } // reset the stream state\n\n                buffer = null;\n                syncPoint = 0;\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n        };\n        NalByteStream.prototype = new Stream$2(); // values of profile_idc that indicate additional fields are included in the SPS\n        // see Recommendation ITU-T H.264 (4/2013),\n        // 7.3.2.1.1 Sequence parameter set data syntax\n\n        PROFILES_WITH_OPTIONAL_SPS_DATA = {\n            100: true,\n            110: true,\n            122: true,\n            244: true,\n            44: true,\n            83: true,\n            86: true,\n            118: true,\n            128: true,\n            // TODO: the three profiles below don't\n            // appear to have sps data in the specificiation anymore?\n            138: true,\n            139: true,\n            134: true\n        };\n        /**\n         * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n         * events.\n         */\n\n        H264Stream$1 = function () {\n            var nalByteStream = new NalByteStream(),\n                self,\n                trackId,\n                currentPts,\n                currentDts,\n                discardEmulationPreventionBytes,\n                readSequenceParameterSet,\n                skipScalingList;\n            H264Stream$1.prototype.init.call(this);\n            self = this;\n            /*\n       * Pushes a packet from a stream onto the NalByteStream\n       *\n       * @param {Object} packet - A packet received from a stream\n       * @param {Uint8Array} packet.data - The raw bytes of the packet\n       * @param {Number} packet.dts - Decode timestamp of the packet\n       * @param {Number} packet.pts - Presentation timestamp of the packet\n       * @param {Number} packet.trackId - The id of the h264 track this packet came from\n       * @param {('video'|'audio')} packet.type - The type of packet\n       *\n       */\n\n            this.push = function (packet) {\n                if (packet.type !== 'video') {\n                    return;\n                }\n                trackId = packet.trackId;\n                currentPts = packet.pts;\n                currentDts = packet.dts;\n                nalByteStream.push(packet);\n            };\n            /*\n       * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n       * for the NALUs to the next stream component.\n       * Also, preprocess caption and sequence parameter NALUs.\n       *\n       * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n       * @see NalByteStream.push\n       */\n\n            nalByteStream.on('data', function (data) {\n                var event = {\n                    trackId: trackId,\n                    pts: currentPts,\n                    dts: currentDts,\n                    data: data,\n                    nalUnitTypeCode: data[0] & 0x1f\n                };\n                switch (event.nalUnitTypeCode) {\n                    case 0x05:\n                        event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n                        break;\n                    case 0x06:\n                        event.nalUnitType = 'sei_rbsp';\n                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n                        break;\n                    case 0x07:\n                        event.nalUnitType = 'seq_parameter_set_rbsp';\n                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n                        event.config = readSequenceParameterSet(event.escapedRBSP);\n                        break;\n                    case 0x08:\n                        event.nalUnitType = 'pic_parameter_set_rbsp';\n                        break;\n                    case 0x09:\n                        event.nalUnitType = 'access_unit_delimiter_rbsp';\n                        break;\n                } // This triggers data on the H264Stream\n\n                self.trigger('data', event);\n            });\n            nalByteStream.on('done', function () {\n                self.trigger('done');\n            });\n            nalByteStream.on('partialdone', function () {\n                self.trigger('partialdone');\n            });\n            nalByteStream.on('reset', function () {\n                self.trigger('reset');\n            });\n            nalByteStream.on('endedtimeline', function () {\n                self.trigger('endedtimeline');\n            });\n            this.flush = function () {\n                nalByteStream.flush();\n            };\n            this.partialFlush = function () {\n                nalByteStream.partialFlush();\n            };\n            this.reset = function () {\n                nalByteStream.reset();\n            };\n            this.endTimeline = function () {\n                nalByteStream.endTimeline();\n            };\n            /**\n             * Advance the ExpGolomb decoder past a scaling list. The scaling\n             * list is optionally transmitted as part of a sequence parameter\n             * set and is not relevant to transmuxing.\n             * @param count {number} the number of entries in this scaling list\n             * @param expGolombDecoder {object} an ExpGolomb pointed to the\n             * start of a scaling list\n             * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n             */\n\n            skipScalingList = function (count, expGolombDecoder) {\n                var lastScale = 8,\n                    nextScale = 8,\n                    j,\n                    deltaScale;\n                for (j = 0; j < count; j++) {\n                    if (nextScale !== 0) {\n                        deltaScale = expGolombDecoder.readExpGolomb();\n                        nextScale = (lastScale + deltaScale + 256) % 256;\n                    }\n                    lastScale = nextScale === 0 ? lastScale : nextScale;\n                }\n            };\n            /**\n             * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n             * Sequence Payload\"\n             * @param data {Uint8Array} the bytes of a RBSP from a NAL\n             * unit\n             * @return {Uint8Array} the RBSP without any Emulation\n             * Prevention Bytes\n             */\n\n            discardEmulationPreventionBytes = function (data) {\n                var length = data.byteLength,\n                    emulationPreventionBytesPositions = [],\n                    i = 1,\n                    newLength,\n                    newData; // Find all `Emulation Prevention Bytes`\n\n                while (i < length - 2) {\n                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n                        emulationPreventionBytesPositions.push(i + 2);\n                        i += 2;\n                    } else {\n                        i++;\n                    }\n                } // If no Emulation Prevention Bytes were found just return the original\n                // array\n\n                if (emulationPreventionBytesPositions.length === 0) {\n                    return data;\n                } // Create a new array to hold the NAL unit data\n\n                newLength = length - emulationPreventionBytesPositions.length;\n                newData = new Uint8Array(newLength);\n                var sourceIndex = 0;\n                for (i = 0; i < newLength; sourceIndex++, i++) {\n                    if (sourceIndex === emulationPreventionBytesPositions[0]) {\n                        // Skip this byte\n                        sourceIndex++; // Remove this position index\n\n                        emulationPreventionBytesPositions.shift();\n                    }\n                    newData[i] = data[sourceIndex];\n                }\n                return newData;\n            };\n            /**\n             * Read a sequence parameter set and return some interesting video\n             * properties. A sequence parameter set is the H264 metadata that\n             * describes the properties of upcoming video frames.\n             * @param data {Uint8Array} the bytes of a sequence parameter set\n             * @return {object} an object with configuration parsed from the\n             * sequence parameter set, including the dimensions of the\n             * associated video frames.\n             */\n\n            readSequenceParameterSet = function (data) {\n                var frameCropLeftOffset = 0,\n                    frameCropRightOffset = 0,\n                    frameCropTopOffset = 0,\n                    frameCropBottomOffset = 0,\n                    expGolombDecoder,\n                    profileIdc,\n                    levelIdc,\n                    profileCompatibility,\n                    chromaFormatIdc,\n                    picOrderCntType,\n                    numRefFramesInPicOrderCntCycle,\n                    picWidthInMbsMinus1,\n                    picHeightInMapUnitsMinus1,\n                    frameMbsOnlyFlag,\n                    scalingListCount,\n                    sarRatio = [1, 1],\n                    aspectRatioIdc,\n                    i;\n                expGolombDecoder = new ExpGolomb(data);\n                profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n                profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n                levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n                expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n                // some profiles have more optional data we don't need\n\n                if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n                    chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n                    if (chromaFormatIdc === 3) {\n                        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n                    }\n\n                    expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n                    expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n                    expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n                    if (expGolombDecoder.readBoolean()) {\n                        // seq_scaling_matrix_present_flag\n                        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n                        for (i = 0; i < scalingListCount; i++) {\n                            if (expGolombDecoder.readBoolean()) {\n                                // seq_scaling_list_present_flag[ i ]\n                                if (i < 6) {\n                                    skipScalingList(16, expGolombDecoder);\n                                } else {\n                                    skipScalingList(64, expGolombDecoder);\n                                }\n                            }\n                        }\n                    }\n                }\n                expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n                picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n                if (picOrderCntType === 0) {\n                    expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n                } else if (picOrderCntType === 1) {\n                    expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n                    expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n                    expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n                    numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n                    for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n                    }\n                }\n\n                expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n                expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n                picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n                picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n                frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n                if (frameMbsOnlyFlag === 0) {\n                    expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n                }\n\n                expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n                if (expGolombDecoder.readBoolean()) {\n                    // frame_cropping_flag\n                    frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n                }\n                if (expGolombDecoder.readBoolean()) {\n                    // vui_parameters_present_flag\n                    if (expGolombDecoder.readBoolean()) {\n                        // aspect_ratio_info_present_flag\n                        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n                        switch (aspectRatioIdc) {\n                            case 1:\n                                sarRatio = [1, 1];\n                                break;\n                            case 2:\n                                sarRatio = [12, 11];\n                                break;\n                            case 3:\n                                sarRatio = [10, 11];\n                                break;\n                            case 4:\n                                sarRatio = [16, 11];\n                                break;\n                            case 5:\n                                sarRatio = [40, 33];\n                                break;\n                            case 6:\n                                sarRatio = [24, 11];\n                                break;\n                            case 7:\n                                sarRatio = [20, 11];\n                                break;\n                            case 8:\n                                sarRatio = [32, 11];\n                                break;\n                            case 9:\n                                sarRatio = [80, 33];\n                                break;\n                            case 10:\n                                sarRatio = [18, 11];\n                                break;\n                            case 11:\n                                sarRatio = [15, 11];\n                                break;\n                            case 12:\n                                sarRatio = [64, 33];\n                                break;\n                            case 13:\n                                sarRatio = [160, 99];\n                                break;\n                            case 14:\n                                sarRatio = [4, 3];\n                                break;\n                            case 15:\n                                sarRatio = [3, 2];\n                                break;\n                            case 16:\n                                sarRatio = [2, 1];\n                                break;\n                            case 255:\n                            {\n                                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                                break;\n                            }\n                        }\n                        if (sarRatio) {\n                            sarRatio[0] / sarRatio[1];\n                        }\n                    }\n                }\n                return {\n                    profileIdc: profileIdc,\n                    levelIdc: levelIdc,\n                    profileCompatibility: profileCompatibility,\n                    width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n                    height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n                    // sar is sample aspect ratio\n                    sarRatio: sarRatio\n                };\n            };\n        };\n        H264Stream$1.prototype = new Stream$2();\n        var h264 = {\n            H264Stream: H264Stream$1,\n            NalByteStream: NalByteStream\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about Aac data.\n         */\n\n        var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n        var parseId3TagSize = function (header, byteIndex) {\n            var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n                flags = header[byteIndex + 5],\n                footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n            returnSize = returnSize >= 0 ? returnSize : 0;\n            if (footerPresent) {\n                return returnSize + 20;\n            }\n            return returnSize + 10;\n        };\n        var getId3Offset = function (data, offset) {\n            if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n                return offset;\n            }\n            offset += parseId3TagSize(data, offset);\n            return getId3Offset(data, offset);\n        }; // TODO: use vhs-utils\n\n        var isLikelyAacData$1 = function (data) {\n            var offset = getId3Offset(data, 0);\n            return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 &&\n                // verify that the 2 layer bits are 0, aka this\n                // is not mp3 data but aac data.\n                (data[offset + 1] & 0x16) === 0x10;\n        };\n        var parseSyncSafeInteger = function (data) {\n            return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n        }; // return a percent-encoded representation of the specified byte range\n        // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n        var percentEncode = function (bytes, start, end) {\n            var i,\n                result = '';\n            for (i = start; i < end; i++) {\n                result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n            }\n            return result;\n        }; // return the string representation of the specified byte range,\n        // interpreted as ISO-8859-1.\n\n        var parseIso88591 = function (bytes, start, end) {\n            return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n        };\n\n        var parseAdtsSize = function (header, byteIndex) {\n            var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n                middle = header[byteIndex + 4] << 3,\n                highTwo = header[byteIndex + 3] & 0x3 << 11;\n            return highTwo | middle | lowThree;\n        };\n        var parseType$4 = function (header, byteIndex) {\n            if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n                return 'timed-metadata';\n            } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n                return 'audio';\n            }\n            return null;\n        };\n        var parseSampleRate = function (packet) {\n            var i = 0;\n            while (i + 5 < packet.length) {\n                if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n                    // If a valid header was not found,  jump one forward and attempt to\n                    // find a valid ADTS header starting at the next byte\n                    i++;\n                    continue;\n                }\n                return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n            }\n            return null;\n        };\n        var parseAacTimestamp = function (packet) {\n            var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n            frameStart = 10;\n            if (packet[5] & 0x40) {\n                // advance the frame start past the extended header\n                frameStart += 4; // header size field\n\n                frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n            } // parse one or more ID3 frames\n            // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n            do {\n                // determine the number of bytes in this frame\n                frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n                if (frameSize < 1) {\n                    return null;\n                }\n                frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n                if (frameHeader === 'PRIV') {\n                    frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n                    for (var i = 0; i < frame.byteLength; i++) {\n                        if (frame[i] === 0) {\n                            var owner = parseIso88591(frame, 0, i);\n                            if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n                                var d = frame.subarray(i + 1);\n                                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                                size *= 4;\n                                size += d[7] & 0x03;\n                                return size;\n                            }\n                            break;\n                        }\n                    }\n                }\n                frameStart += 10; // advance past the frame header\n\n                frameStart += frameSize; // advance past the frame body\n            } while (frameStart < packet.byteLength);\n            return null;\n        };\n        var utils = {\n            isLikelyAacData: isLikelyAacData$1,\n            parseId3TagSize: parseId3TagSize,\n            parseAdtsSize: parseAdtsSize,\n            parseType: parseType$4,\n            parseSampleRate: parseSampleRate,\n            parseAacTimestamp: parseAacTimestamp\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based aac to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream$1 = stream;\n        var aacUtils = utils; // Constants\n\n        var AacStream$1;\n        /**\n         * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n         */\n\n        AacStream$1 = function () {\n            var everything = new Uint8Array(),\n                timeStamp = 0;\n            AacStream$1.prototype.init.call(this);\n            this.setTimestamp = function (timestamp) {\n                timeStamp = timestamp;\n            };\n            this.push = function (bytes) {\n                var frameSize = 0,\n                    byteIndex = 0,\n                    bytesLeft,\n                    chunk,\n                    packet,\n                    tempLength; // If there are bytes remaining from the last segment, prepend them to the\n                // bytes that were pushed in\n\n                if (everything.length) {\n                    tempLength = everything.length;\n                    everything = new Uint8Array(bytes.byteLength + tempLength);\n                    everything.set(everything.subarray(0, tempLength));\n                    everything.set(bytes, tempLength);\n                } else {\n                    everything = bytes;\n                }\n                while (everything.length - byteIndex >= 3) {\n                    if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n                        // Exit early because we don't have enough to parse\n                        // the ID3 tag header\n                        if (everything.length - byteIndex < 10) {\n                            break;\n                        } // check framesize\n\n                        frameSize = aacUtils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n                        // Add to byteIndex to support multiple ID3 tags in sequence\n\n                        if (byteIndex + frameSize > everything.length) {\n                            break;\n                        }\n                        chunk = {\n                            type: 'timed-metadata',\n                            data: everything.subarray(byteIndex, byteIndex + frameSize)\n                        };\n                        this.trigger('data', chunk);\n                        byteIndex += frameSize;\n                        continue;\n                    } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n                        // Exit early because we don't have enough to parse\n                        // the ADTS frame header\n                        if (everything.length - byteIndex < 7) {\n                            break;\n                        }\n                        frameSize = aacUtils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (byteIndex + frameSize > everything.length) {\n                            break;\n                        }\n                        packet = {\n                            type: 'audio',\n                            data: everything.subarray(byteIndex, byteIndex + frameSize),\n                            pts: timeStamp,\n                            dts: timeStamp\n                        };\n                        this.trigger('data', packet);\n                        byteIndex += frameSize;\n                        continue;\n                    }\n                    byteIndex++;\n                }\n                bytesLeft = everything.length - byteIndex;\n                if (bytesLeft > 0) {\n                    everything = everything.subarray(byteIndex);\n                } else {\n                    everything = new Uint8Array();\n                }\n            };\n            this.reset = function () {\n                everything = new Uint8Array();\n                this.trigger('reset');\n            };\n            this.endTimeline = function () {\n                everything = new Uint8Array();\n                this.trigger('endedtimeline');\n            };\n        };\n        AacStream$1.prototype = new Stream$1();\n        var aac = AacStream$1;\n        var AUDIO_PROPERTIES$1 = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n        var audioProperties = AUDIO_PROPERTIES$1;\n        var VIDEO_PROPERTIES$1 = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n        var videoProperties = VIDEO_PROPERTIES$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based mp2t to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream = stream;\n        var mp4 = mp4Generator;\n        var frameUtils = frameUtils$1;\n        var audioFrameUtils = audioFrameUtils$1;\n        var trackDecodeInfo = trackDecodeInfo$1;\n        var m2ts = m2ts_1;\n        var clock = clock$2;\n        var AdtsStream = adts;\n        var H264Stream = h264.H264Stream;\n        var AacStream = aac;\n        var isLikelyAacData = utils.isLikelyAacData;\n        var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;\n        var AUDIO_PROPERTIES = audioProperties;\n        var VIDEO_PROPERTIES = videoProperties; // object types\n\n        var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n        var retriggerForStream = function (key, event) {\n            event.stream = key;\n            this.trigger('log', event);\n        };\n        var addPipelineLogRetriggers = function (transmuxer, pipeline) {\n            var keys = Object.keys(pipeline);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i]; // skip non-stream keys and headOfPipeline\n                // which is just a duplicate\n\n                if (key === 'headOfPipeline' || !pipeline[key].on) {\n                    continue;\n                }\n                pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n            }\n        };\n        /**\n         * Compare two arrays (even typed) for same-ness\n         */\n\n        var arrayEquals = function (a, b) {\n            var i;\n            if (a.length !== b.length) {\n                return false;\n            } // compare the value of each element in the array\n\n            for (i = 0; i < a.length; i++) {\n                if (a[i] !== b[i]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        var generateSegmentTimingInfo = function (baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n            var ptsOffsetFromDts = startPts - startDts,\n                decodeDuration = endDts - startDts,\n                presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n            // however, the player time values will reflect a start from the baseMediaDecodeTime.\n            // In order to provide relevant values for the player times, base timing info on the\n            // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n            return {\n                start: {\n                    dts: baseMediaDecodeTime,\n                    pts: baseMediaDecodeTime + ptsOffsetFromDts\n                },\n                end: {\n                    dts: baseMediaDecodeTime + decodeDuration,\n                    pts: baseMediaDecodeTime + presentationDuration\n                },\n                prependedContentDuration: prependedContentDuration,\n                baseMediaDecodeTime: baseMediaDecodeTime\n            };\n        };\n        /**\n         * Constructs a single-track, ISO BMFF media segment from AAC data\n         * events. The output of this stream can be fed to a SourceBuffer\n         * configured with a suitable initialization segment.\n         * @param track {object} track metadata configuration\n         * @param options {object} transmuxer options object\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        AudioSegmentStream = function (track, options) {\n            var adtsFrames = [],\n                sequenceNumber,\n                earliestAllowedDts = 0,\n                audioAppendStartTs = 0,\n                videoBaseMediaDecodeTime = Infinity;\n            options = options || {};\n            sequenceNumber = options.firstSequenceNumber || 0;\n            AudioSegmentStream.prototype.init.call(this);\n            this.push = function (data) {\n                trackDecodeInfo.collectDtsInfo(track, data);\n                if (track) {\n                    AUDIO_PROPERTIES.forEach(function (prop) {\n                        track[prop] = data[prop];\n                    });\n                } // buffer audio data until end() is called\n\n                adtsFrames.push(data);\n            };\n            this.setEarliestDts = function (earliestDts) {\n                earliestAllowedDts = earliestDts;\n            };\n            this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n                videoBaseMediaDecodeTime = baseMediaDecodeTime;\n            };\n            this.setAudioAppendStart = function (timestamp) {\n                audioAppendStartTs = timestamp;\n            };\n            this.flush = function () {\n                var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n                if (adtsFrames.length === 0) {\n                    this.trigger('done', 'AudioSegmentStream');\n                    return;\n                }\n                frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n                track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n                videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n                // samples (that is, adts frames) in the audio data\n\n                track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n                mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n                adtsFrames = [];\n                moof = mp4.moof(sequenceNumber, [track]);\n                boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n                sequenceNumber++;\n                boxes.set(moof);\n                boxes.set(mdat, moof.byteLength);\n                trackDecodeInfo.clearDtsInfo(track);\n                frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n                // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n                // valid use-case where an init segment/data should be triggered without associated\n                // frames. Leaving for now, but should be looked into.\n\n                if (frames.length) {\n                    segmentDuration = frames.length * frameDuration;\n                    this.trigger('segmentTimingInfo', generateSegmentTimingInfo(\n                        // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n                        // frame info is in video clock cycles. Convert to match expectation of\n                        // listeners (that all timestamps will be based on video clock cycles).\n                        clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),\n                        // frame times are already in video clock, as is segment duration\n                        frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n                    this.trigger('timingInfo', {\n                        start: frames[0].pts,\n                        end: frames[0].pts + segmentDuration\n                    });\n                }\n                this.trigger('data', {\n                    track: track,\n                    boxes: boxes\n                });\n                this.trigger('done', 'AudioSegmentStream');\n            };\n            this.reset = function () {\n                trackDecodeInfo.clearDtsInfo(track);\n                adtsFrames = [];\n                this.trigger('reset');\n            };\n        };\n        AudioSegmentStream.prototype = new Stream();\n        /**\n         * Constructs a single-track, ISO BMFF media segment from H264 data\n         * events. The output of this stream can be fed to a SourceBuffer\n         * configured with a suitable initialization segment.\n         * @param track {object} track metadata configuration\n         * @param options {object} transmuxer options object\n         * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n         *        gopsToAlignWith list when attempting to align gop pts\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        VideoSegmentStream = function (track, options) {\n            var sequenceNumber,\n                nalUnits = [],\n                gopsToAlignWith = [],\n                config,\n                pps;\n            options = options || {};\n            sequenceNumber = options.firstSequenceNumber || 0;\n            VideoSegmentStream.prototype.init.call(this);\n            delete track.minPTS;\n            this.gopCache_ = [];\n            /**\n             * Constructs a ISO BMFF segment given H264 nalUnits\n             * @param {Object} nalUnit A data event representing a nalUnit\n             * @param {String} nalUnit.nalUnitType\n             * @param {Object} nalUnit.config Properties for a mp4 track\n             * @param {Uint8Array} nalUnit.data The nalUnit bytes\n             * @see lib/codecs/h264.js\n             **/\n\n            this.push = function (nalUnit) {\n                trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n                if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n                    config = nalUnit.config;\n                    track.sps = [nalUnit.data];\n                    VIDEO_PROPERTIES.forEach(function (prop) {\n                        track[prop] = config[prop];\n                    }, this);\n                }\n                if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n                    pps = nalUnit.data;\n                    track.pps = [nalUnit.data];\n                } // buffer video until flush() is called\n\n                nalUnits.push(nalUnit);\n            };\n            /**\n             * Pass constructed ISO BMFF track and boxes on to the\n             * next stream in the pipeline\n             **/\n\n            this.flush = function () {\n                var frames,\n                    gopForFusion,\n                    gops,\n                    moof,\n                    mdat,\n                    boxes,\n                    prependedContentDuration = 0,\n                    firstGop,\n                    lastGop; // Throw away nalUnits at the start of the byte stream until\n                // we find the first AUD\n\n                while (nalUnits.length) {\n                    if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n                        break;\n                    }\n                    nalUnits.shift();\n                } // Return early if no video data has been observed\n\n                if (nalUnits.length === 0) {\n                    this.resetStream_();\n                    this.trigger('done', 'VideoSegmentStream');\n                    return;\n                } // Organize the raw nal-units into arrays that represent\n                // higher-level constructs such as frames and gops\n                // (group-of-pictures)\n\n                frames = frameUtils.groupNalsIntoFrames(nalUnits);\n                gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n                // a problem since MSE (on Chrome) requires a leading keyframe.\n                //\n                // We have two approaches to repairing this situation:\n                // 1) GOP-FUSION:\n                //    This is where we keep track of the GOPS (group-of-pictures)\n                //    from previous fragments and attempt to find one that we can\n                //    prepend to the current fragment in order to create a valid\n                //    fragment.\n                // 2) KEYFRAME-PULLING:\n                //    Here we search for the first keyframe in the fragment and\n                //    throw away all the frames between the start of the fragment\n                //    and that keyframe. We then extend the duration and pull the\n                //    PTS of the keyframe forward so that it covers the time range\n                //    of the frames that were disposed of.\n                //\n                // #1 is far prefereable over #2 which can cause \"stuttering\" but\n                // requires more things to be just right.\n\n                if (!gops[0][0].keyFrame) {\n                    // Search for a gop for fusion from our gopCache\n                    gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n                    if (gopForFusion) {\n                        // in order to provide more accurate timing information about the segment, save\n                        // the number of seconds prepended to the original segment due to GOP fusion\n                        prependedContentDuration = gopForFusion.duration;\n                        gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n                        // new gop at the beginning\n\n                        gops.byteLength += gopForFusion.byteLength;\n                        gops.nalCount += gopForFusion.nalCount;\n                        gops.pts = gopForFusion.pts;\n                        gops.dts = gopForFusion.dts;\n                        gops.duration += gopForFusion.duration;\n                    } else {\n                        // If we didn't find a candidate gop fall back to keyframe-pulling\n                        gops = frameUtils.extendFirstKeyFrame(gops);\n                    }\n                } // Trim gops to align with gopsToAlignWith\n\n                if (gopsToAlignWith.length) {\n                    var alignedGops;\n                    if (options.alignGopsAtEnd) {\n                        alignedGops = this.alignGopsAtEnd_(gops);\n                    } else {\n                        alignedGops = this.alignGopsAtStart_(gops);\n                    }\n                    if (!alignedGops) {\n                        // save all the nals in the last GOP into the gop cache\n                        this.gopCache_.unshift({\n                            gop: gops.pop(),\n                            pps: track.pps,\n                            sps: track.sps\n                        }); // Keep a maximum of 6 GOPs in the cache\n\n                        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n                        nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n                        this.resetStream_();\n                        this.trigger('done', 'VideoSegmentStream');\n                        return;\n                    } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n                    // when recalculated before sending off to CoalesceStream\n\n                    trackDecodeInfo.clearDtsInfo(track);\n                    gops = alignedGops;\n                }\n                trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n                // samples (that is, frames) in the video data\n\n                track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n                mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n                track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n                this.trigger('processedGopsInfo', gops.map(function (gop) {\n                    return {\n                        pts: gop.pts,\n                        dts: gop.dts,\n                        byteLength: gop.byteLength\n                    };\n                }));\n                firstGop = gops[0];\n                lastGop = gops[gops.length - 1];\n                this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n                this.trigger('timingInfo', {\n                    start: gops[0].pts,\n                    end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n                }); // save all the nals in the last GOP into the gop cache\n\n                this.gopCache_.unshift({\n                    gop: gops.pop(),\n                    pps: track.pps,\n                    sps: track.sps\n                }); // Keep a maximum of 6 GOPs in the cache\n\n                this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n                nalUnits = [];\n                this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n                this.trigger('timelineStartInfo', track.timelineStartInfo);\n                moof = mp4.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n                // throwing away hundreds of media segment fragments\n\n                boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n                sequenceNumber++;\n                boxes.set(moof);\n                boxes.set(mdat, moof.byteLength);\n                this.trigger('data', {\n                    track: track,\n                    boxes: boxes\n                });\n                this.resetStream_(); // Continue with the flush process now\n\n                this.trigger('done', 'VideoSegmentStream');\n            };\n            this.reset = function () {\n                this.resetStream_();\n                nalUnits = [];\n                this.gopCache_.length = 0;\n                gopsToAlignWith.length = 0;\n                this.trigger('reset');\n            };\n            this.resetStream_ = function () {\n                trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n                // for instance, when we are rendition switching\n\n                config = undefined;\n                pps = undefined;\n            }; // Search for a candidate Gop for gop-fusion from the gop cache and\n            // return it or return null if no good candidate was found\n\n            this.getGopForFusion_ = function (nalUnit) {\n                var halfSecond = 45000,\n                    // Half-a-second in a 90khz clock\n                    allowableOverlap = 10000,\n                    // About 3 frames @ 30fps\n                    nearestDistance = Infinity,\n                    dtsDistance,\n                    nearestGopObj,\n                    currentGop,\n                    currentGopObj,\n                    i; // Search for the GOP nearest to the beginning of this nal unit\n\n                for (i = 0; i < this.gopCache_.length; i++) {\n                    currentGopObj = this.gopCache_[i];\n                    currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n                    if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n                        continue;\n                    } // Reject Gops that would require a negative baseMediaDecodeTime\n\n                    if (currentGop.dts < track.timelineStartInfo.dts) {\n                        continue;\n                    } // The distance between the end of the gop and the start of the nalUnit\n\n                    dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n                    // a half-second of the nal unit\n\n                    if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n                        // Always use the closest GOP we found if there is more than\n                        // one candidate\n                        if (!nearestGopObj || nearestDistance > dtsDistance) {\n                            nearestGopObj = currentGopObj;\n                            nearestDistance = dtsDistance;\n                        }\n                    }\n                }\n                if (nearestGopObj) {\n                    return nearestGopObj.gop;\n                }\n                return null;\n            }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n            // of gopsToAlignWith starting from the START of the list\n\n            this.alignGopsAtStart_ = function (gops) {\n                var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n                byteLength = gops.byteLength;\n                nalCount = gops.nalCount;\n                duration = gops.duration;\n                alignIndex = gopIndex = 0;\n                while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n                    align = gopsToAlignWith[alignIndex];\n                    gop = gops[gopIndex];\n                    if (align.pts === gop.pts) {\n                        break;\n                    }\n                    if (gop.pts > align.pts) {\n                        // this current gop starts after the current gop we want to align on, so increment\n                        // align index\n                        alignIndex++;\n                        continue;\n                    } // current gop starts before the current gop we want to align on. so increment gop\n                    // index\n\n                    gopIndex++;\n                    byteLength -= gop.byteLength;\n                    nalCount -= gop.nalCount;\n                    duration -= gop.duration;\n                }\n                if (gopIndex === 0) {\n                    // no gops to trim\n                    return gops;\n                }\n                if (gopIndex === gops.length) {\n                    // all gops trimmed, skip appending all gops\n                    return null;\n                }\n                alignedGops = gops.slice(gopIndex);\n                alignedGops.byteLength = byteLength;\n                alignedGops.duration = duration;\n                alignedGops.nalCount = nalCount;\n                alignedGops.pts = alignedGops[0].pts;\n                alignedGops.dts = alignedGops[0].dts;\n                return alignedGops;\n            }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n            // of gopsToAlignWith starting from the END of the list\n\n            this.alignGopsAtEnd_ = function (gops) {\n                var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n                alignIndex = gopsToAlignWith.length - 1;\n                gopIndex = gops.length - 1;\n                alignEndIndex = null;\n                matchFound = false;\n                while (alignIndex >= 0 && gopIndex >= 0) {\n                    align = gopsToAlignWith[alignIndex];\n                    gop = gops[gopIndex];\n                    if (align.pts === gop.pts) {\n                        matchFound = true;\n                        break;\n                    }\n                    if (align.pts > gop.pts) {\n                        alignIndex--;\n                        continue;\n                    }\n                    if (alignIndex === gopsToAlignWith.length - 1) {\n                        // gop.pts is greater than the last alignment candidate. If no match is found\n                        // by the end of this loop, we still want to append gops that come after this\n                        // point\n                        alignEndIndex = gopIndex;\n                    }\n                    gopIndex--;\n                }\n                if (!matchFound && alignEndIndex === null) {\n                    return null;\n                }\n                var trimIndex;\n                if (matchFound) {\n                    trimIndex = gopIndex;\n                } else {\n                    trimIndex = alignEndIndex;\n                }\n                if (trimIndex === 0) {\n                    return gops;\n                }\n                var alignedGops = gops.slice(trimIndex);\n                var metadata = alignedGops.reduce(function (total, gop) {\n                    total.byteLength += gop.byteLength;\n                    total.duration += gop.duration;\n                    total.nalCount += gop.nalCount;\n                    return total;\n                }, {\n                    byteLength: 0,\n                    duration: 0,\n                    nalCount: 0\n                });\n                alignedGops.byteLength = metadata.byteLength;\n                alignedGops.duration = metadata.duration;\n                alignedGops.nalCount = metadata.nalCount;\n                alignedGops.pts = alignedGops[0].pts;\n                alignedGops.dts = alignedGops[0].dts;\n                return alignedGops;\n            };\n            this.alignGopsWith = function (newGopsToAlignWith) {\n                gopsToAlignWith = newGopsToAlignWith;\n            };\n        };\n        VideoSegmentStream.prototype = new Stream();\n        /**\n         * A Stream that can combine multiple streams (ie. audio & video)\n         * into a single output segment for MSE. Also supports audio-only\n         * and video-only streams.\n         * @param options {object} transmuxer options object\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at media timeline start.\n         */\n\n        CoalesceStream = function (options, metadataStream) {\n            // Number of Tracks per output segment\n            // If greater than 1, we combine multiple\n            // tracks into a single segment\n            this.numberOfTracks = 0;\n            this.metadataStream = metadataStream;\n            options = options || {};\n            if (typeof options.remux !== 'undefined') {\n                this.remuxTracks = !!options.remux;\n            } else {\n                this.remuxTracks = true;\n            }\n            if (typeof options.keepOriginalTimestamps === 'boolean') {\n                this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n            } else {\n                this.keepOriginalTimestamps = false;\n            }\n            this.pendingTracks = [];\n            this.videoTrack = null;\n            this.pendingBoxes = [];\n            this.pendingCaptions = [];\n            this.pendingMetadata = [];\n            this.pendingBytes = 0;\n            this.emittedTracks = 0;\n            CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n            this.push = function (output) {\n                // buffer incoming captions until the associated video segment\n                // finishes\n                if (output.content || output.text) {\n                    return this.pendingCaptions.push(output);\n                } // buffer incoming id3 tags until the final flush\n\n                if (output.frames) {\n                    return this.pendingMetadata.push(output);\n                } // Add this track to the list of pending tracks and store\n                // important information required for the construction of\n                // the final segment\n\n                this.pendingTracks.push(output.track);\n                this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n                // We unshift audio and push video because\n                // as of Chrome 75 when switching from\n                // one init segment to another if the video\n                // mdat does not appear after the audio mdat\n                // only audio will play for the duration of our transmux.\n\n                if (output.track.type === 'video') {\n                    this.videoTrack = output.track;\n                    this.pendingBoxes.push(output.boxes);\n                }\n                if (output.track.type === 'audio') {\n                    this.audioTrack = output.track;\n                    this.pendingBoxes.unshift(output.boxes);\n                }\n            };\n        };\n        CoalesceStream.prototype = new Stream();\n        CoalesceStream.prototype.flush = function (flushSource) {\n            var offset = 0,\n                event = {\n                    captions: [],\n                    captionStreams: {},\n                    metadata: [],\n                    info: {}\n                },\n                caption,\n                id3,\n                initSegment,\n                timelineStartPts = 0,\n                i;\n            if (this.pendingTracks.length < this.numberOfTracks) {\n                if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n                    // Return because we haven't received a flush from a data-generating\n                    // portion of the segment (meaning that we have only recieved meta-data\n                    // or captions.)\n                    return;\n                } else if (this.remuxTracks) {\n                    // Return until we have enough tracks from the pipeline to remux (if we\n                    // are remuxing audio and video into a single MP4)\n                    return;\n                } else if (this.pendingTracks.length === 0) {\n                    // In the case where we receive a flush without any data having been\n                    // received we consider it an emitted track for the purposes of coalescing\n                    // `done` events.\n                    // We do this for the case where there is an audio and video track in the\n                    // segment but no audio data. (seen in several playlists with alternate\n                    // audio tracks and no audio present in the main TS segments.)\n                    this.emittedTracks++;\n                    if (this.emittedTracks >= this.numberOfTracks) {\n                        this.trigger('done');\n                        this.emittedTracks = 0;\n                    }\n                    return;\n                }\n            }\n            if (this.videoTrack) {\n                timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n                VIDEO_PROPERTIES.forEach(function (prop) {\n                    event.info[prop] = this.videoTrack[prop];\n                }, this);\n            } else if (this.audioTrack) {\n                timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n                AUDIO_PROPERTIES.forEach(function (prop) {\n                    event.info[prop] = this.audioTrack[prop];\n                }, this);\n            }\n            if (this.videoTrack || this.audioTrack) {\n                if (this.pendingTracks.length === 1) {\n                    event.type = this.pendingTracks[0].type;\n                } else {\n                    event.type = 'combined';\n                }\n                this.emittedTracks += this.pendingTracks.length;\n                initSegment = mp4.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n                event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n                // and track definitions\n\n                event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n                event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n                for (i = 0; i < this.pendingBoxes.length; i++) {\n                    event.data.set(this.pendingBoxes[i], offset);\n                    offset += this.pendingBoxes[i].byteLength;\n                } // Translate caption PTS times into second offsets to match the\n                // video timeline for the segment, and add track info\n\n                for (i = 0; i < this.pendingCaptions.length; i++) {\n                    caption = this.pendingCaptions[i];\n                    caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n                    caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n                    event.captionStreams[caption.stream] = true;\n                    event.captions.push(caption);\n                } // Translate ID3 frame PTS times into second offsets to match the\n                // video timeline for the segment\n\n                for (i = 0; i < this.pendingMetadata.length; i++) {\n                    id3 = this.pendingMetadata[i];\n                    id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n                    event.metadata.push(id3);\n                } // We add this to every single emitted segment even though we only need\n                // it for the first\n\n                event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n                this.pendingTracks.length = 0;\n                this.videoTrack = null;\n                this.pendingBoxes.length = 0;\n                this.pendingCaptions.length = 0;\n                this.pendingBytes = 0;\n                this.pendingMetadata.length = 0; // Emit the built segment\n                // We include captions and ID3 tags for backwards compatibility,\n                // ideally we should send only video and audio in the data event\n\n                this.trigger('data', event); // Emit each caption to the outside world\n                // Ideally, this would happen immediately on parsing captions,\n                // but we need to ensure that video data is sent back first\n                // so that caption timing can be adjusted to match video timing\n\n                for (i = 0; i < event.captions.length; i++) {\n                    caption = event.captions[i];\n                    this.trigger('caption', caption);\n                } // Emit each id3 tag to the outside world\n                // Ideally, this would happen immediately on parsing the tag,\n                // but we need to ensure that video data is sent back first\n                // so that ID3 frame timing can be adjusted to match video timing\n\n                for (i = 0; i < event.metadata.length; i++) {\n                    id3 = event.metadata[i];\n                    this.trigger('id3Frame', id3);\n                }\n            } // Only emit `done` if all tracks have been flushed and emitted\n\n            if (this.emittedTracks >= this.numberOfTracks) {\n                this.trigger('done');\n                this.emittedTracks = 0;\n            }\n        };\n        CoalesceStream.prototype.setRemux = function (val) {\n            this.remuxTracks = val;\n        };\n        /**\n         * A Stream that expects MP2T binary data as input and produces\n         * corresponding media segments, suitable for use with Media Source\n         * Extension (MSE) implementations that support the ISO BMFF byte\n         * stream format, like Chrome.\n         */\n\n        Transmuxer = function (options) {\n            var self = this,\n                hasFlushed = true,\n                videoTrack,\n                audioTrack;\n            Transmuxer.prototype.init.call(this);\n            options = options || {};\n            this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n            this.transmuxPipeline_ = {};\n            this.setupAacPipeline = function () {\n                var pipeline = {};\n                this.transmuxPipeline_ = pipeline;\n                pipeline.type = 'aac';\n                pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n                pipeline.aacStream = new AacStream();\n                pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n                pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n                pipeline.adtsStream = new AdtsStream();\n                pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n                pipeline.headOfPipeline = pipeline.aacStream;\n                pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n                pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n                pipeline.metadataStream.on('timestamp', function (frame) {\n                    pipeline.aacStream.setTimestamp(frame.timeStamp);\n                });\n                pipeline.aacStream.on('data', function (data) {\n                    if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n                        return;\n                    }\n                    audioTrack = audioTrack || {\n                        timelineStartInfo: {\n                            baseMediaDecodeTime: self.baseMediaDecodeTime\n                        },\n                        codec: 'adts',\n                        type: 'audio'\n                    }; // hook up the audio segment stream to the first track with aac data\n\n                    pipeline.coalesceStream.numberOfTracks++;\n                    pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n                    pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n                    pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n                    pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n                    self.trigger('trackinfo', {\n                        hasAudio: !!audioTrack,\n                        hasVideo: !!videoTrack\n                    });\n                }); // Re-emit any data coming from the coalesce stream to the outside world\n\n                pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n                pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n                addPipelineLogRetriggers(this, pipeline);\n            };\n            this.setupTsPipeline = function () {\n                var pipeline = {};\n                this.transmuxPipeline_ = pipeline;\n                pipeline.type = 'ts';\n                pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n                pipeline.packetStream = new m2ts.TransportPacketStream();\n                pipeline.parseStream = new m2ts.TransportParseStream();\n                pipeline.elementaryStream = new m2ts.ElementaryStream();\n                pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();\n                pipeline.adtsStream = new AdtsStream();\n                pipeline.h264Stream = new H264Stream();\n                pipeline.captionStream = new m2ts.CaptionStream(options);\n                pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n                pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n                pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n                // demux the streams\n\n                pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n                pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n                pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n                pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n                pipeline.elementaryStream.on('data', function (data) {\n                    var i;\n                    if (data.type === 'metadata') {\n                        i = data.tracks.length; // scan the tracks listed in the metadata\n\n                        while (i--) {\n                            if (!videoTrack && data.tracks[i].type === 'video') {\n                                videoTrack = data.tracks[i];\n                                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n                            } else if (!audioTrack && data.tracks[i].type === 'audio') {\n                                audioTrack = data.tracks[i];\n                                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n                            }\n                        } // hook up the video segment stream to the first track with h264 data\n\n                        if (videoTrack && !pipeline.videoSegmentStream) {\n                            pipeline.coalesceStream.numberOfTracks++;\n                            pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n                            pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n                            pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n                                // When video emits timelineStartInfo data after a flush, we forward that\n                                // info to the AudioSegmentStream, if it exists, because video timeline\n                                // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n                                // because this is a particularly subtle form of timestamp alteration.\n                                if (audioTrack && !options.keepOriginalTimestamps) {\n                                    audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                                    // very earliest DTS we have seen in video because Chrome will\n                                    // interpret any video track with a baseMediaDecodeTime that is\n                                    // non-zero as a gap.\n\n                                    pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n                                }\n                            });\n                            pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n                            pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n                            pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n                                if (audioTrack) {\n                                    pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n                                }\n                            });\n                            pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n                            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n                        }\n                        if (audioTrack && !pipeline.audioSegmentStream) {\n                            // hook up the audio segment stream to the first track with aac data\n                            pipeline.coalesceStream.numberOfTracks++;\n                            pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n                            pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n                            pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n                            pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n                            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n                        } // emit pmt info\n\n                        self.trigger('trackinfo', {\n                            hasAudio: !!audioTrack,\n                            hasVideo: !!videoTrack\n                        });\n                    }\n                }); // Re-emit any data coming from the coalesce stream to the outside world\n\n                pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n                pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n                    id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n                    self.trigger('id3Frame', id3Frame);\n                });\n                pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n                pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n                addPipelineLogRetriggers(this, pipeline);\n            }; // hook up the segment streams once track metadata is delivered\n\n            this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n                var pipeline = this.transmuxPipeline_;\n                if (!options.keepOriginalTimestamps) {\n                    this.baseMediaDecodeTime = baseMediaDecodeTime;\n                }\n                if (audioTrack) {\n                    audioTrack.timelineStartInfo.dts = undefined;\n                    audioTrack.timelineStartInfo.pts = undefined;\n                    trackDecodeInfo.clearDtsInfo(audioTrack);\n                    if (pipeline.audioTimestampRolloverStream) {\n                        pipeline.audioTimestampRolloverStream.discontinuity();\n                    }\n                }\n                if (videoTrack) {\n                    if (pipeline.videoSegmentStream) {\n                        pipeline.videoSegmentStream.gopCache_ = [];\n                    }\n                    videoTrack.timelineStartInfo.dts = undefined;\n                    videoTrack.timelineStartInfo.pts = undefined;\n                    trackDecodeInfo.clearDtsInfo(videoTrack);\n                    pipeline.captionStream.reset();\n                }\n                if (pipeline.timestampRolloverStream) {\n                    pipeline.timestampRolloverStream.discontinuity();\n                }\n            };\n            this.setAudioAppendStart = function (timestamp) {\n                if (audioTrack) {\n                    this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n                }\n            };\n            this.setRemux = function (val) {\n                var pipeline = this.transmuxPipeline_;\n                options.remux = val;\n                if (pipeline && pipeline.coalesceStream) {\n                    pipeline.coalesceStream.setRemux(val);\n                }\n            };\n            this.alignGopsWith = function (gopsToAlignWith) {\n                if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n                    this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n                }\n            };\n            this.getLogTrigger_ = function (key) {\n                var self = this;\n                return function (event) {\n                    event.stream = key;\n                    self.trigger('log', event);\n                };\n            }; // feed incoming data to the front of the parsing pipeline\n\n            this.push = function (data) {\n                if (hasFlushed) {\n                    var isAac = isLikelyAacData(data);\n                    if (isAac && this.transmuxPipeline_.type !== 'aac') {\n                        this.setupAacPipeline();\n                    } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n                        this.setupTsPipeline();\n                    }\n                    hasFlushed = false;\n                }\n                this.transmuxPipeline_.headOfPipeline.push(data);\n            }; // flush any buffered data\n\n            this.flush = function () {\n                hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n                this.transmuxPipeline_.headOfPipeline.flush();\n            };\n            this.endTimeline = function () {\n                this.transmuxPipeline_.headOfPipeline.endTimeline();\n            };\n            this.reset = function () {\n                if (this.transmuxPipeline_.headOfPipeline) {\n                    this.transmuxPipeline_.headOfPipeline.reset();\n                }\n            }; // Caption data has to be reset when seeking outside buffered range\n\n            this.resetCaptions = function () {\n                if (this.transmuxPipeline_.captionStream) {\n                    this.transmuxPipeline_.captionStream.reset();\n                }\n            };\n        };\n        Transmuxer.prototype = new Stream();\n        var transmuxer = {\n            Transmuxer: Transmuxer,\n            VideoSegmentStream: VideoSegmentStream,\n            AudioSegmentStream: AudioSegmentStream,\n            AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n            VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n            // exported for testing\n            generateSegmentTimingInfo: generateSegmentTimingInfo\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var toUnsigned$3 = function (value) {\n            return value >>> 0;\n        };\n        var toHexString$1 = function (value) {\n            return ('00' + value.toString(16)).slice(-2);\n        };\n        var bin = {\n            toUnsigned: toUnsigned$3,\n            toHexString: toHexString$1\n        };\n        var parseType$3 = function (buffer) {\n            var result = '';\n            result += String.fromCharCode(buffer[0]);\n            result += String.fromCharCode(buffer[1]);\n            result += String.fromCharCode(buffer[2]);\n            result += String.fromCharCode(buffer[3]);\n            return result;\n        };\n        var parseType_1 = parseType$3;\n        var toUnsigned$2 = bin.toUnsigned;\n        var parseType$2 = parseType_1;\n        var findBox$2 = function (data, path) {\n            var results = [],\n                i,\n                size,\n                type,\n                end,\n                subresults;\n            if (!path.length) {\n                // short-circuit the search for empty paths\n                return null;\n            }\n            for (i = 0; i < data.byteLength;) {\n                size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n                type = parseType$2(data.subarray(i + 4, i + 8));\n                end = size > 1 ? i + size : data.byteLength;\n                if (type === path[0]) {\n                    if (path.length === 1) {\n                        // this is the end of the path and we've found the box we were\n                        // looking for\n                        results.push(data.subarray(i + 8, end));\n                    } else {\n                        // recursively search for the next box along the path\n                        subresults = findBox$2(data.subarray(i + 8, end), path.slice(1));\n                        if (subresults.length) {\n                            results = results.concat(subresults);\n                        }\n                    }\n                }\n                i = end;\n            } // we've finished searching all of data\n\n            return results;\n        };\n        var findBox_1 = findBox$2;\n        var toUnsigned$1 = bin.toUnsigned;\n        var getUint64$2 = numbers.getUint64;\n        var tfdt = function (data) {\n            var result = {\n                version: data[0],\n                flags: new Uint8Array(data.subarray(1, 4))\n            };\n            if (result.version === 1) {\n                result.baseMediaDecodeTime = getUint64$2(data.subarray(4));\n            } else {\n                result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n            }\n            return result;\n        };\n        var parseTfdt$2 = tfdt;\n        var parseSampleFlags$1 = function (flags) {\n            return {\n                isLeading: (flags[0] & 0x0c) >>> 2,\n                dependsOn: flags[0] & 0x03,\n                isDependedOn: (flags[1] & 0xc0) >>> 6,\n                hasRedundancy: (flags[1] & 0x30) >>> 4,\n                paddingValue: (flags[1] & 0x0e) >>> 1,\n                isNonSyncSample: flags[1] & 0x01,\n                degradationPriority: flags[2] << 8 | flags[3]\n            };\n        };\n        var parseSampleFlags_1 = parseSampleFlags$1;\n        var parseSampleFlags = parseSampleFlags_1;\n        var trun = function (data) {\n            var result = {\n                    version: data[0],\n                    flags: new Uint8Array(data.subarray(1, 4)),\n                    samples: []\n                },\n                view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n                // Flag interpretation\n                dataOffsetPresent = result.flags[2] & 0x01,\n                // compare with 2nd byte of 0x1\n                firstSampleFlagsPresent = result.flags[2] & 0x04,\n                // compare with 2nd byte of 0x4\n                sampleDurationPresent = result.flags[1] & 0x01,\n                // compare with 2nd byte of 0x100\n                sampleSizePresent = result.flags[1] & 0x02,\n                // compare with 2nd byte of 0x200\n                sampleFlagsPresent = result.flags[1] & 0x04,\n                // compare with 2nd byte of 0x400\n                sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n                // compare with 2nd byte of 0x800\n                sampleCount = view.getUint32(4),\n                offset = 8,\n                sample;\n            if (dataOffsetPresent) {\n                // 32 bit signed integer\n                result.dataOffset = view.getInt32(offset);\n                offset += 4;\n            } // Overrides the flags for the first sample only. The order of\n            // optional values will be: duration, size, compositionTimeOffset\n\n            if (firstSampleFlagsPresent && sampleCount) {\n                sample = {\n                    flags: parseSampleFlags(data.subarray(offset, offset + 4))\n                };\n                offset += 4;\n                if (sampleDurationPresent) {\n                    sample.duration = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleSizePresent) {\n                    sample.size = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleCompositionTimeOffsetPresent) {\n                    if (result.version === 1) {\n                        sample.compositionTimeOffset = view.getInt32(offset);\n                    } else {\n                        sample.compositionTimeOffset = view.getUint32(offset);\n                    }\n                    offset += 4;\n                }\n                result.samples.push(sample);\n                sampleCount--;\n            }\n            while (sampleCount--) {\n                sample = {};\n                if (sampleDurationPresent) {\n                    sample.duration = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleSizePresent) {\n                    sample.size = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleFlagsPresent) {\n                    sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n                    offset += 4;\n                }\n                if (sampleCompositionTimeOffsetPresent) {\n                    if (result.version === 1) {\n                        sample.compositionTimeOffset = view.getInt32(offset);\n                    } else {\n                        sample.compositionTimeOffset = view.getUint32(offset);\n                    }\n                    offset += 4;\n                }\n                result.samples.push(sample);\n            }\n            return result;\n        };\n        var parseTrun$2 = trun;\n        var tfhd = function (data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n                result = {\n                    version: data[0],\n                    flags: new Uint8Array(data.subarray(1, 4)),\n                    trackId: view.getUint32(4)\n                },\n                baseDataOffsetPresent = result.flags[2] & 0x01,\n                sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n                defaultSampleDurationPresent = result.flags[2] & 0x08,\n                defaultSampleSizePresent = result.flags[2] & 0x10,\n                defaultSampleFlagsPresent = result.flags[2] & 0x20,\n                durationIsEmpty = result.flags[0] & 0x010000,\n                defaultBaseIsMoof = result.flags[0] & 0x020000,\n                i;\n            i = 8;\n            if (baseDataOffsetPresent) {\n                i += 4; // truncate top 4 bytes\n                // FIXME: should we read the full 64 bits?\n\n                result.baseDataOffset = view.getUint32(12);\n                i += 4;\n            }\n            if (sampleDescriptionIndexPresent) {\n                result.sampleDescriptionIndex = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleDurationPresent) {\n                result.defaultSampleDuration = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleSizePresent) {\n                result.defaultSampleSize = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleFlagsPresent) {\n                result.defaultSampleFlags = view.getUint32(i);\n            }\n            if (durationIsEmpty) {\n                result.durationIsEmpty = true;\n            }\n            if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n                result.baseDataOffsetIsMoof = true;\n            }\n            return result;\n        };\n        var parseTfhd$2 = tfhd;\n        var win;\n        if (typeof window !== \"undefined\") {\n            win = window;\n        } else if (typeof commonjsGlobal !== \"undefined\") {\n            win = commonjsGlobal;\n        } else if (typeof self !== \"undefined\") {\n            win = self;\n        } else {\n            win = {};\n        }\n        var window_1 = win;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band CEA-708 captions out of FMP4 segments.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         */\n\n        var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n        var CaptionStream = captionStream.CaptionStream;\n        var findBox$1 = findBox_1;\n        var parseTfdt$1 = parseTfdt$2;\n        var parseTrun$1 = parseTrun$2;\n        var parseTfhd$1 = parseTfhd$2;\n        var window$2 = window_1;\n        /**\n         * Maps an offset in the mdat to a sample based on the the size of the samples.\n         * Assumes that `parseSamples` has been called first.\n         *\n         * @param {Number} offset - The offset into the mdat\n         * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n         * @return {?Object} The matching sample, or null if no match was found.\n         *\n         * @see ISO-BMFF-12/2015, Section 8.8.8\n         **/\n\n        var mapToSample = function (offset, samples) {\n            var approximateOffset = offset;\n            for (var i = 0; i < samples.length; i++) {\n                var sample = samples[i];\n                if (approximateOffset < sample.size) {\n                    return sample;\n                }\n                approximateOffset -= sample.size;\n            }\n            return null;\n        };\n        /**\n         * Finds SEI nal units contained in a Media Data Box.\n         * Assumes that `parseSamples` has been called first.\n         *\n         * @param {Uint8Array} avcStream - The bytes of the mdat\n         * @param {Object[]} samples - The samples parsed out by `parseSamples`\n         * @param {Number} trackId - The trackId of this video track\n         * @return {Object[]} seiNals - the parsed SEI NALUs found.\n         *   The contents of the seiNal should match what is expected by\n         *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n         *\n         * @see ISO-BMFF-12/2015, Section 8.1.1\n         * @see Rec. ITU-T H.264, 7.3.2.3.1\n         **/\n\n        var findSeiNals = function (avcStream, samples, trackId) {\n            var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n                result = {\n                    logs: [],\n                    seiNals: []\n                },\n                seiNal,\n                i,\n                length,\n                lastMatchedSample;\n            for (i = 0; i + 4 < avcStream.length; i += length) {\n                length = avcView.getUint32(i);\n                i += 4; // Bail if this doesn't appear to be an H264 stream\n\n                if (length <= 0) {\n                    continue;\n                }\n                switch (avcStream[i] & 0x1F) {\n                    case 0x06:\n                        var data = avcStream.subarray(i + 1, i + 1 + length);\n                        var matchingSample = mapToSample(i, samples);\n                        seiNal = {\n                            nalUnitType: 'sei_rbsp',\n                            size: length,\n                            data: data,\n                            escapedRBSP: discardEmulationPreventionBytes(data),\n                            trackId: trackId\n                        };\n                        if (matchingSample) {\n                            seiNal.pts = matchingSample.pts;\n                            seiNal.dts = matchingSample.dts;\n                            lastMatchedSample = matchingSample;\n                        } else if (lastMatchedSample) {\n                            // If a matching sample cannot be found, use the last\n                            // sample's values as they should be as close as possible\n                            seiNal.pts = lastMatchedSample.pts;\n                            seiNal.dts = lastMatchedSample.dts;\n                        } else {\n                            result.logs.push({\n                                level: 'warn',\n                                message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n                            });\n                            break;\n                        }\n                        result.seiNals.push(seiNal);\n                        break;\n                }\n            }\n            return result;\n        };\n        /**\n         * Parses sample information out of Track Run Boxes and calculates\n         * the absolute presentation and decode timestamps of each sample.\n         *\n         * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n         * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n         @see ISO-BMFF-12/2015, Section 8.8.12\n         * @param {Object} tfhd - The parsed Track Fragment Header\n         *   @see inspect.parseTfhd\n         * @return {Object[]} the parsed samples\n         *\n         * @see ISO-BMFF-12/2015, Section 8.8.8\n         **/\n\n        var parseSamples = function (truns, baseMediaDecodeTime, tfhd) {\n            var currentDts = baseMediaDecodeTime;\n            var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n            var defaultSampleSize = tfhd.defaultSampleSize || 0;\n            var trackId = tfhd.trackId;\n            var allSamples = [];\n            truns.forEach(function (trun) {\n                // Note: We currently do not parse the sample table as well\n                // as the trun. It's possible some sources will require this.\n                // moov > trak > mdia > minf > stbl\n                var trackRun = parseTrun$1(trun);\n                var samples = trackRun.samples;\n                samples.forEach(function (sample) {\n                    if (sample.duration === undefined) {\n                        sample.duration = defaultSampleDuration;\n                    }\n                    if (sample.size === undefined) {\n                        sample.size = defaultSampleSize;\n                    }\n                    sample.trackId = trackId;\n                    sample.dts = currentDts;\n                    if (sample.compositionTimeOffset === undefined) {\n                        sample.compositionTimeOffset = 0;\n                    }\n                    if (typeof currentDts === 'bigint') {\n                        sample.pts = currentDts + window$2.BigInt(sample.compositionTimeOffset);\n                        currentDts += window$2.BigInt(sample.duration);\n                    } else {\n                        sample.pts = currentDts + sample.compositionTimeOffset;\n                        currentDts += sample.duration;\n                    }\n                });\n                allSamples = allSamples.concat(samples);\n            });\n            return allSamples;\n        };\n        /**\n         * Parses out caption nals from an FMP4 segment's video tracks.\n         *\n         * @param {Uint8Array} segment - The bytes of a single segment\n         * @param {Number} videoTrackId - The trackId of a video track in the segment\n         * @return {Object.<Number, Object[]>} A mapping of video trackId to\n         *   a list of seiNals found in that track\n         **/\n\n        var parseCaptionNals = function (segment, videoTrackId) {\n            // To get the samples\n            var trafs = findBox$1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n            var mdats = findBox$1(segment, ['mdat']);\n            var captionNals = {};\n            var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n            mdats.forEach(function (mdat, index) {\n                var matchingTraf = trafs[index];\n                mdatTrafPairs.push({\n                    mdat: mdat,\n                    traf: matchingTraf\n                });\n            });\n            mdatTrafPairs.forEach(function (pair) {\n                var mdat = pair.mdat;\n                var traf = pair.traf;\n                var tfhd = findBox$1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n                var headerInfo = parseTfhd$1(tfhd[0]);\n                var trackId = headerInfo.trackId;\n                var tfdt = findBox$1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n                var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt$1(tfdt[0]).baseMediaDecodeTime : 0;\n                var truns = findBox$1(traf, ['trun']);\n                var samples;\n                var result; // Only parse video data for the chosen video track\n\n                if (videoTrackId === trackId && truns.length > 0) {\n                    samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n                    result = findSeiNals(mdat, samples, trackId);\n                    if (!captionNals[trackId]) {\n                        captionNals[trackId] = {\n                            seiNals: [],\n                            logs: []\n                        };\n                    }\n                    captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n                    captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n                }\n            });\n            return captionNals;\n        };\n        /**\n         * Parses out inband captions from an MP4 container and returns\n         * caption objects that can be used by WebVTT and the TextTrack API.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n         * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n         *\n         * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n         * @param {Number} trackId - The id of the video track to parse\n         * @param {Number} timescale - The timescale for the video track from the init segment\n         *\n         * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n         * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n         * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n         * @return {Object[]} parsedCaptions[].content - A list of individual caption segments\n         * @return {String} parsedCaptions[].content.text - The visible content of the caption segment\n         * @return {Number} parsedCaptions[].content.line - The line height from 1-15 for positioning of the caption segment\n         * @return {Number} parsedCaptions[].content.position - The column indent percentage for cue positioning from 10-80\n         **/\n\n        var parseEmbeddedCaptions = function (segment, trackId, timescale) {\n            var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n            if (trackId === null) {\n                return null;\n            }\n            captionNals = parseCaptionNals(segment, trackId);\n            var trackNals = captionNals[trackId] || {};\n            return {\n                seiNals: trackNals.seiNals,\n                logs: trackNals.logs,\n                timescale: timescale\n            };\n        };\n        /**\n         * Converts SEI NALUs into captions that can be used by video.js\n         **/\n\n        var CaptionParser = function () {\n            var isInitialized = false;\n            var captionStream; // Stores segments seen before trackId and timescale are set\n\n            var segmentCache; // Stores video track ID of the track being parsed\n\n            var trackId; // Stores the timescale of the track being parsed\n\n            var timescale; // Stores captions parsed so far\n\n            var parsedCaptions; // Stores whether we are receiving partial data or not\n\n            var parsingPartial;\n            /**\n             * A method to indicate whether a CaptionParser has been initalized\n             * @returns {Boolean}\n             **/\n\n            this.isInitialized = function () {\n                return isInitialized;\n            };\n            /**\n             * Initializes the underlying CaptionStream, SEI NAL parsing\n             * and management, and caption collection\n             **/\n\n            this.init = function (options) {\n                captionStream = new CaptionStream();\n                isInitialized = true;\n                parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n                captionStream.on('data', function (event) {\n                    // Convert to seconds in the source's timescale\n                    event.startTime = event.startPts / timescale;\n                    event.endTime = event.endPts / timescale;\n                    parsedCaptions.captions.push(event);\n                    parsedCaptions.captionStreams[event.stream] = true;\n                });\n                captionStream.on('log', function (log) {\n                    parsedCaptions.logs.push(log);\n                });\n            };\n            /**\n             * Determines if a new video track will be selected\n             * or if the timescale changed\n             * @return {Boolean}\n             **/\n\n            this.isNewInit = function (videoTrackIds, timescales) {\n                if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n                    return false;\n                }\n                return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n            };\n            /**\n             * Parses out SEI captions and interacts with underlying\n             * CaptionStream to return dispatched captions\n             *\n             * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n             * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n             * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n             * @see parseEmbeddedCaptions\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.parse = function (segment, videoTrackIds, timescales) {\n                var parsedData;\n                if (!this.isInitialized()) {\n                    return null; // This is not likely to be a video segment\n                } else if (!videoTrackIds || !timescales) {\n                    return null;\n                } else if (this.isNewInit(videoTrackIds, timescales)) {\n                    // Use the first video track only as there is no\n                    // mechanism to switch to other video tracks\n                    trackId = videoTrackIds[0];\n                    timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n                    // data until we have one.\n                    // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n                } else if (trackId === null || !timescale) {\n                    segmentCache.push(segment);\n                    return null;\n                } // Now that a timescale and trackId is set, parse cached segments\n\n                while (segmentCache.length > 0) {\n                    var cachedSegment = segmentCache.shift();\n                    this.parse(cachedSegment, videoTrackIds, timescales);\n                }\n                parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n                if (parsedData && parsedData.logs) {\n                    parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n                }\n                if (parsedData === null || !parsedData.seiNals) {\n                    if (parsedCaptions.logs.length) {\n                        return {\n                            logs: parsedCaptions.logs,\n                            captions: [],\n                            captionStreams: []\n                        };\n                    }\n                    return null;\n                }\n                this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n                this.flushStream();\n                return parsedCaptions;\n            };\n            /**\n             * Pushes SEI NALUs onto CaptionStream\n             * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n             * Assumes that `parseCaptionNals` has been called first\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.pushNals = function (nals) {\n                if (!this.isInitialized() || !nals || nals.length === 0) {\n                    return null;\n                }\n                nals.forEach(function (nal) {\n                    captionStream.push(nal);\n                });\n            };\n            /**\n             * Flushes underlying CaptionStream to dispatch processed, displayable captions\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.flushStream = function () {\n                if (!this.isInitialized()) {\n                    return null;\n                }\n                if (!parsingPartial) {\n                    captionStream.flush();\n                } else {\n                    captionStream.partialFlush();\n                }\n            };\n            /**\n             * Reset caption buckets for new data\n             **/\n\n            this.clearParsedCaptions = function () {\n                parsedCaptions.captions = [];\n                parsedCaptions.captionStreams = {};\n                parsedCaptions.logs = [];\n            };\n            /**\n             * Resets underlying CaptionStream\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.resetCaptionStream = function () {\n                if (!this.isInitialized()) {\n                    return null;\n                }\n                captionStream.reset();\n            };\n            /**\n             * Convenience method to clear all captions flushed from the\n             * CaptionStream and still being parsed\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.clearAllCaptions = function () {\n                this.clearParsedCaptions();\n                this.resetCaptionStream();\n            };\n            /**\n             * Reset caption parser\n             **/\n\n            this.reset = function () {\n                segmentCache = [];\n                trackId = null;\n                timescale = null;\n                if (!parsedCaptions) {\n                    parsedCaptions = {\n                        captions: [],\n                        // CC1, CC2, CC3, CC4\n                        captionStreams: {},\n                        logs: []\n                    };\n                } else {\n                    this.clearParsedCaptions();\n                }\n                this.resetCaptionStream();\n            };\n            this.reset();\n        };\n        var captionParser = CaptionParser;\n        /**\n         * Returns the first string in the data array ending with a null char '\\0'\n         * @param {UInt8} data\n         * @returns the string with the null char\n         */\n\n        var uint8ToCString$1 = function (data) {\n            var index = 0;\n            var curChar = String.fromCharCode(data[index]);\n            var retString = '';\n            while (curChar !== '\\0') {\n                retString += curChar;\n                index++;\n                curChar = String.fromCharCode(data[index]);\n            } // Add nullChar\n\n            retString += curChar;\n            return retString;\n        };\n        var string = {\n            uint8ToCString: uint8ToCString$1\n        };\n        var uint8ToCString = string.uint8ToCString;\n        var getUint64$1 = numbers.getUint64;\n        /**\n         * Based on: ISO/IEC 23009 Section: 5.10.3.3\n         * References:\n         * https://dashif-documents.azurewebsites.net/Events/master/event.html#emsg-format\n         * https://aomediacodec.github.io/id3-emsg/\n         *\n         * Takes emsg box data as a uint8 array and returns a emsg box object\n         * @param {UInt8Array} boxData data from emsg box\n         * @returns A parsed emsg box object\n         */\n\n        var parseEmsgBox = function (boxData) {\n            // version + flags\n            var offset = 4;\n            var version = boxData[0];\n            var scheme_id_uri, value, timescale, presentation_time, presentation_time_delta, event_duration, id, message_data;\n            if (version === 0) {\n                scheme_id_uri = uint8ToCString(boxData.subarray(offset));\n                offset += scheme_id_uri.length;\n                value = uint8ToCString(boxData.subarray(offset));\n                offset += value.length;\n                var dv = new DataView(boxData.buffer);\n                timescale = dv.getUint32(offset);\n                offset += 4;\n                presentation_time_delta = dv.getUint32(offset);\n                offset += 4;\n                event_duration = dv.getUint32(offset);\n                offset += 4;\n                id = dv.getUint32(offset);\n                offset += 4;\n            } else if (version === 1) {\n                var dv = new DataView(boxData.buffer);\n                timescale = dv.getUint32(offset);\n                offset += 4;\n                presentation_time = getUint64$1(boxData.subarray(offset));\n                offset += 8;\n                event_duration = dv.getUint32(offset);\n                offset += 4;\n                id = dv.getUint32(offset);\n                offset += 4;\n                scheme_id_uri = uint8ToCString(boxData.subarray(offset));\n                offset += scheme_id_uri.length;\n                value = uint8ToCString(boxData.subarray(offset));\n                offset += value.length;\n            }\n            message_data = new Uint8Array(boxData.subarray(offset, boxData.byteLength));\n            var emsgBox = {\n                scheme_id_uri,\n                value,\n                // if timescale is undefined or 0 set to 1\n                timescale: timescale ? timescale : 1,\n                presentation_time,\n                presentation_time_delta,\n                event_duration,\n                id,\n                message_data\n            };\n            return isValidEmsgBox(version, emsgBox) ? emsgBox : undefined;\n        };\n        /**\n         * Scales a presentation time or time delta with an offset with a provided timescale\n         * @param {number} presentationTime\n         * @param {number} timescale\n         * @param {number} timeDelta\n         * @param {number} offset\n         * @returns the scaled time as a number\n         */\n\n        var scaleTime = function (presentationTime, timescale, timeDelta, offset) {\n            return presentationTime || presentationTime === 0 ? presentationTime / timescale : offset + timeDelta / timescale;\n        };\n        /**\n         * Checks the emsg box data for validity based on the version\n         * @param {number} version of the emsg box to validate\n         * @param {Object} emsg the emsg data to validate\n         * @returns if the box is valid as a boolean\n         */\n\n        var isValidEmsgBox = function (version, emsg) {\n            var hasScheme = emsg.scheme_id_uri !== '\\0';\n            var isValidV0Box = version === 0 && isDefined(emsg.presentation_time_delta) && hasScheme;\n            var isValidV1Box = version === 1 && isDefined(emsg.presentation_time) && hasScheme; // Only valid versions of emsg are 0 and 1\n\n            return !(version > 1) && isValidV0Box || isValidV1Box;\n        }; // Utility function to check if an object is defined\n\n        var isDefined = function (data) {\n            return data !== undefined || data !== null;\n        };\n        var emsg$1 = {\n            parseEmsgBox: parseEmsgBox,\n            scaleTime: scaleTime\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about MP4s.\n         */\n\n        var toUnsigned = bin.toUnsigned;\n        var toHexString = bin.toHexString;\n        var findBox = findBox_1;\n        var parseType$1 = parseType_1;\n        var emsg = emsg$1;\n        var parseTfhd = parseTfhd$2;\n        var parseTrun = parseTrun$2;\n        var parseTfdt = parseTfdt$2;\n        var getUint64 = numbers.getUint64;\n        var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader, getEmsgID3;\n        var window$1 = window_1;\n        var parseId3Frames = parseId3.parseId3Frames;\n        /**\n         * Parses an MP4 initialization segment and extracts the timescale\n         * values for any declared tracks. Timescale values indicate the\n         * number of clock ticks per second to assume for time-based values\n         * elsewhere in the MP4.\n         *\n         * To determine the start time of an MP4, you need two pieces of\n         * information: the timescale unit and the earliest base media decode\n         * time. Multiple timescales can be specified within an MP4 but the\n         * base media decode time is always expressed in the timescale from\n         * the media header box for the track:\n         * ```\n         * moov > trak > mdia > mdhd.timescale\n         * ```\n         * @param init {Uint8Array} the bytes of the init segment\n         * @return {object} a hash of track ids to timescale values or null if\n         * the init segment is malformed.\n         */\n\n        timescale = function (init) {\n            var result = {},\n                traks = findBox(init, ['moov', 'trak']); // mdhd timescale\n\n            return traks.reduce(function (result, trak) {\n                var tkhd, version, index, id, mdhd;\n                tkhd = findBox(trak, ['tkhd'])[0];\n                if (!tkhd) {\n                    return null;\n                }\n                version = tkhd[0];\n                index = version === 0 ? 12 : 20;\n                id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n                mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n                if (!mdhd) {\n                    return null;\n                }\n                version = mdhd[0];\n                index = version === 0 ? 12 : 20;\n                result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n                return result;\n            }, result);\n        };\n        /**\n         * Determine the base media decode start time, in seconds, for an MP4\n         * fragment. If multiple fragments are specified, the earliest time is\n         * returned.\n         *\n         * The base media decode time can be parsed from track fragment\n         * metadata:\n         * ```\n         * moof > traf > tfdt.baseMediaDecodeTime\n         * ```\n         * It requires the timescale value from the mdhd to interpret.\n         *\n         * @param timescale {object} a hash of track ids to timescale values.\n         * @return {number} the earliest base media decode start time for the\n         * fragment, in seconds\n         */\n\n        startTime = function (timescale, fragment) {\n            var trafs; // we need info from two childrend of each track fragment box\n\n            trafs = findBox(fragment, ['moof', 'traf']); // determine the start times for each track\n\n            var lowestTime = trafs.reduce(function (acc, traf) {\n                var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n                var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n                var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n                var tfdt = findBox(traf, ['tfdt'])[0];\n                var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n                var baseTime; // version 1 is 64 bit\n\n                if (tfdt[0] === 1) {\n                    baseTime = getUint64(tfdt.subarray(4, 12));\n                } else {\n                    baseTime = dv.getUint32(4);\n                } // convert base time to seconds if it is a valid number.\n\n                let seconds;\n                if (typeof baseTime === 'bigint') {\n                    seconds = baseTime / window$1.BigInt(scale);\n                } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n                    seconds = baseTime / scale;\n                }\n                if (seconds < Number.MAX_SAFE_INTEGER) {\n                    seconds = Number(seconds);\n                }\n                if (seconds < acc) {\n                    acc = seconds;\n                }\n                return acc;\n            }, Infinity);\n            return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n        };\n        /**\n         * Determine the composition start, in seconds, for an MP4\n         * fragment.\n         *\n         * The composition start time of a fragment can be calculated using the base\n         * media decode time, composition time offset, and timescale, as follows:\n         *\n         * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n         *\n         * All of the aforementioned information is contained within a media fragment's\n         * `traf` box, except for timescale info, which comes from the initialization\n         * segment, so a track id (also contained within a `traf`) is also necessary to\n         * associate it with a timescale\n         *\n         *\n         * @param timescales {object} - a hash of track ids to timescale values.\n         * @param fragment {Unit8Array} - the bytes of a media segment\n         * @return {number} the composition start time for the fragment, in seconds\n         **/\n\n        compositionStartTime = function (timescales, fragment) {\n            var trafBoxes = findBox(fragment, ['moof', 'traf']);\n            var baseMediaDecodeTime = 0;\n            var compositionTimeOffset = 0;\n            var trackId;\n            if (trafBoxes && trafBoxes.length) {\n                // The spec states that track run samples contained within a `traf` box are contiguous, but\n                // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n                // We will assume that they are, so we only need the first to calculate start time.\n                var tfhd = findBox(trafBoxes[0], ['tfhd'])[0];\n                var trun = findBox(trafBoxes[0], ['trun'])[0];\n                var tfdt = findBox(trafBoxes[0], ['tfdt'])[0];\n                if (tfhd) {\n                    var parsedTfhd = parseTfhd(tfhd);\n                    trackId = parsedTfhd.trackId;\n                }\n                if (tfdt) {\n                    var parsedTfdt = parseTfdt(tfdt);\n                    baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n                }\n                if (trun) {\n                    var parsedTrun = parseTrun(trun);\n                    if (parsedTrun.samples && parsedTrun.samples.length) {\n                        compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n                    }\n                }\n            } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n            // specified.\n\n            var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n            if (typeof baseMediaDecodeTime === 'bigint') {\n                compositionTimeOffset = window$1.BigInt(compositionTimeOffset);\n                timescale = window$1.BigInt(timescale);\n            }\n            var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n            if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n                result = Number(result);\n            }\n            return result;\n        };\n        /**\n         * Find the trackIds of the video tracks in this source.\n         * Found by parsing the Handler Reference and Track Header Boxes:\n         *   moov > trak > mdia > hdlr\n         *   moov > trak > tkhd\n         *\n         * @param {Uint8Array} init - The bytes of the init segment for this source\n         * @return {Number[]} A list of trackIds\n         *\n         * @see ISO-BMFF-12/2015, Section 8.4.3\n         **/\n\n        getVideoTrackIds = function (init) {\n            var traks = findBox(init, ['moov', 'trak']);\n            var videoTrackIds = [];\n            traks.forEach(function (trak) {\n                var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n                var tkhds = findBox(trak, ['tkhd']);\n                hdlrs.forEach(function (hdlr, index) {\n                    var handlerType = parseType$1(hdlr.subarray(8, 12));\n                    var tkhd = tkhds[index];\n                    var view;\n                    var version;\n                    var trackId;\n                    if (handlerType === 'vide') {\n                        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n                        version = view.getUint8(0);\n                        trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n                        videoTrackIds.push(trackId);\n                    }\n                });\n            });\n            return videoTrackIds;\n        };\n        getTimescaleFromMediaHeader = function (mdhd) {\n            // mdhd is a FullBox, meaning it will have its own version as the first byte\n            var version = mdhd[0];\n            var index = version === 0 ? 12 : 20;\n            return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n        };\n        /**\n         * Get all the video, audio, and hint tracks from a non fragmented\n         * mp4 segment\n         */\n\n        getTracks = function (init) {\n            var traks = findBox(init, ['moov', 'trak']);\n            var tracks = [];\n            traks.forEach(function (trak) {\n                var track = {};\n                var tkhd = findBox(trak, ['tkhd'])[0];\n                var view, tkhdVersion; // id\n\n                if (tkhd) {\n                    view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n                    tkhdVersion = view.getUint8(0);\n                    track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n                }\n                var hdlr = findBox(trak, ['mdia', 'hdlr'])[0]; // type\n\n                if (hdlr) {\n                    var type = parseType$1(hdlr.subarray(8, 12));\n                    if (type === 'vide') {\n                        track.type = 'video';\n                    } else if (type === 'soun') {\n                        track.type = 'audio';\n                    } else {\n                        track.type = type;\n                    }\n                } // codec\n\n                var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n                if (stsd) {\n                    var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n                    track.codec = parseType$1(sampleDescriptions.subarray(4, 8));\n                    var codecBox = findBox(sampleDescriptions, [track.codec])[0];\n                    var codecConfig, codecConfigType;\n                    if (codecBox) {\n                        // https://tools.ietf.org/html/rfc6381#section-3.3\n                        if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n                            // we don't need anything but the \"config\" parameter of the\n                            // avc1 codecBox\n                            codecConfig = codecBox.subarray(78);\n                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n                            if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n                                track.codec += '.'; // left padded with zeroes for single digit hex\n                                // profile idc\n\n                                track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n                                track.codec += toHexString(codecConfig[10]); // level idc\n\n                                track.codec += toHexString(codecConfig[11]);\n                            } else {\n                                // TODO: show a warning that we couldn't parse the codec\n                                // and are using the default\n                                track.codec = 'avc1.4d400d';\n                            }\n                        } else if (/^mp4[a,v]$/i.test(track.codec)) {\n                            // we do not need anything but the streamDescriptor of the mp4a codecBox\n                            codecConfig = codecBox.subarray(28);\n                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n                            if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n                                track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n                                track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n                            } else {\n                                // TODO: show a warning that we couldn't parse the codec\n                                // and are using the default\n                                track.codec = 'mp4a.40.2';\n                            }\n                        } else {\n                            // flac, opus, etc\n                            track.codec = track.codec.toLowerCase();\n                        }\n                    }\n                }\n                var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n                if (mdhd) {\n                    track.timescale = getTimescaleFromMediaHeader(mdhd);\n                }\n                tracks.push(track);\n            });\n            return tracks;\n        };\n        /**\n         * Returns an array of emsg ID3 data from the provided segmentData.\n         * An offset can also be provided as the Latest Arrival Time to calculate\n         * the Event Start Time of v0 EMSG boxes.\n         * See: https://dashif-documents.azurewebsites.net/Events/master/event.html#Inband-event-timing\n         *\n         * @param {Uint8Array} segmentData the segment byte array.\n         * @param {number} offset the segment start time or Latest Arrival Time,\n         * @return {Object[]} an array of ID3 parsed from EMSG boxes\n         */\n\n        getEmsgID3 = function (segmentData, offset = 0) {\n            var emsgBoxes = findBox(segmentData, ['emsg']);\n            return emsgBoxes.map(data => {\n                var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));\n                var parsedId3Frames = parseId3Frames(parsedBox.message_data);\n                return {\n                    cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset),\n                    duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),\n                    frames: parsedId3Frames\n                };\n            });\n        };\n        var probe$2 = {\n            // export mp4 inspector's findBox and parseType for backwards compatibility\n            findBox: findBox,\n            parseType: parseType$1,\n            timescale: timescale,\n            startTime: startTime,\n            compositionStartTime: compositionStartTime,\n            videoTrackIds: getVideoTrackIds,\n            tracks: getTracks,\n            getTimescaleFromMediaHeader: getTimescaleFromMediaHeader,\n            getEmsgID3: getEmsgID3\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about TS Segments.\n         */\n\n        var StreamTypes$1 = streamTypes;\n        var parsePid = function (packet) {\n            var pid = packet[1] & 0x1f;\n            pid <<= 8;\n            pid |= packet[2];\n            return pid;\n        };\n        var parsePayloadUnitStartIndicator = function (packet) {\n            return !!(packet[1] & 0x40);\n        };\n        var parseAdaptionField = function (packet) {\n            var offset = 0; // if an adaption field is present, its length is specified by the\n            // fifth byte of the TS packet header. The adaptation field is\n            // used to add stuffing to PES packets that don't fill a complete\n            // TS packet, and to specify some forms of timing and control data\n            // that we do not currently use.\n\n            if ((packet[3] & 0x30) >>> 4 > 0x01) {\n                offset += packet[4] + 1;\n            }\n            return offset;\n        };\n        var parseType = function (packet, pmtPid) {\n            var pid = parsePid(packet);\n            if (pid === 0) {\n                return 'pat';\n            } else if (pid === pmtPid) {\n                return 'pmt';\n            } else if (pmtPid) {\n                return 'pes';\n            }\n            return null;\n        };\n        var parsePat = function (packet) {\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            var offset = 4 + parseAdaptionField(packet);\n            if (pusi) {\n                offset += packet[offset] + 1;\n            }\n            return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n        };\n        var parsePmt = function (packet) {\n            var programMapTable = {};\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            var payloadOffset = 4 + parseAdaptionField(packet);\n            if (pusi) {\n                payloadOffset += packet[payloadOffset] + 1;\n            } // PMTs can be sent ahead of the time when they should actually\n            // take effect. We don't believe this should ever be the case\n            // for HLS but we'll ignore \"forward\" PMT declarations if we see\n            // them. Future PMT declarations have the current_next_indicator\n            // set to zero.\n\n            if (!(packet[payloadOffset + 5] & 0x01)) {\n                return;\n            }\n            var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n            sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n            tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n            // long the program info descriptors are\n\n            programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n            var offset = 12 + programInfoLength;\n            while (offset < tableEnd) {\n                var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n                programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n                // skip past the elementary stream descriptors, if present\n\n                offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n            }\n            return programMapTable;\n        };\n        var parsePesType = function (packet, programMapTable) {\n            var pid = parsePid(packet);\n            var type = programMapTable[pid];\n            switch (type) {\n                case StreamTypes$1.H264_STREAM_TYPE:\n                    return 'video';\n                case StreamTypes$1.ADTS_STREAM_TYPE:\n                    return 'audio';\n                case StreamTypes$1.METADATA_STREAM_TYPE:\n                    return 'timed-metadata';\n                default:\n                    return null;\n            }\n        };\n        var parsePesTime = function (packet) {\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            if (!pusi) {\n                return null;\n            }\n            var offset = 4 + parseAdaptionField(packet);\n            if (offset >= packet.byteLength) {\n                // From the H 222.0 MPEG-TS spec\n                // \"For transport stream packets carrying PES packets, stuffing is needed when there\n                //  is insufficient PES packet data to completely fill the transport stream packet\n                //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n                //  the sum of the lengths of the data elements in it, so that the payload bytes\n                //  remaining after the adaptation field exactly accommodates the available PES packet\n                //  data.\"\n                //\n                // If the offset is >= the length of the packet, then the packet contains no data\n                // and instead is just adaption field stuffing bytes\n                return null;\n            }\n            var pes = null;\n            var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n            // and a DTS value. Determine what combination of values is\n            // available to work with.\n\n            ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n            // performs all bitwise operations on 32-bit integers but javascript\n            // supports a much greater range (52-bits) of integer using standard\n            // mathematical operations.\n            // We construct a 31-bit value using bitwise operators over the 31\n            // most significant bits and then multiply by 4 (equal to a left-shift\n            // of 2) before we add the final 2 least significant bits of the\n            // timestamp (equal to an OR.)\n\n            if (ptsDtsFlags & 0xC0) {\n                pes = {}; // the PTS and DTS are not written out directly. For information\n                // on how they are encoded, see\n                // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n                pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n                pes.pts *= 4; // Left shift by 2\n\n                pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n                pes.dts = pes.pts;\n                if (ptsDtsFlags & 0x40) {\n                    pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n                    pes.dts *= 4; // Left shift by 2\n\n                    pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n                }\n            }\n\n            return pes;\n        };\n        var parseNalUnitType = function (type) {\n            switch (type) {\n                case 0x05:\n                    return 'slice_layer_without_partitioning_rbsp_idr';\n                case 0x06:\n                    return 'sei_rbsp';\n                case 0x07:\n                    return 'seq_parameter_set_rbsp';\n                case 0x08:\n                    return 'pic_parameter_set_rbsp';\n                case 0x09:\n                    return 'access_unit_delimiter_rbsp';\n                default:\n                    return null;\n            }\n        };\n        var videoPacketContainsKeyFrame = function (packet) {\n            var offset = 4 + parseAdaptionField(packet);\n            var frameBuffer = packet.subarray(offset);\n            var frameI = 0;\n            var frameSyncPoint = 0;\n            var foundKeyFrame = false;\n            var nalType; // advance the sync point to a NAL start, if necessary\n\n            for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n                if (frameBuffer[frameSyncPoint + 2] === 1) {\n                    // the sync point is properly aligned\n                    frameI = frameSyncPoint + 5;\n                    break;\n                }\n            }\n            while (frameI < frameBuffer.byteLength) {\n                // look at the current byte to determine if we've hit the end of\n                // a NAL unit boundary\n                switch (frameBuffer[frameI]) {\n                    case 0:\n                        // skip past non-sync sequences\n                        if (frameBuffer[frameI - 1] !== 0) {\n                            frameI += 2;\n                            break;\n                        } else if (frameBuffer[frameI - 2] !== 0) {\n                            frameI++;\n                            break;\n                        }\n                        if (frameSyncPoint + 3 !== frameI - 2) {\n                            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                                foundKeyFrame = true;\n                            }\n                        } // drop trailing zeroes\n\n                        do {\n                            frameI++;\n                        } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n                        frameSyncPoint = frameI - 2;\n                        frameI += 3;\n                        break;\n                    case 1:\n                        // skip past non-sync sequences\n                        if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n                            frameI += 3;\n                            break;\n                        }\n                        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                            foundKeyFrame = true;\n                        }\n                        frameSyncPoint = frameI - 2;\n                        frameI += 3;\n                        break;\n                    default:\n                        // the current byte isn't a one or zero, so it cannot be part\n                        // of a sync sequence\n                        frameI += 3;\n                        break;\n                }\n            }\n            frameBuffer = frameBuffer.subarray(frameSyncPoint);\n            frameI -= frameSyncPoint;\n            frameSyncPoint = 0; // parse the final nal\n\n            if (frameBuffer && frameBuffer.byteLength > 3) {\n                nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                    foundKeyFrame = true;\n                }\n            }\n            return foundKeyFrame;\n        };\n        var probe$1 = {\n            parseType: parseType,\n            parsePat: parsePat,\n            parsePmt: parsePmt,\n            parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n            parsePesType: parsePesType,\n            parsePesTime: parsePesTime,\n            videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Parse mpeg2 transport stream packets to extract basic timing information\n         */\n\n        var StreamTypes = streamTypes;\n        var handleRollover = timestampRolloverStream.handleRollover;\n        var probe = {};\n        probe.ts = probe$1;\n        probe.aac = utils;\n        var ONE_SECOND_IN_TS = clock$2.ONE_SECOND_IN_TS;\n        var MP2T_PACKET_LENGTH = 188,\n            // bytes\n            SYNC_BYTE = 0x47;\n        /**\n         * walks through segment data looking for pat and pmt packets to parse out\n         * program map table information\n         */\n\n        var parsePsi_ = function (bytes, pmt) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type;\n            while (endIndex < bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pat':\n                            pmt.pid = probe.ts.parsePat(packet);\n                            break;\n                        case 'pmt':\n                            var table = probe.ts.parsePmt(packet);\n                            pmt.table = pmt.table || {};\n                            Object.keys(table).forEach(function (key) {\n                                pmt.table[key] = table[key];\n                            });\n                            break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            }\n        };\n        /**\n         * walks through the segment data from the start and end to get timing information\n         * for the first and last audio pes packets\n         */\n\n        var parseAudioPes_ = function (bytes, pmt, result) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type,\n                pesType,\n                pusi,\n                parsed;\n            var endLoop = false; // Start walking from start of segment to get first audio packet\n\n            while (endIndex <= bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'audio' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'audio';\n                                    result.audio.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            } // Start walking from end of segment to get last audio packet\n\n            endIndex = bytes.byteLength;\n            startIndex = endIndex - MP2T_PACKET_LENGTH;\n            endLoop = false;\n            while (startIndex >= 0) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'audio' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'audio';\n                                    result.audio.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex -= MP2T_PACKET_LENGTH;\n                    endIndex -= MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex--;\n                endIndex--;\n            }\n        };\n        /**\n         * walks through the segment data from the start and end to get timing information\n         * for the first and last video pes packets as well as timing information for the first\n         * key frame.\n         */\n\n        var parseVideoPes_ = function (bytes, pmt, result) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type,\n                pesType,\n                pusi,\n                parsed,\n                frame,\n                i,\n                pes;\n            var endLoop = false;\n            var currentFrame = {\n                data: [],\n                size: 0\n            }; // Start walking from start of segment to get first video packet\n\n            while (endIndex < bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'video') {\n                                if (pusi && !endLoop) {\n                                    parsed = probe.ts.parsePesTime(packet);\n                                    if (parsed) {\n                                        parsed.type = 'video';\n                                        result.video.push(parsed);\n                                        endLoop = true;\n                                    }\n                                }\n                                if (!result.firstKeyFrame) {\n                                    if (pusi) {\n                                        if (currentFrame.size !== 0) {\n                                            frame = new Uint8Array(currentFrame.size);\n                                            i = 0;\n                                            while (currentFrame.data.length) {\n                                                pes = currentFrame.data.shift();\n                                                frame.set(pes, i);\n                                                i += pes.byteLength;\n                                            }\n                                            if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                                                var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                                                // the keyframe seems to work fine with HLS playback\n                                                // and definitely preferable to a crash with TypeError...\n\n                                                if (firstKeyFrame) {\n                                                    result.firstKeyFrame = firstKeyFrame;\n                                                    result.firstKeyFrame.type = 'video';\n                                                } else {\n                                                    // eslint-disable-next-line\n                                                    console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                                                }\n                                            }\n                                            currentFrame.size = 0;\n                                        }\n                                    }\n                                    currentFrame.data.push(packet);\n                                    currentFrame.size += packet.byteLength;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop && result.firstKeyFrame) {\n                        break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            } // Start walking from end of segment to get last video packet\n\n            endIndex = bytes.byteLength;\n            startIndex = endIndex - MP2T_PACKET_LENGTH;\n            endLoop = false;\n            while (startIndex >= 0) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'video' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'video';\n                                    result.video.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex -= MP2T_PACKET_LENGTH;\n                    endIndex -= MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex--;\n                endIndex--;\n            }\n        };\n        /**\n         * Adjusts the timestamp information for the segment to account for\n         * rollover and convert to seconds based on pes packet timescale (90khz clock)\n         */\n\n        var adjustTimestamp_ = function (segmentInfo, baseTimestamp) {\n            if (segmentInfo.audio && segmentInfo.audio.length) {\n                var audioBaseTimestamp = baseTimestamp;\n                if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n                    audioBaseTimestamp = segmentInfo.audio[0].dts;\n                }\n                segmentInfo.audio.forEach(function (info) {\n                    info.dts = handleRollover(info.dts, audioBaseTimestamp);\n                    info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n                    info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n                    info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n                });\n            }\n            if (segmentInfo.video && segmentInfo.video.length) {\n                var videoBaseTimestamp = baseTimestamp;\n                if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n                    videoBaseTimestamp = segmentInfo.video[0].dts;\n                }\n                segmentInfo.video.forEach(function (info) {\n                    info.dts = handleRollover(info.dts, videoBaseTimestamp);\n                    info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n                    info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n                    info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n                });\n                if (segmentInfo.firstKeyFrame) {\n                    var frame = segmentInfo.firstKeyFrame;\n                    frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n                    frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n                    frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n                    frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n                }\n            }\n        };\n        /**\n         * inspects the aac data stream for start and end time information\n         */\n\n        var inspectAac_ = function (bytes) {\n            var endLoop = false,\n                audioCount = 0,\n                sampleRate = null,\n                timestamp = null,\n                frameSize = 0,\n                byteIndex = 0,\n                packet;\n            while (bytes.length - byteIndex >= 3) {\n                var type = probe.aac.parseType(bytes, byteIndex);\n                switch (type) {\n                    case 'timed-metadata':\n                        // Exit early because we don't have enough to parse\n                        // the ID3 tag header\n                        if (bytes.length - byteIndex < 10) {\n                            endLoop = true;\n                            break;\n                        }\n                        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (frameSize > bytes.length) {\n                            endLoop = true;\n                            break;\n                        }\n                        if (timestamp === null) {\n                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n                            timestamp = probe.aac.parseAacTimestamp(packet);\n                        }\n                        byteIndex += frameSize;\n                        break;\n                    case 'audio':\n                        // Exit early because we don't have enough to parse\n                        // the ADTS frame header\n                        if (bytes.length - byteIndex < 7) {\n                            endLoop = true;\n                            break;\n                        }\n                        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (frameSize > bytes.length) {\n                            endLoop = true;\n                            break;\n                        }\n                        if (sampleRate === null) {\n                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n                            sampleRate = probe.aac.parseSampleRate(packet);\n                        }\n                        audioCount++;\n                        byteIndex += frameSize;\n                        break;\n                    default:\n                        byteIndex++;\n                        break;\n                }\n                if (endLoop) {\n                    return null;\n                }\n            }\n            if (sampleRate === null || timestamp === null) {\n                return null;\n            }\n            var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n            var result = {\n                audio: [{\n                    type: 'audio',\n                    dts: timestamp,\n                    pts: timestamp\n                }, {\n                    type: 'audio',\n                    dts: timestamp + audioCount * 1024 * audioTimescale,\n                    pts: timestamp + audioCount * 1024 * audioTimescale\n                }]\n            };\n            return result;\n        };\n        /**\n         * inspects the transport stream segment data for start and end time information\n         * of the audio and video tracks (when present) as well as the first key frame's\n         * start time.\n         */\n\n        var inspectTs_ = function (bytes) {\n            var pmt = {\n                pid: null,\n                table: null\n            };\n            var result = {};\n            parsePsi_(bytes, pmt);\n            for (var pid in pmt.table) {\n                if (pmt.table.hasOwnProperty(pid)) {\n                    var type = pmt.table[pid];\n                    switch (type) {\n                        case StreamTypes.H264_STREAM_TYPE:\n                            result.video = [];\n                            parseVideoPes_(bytes, pmt, result);\n                            if (result.video.length === 0) {\n                                delete result.video;\n                            }\n                            break;\n                        case StreamTypes.ADTS_STREAM_TYPE:\n                            result.audio = [];\n                            parseAudioPes_(bytes, pmt, result);\n                            if (result.audio.length === 0) {\n                                delete result.audio;\n                            }\n                            break;\n                    }\n                }\n            }\n            return result;\n        };\n        /**\n         * Inspects segment byte data and returns an object with start and end timing information\n         *\n         * @param {Uint8Array} bytes The segment byte data\n         * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n         *  timestamps for rollover. This value must be in 90khz clock.\n         * @return {Object} Object containing start and end frame timing info of segment.\n         */\n\n        var inspect = function (bytes, baseTimestamp) {\n            var isAacData = probe.aac.isLikelyAacData(bytes);\n            var result;\n            if (isAacData) {\n                result = inspectAac_(bytes);\n            } else {\n                result = inspectTs_(bytes);\n            }\n            if (!result || !result.audio && !result.video) {\n                return null;\n            }\n            adjustTimestamp_(result, baseTimestamp);\n            return result;\n        };\n        var tsInspector = {\n            inspect: inspect,\n            parseAudioPes_: parseAudioPes_\n        };\n        /* global self */\n\n        /**\n         * Re-emits transmuxer events by converting them into messages to the\n         * world outside the worker.\n         *\n         * @param {Object} transmuxer the transmuxer to wire events on\n         * @private\n         */\n\n        const wireTransmuxerEvents = function (self, transmuxer) {\n            transmuxer.on('data', function (segment) {\n                // transfer ownership of the underlying ArrayBuffer\n                // instead of doing a copy to save memory\n                // ArrayBuffers are transferable but generic TypedArrays are not\n                // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n                const initArray = segment.initSegment;\n                segment.initSegment = {\n                    data: initArray.buffer,\n                    byteOffset: initArray.byteOffset,\n                    byteLength: initArray.byteLength\n                };\n                const typedArray = segment.data;\n                segment.data = typedArray.buffer;\n                self.postMessage({\n                    action: 'data',\n                    segment,\n                    byteOffset: typedArray.byteOffset,\n                    byteLength: typedArray.byteLength\n                }, [segment.data]);\n            });\n            transmuxer.on('done', function (data) {\n                self.postMessage({\n                    action: 'done'\n                });\n            });\n            transmuxer.on('gopInfo', function (gopInfo) {\n                self.postMessage({\n                    action: 'gopInfo',\n                    gopInfo\n                });\n            });\n            transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {\n                const videoSegmentTimingInfo = {\n                    start: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n                    },\n                    end: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n                    },\n                    baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n                };\n                if (timingInfo.prependedContentDuration) {\n                    videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n                }\n                self.postMessage({\n                    action: 'videoSegmentTimingInfo',\n                    videoSegmentTimingInfo\n                });\n            });\n            transmuxer.on('audioSegmentTimingInfo', function (timingInfo) {\n                // Note that all times for [audio/video]SegmentTimingInfo events are in video clock\n                const audioSegmentTimingInfo = {\n                    start: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n                    },\n                    end: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n                    },\n                    baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n                };\n                if (timingInfo.prependedContentDuration) {\n                    audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n                }\n                self.postMessage({\n                    action: 'audioSegmentTimingInfo',\n                    audioSegmentTimingInfo\n                });\n            });\n            transmuxer.on('id3Frame', function (id3Frame) {\n                self.postMessage({\n                    action: 'id3Frame',\n                    id3Frame\n                });\n            });\n            transmuxer.on('caption', function (caption) {\n                self.postMessage({\n                    action: 'caption',\n                    caption\n                });\n            });\n            transmuxer.on('trackinfo', function (trackInfo) {\n                self.postMessage({\n                    action: 'trackinfo',\n                    trackInfo\n                });\n            });\n            transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\n                // convert to video TS since we prioritize video time over audio\n                self.postMessage({\n                    action: 'audioTimingInfo',\n                    audioTimingInfo: {\n                        start: clock$2.videoTsToSeconds(audioTimingInfo.start),\n                        end: clock$2.videoTsToSeconds(audioTimingInfo.end)\n                    }\n                });\n            });\n            transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\n                self.postMessage({\n                    action: 'videoTimingInfo',\n                    videoTimingInfo: {\n                        start: clock$2.videoTsToSeconds(videoTimingInfo.start),\n                        end: clock$2.videoTsToSeconds(videoTimingInfo.end)\n                    }\n                });\n            });\n            transmuxer.on('log', function (log) {\n                self.postMessage({\n                    action: 'log',\n                    log\n                });\n            });\n        };\n        /**\n         * All incoming messages route through this hash. If no function exists\n         * to handle an incoming message, then we ignore the message.\n         *\n         * @class MessageHandlers\n         * @param {Object} options the options to initialize with\n         */\n\n        class MessageHandlers {\n            constructor(self, options) {\n                this.options = options || {};\n                this.self = self;\n                this.init();\n            }\n            /**\n             * initialize our web worker and wire all the events.\n             */\n\n            init() {\n                if (this.transmuxer) {\n                    this.transmuxer.dispose();\n                }\n                this.transmuxer = new transmuxer.Transmuxer(this.options);\n                wireTransmuxerEvents(this.self, this.transmuxer);\n            }\n            pushMp4Captions(data) {\n                if (!this.captionParser) {\n                    this.captionParser = new captionParser();\n                    this.captionParser.init();\n                }\n                const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n                const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);\n                this.self.postMessage({\n                    action: 'mp4Captions',\n                    captions: parsed && parsed.captions || [],\n                    logs: parsed && parsed.logs || [],\n                    data: segment.buffer\n                }, [segment.buffer]);\n            }\n            probeMp4StartTime({\n                                  timescales,\n                                  data\n                              }) {\n                const startTime = probe$2.startTime(timescales, data);\n                this.self.postMessage({\n                    action: 'probeMp4StartTime',\n                    startTime,\n                    data\n                }, [data.buffer]);\n            }\n            probeMp4Tracks({\n                               data\n                           }) {\n                const tracks = probe$2.tracks(data);\n                this.self.postMessage({\n                    action: 'probeMp4Tracks',\n                    tracks,\n                    data\n                }, [data.buffer]);\n            }\n            /**\n             * Probes an mp4 segment for EMSG boxes containing ID3 data.\n             * https://aomediacodec.github.io/id3-emsg/\n             *\n             * @param {Uint8Array} data segment data\n             * @param {number} offset segment start time\n             * @return {Object[]} an array of ID3 frames\n             */\n\n            probeEmsgID3({\n                             data,\n                             offset\n                         }) {\n                const id3Frames = probe$2.getEmsgID3(data, offset);\n                this.self.postMessage({\n                    action: 'probeEmsgID3',\n                    id3Frames,\n                    emsgData: data\n                }, [data.buffer]);\n            }\n            /**\n             * Probe an mpeg2-ts segment to determine the start time of the segment in it's\n             * internal \"media time,\" as well as whether it contains video and/or audio.\n             *\n             * @private\n             * @param {Uint8Array} bytes - segment bytes\n             * @param {number} baseStartTime\n             *        Relative reference timestamp used when adjusting frame timestamps for rollover.\n             *        This value should be in seconds, as it's converted to a 90khz clock within the\n             *        function body.\n             * @return {Object} The start time of the current segment in \"media time\" as well as\n             *                  whether it contains video and/or audio\n             */\n\n            probeTs({\n                        data,\n                        baseStartTime\n                    }) {\n                const tsStartTime = typeof baseStartTime === 'number' && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;\n                const timeInfo = tsInspector.inspect(data, tsStartTime);\n                let result = null;\n                if (timeInfo) {\n                    result = {\n                        // each type's time info comes back as an array of 2 times, start and end\n                        hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,\n                        hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false\n                    };\n                    if (result.hasVideo) {\n                        result.videoStart = timeInfo.video[0].ptsTime;\n                    }\n                    if (result.hasAudio) {\n                        result.audioStart = timeInfo.audio[0].ptsTime;\n                    }\n                }\n                this.self.postMessage({\n                    action: 'probeTs',\n                    result,\n                    data\n                }, [data.buffer]);\n            }\n            clearAllMp4Captions() {\n                if (this.captionParser) {\n                    this.captionParser.clearAllCaptions();\n                }\n            }\n            clearParsedMp4Captions() {\n                if (this.captionParser) {\n                    this.captionParser.clearParsedCaptions();\n                }\n            }\n            /**\n             * Adds data (a ts segment) to the start of the transmuxer pipeline for\n             * processing.\n             *\n             * @param {ArrayBuffer} data data to push into the muxer\n             */\n\n            push(data) {\n                // Cast array buffer to correct type for transmuxer\n                const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n                this.transmuxer.push(segment);\n            }\n            /**\n             * Recreate the transmuxer so that the next segment added via `push`\n             * start with a fresh transmuxer.\n             */\n\n            reset() {\n                this.transmuxer.reset();\n            }\n            /**\n             * Set the value that will be used as the `baseMediaDecodeTime` time for the\n             * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n             * set relative to the first based on the PTS values.\n             *\n             * @param {Object} data used to set the timestamp offset in the muxer\n             */\n\n            setTimestampOffset(data) {\n                const timestampOffset = data.timestampOffset || 0;\n                this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));\n            }\n            setAudioAppendStart(data) {\n                this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));\n            }\n            setRemux(data) {\n                this.transmuxer.setRemux(data.remux);\n            }\n            /**\n             * Forces the pipeline to finish processing the last segment and emit it's\n             * results.\n             *\n             * @param {Object} data event data, not really used\n             */\n\n            flush(data) {\n                this.transmuxer.flush(); // transmuxed done action is fired after both audio/video pipelines are flushed\n\n                self.postMessage({\n                    action: 'done',\n                    type: 'transmuxed'\n                });\n            }\n            endTimeline() {\n                this.transmuxer.endTimeline(); // transmuxed endedtimeline action is fired after both audio/video pipelines end their\n                // timelines\n\n                self.postMessage({\n                    action: 'endedtimeline',\n                    type: 'transmuxed'\n                });\n            }\n            alignGopsWith(data) {\n                this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n            }\n        }\n        /**\n         * Our web worker interface so that things can talk to mux.js\n         * that will be running in a web worker. the scope is passed to this by\n         * webworkify.\n         *\n         * @param {Object} self the scope for the web worker\n         */\n\n        self.onmessage = function (event) {\n            if (event.data.action === 'init' && event.data.options) {\n                this.messageHandlers = new MessageHandlers(self, event.data.options);\n                return;\n            }\n            if (!this.messageHandlers) {\n                this.messageHandlers = new MessageHandlers(self);\n            }\n            if (event.data && event.data.action && event.data.action !== 'init') {\n                if (this.messageHandlers[event.data.action]) {\n                    this.messageHandlers[event.data.action](event.data);\n                }\n            }\n        };\n    }));\n    var TransmuxWorker = factory(workerCode$1);\n    /* rollup-plugin-worker-factory end for worker!/home/runner/work/http-streaming/http-streaming/src/transmuxer-worker.js */\n\n    const handleData_ = (event, transmuxedData, callback) => {\n        const {\n            type,\n            initSegment,\n            captions,\n            captionStreams,\n            metadata,\n            videoFrameDtsTime,\n            videoFramePtsTime\n        } = event.data.segment;\n        transmuxedData.buffer.push({\n            captions,\n            captionStreams,\n            metadata\n        });\n        const boxes = event.data.segment.boxes || {\n            data: event.data.segment.data\n        };\n        const result = {\n            type,\n            // cast ArrayBuffer to TypedArray\n            data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),\n            initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)\n        };\n        if (typeof videoFrameDtsTime !== 'undefined') {\n            result.videoFrameDtsTime = videoFrameDtsTime;\n        }\n        if (typeof videoFramePtsTime !== 'undefined') {\n            result.videoFramePtsTime = videoFramePtsTime;\n        }\n        callback(result);\n    };\n    const handleDone_ = ({\n                             transmuxedData,\n                             callback\n                         }) => {\n        // Previously we only returned data on data events,\n        // not on done events. Clear out the buffer to keep that consistent.\n        transmuxedData.buffer = []; // all buffers should have been flushed from the muxer, so start processing anything we\n        // have received\n\n        callback(transmuxedData);\n    };\n    const handleGopInfo_ = (event, transmuxedData) => {\n        transmuxedData.gopInfo = event.data.gopInfo;\n    };\n    const processTransmux = options => {\n        const {\n            transmuxer,\n            bytes,\n            audioAppendStart,\n            gopsToAlignWith,\n            remux,\n            onData,\n            onTrackInfo,\n            onAudioTimingInfo,\n            onVideoTimingInfo,\n            onVideoSegmentTimingInfo,\n            onAudioSegmentTimingInfo,\n            onId3,\n            onCaptions,\n            onDone,\n            onEndedTimeline,\n            onTransmuxerLog,\n            isEndOfTimeline\n        } = options;\n        const transmuxedData = {\n            buffer: []\n        };\n        let waitForEndedTimelineEvent = isEndOfTimeline;\n        const handleMessage = event => {\n            if (transmuxer.currentTransmux !== options) {\n                // disposed\n                return;\n            }\n            if (event.data.action === 'data') {\n                handleData_(event, transmuxedData, onData);\n            }\n            if (event.data.action === 'trackinfo') {\n                onTrackInfo(event.data.trackInfo);\n            }\n            if (event.data.action === 'gopInfo') {\n                handleGopInfo_(event, transmuxedData);\n            }\n            if (event.data.action === 'audioTimingInfo') {\n                onAudioTimingInfo(event.data.audioTimingInfo);\n            }\n            if (event.data.action === 'videoTimingInfo') {\n                onVideoTimingInfo(event.data.videoTimingInfo);\n            }\n            if (event.data.action === 'videoSegmentTimingInfo') {\n                onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);\n            }\n            if (event.data.action === 'audioSegmentTimingInfo') {\n                onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);\n            }\n            if (event.data.action === 'id3Frame') {\n                onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);\n            }\n            if (event.data.action === 'caption') {\n                onCaptions(event.data.caption);\n            }\n            if (event.data.action === 'endedtimeline') {\n                waitForEndedTimelineEvent = false;\n                onEndedTimeline();\n            }\n            if (event.data.action === 'log') {\n                onTransmuxerLog(event.data.log);\n            } // wait for the transmuxed event since we may have audio and video\n\n            if (event.data.type !== 'transmuxed') {\n                return;\n            } // If the \"endedtimeline\" event has not yet fired, and this segment represents the end\n            // of a timeline, that means there may still be data events before the segment\n            // processing can be considerred complete. In that case, the final event should be\n            // an \"endedtimeline\" event with the type \"transmuxed.\"\n\n            if (waitForEndedTimelineEvent) {\n                return;\n            }\n            transmuxer.onmessage = null;\n            handleDone_({\n                transmuxedData,\n                callback: onDone\n            });\n            /* eslint-disable no-use-before-define */\n\n            dequeue(transmuxer);\n            /* eslint-enable */\n        };\n\n        transmuxer.onmessage = handleMessage;\n        if (audioAppendStart) {\n            transmuxer.postMessage({\n                action: 'setAudioAppendStart',\n                appendStart: audioAppendStart\n            });\n        } // allow empty arrays to be passed to clear out GOPs\n\n        if (Array.isArray(gopsToAlignWith)) {\n            transmuxer.postMessage({\n                action: 'alignGopsWith',\n                gopsToAlignWith\n            });\n        }\n        if (typeof remux !== 'undefined') {\n            transmuxer.postMessage({\n                action: 'setRemux',\n                remux\n            });\n        }\n        if (bytes.byteLength) {\n            const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\n            const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\n            transmuxer.postMessage({\n                action: 'push',\n                // Send the typed-array of data as an ArrayBuffer so that\n                // it can be sent as a \"Transferable\" and avoid the costly\n                // memory copy\n                data: buffer,\n                // To recreate the original typed-array, we need information\n                // about what portion of the ArrayBuffer it was a view into\n                byteOffset,\n                byteLength: bytes.byteLength\n            }, [buffer]);\n        }\n        if (isEndOfTimeline) {\n            transmuxer.postMessage({\n                action: 'endTimeline'\n            });\n        } // even if we didn't push any bytes, we have to make sure we flush in case we reached\n        // the end of the segment\n\n        transmuxer.postMessage({\n            action: 'flush'\n        });\n    };\n    const dequeue = transmuxer => {\n        transmuxer.currentTransmux = null;\n        if (transmuxer.transmuxQueue.length) {\n            transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();\n            if (typeof transmuxer.currentTransmux === 'function') {\n                transmuxer.currentTransmux();\n            } else {\n                processTransmux(transmuxer.currentTransmux);\n            }\n        }\n    };\n    const processAction = (transmuxer, action) => {\n        transmuxer.postMessage({\n            action\n        });\n        dequeue(transmuxer);\n    };\n    const enqueueAction = (action, transmuxer) => {\n        if (!transmuxer.currentTransmux) {\n            transmuxer.currentTransmux = action;\n            processAction(transmuxer, action);\n            return;\n        }\n        transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));\n    };\n    const reset = transmuxer => {\n        enqueueAction('reset', transmuxer);\n    };\n    const endTimeline = transmuxer => {\n        enqueueAction('endTimeline', transmuxer);\n    };\n    const transmux = options => {\n        if (!options.transmuxer.currentTransmux) {\n            options.transmuxer.currentTransmux = options;\n            processTransmux(options);\n            return;\n        }\n        options.transmuxer.transmuxQueue.push(options);\n    };\n    const createTransmuxer = options => {\n        const transmuxer = new TransmuxWorker();\n        transmuxer.currentTransmux = null;\n        transmuxer.transmuxQueue = [];\n        const term = transmuxer.terminate;\n        transmuxer.terminate = () => {\n            transmuxer.currentTransmux = null;\n            transmuxer.transmuxQueue.length = 0;\n            return term.call(transmuxer);\n        };\n        transmuxer.postMessage({\n            action: 'init',\n            options\n        });\n        return transmuxer;\n    };\n    var segmentTransmuxer = {\n        reset,\n        endTimeline,\n        transmux,\n        createTransmuxer\n    };\n    const workerCallback = function (options) {\n        const transmuxer = options.transmuxer;\n        const endAction = options.endAction || options.action;\n        const callback = options.callback;\n        const message = _extends$1({}, options, {\n            endAction: null,\n            transmuxer: null,\n            callback: null\n        });\n        const listenForEndEvent = event => {\n            if (event.data.action !== endAction) {\n                return;\n            }\n            transmuxer.removeEventListener('message', listenForEndEvent); // transfer ownership of bytes back to us.\n\n            if (event.data.data) {\n                event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);\n                if (options.data) {\n                    options.data = event.data.data;\n                }\n            }\n            callback(event.data);\n        };\n        transmuxer.addEventListener('message', listenForEndEvent);\n        if (options.data) {\n            const isArrayBuffer = options.data instanceof ArrayBuffer;\n            message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;\n            message.byteLength = options.data.byteLength;\n            const transfers = [isArrayBuffer ? options.data : options.data.buffer];\n            transmuxer.postMessage(message, transfers);\n        } else {\n            transmuxer.postMessage(message);\n        }\n    };\n    const REQUEST_ERRORS = {\n        FAILURE: 2,\n        TIMEOUT: -101,\n        ABORTED: -102\n    };\n    /**\n     * Abort all requests\n     *\n     * @param {Object} activeXhrs - an object that tracks all XHR requests\n     */\n\n    const abortAll = activeXhrs => {\n        activeXhrs.forEach(xhr => {\n            xhr.abort();\n        });\n    };\n    /**\n     * Gather important bandwidth stats once a request has completed\n     *\n     * @param {Object} request - the XHR request from which to gather stats\n     */\n\n    const getRequestStats = request => {\n        return {\n            bandwidth: request.bandwidth,\n            bytesReceived: request.bytesReceived || 0,\n            roundTripTime: request.roundTripTime || 0\n        };\n    };\n    /**\n     * If possible gather bandwidth stats as a request is in\n     * progress\n     *\n     * @param {Event} progressEvent - an event object from an XHR's progress event\n     */\n\n    const getProgressStats = progressEvent => {\n        const request = progressEvent.target;\n        const roundTripTime = Date.now() - request.requestTime;\n        const stats = {\n            bandwidth: Infinity,\n            bytesReceived: 0,\n            roundTripTime: roundTripTime || 0\n        };\n        stats.bytesReceived = progressEvent.loaded; // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n        // because we should only use bandwidth stats on progress to determine when\n        // abort a request early due to insufficient bandwidth\n\n        stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n        return stats;\n    };\n    /**\n     * Handle all error conditions in one place and return an object\n     * with all the information\n     *\n     * @param {Error|null} error - if non-null signals an error occured with the XHR\n     * @param {Object} request -  the XHR request that possibly generated the error\n     */\n\n    const handleErrors = (error, request) => {\n        if (request.timedout) {\n            return {\n                status: request.status,\n                message: 'HLS request timed-out at URL: ' + request.uri,\n                code: REQUEST_ERRORS.TIMEOUT,\n                xhr: request\n            };\n        }\n        if (request.aborted) {\n            return {\n                status: request.status,\n                message: 'HLS request aborted at URL: ' + request.uri,\n                code: REQUEST_ERRORS.ABORTED,\n                xhr: request\n            };\n        }\n        if (error) {\n            return {\n                status: request.status,\n                message: 'HLS request errored at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            };\n        }\n        if (request.responseType === 'arraybuffer' && request.response.byteLength === 0) {\n            return {\n                status: request.status,\n                message: 'Empty HLS response at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            };\n        }\n        return null;\n    };\n    /**\n     * Handle responses for key data and convert the key data to the correct format\n     * for the decryption step later\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Array} objects - objects to add the key bytes to.\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleKeyResponse = (segment, objects, finishProcessingFn) => (error, request) => {\n        const response = request.response;\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        if (response.byteLength !== 16) {\n            return finishProcessingFn({\n                status: request.status,\n                message: 'Invalid HLS key at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            }, segment);\n        }\n        const view = new DataView(response);\n        const bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n        for (let i = 0; i < objects.length; i++) {\n            objects[i].bytes = bytes;\n        }\n        return finishProcessingFn(null, segment);\n    };\n    const parseInitSegment = (segment, callback) => {\n        const type = detectContainerForBytes(segment.map.bytes); // TODO: We should also handle ts init segments here, but we\n        // only know how to parse mp4 init segments at the moment\n\n        if (type !== 'mp4') {\n            const uri = segment.map.resolvedUri || segment.map.uri;\n            return callback({\n                internal: true,\n                message: `Found unsupported ${type || 'unknown'} container for initialization segment at URL: ${uri}`,\n                code: REQUEST_ERRORS.FAILURE\n            });\n        }\n        workerCallback({\n            action: 'probeMp4Tracks',\n            data: segment.map.bytes,\n            transmuxer: segment.transmuxer,\n            callback: ({\n                           tracks,\n                           data\n                       }) => {\n                // transfer bytes back to us\n                segment.map.bytes = data;\n                tracks.forEach(function (track) {\n                    segment.map.tracks = segment.map.tracks || {}; // only support one track of each type for now\n\n                    if (segment.map.tracks[track.type]) {\n                        return;\n                    }\n                    segment.map.tracks[track.type] = track;\n                    if (typeof track.id === 'number' && track.timescale) {\n                        segment.map.timescales = segment.map.timescales || {};\n                        segment.map.timescales[track.id] = track.timescale;\n                    }\n                });\n                return callback(null);\n            }\n        });\n    };\n    /**\n     * Handle init-segment responses\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleInitSegmentResponse = ({\n                                           segment,\n                                           finishProcessingFn\n                                       }) => (error, request) => {\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        const bytes = new Uint8Array(request.response); // init segment is encypted, we will have to wait\n        // until the key request is done to decrypt.\n\n        if (segment.map.key) {\n            segment.map.encryptedBytes = bytes;\n            return finishProcessingFn(null, segment);\n        }\n        segment.map.bytes = bytes;\n        parseInitSegment(segment, function (parseError) {\n            if (parseError) {\n                parseError.xhr = request;\n                parseError.status = request.status;\n                return finishProcessingFn(parseError, segment);\n            }\n            finishProcessingFn(null, segment);\n        });\n    };\n    /**\n     * Response handler for segment-requests being sure to set the correct\n     * property depending on whether the segment is encryped or not\n     * Also records and keeps track of stats that are used for ABR purposes\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleSegmentResponse = ({\n                                       segment,\n                                       finishProcessingFn,\n                                       responseType\n                                   }) => (error, request) => {\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        const newBytes =\n            // although responseText \"should\" exist, this guard serves to prevent an error being\n            // thrown for two primary cases:\n            // 1. the mime type override stops working, or is not implemented for a specific\n            //    browser\n            // 2. when using mock XHR libraries like sinon that do not allow the override behavior\n            responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));\n        segment.stats = getRequestStats(request);\n        if (segment.key) {\n            segment.encryptedBytes = new Uint8Array(newBytes);\n        } else {\n            segment.bytes = new Uint8Array(newBytes);\n        }\n        return finishProcessingFn(null, segment);\n    };\n    const transmuxAndNotify = ({\n                                   segment,\n                                   bytes,\n                                   trackInfoFn,\n                                   timingInfoFn,\n                                   videoSegmentTimingInfoFn,\n                                   audioSegmentTimingInfoFn,\n                                   id3Fn,\n                                   captionsFn,\n                                   isEndOfTimeline,\n                                   endedTimelineFn,\n                                   dataFn,\n                                   doneFn,\n                                   onTransmuxerLog\n                               }) => {\n        const fmp4Tracks = segment.map && segment.map.tracks || {};\n        const isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video); // Keep references to each function so we can null them out after we're done with them.\n        // One reason for this is that in the case of full segments, we want to trust start\n        // times from the probe, rather than the transmuxer.\n\n        let audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');\n        const audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');\n        let videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');\n        const videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end');\n        const finish = () => transmux({\n            bytes,\n            transmuxer: segment.transmuxer,\n            audioAppendStart: segment.audioAppendStart,\n            gopsToAlignWith: segment.gopsToAlignWith,\n            remux: isMuxed,\n            onData: result => {\n                result.type = result.type === 'combined' ? 'video' : result.type;\n                dataFn(segment, result);\n            },\n            onTrackInfo: trackInfo => {\n                if (trackInfoFn) {\n                    if (isMuxed) {\n                        trackInfo.isMuxed = true;\n                    }\n                    trackInfoFn(segment, trackInfo);\n                }\n            },\n            onAudioTimingInfo: audioTimingInfo => {\n                // we only want the first start value we encounter\n                if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {\n                    audioStartFn(audioTimingInfo.start);\n                    audioStartFn = null;\n                } // we want to continually update the end time\n\n                if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {\n                    audioEndFn(audioTimingInfo.end);\n                }\n            },\n            onVideoTimingInfo: videoTimingInfo => {\n                // we only want the first start value we encounter\n                if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {\n                    videoStartFn(videoTimingInfo.start);\n                    videoStartFn = null;\n                } // we want to continually update the end time\n\n                if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {\n                    videoEndFn(videoTimingInfo.end);\n                }\n            },\n            onVideoSegmentTimingInfo: videoSegmentTimingInfo => {\n                videoSegmentTimingInfoFn(videoSegmentTimingInfo);\n            },\n            onAudioSegmentTimingInfo: audioSegmentTimingInfo => {\n                audioSegmentTimingInfoFn(audioSegmentTimingInfo);\n            },\n            onId3: (id3Frames, dispatchType) => {\n                id3Fn(segment, id3Frames, dispatchType);\n            },\n            onCaptions: captions => {\n                captionsFn(segment, [captions]);\n            },\n            isEndOfTimeline,\n            onEndedTimeline: () => {\n                endedTimelineFn();\n            },\n            onTransmuxerLog,\n            onDone: result => {\n                if (!doneFn) {\n                    return;\n                }\n                result.type = result.type === 'combined' ? 'video' : result.type;\n                doneFn(null, segment, result);\n            }\n        }); // In the transmuxer, we don't yet have the ability to extract a \"proper\" start time.\n        // Meaning cached frame data may corrupt our notion of where this segment\n        // really starts. To get around this, probe for the info needed.\n\n        workerCallback({\n            action: 'probeTs',\n            transmuxer: segment.transmuxer,\n            data: bytes,\n            baseStartTime: segment.baseStartTime,\n            callback: data => {\n                segment.bytes = bytes = data.data;\n                const probeResult = data.result;\n                if (probeResult) {\n                    trackInfoFn(segment, {\n                        hasAudio: probeResult.hasAudio,\n                        hasVideo: probeResult.hasVideo,\n                        isMuxed\n                    });\n                    trackInfoFn = null;\n                }\n                finish();\n            }\n        });\n    };\n    const handleSegmentBytes = ({\n                                    segment,\n                                    bytes,\n                                    trackInfoFn,\n                                    timingInfoFn,\n                                    videoSegmentTimingInfoFn,\n                                    audioSegmentTimingInfoFn,\n                                    id3Fn,\n                                    captionsFn,\n                                    isEndOfTimeline,\n                                    endedTimelineFn,\n                                    dataFn,\n                                    doneFn,\n                                    onTransmuxerLog\n                                }) => {\n        let bytesAsUint8Array = new Uint8Array(bytes); // TODO:\n        // We should have a handler that fetches the number of bytes required\n        // to check if something is fmp4. This will allow us to save bandwidth\n        // because we can only exclude a playlist and abort requests\n        // by codec after trackinfo triggers.\n\n        if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {\n            segment.isFmp4 = true;\n            const {\n                tracks\n            } = segment.map;\n            const trackInfo = {\n                isFmp4: true,\n                hasVideo: !!tracks.video,\n                hasAudio: !!tracks.audio\n            }; // if we have a audio track, with a codec that is not set to\n            // encrypted audio\n\n            if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {\n                trackInfo.audioCodec = tracks.audio.codec;\n            } // if we have a video track, with a codec that is not set to\n            // encrypted video\n\n            if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {\n                trackInfo.videoCodec = tracks.video.codec;\n            }\n            if (tracks.video && tracks.audio) {\n                trackInfo.isMuxed = true;\n            } // since we don't support appending fmp4 data on progress, we know we have the full\n            // segment here\n\n            trackInfoFn(segment, trackInfo); // The probe doesn't provide the segment end time, so only callback with the start\n            // time. The end time can be roughly calculated by the receiver using the duration.\n            //\n            // Note that the start time returned by the probe reflects the baseMediaDecodeTime, as\n            // that is the true start of the segment (where the playback engine should begin\n            // decoding).\n\n            const finishLoading = (captions, id3Frames) => {\n                // if the track still has audio at this point it is only possible\n                // for it to be audio only. See `tracks.video && tracks.audio` if statement\n                // above.\n                // we make sure to use segment.bytes here as that\n                dataFn(segment, {\n                    data: bytesAsUint8Array,\n                    type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'\n                });\n                if (id3Frames && id3Frames.length) {\n                    id3Fn(segment, id3Frames);\n                }\n                if (captions && captions.length) {\n                    captionsFn(segment, captions);\n                }\n                doneFn(null, segment, {});\n            };\n            workerCallback({\n                action: 'probeMp4StartTime',\n                timescales: segment.map.timescales,\n                data: bytesAsUint8Array,\n                transmuxer: segment.transmuxer,\n                callback: ({\n                               data,\n                               startTime\n                           }) => {\n                    // transfer bytes back to us\n                    bytes = data.buffer;\n                    segment.bytes = bytesAsUint8Array = data;\n                    if (trackInfo.hasAudio && !trackInfo.isMuxed) {\n                        timingInfoFn(segment, 'audio', 'start', startTime);\n                    }\n                    if (trackInfo.hasVideo) {\n                        timingInfoFn(segment, 'video', 'start', startTime);\n                    }\n                    workerCallback({\n                        action: 'probeEmsgID3',\n                        data: bytesAsUint8Array,\n                        transmuxer: segment.transmuxer,\n                        offset: startTime,\n                        callback: ({\n                                       emsgData,\n                                       id3Frames\n                                   }) => {\n                            // transfer bytes back to us\n                            bytes = emsgData.buffer;\n                            segment.bytes = bytesAsUint8Array = emsgData; // Run through the CaptionParser in case there are captions.\n                            // Initialize CaptionParser if it hasn't been yet\n\n                            if (!tracks.video || !emsgData.byteLength || !segment.transmuxer) {\n                                finishLoading(undefined, id3Frames);\n                                return;\n                            }\n                            workerCallback({\n                                action: 'pushMp4Captions',\n                                endAction: 'mp4Captions',\n                                transmuxer: segment.transmuxer,\n                                data: bytesAsUint8Array,\n                                timescales: segment.map.timescales,\n                                trackIds: [tracks.video.id],\n                                callback: message => {\n                                    // transfer bytes back to us\n                                    bytes = message.data.buffer;\n                                    segment.bytes = bytesAsUint8Array = message.data;\n                                    message.logs.forEach(function (log) {\n                                        onTransmuxerLog(merge(log, {\n                                            stream: 'mp4CaptionParser'\n                                        }));\n                                    });\n                                    finishLoading(message.captions, id3Frames);\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            return;\n        } // VTT or other segments that don't need processing\n\n        if (!segment.transmuxer) {\n            doneFn(null, segment, {});\n            return;\n        }\n        if (typeof segment.container === 'undefined') {\n            segment.container = detectContainerForBytes(bytesAsUint8Array);\n        }\n        if (segment.container !== 'ts' && segment.container !== 'aac') {\n            trackInfoFn(segment, {\n                hasAudio: false,\n                hasVideo: false\n            });\n            doneFn(null, segment, {});\n            return;\n        } // ts or aac\n\n        transmuxAndNotify({\n            segment,\n            bytes,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn,\n            doneFn,\n            onTransmuxerLog\n        });\n    };\n    const decrypt = function ({\n                                  id,\n                                  key,\n                                  encryptedBytes,\n                                  decryptionWorker\n                              }, callback) {\n        const decryptionHandler = event => {\n            if (event.data.source === id) {\n                decryptionWorker.removeEventListener('message', decryptionHandler);\n                const decrypted = event.data.decrypted;\n                callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));\n            }\n        };\n        decryptionWorker.addEventListener('message', decryptionHandler);\n        let keyBytes;\n        if (key.bytes.slice) {\n            keyBytes = key.bytes.slice();\n        } else {\n            keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));\n        } // incrementally decrypt the bytes\n\n        decryptionWorker.postMessage(createTransferableMessage({\n            source: id,\n            encrypted: encryptedBytes,\n            key: keyBytes,\n            iv: key.iv\n        }), [encryptedBytes.buffer, keyBytes.buffer]);\n    };\n    /**\n     * Decrypt the segment via the decryption web worker\n     *\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n     *                                       routines\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Function} doneFn - a callback that is executed after decryption has completed\n     */\n\n    const decryptSegment = ({\n                                decryptionWorker,\n                                segment,\n                                trackInfoFn,\n                                timingInfoFn,\n                                videoSegmentTimingInfoFn,\n                                audioSegmentTimingInfoFn,\n                                id3Fn,\n                                captionsFn,\n                                isEndOfTimeline,\n                                endedTimelineFn,\n                                dataFn,\n                                doneFn,\n                                onTransmuxerLog\n                            }) => {\n        decrypt({\n            id: segment.requestId,\n            key: segment.key,\n            encryptedBytes: segment.encryptedBytes,\n            decryptionWorker\n        }, decryptedBytes => {\n            segment.bytes = decryptedBytes;\n            handleSegmentBytes({\n                segment,\n                bytes: segment.bytes,\n                trackInfoFn,\n                timingInfoFn,\n                videoSegmentTimingInfoFn,\n                audioSegmentTimingInfoFn,\n                id3Fn,\n                captionsFn,\n                isEndOfTimeline,\n                endedTimelineFn,\n                dataFn,\n                doneFn,\n                onTransmuxerLog\n            });\n        });\n    };\n    /**\n     * This function waits for all XHRs to finish (with either success or failure)\n     * before continueing processing via it's callback. The function gathers errors\n     * from each request into a single errors array so that the error status for\n     * each request can be examined later.\n     *\n     * @param {Object} activeXhrs - an object that tracks all XHR requests\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n     *                                       routines\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} id3Fn - a callback that receives ID3 metadata\n     * @param {Function} captionsFn - a callback that receives captions\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Function} doneFn - a callback that is executed after all resources have been\n     *                            downloaded and any decryption completed\n     */\n\n    const waitForCompletion = ({\n                                   activeXhrs,\n                                   decryptionWorker,\n                                   trackInfoFn,\n                                   timingInfoFn,\n                                   videoSegmentTimingInfoFn,\n                                   audioSegmentTimingInfoFn,\n                                   id3Fn,\n                                   captionsFn,\n                                   isEndOfTimeline,\n                                   endedTimelineFn,\n                                   dataFn,\n                                   doneFn,\n                                   onTransmuxerLog\n                               }) => {\n        let count = 0;\n        let didError = false;\n        return (error, segment) => {\n            if (didError) {\n                return;\n            }\n            if (error) {\n                didError = true; // If there are errors, we have to abort any outstanding requests\n\n                abortAll(activeXhrs); // Even though the requests above are aborted, and in theory we could wait until we\n                // handle the aborted events from those requests, there are some cases where we may\n                // never get an aborted event. For instance, if the network connection is lost and\n                // there were two requests, the first may have triggered an error immediately, while\n                // the second request remains unsent. In that case, the aborted algorithm will not\n                // trigger an abort: see https://xhr.spec.whatwg.org/#the-abort()-method\n                //\n                // We also can't rely on the ready state of the XHR, since the request that\n                // triggered the connection error may also show as a ready state of 0 (unsent).\n                // Therefore, we have to finish this group of requests immediately after the first\n                // seen error.\n\n                return doneFn(error, segment);\n            }\n            count += 1;\n            if (count === activeXhrs.length) {\n                const segmentFinish = function () {\n                    if (segment.encryptedBytes) {\n                        return decryptSegment({\n                            decryptionWorker,\n                            segment,\n                            trackInfoFn,\n                            timingInfoFn,\n                            videoSegmentTimingInfoFn,\n                            audioSegmentTimingInfoFn,\n                            id3Fn,\n                            captionsFn,\n                            isEndOfTimeline,\n                            endedTimelineFn,\n                            dataFn,\n                            doneFn,\n                            onTransmuxerLog\n                        });\n                    } // Otherwise, everything is ready just continue\n\n                    handleSegmentBytes({\n                        segment,\n                        bytes: segment.bytes,\n                        trackInfoFn,\n                        timingInfoFn,\n                        videoSegmentTimingInfoFn,\n                        audioSegmentTimingInfoFn,\n                        id3Fn,\n                        captionsFn,\n                        isEndOfTimeline,\n                        endedTimelineFn,\n                        dataFn,\n                        doneFn,\n                        onTransmuxerLog\n                    });\n                }; // Keep track of when *all* of the requests have completed\n\n                segment.endOfAllRequests = Date.now();\n                if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {\n                    return decrypt({\n                        decryptionWorker,\n                        // add -init to the \"id\" to differentiate between segment\n                        // and init segment decryption, just in case they happen\n                        // at the same time at some point in the future.\n                        id: segment.requestId + '-init',\n                        encryptedBytes: segment.map.encryptedBytes,\n                        key: segment.map.key\n                    }, decryptedBytes => {\n                        segment.map.bytes = decryptedBytes;\n                        parseInitSegment(segment, parseError => {\n                            if (parseError) {\n                                abortAll(activeXhrs);\n                                return doneFn(parseError, segment);\n                            }\n                            segmentFinish();\n                        });\n                    });\n                }\n                segmentFinish();\n            }\n        };\n    };\n    /**\n     * Calls the abort callback if any request within the batch was aborted. Will only call\n     * the callback once per batch of requests, even if multiple were aborted.\n     *\n     * @param {Object} loadendState - state to check to see if the abort function was called\n     * @param {Function} abortFn - callback to call for abort\n     */\n\n    const handleLoadEnd = ({\n                               loadendState,\n                               abortFn\n                           }) => event => {\n        const request = event.target;\n        if (request.aborted && abortFn && !loadendState.calledAbortFn) {\n            abortFn();\n            loadendState.calledAbortFn = true;\n        }\n    };\n    /**\n     * Simple progress event callback handler that gathers some stats before\n     * executing a provided callback with the `segment` object\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} progressFn - a callback that is executed each time a progress event\n     *                                is received\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Event} event - the progress event object from XMLHttpRequest\n     */\n\n    const handleProgress = ({\n                                segment,\n                                progressFn,\n                                trackInfoFn,\n                                timingInfoFn,\n                                videoSegmentTimingInfoFn,\n                                audioSegmentTimingInfoFn,\n                                id3Fn,\n                                captionsFn,\n                                isEndOfTimeline,\n                                endedTimelineFn,\n                                dataFn\n                            }) => event => {\n        const request = event.target;\n        if (request.aborted) {\n            return;\n        }\n        segment.stats = merge(segment.stats, getProgressStats(event)); // record the time that we receive the first byte of data\n\n        if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n            segment.stats.firstBytesReceivedAt = Date.now();\n        }\n        return progressFn(event, segment);\n    };\n    /**\n     * Load all resources and does any processing necessary for a media-segment\n     *\n     * Features:\n     *   decrypts the media-segment if it has a key uri and an iv\n     *   aborts *all* requests if *any* one request fails\n     *\n     * The segment object, at minimum, has the following format:\n     * {\n     *   resolvedUri: String,\n     *   [transmuxer]: Object,\n     *   [byterange]: {\n     *     offset: Number,\n     *     length: Number\n     *   },\n     *   [key]: {\n     *     resolvedUri: String\n     *     [byterange]: {\n     *       offset: Number,\n     *       length: Number\n     *     },\n     *     iv: {\n     *       bytes: Uint32Array\n     *     }\n     *   },\n     *   [map]: {\n     *     resolvedUri: String,\n     *     [byterange]: {\n     *       offset: Number,\n     *       length: Number\n     *     },\n     *     [bytes]: Uint8Array\n     *   }\n     * }\n     * ...where [name] denotes optional properties\n     *\n     * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n     * @param {Object} xhrOptions - the base options to provide to all xhr requests\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n     *                                       decryption routines\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} abortFn - a callback called (only once) if any piece of a request was\n     *                             aborted\n     * @param {Function} progressFn - a callback that receives progress events from the main\n     *                                segment's xhr request\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} id3Fn - a callback that receives ID3 metadata\n     * @param {Function} captionsFn - a callback that receives captions\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that receives data from the main segment's xhr\n     *                            request, transmuxed if needed\n     * @param {Function} doneFn - a callback that is executed only once all requests have\n     *                            succeeded or failed\n     * @return {Function} a function that, when invoked, immediately aborts all\n     *                     outstanding requests\n     */\n\n    const mediaSegmentRequest = ({\n                                     xhr,\n                                     xhrOptions,\n                                     decryptionWorker,\n                                     segment,\n                                     abortFn,\n                                     progressFn,\n                                     trackInfoFn,\n                                     timingInfoFn,\n                                     videoSegmentTimingInfoFn,\n                                     audioSegmentTimingInfoFn,\n                                     id3Fn,\n                                     captionsFn,\n                                     isEndOfTimeline,\n                                     endedTimelineFn,\n                                     dataFn,\n                                     doneFn,\n                                     onTransmuxerLog\n                                 }) => {\n        const activeXhrs = [];\n        const finishProcessingFn = waitForCompletion({\n            activeXhrs,\n            decryptionWorker,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn,\n            doneFn,\n            onTransmuxerLog\n        }); // optionally, request the decryption key\n\n        if (segment.key && !segment.key.bytes) {\n            const objects = [segment.key];\n            if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {\n                objects.push(segment.map.key);\n            }\n            const keyRequestOptions = merge(xhrOptions, {\n                uri: segment.key.resolvedUri,\n                responseType: 'arraybuffer'\n            });\n            const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);\n            const keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n            activeXhrs.push(keyXhr);\n        } // optionally, request the associated media init segment\n\n        if (segment.map && !segment.map.bytes) {\n            const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);\n            if (differentMapKey) {\n                const mapKeyRequestOptions = merge(xhrOptions, {\n                    uri: segment.map.key.resolvedUri,\n                    responseType: 'arraybuffer'\n                });\n                const mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);\n                const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);\n                activeXhrs.push(mapKeyXhr);\n            }\n            const initSegmentOptions = merge(xhrOptions, {\n                uri: segment.map.resolvedUri,\n                responseType: 'arraybuffer',\n                headers: segmentXhrHeaders(segment.map)\n            });\n            const initSegmentRequestCallback = handleInitSegmentResponse({\n                segment,\n                finishProcessingFn\n            });\n            const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n            activeXhrs.push(initSegmentXhr);\n        }\n        const segmentRequestOptions = merge(xhrOptions, {\n            uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,\n            responseType: 'arraybuffer',\n            headers: segmentXhrHeaders(segment)\n        });\n        const segmentRequestCallback = handleSegmentResponse({\n            segment,\n            finishProcessingFn,\n            responseType: segmentRequestOptions.responseType\n        });\n        const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n        segmentXhr.addEventListener('progress', handleProgress({\n            segment,\n            progressFn,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn\n        }));\n        activeXhrs.push(segmentXhr); // since all parts of the request must be considered, but should not make callbacks\n        // multiple times, provide a shared state object\n\n        const loadendState = {};\n        activeXhrs.forEach(activeXhr => {\n            activeXhr.addEventListener('loadend', handleLoadEnd({\n                loadendState,\n                abortFn\n            }));\n        });\n        return () => abortAll(activeXhrs);\n    };\n\n    /**\n     * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n     * codec strings, or translating codec strings into objects that can be examined.\n     */\n    const logFn$1 = logger('CodecUtils');\n    /**\n     * Returns a set of codec strings parsed from the playlist or the default\n     * codec strings if no codecs were specified in the playlist\n     *\n     * @param {Playlist} media the current media playlist\n     * @return {Object} an object with the video and audio codecs\n     */\n\n    const getCodecs = function (media) {\n        // if the codecs were explicitly specified, use them instead of the\n        // defaults\n        const mediaAttributes = media.attributes || {};\n        if (mediaAttributes.CODECS) {\n            return parseCodecs(mediaAttributes.CODECS);\n        }\n    };\n    const isMaat = (main, media) => {\n        const mediaAttributes = media.attributes || {};\n        return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n    };\n    const isMuxed = (main, media) => {\n        if (!isMaat(main, media)) {\n            return true;\n        }\n        const mediaAttributes = media.attributes || {};\n        const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n        for (const groupId in audioGroup) {\n            // If an audio group has a URI (the case for HLS, as HLS will use external playlists),\n            // or there are listed playlists (the case for DASH, as the manifest will have already\n            // provided all of the details necessary to generate the audio playlist, as opposed to\n            // HLS' externally requested playlists), then the content is demuxed.\n            if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const unwrapCodecList = function (codecList) {\n        const codecs = {};\n        codecList.forEach(({\n                               mediaType,\n                               type,\n                               details\n                           }) => {\n            codecs[mediaType] = codecs[mediaType] || [];\n            codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));\n        });\n        Object.keys(codecs).forEach(function (mediaType) {\n            if (codecs[mediaType].length > 1) {\n                logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(', ')}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);\n                codecs[mediaType] = null;\n                return;\n            }\n            codecs[mediaType] = codecs[mediaType][0];\n        });\n        return codecs;\n    };\n    const codecCount = function (codecObj) {\n        let count = 0;\n        if (codecObj.audio) {\n            count++;\n        }\n        if (codecObj.video) {\n            count++;\n        }\n        return count;\n    };\n    /**\n     * Calculates the codec strings for a working configuration of\n     * SourceBuffers to play variant streams in a main playlist. If\n     * there is no possible working configuration, an empty object will be\n     * returned.\n     *\n     * @param main {Object} the m3u8 object for the main playlist\n     * @param media {Object} the m3u8 object for the variant playlist\n     * @return {Object} the codec strings.\n     *\n     * @private\n     */\n\n    const codecsForPlaylist = function (main, media) {\n        const mediaAttributes = media.attributes || {};\n        const codecInfo = unwrapCodecList(getCodecs(media) || []); // HLS with multiple-audio tracks must always get an audio codec.\n        // Put another way, there is no way to have a video-only multiple-audio HLS!\n\n        if (isMaat(main, media) && !codecInfo.audio) {\n            if (!isMuxed(main, media)) {\n                // It is possible for codecs to be specified on the audio media group playlist but\n                // not on the rendition playlist. This is mostly the case for DASH, where audio and\n                // video are always separate (and separately specified).\n                const defaultCodecs = unwrapCodecList(codecsFromDefault(main, mediaAttributes.AUDIO) || []);\n                if (defaultCodecs.audio) {\n                    codecInfo.audio = defaultCodecs.audio;\n                }\n            }\n        }\n        return codecInfo;\n    };\n    const logFn = logger('PlaylistSelector');\n    const representationToString = function (representation) {\n        if (!representation || !representation.playlist) {\n            return;\n        }\n        const playlist = representation.playlist;\n        return JSON.stringify({\n            id: playlist.id,\n            bandwidth: representation.bandwidth,\n            width: representation.width,\n            height: representation.height,\n            codecs: playlist.attributes && playlist.attributes.CODECS || ''\n        });\n    }; // Utilities\n\n    /**\n     * Returns the CSS value for the specified property on an element\n     * using `getComputedStyle`. Firefox has a long-standing issue where\n     * getComputedStyle() may return null when running in an iframe with\n     * `display: none`.\n     *\n     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n     * @param {HTMLElement} el the htmlelement to work on\n     * @param {string} the proprety to get the style for\n     */\n\n    const safeGetComputedStyle = function (el, property) {\n        if (!el) {\n            return '';\n        }\n        const result = window.getComputedStyle(el);\n        if (!result) {\n            return '';\n        }\n        return result[property];\n    };\n    /**\n     * Resuable stable sort function\n     *\n     * @param {Playlists} array\n     * @param {Function} sortFn Different comparators\n     * @function stableSort\n     */\n\n    const stableSort = function (array, sortFn) {\n        const newArray = array.slice();\n        array.sort(function (left, right) {\n            const cmp = sortFn(left, right);\n            if (cmp === 0) {\n                return newArray.indexOf(left) - newArray.indexOf(right);\n            }\n            return cmp;\n        });\n    };\n    /**\n     * A comparator function to sort two playlist object by bandwidth.\n     *\n     * @param {Object} left a media playlist object\n     * @param {Object} right a media playlist object\n     * @return {number} Greater than zero if the bandwidth attribute of\n     * left is greater than the corresponding attribute of right. Less\n     * than zero if the bandwidth of right is greater than left and\n     * exactly zero if the two are equal.\n     */\n\n    const comparePlaylistBandwidth = function (left, right) {\n        let leftBandwidth;\n        let rightBandwidth;\n        if (left.attributes.BANDWIDTH) {\n            leftBandwidth = left.attributes.BANDWIDTH;\n        }\n        leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n        if (right.attributes.BANDWIDTH) {\n            rightBandwidth = right.attributes.BANDWIDTH;\n        }\n        rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n        return leftBandwidth - rightBandwidth;\n    };\n    /**\n     * A comparator function to sort two playlist object by resolution (width).\n     *\n     * @param {Object} left a media playlist object\n     * @param {Object} right a media playlist object\n     * @return {number} Greater than zero if the resolution.width attribute of\n     * left is greater than the corresponding attribute of right. Less\n     * than zero if the resolution.width of right is greater than left and\n     * exactly zero if the two are equal.\n     */\n\n    const comparePlaylistResolution = function (left, right) {\n        let leftWidth;\n        let rightWidth;\n        if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n            leftWidth = left.attributes.RESOLUTION.width;\n        }\n        leftWidth = leftWidth || window.Number.MAX_VALUE;\n        if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n            rightWidth = right.attributes.RESOLUTION.width;\n        }\n        rightWidth = rightWidth || window.Number.MAX_VALUE; // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n        // have the same media dimensions/ resolution\n\n        if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n            return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n        }\n        return leftWidth - rightWidth;\n    };\n    /**\n     * Chooses the appropriate media playlist based on bandwidth and player size\n     *\n     * @param {Object} main\n     *        Object representation of the main manifest\n     * @param {number} playerBandwidth\n     *        Current calculated bandwidth of the player\n     * @param {number} playerWidth\n     *        Current width of the player element (should account for the device pixel ratio)\n     * @param {number} playerHeight\n     *        Current height of the player element (should account for the device pixel ratio)\n     * @param {boolean} limitRenditionByPlayerDimensions\n     *        True if the player width and height should be used during the selection, false otherwise\n     * @param {Object} playlistController\n     *        the current playlistController object\n     * @return {Playlist} the highest bitrate playlist less than the\n     * currently detected bandwidth, accounting for some amount of\n     * bandwidth variance\n     */\n\n    let simpleSelector = function (main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {\n        // If we end up getting called before `main` is available, exit early\n        if (!main) {\n            return;\n        }\n        const options = {\n            bandwidth: playerBandwidth,\n            width: playerWidth,\n            height: playerHeight,\n            limitRenditionByPlayerDimensions\n        };\n        let playlists = main.playlists; // if playlist is audio only, select between currently active audio group playlists.\n\n        if (Playlist.isAudioOnly(main)) {\n            playlists = playlistController.getAudioTrackPlaylists_(); // add audioOnly to options so that we log audioOnly: true\n            // at the buttom of this function for debugging.\n\n            options.audioOnly = true;\n        } // convert the playlists to an intermediary representation to make comparisons easier\n\n        let sortedPlaylistReps = playlists.map(playlist => {\n            let bandwidth;\n            const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n            const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n            bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;\n            bandwidth = bandwidth || window.Number.MAX_VALUE;\n            return {\n                bandwidth,\n                width,\n                height,\n                playlist\n            };\n        });\n        stableSort(sortedPlaylistReps, (left, right) => left.bandwidth - right.bandwidth); // filter out any playlists that have been excluded due to\n        // incompatible configurations\n\n        sortedPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isIncompatible(rep.playlist)); // filter out any playlists that have been disabled manually through the representations\n        // api or excluded temporarily due to playback errors.\n\n        let enabledPlaylistReps = sortedPlaylistReps.filter(rep => Playlist.isEnabled(rep.playlist));\n        if (!enabledPlaylistReps.length) {\n            // if there are no enabled playlists, then they have all been excluded or disabled\n            // by the user through the representations api. In this case, ignore exclusion and\n            // fallback to what the user wants by using playlists the user has not disabled.\n            enabledPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isDisabled(rep.playlist));\n        } // filter out any variant that has greater effective bitrate\n        // than the current estimated bandwidth\n\n        const bandwidthPlaylistReps = enabledPlaylistReps.filter(rep => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth);\n        let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1]; // get all of the renditions with the same (highest) bandwidth\n        // and then taking the very first element\n\n        const bandwidthBestRep = bandwidthPlaylistReps.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0]; // if we're not going to limit renditions by player size, make an early decision.\n\n        if (limitRenditionByPlayerDimensions === false) {\n            const chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n            if (chosenRep && chosenRep.playlist) {\n                let type = 'sortedPlaylistReps';\n                if (bandwidthBestRep) {\n                    type = 'bandwidthBestRep';\n                }\n                if (enabledPlaylistReps[0]) {\n                    type = 'enabledPlaylistReps';\n                }\n                logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n                return chosenRep.playlist;\n            }\n            logFn('could not choose a playlist with options', options);\n            return null;\n        } // filter out playlists without resolution information\n\n        const haveResolution = bandwidthPlaylistReps.filter(rep => rep.width && rep.height); // sort variants by resolution\n\n        stableSort(haveResolution, (left, right) => left.width - right.width); // if we have the exact resolution as the player use it\n\n        const resolutionBestRepList = haveResolution.filter(rep => rep.width === playerWidth && rep.height === playerHeight);\n        highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1]; // ensure that we pick the highest bandwidth variant that have exact resolution\n\n        const resolutionBestRep = resolutionBestRepList.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n        let resolutionPlusOneList;\n        let resolutionPlusOneSmallest;\n        let resolutionPlusOneRep; // find the smallest variant that is larger than the player\n        // if there is no match of exact resolution\n\n        if (!resolutionBestRep) {\n            resolutionPlusOneList = haveResolution.filter(rep => rep.width > playerWidth || rep.height > playerHeight); // find all the variants have the same smallest resolution\n\n            resolutionPlusOneSmallest = resolutionPlusOneList.filter(rep => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height); // ensure that we also pick the highest bandwidth variant that\n            // is just-larger-than the video player\n\n            highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n            resolutionPlusOneRep = resolutionPlusOneSmallest.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n        }\n        let leastPixelDiffRep; // If this selector proves to be better than others,\n        // resolutionPlusOneRep and resolutionBestRep and all\n        // the code involving them should be removed.\n\n        if (playlistController.leastPixelDiffSelector) {\n            // find the variant that is closest to the player's pixel size\n            const leastPixelDiffList = haveResolution.map(rep => {\n                rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);\n                return rep;\n            }); // get the highest bandwidth, closest resolution playlist\n\n            stableSort(leastPixelDiffList, (left, right) => {\n                // sort by highest bandwidth if pixelDiff is the same\n                if (left.pixelDiff === right.pixelDiff) {\n                    return right.bandwidth - left.bandwidth;\n                }\n                return left.pixelDiff - right.pixelDiff;\n            });\n            leastPixelDiffRep = leastPixelDiffList[0];\n        } // fallback chain of variants\n\n        const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n        if (chosenRep && chosenRep.playlist) {\n            let type = 'sortedPlaylistReps';\n            if (leastPixelDiffRep) {\n                type = 'leastPixelDiffRep';\n            } else if (resolutionPlusOneRep) {\n                type = 'resolutionPlusOneRep';\n            } else if (resolutionBestRep) {\n                type = 'resolutionBestRep';\n            } else if (bandwidthBestRep) {\n                type = 'bandwidthBestRep';\n            } else if (enabledPlaylistReps[0]) {\n                type = 'enabledPlaylistReps';\n            }\n            logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n            return chosenRep.playlist;\n        }\n        logFn('could not choose a playlist with options', options);\n        return null;\n    };\n\n    /**\n     * Chooses the appropriate media playlist based on the most recent\n     * bandwidth estimate and the player size.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @return {Playlist} the highest bitrate playlist less than the\n     * currently detected bandwidth, accounting for some amount of\n     * bandwidth variance\n     */\n\n    const lastBandwidthSelector = function () {\n        const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n        return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n    };\n    /**\n     * Chooses the appropriate media playlist based on an\n     * exponential-weighted moving average of the bandwidth after\n     * filtering for player size.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @param {number} decay - a number between 0 and 1. Higher values of\n     * this parameter will cause previous bandwidth estimates to lose\n     * significance more quickly.\n     * @return {Function} a function which can be invoked to create a new\n     * playlist selector function.\n     * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n     */\n\n    const movingAverageBandwidthSelector = function (decay) {\n        let average = -1;\n        let lastSystemBandwidth = -1;\n        if (decay < 0 || decay > 1) {\n            throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n        }\n        return function () {\n            const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n            if (average < 0) {\n                average = this.systemBandwidth;\n                lastSystemBandwidth = this.systemBandwidth;\n            } // stop the average value from decaying for every 250ms\n            // when the systemBandwidth is constant\n            // and\n            // stop average from setting to a very low value when the\n            // systemBandwidth becomes 0 in case of chunk cancellation\n\n            if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {\n                average = decay * this.systemBandwidth + (1 - decay) * average;\n                lastSystemBandwidth = this.systemBandwidth;\n            }\n            return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n        };\n    };\n    /**\n     * Chooses the appropriate media playlist based on the potential to rebuffer\n     *\n     * @param {Object} settings\n     *        Object of information required to use this selector\n     * @param {Object} settings.main\n     *        Object representation of the main manifest\n     * @param {number} settings.currentTime\n     *        The current time of the player\n     * @param {number} settings.bandwidth\n     *        Current measured bandwidth\n     * @param {number} settings.duration\n     *        Duration of the media\n     * @param {number} settings.segmentDuration\n     *        Segment duration to be used in round trip time calculations\n     * @param {number} settings.timeUntilRebuffer\n     *        Time left in seconds until the player has to rebuffer\n     * @param {number} settings.currentTimeline\n     *        The current timeline segments are being loaded from\n     * @param {SyncController} settings.syncController\n     *        SyncController for determining if we have a sync point for a given playlist\n     * @return {Object|null}\n     *         {Object} return.playlist\n     *         The highest bandwidth playlist with the least amount of rebuffering\n     *         {Number} return.rebufferingImpact\n     *         The amount of time in seconds switching to this playlist will rebuffer. A\n     *         negative value means that switching will cause zero rebuffering.\n     */\n\n    const minRebufferMaxBandwidthSelector = function (settings) {\n        const {\n            main,\n            currentTime,\n            bandwidth,\n            duration,\n            segmentDuration,\n            timeUntilRebuffer,\n            currentTimeline,\n            syncController\n        } = settings; // filter out any playlists that have been excluded due to\n        // incompatible configurations\n\n        const compatiblePlaylists = main.playlists.filter(playlist => !Playlist.isIncompatible(playlist)); // filter out any playlists that have been disabled manually through the representations\n        // api or excluded temporarily due to playback errors.\n\n        let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\n        if (!enabledPlaylists.length) {\n            // if there are no enabled playlists, then they have all been excluded or disabled\n            // by the user through the representations api. In this case, ignore exclusion and\n            // fallback to what the user wants by using playlists the user has not disabled.\n            enabledPlaylists = compatiblePlaylists.filter(playlist => !Playlist.isDisabled(playlist));\n        }\n        const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\n        const rebufferingEstimates = bandwidthPlaylists.map(playlist => {\n            const syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime); // If there is no sync point for this playlist, switching to it will require a\n            // sync request first. This will double the request time\n\n            const numRequests = syncPoint ? 1 : 2;\n            const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n            const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n            return {\n                playlist,\n                rebufferingImpact\n            };\n        });\n        const noRebufferingPlaylists = rebufferingEstimates.filter(estimate => estimate.rebufferingImpact <= 0); // Sort by bandwidth DESC\n\n        stableSort(noRebufferingPlaylists, (a, b) => comparePlaylistBandwidth(b.playlist, a.playlist));\n        if (noRebufferingPlaylists.length) {\n            return noRebufferingPlaylists[0];\n        }\n        stableSort(rebufferingEstimates, (a, b) => a.rebufferingImpact - b.rebufferingImpact);\n        return rebufferingEstimates[0] || null;\n    };\n    /**\n     * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n     * one with video.  If no renditions with video exist, return the lowest audio rendition.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @return {Object|null}\n     *         {Object} return.playlist\n     *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n     *         exists pick the lowest audio rendition.\n     */\n\n    const lowestBitrateCompatibleVariantSelector = function () {\n        // filter out any playlists that have been excluded due to\n        // incompatible configurations or playback errors\n        const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled); // Sort ascending by bitrate\n\n        stableSort(playlists, (a, b) => comparePlaylistBandwidth(a, b)); // Parse and assume that playlists with no video codec have no video\n        // (this is not necessarily true, although it is generally true).\n        //\n        // If an entire manifest has no valid videos everything will get filtered\n        // out.\n\n        const playlistsWithVideo = playlists.filter(playlist => !!codecsForPlaylist(this.playlists.main, playlist).video);\n        return playlistsWithVideo[0] || null;\n    };\n\n    /**\n     * Combine all segments into a single Uint8Array\n     *\n     * @param {Object} segmentObj\n     * @return {Uint8Array} concatenated bytes\n     * @private\n     */\n    const concatSegments = segmentObj => {\n        let offset = 0;\n        let tempBuffer;\n        if (segmentObj.bytes) {\n            tempBuffer = new Uint8Array(segmentObj.bytes); // combine the individual segments into one large typed-array\n\n            segmentObj.segments.forEach(segment => {\n                tempBuffer.set(segment, offset);\n                offset += segment.byteLength;\n            });\n        }\n        return tempBuffer;\n    };\n\n    /**\n     * @file text-tracks.js\n     */\n    /**\n     * Create captions text tracks on video.js if they do not exist\n     *\n     * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n     * @param {Object} tech the video.js tech\n     * @param {Object} captionStream the caption stream to create\n     * @private\n     */\n\n    const createCaptionsTrackIfNotExists = function (inbandTextTracks, tech, captionStream) {\n        if (!inbandTextTracks[captionStream]) {\n            tech.trigger({\n                type: 'usage',\n                name: 'vhs-608'\n            });\n            let instreamId = captionStream; // we need to translate SERVICEn for 708 to how mux.js currently labels them\n\n            if (/^cc708_/.test(captionStream)) {\n                instreamId = 'SERVICE' + captionStream.split('_')[1];\n            }\n            const track = tech.textTracks().getTrackById(instreamId);\n            if (track) {\n                // Resuse an existing track with a CC# id because this was\n                // very likely created by videojs-contrib-hls from information\n                // in the m3u8 for us to use\n                inbandTextTracks[captionStream] = track;\n            } else {\n                // This section gets called when we have caption services that aren't specified in the manifest.\n                // Manifest level caption services are handled in media-groups.js under CLOSED-CAPTIONS.\n                const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n                let label = captionStream;\n                let language = captionStream;\n                let def = false;\n                const captionService = captionServices[instreamId];\n                if (captionService) {\n                    label = captionService.label;\n                    language = captionService.language;\n                    def = captionService.default;\n                } // Otherwise, create a track with the default `CC#` label and\n                // without a language\n\n                inbandTextTracks[captionStream] = tech.addRemoteTextTrack({\n                    kind: 'captions',\n                    id: instreamId,\n                    // TODO: investigate why this doesn't seem to turn the caption on by default\n                    default: def,\n                    label,\n                    language\n                }, false).track;\n            }\n        }\n    };\n    /**\n     * Add caption text track data to a source handler given an array of captions\n     *\n     * @param {Object}\n     *   @param {Object} inbandTextTracks the inband text tracks\n     *   @param {number} timestampOffset the timestamp offset of the source buffer\n     *   @param {Array} captionArray an array of caption data\n     * @private\n     */\n\n    const addCaptionData = function ({\n                                         inbandTextTracks,\n                                         captionArray,\n                                         timestampOffset\n                                     }) {\n        if (!captionArray) {\n            return;\n        }\n        const Cue = window.WebKitDataCue || window.VTTCue;\n        captionArray.forEach(caption => {\n            const track = caption.stream; // in CEA 608 captions, video.js/mux.js sends a content array\n            // with positioning data\n\n            if (caption.content) {\n                caption.content.forEach(value => {\n                    const cue = new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, value.text);\n                    cue.line = value.line;\n                    cue.align = 'left';\n                    cue.position = value.position;\n                    cue.positionAlign = 'line-left';\n                    inbandTextTracks[track].addCue(cue);\n                });\n            } else {\n                // otherwise, a text value with combined captions is sent\n                inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));\n            }\n        });\n    };\n    /**\n     * Define properties on a cue for backwards compatability,\n     * but warn the user that the way that they are using it\n     * is depricated and will be removed at a later date.\n     *\n     * @param {Cue} cue the cue to add the properties on\n     * @private\n     */\n\n    const deprecateOldCue = function (cue) {\n        Object.defineProperties(cue.frame, {\n            id: {\n                get() {\n                    videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n                    return cue.value.key;\n                }\n            },\n            value: {\n                get() {\n                    videojs.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n                    return cue.value.data;\n                }\n            },\n            privateData: {\n                get() {\n                    videojs.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n                    return cue.value.data;\n                }\n            }\n        });\n    };\n    /**\n     * Add metadata text track data to a source handler given an array of metadata\n     *\n     * @param {Object}\n     *   @param {Object} inbandTextTracks the inband text tracks\n     *   @param {Array} metadataArray an array of meta data\n     *   @param {number} timestampOffset the timestamp offset of the source buffer\n     *   @param {number} videoDuration the duration of the video\n     * @private\n     */\n\n    const addMetadata = ({\n                             inbandTextTracks,\n                             metadataArray,\n                             timestampOffset,\n                             videoDuration\n                         }) => {\n        if (!metadataArray) {\n            return;\n        }\n        const Cue = window.WebKitDataCue || window.VTTCue;\n        const metadataTrack = inbandTextTracks.metadataTrack_;\n        if (!metadataTrack) {\n            return;\n        }\n        metadataArray.forEach(metadata => {\n            const time = metadata.cueTime + timestampOffset; // if time isn't a finite number between 0 and Infinity, like NaN,\n            // ignore this bit of metadata.\n            // This likely occurs when you have an non-timed ID3 tag like TIT2,\n            // which is the \"Title/Songname/Content description\" frame\n\n            if (typeof time !== 'number' || window.isNaN(time) || time < 0 || !(time < Infinity)) {\n                return;\n            } // If we have no frames, we can't create a cue.\n\n            if (!metadata.frames || !metadata.frames.length) {\n                return;\n            }\n            metadata.frames.forEach(frame => {\n                const cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n                cue.frame = frame;\n                cue.value = frame;\n                deprecateOldCue(cue);\n                metadataTrack.addCue(cue);\n            });\n        });\n        if (!metadataTrack.cues || !metadataTrack.cues.length) {\n            return;\n        } // Updating the metadeta cues so that\n        // the endTime of each cue is the startTime of the next cue\n        // the endTime of last cue is the duration of the video\n\n        const cues = metadataTrack.cues;\n        const cuesArray = []; // Create a copy of the TextTrackCueList...\n        // ...disregarding cues with a falsey value\n\n        for (let i = 0; i < cues.length; i++) {\n            if (cues[i]) {\n                cuesArray.push(cues[i]);\n            }\n        } // Group cues by their startTime value\n\n        const cuesGroupedByStartTime = cuesArray.reduce((obj, cue) => {\n            const timeSlot = obj[cue.startTime] || [];\n            timeSlot.push(cue);\n            obj[cue.startTime] = timeSlot;\n            return obj;\n        }, {}); // Sort startTimes by ascending order\n\n        const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort((a, b) => Number(a) - Number(b)); // Map each cue group's endTime to the next group's startTime\n\n        sortedStartTimes.forEach((startTime, idx) => {\n            const cueGroup = cuesGroupedByStartTime[startTime];\n            const finiteDuration = isFinite(videoDuration) ? videoDuration : startTime;\n            const nextTime = Number(sortedStartTimes[idx + 1]) || finiteDuration; // Map each cue's endTime the next group's startTime\n\n            cueGroup.forEach(cue => {\n                cue.endTime = nextTime;\n            });\n        });\n    }; // object for mapping daterange attributes\n\n    const dateRangeAttr = {\n        id: 'ID',\n        class: 'CLASS',\n        startDate: 'START-DATE',\n        duration: 'DURATION',\n        endDate: 'END-DATE',\n        endOnNext: 'END-ON-NEXT',\n        plannedDuration: 'PLANNED-DURATION',\n        scte35Out: 'SCTE35-OUT',\n        scte35In: 'SCTE35-IN'\n    };\n    const dateRangeKeysToOmit = new Set(['id', 'class', 'startDate', 'duration', 'endDate', 'endOnNext', 'startTime', 'endTime', 'processDateRange']);\n    /**\n     * Add DateRange metadata text track to a source handler given an array of metadata\n     *\n     * @param {Object}\n     *   @param {Object} inbandTextTracks the inband text tracks\n     *   @param {Array} dateRanges parsed media playlist\n     * @private\n     */\n\n    const addDateRangeMetadata = ({\n                                      inbandTextTracks,\n                                      dateRanges\n                                  }) => {\n        const metadataTrack = inbandTextTracks.metadataTrack_;\n        if (!metadataTrack) {\n            return;\n        }\n        const Cue = window.WebKitDataCue || window.VTTCue;\n        dateRanges.forEach(dateRange => {\n            // we generate multiple cues for each date range with different attributes\n            for (const key of Object.keys(dateRange)) {\n                if (dateRangeKeysToOmit.has(key)) {\n                    continue;\n                }\n                const cue = new Cue(dateRange.startTime, dateRange.endTime, '');\n                cue.id = dateRange.id;\n                cue.type = 'com.apple.quicktime.HLS';\n                cue.value = {\n                    key: dateRangeAttr[key],\n                    data: dateRange[key]\n                };\n                if (key === 'scte35Out' || key === 'scte35In') {\n                    cue.value.data = new Uint8Array(cue.value.data.match(/[\\da-f]{2}/gi)).buffer;\n                }\n                metadataTrack.addCue(cue);\n            }\n            dateRange.processDateRange();\n        });\n    };\n    /**\n     * Create metadata text track on video.js if it does not exist\n     *\n     * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n     * @param {string} dispatchType the inband metadata track dispatch type\n     * @param {Object} tech the video.js tech\n     * @private\n     */\n\n    const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {\n        if (inbandTextTracks.metadataTrack_) {\n            return;\n        }\n        inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({\n            kind: 'metadata',\n            label: 'Timed Metadata'\n        }, false).track;\n        if (!videojs.browser.IS_ANY_SAFARI) {\n            inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;\n        }\n    };\n    /**\n     * Remove cues from a track on video.js.\n     *\n     * @param {Double} start start of where we should remove the cue\n     * @param {Double} end end of where the we should remove the cue\n     * @param {Object} track the text track to remove the cues from\n     * @private\n     */\n\n    const removeCuesFromTrack = function (start, end, track) {\n        let i;\n        let cue;\n        if (!track) {\n            return;\n        }\n        if (!track.cues) {\n            return;\n        }\n        i = track.cues.length;\n        while (i--) {\n            cue = track.cues[i]; // Remove any cue within the provided start and end time\n\n            if (cue.startTime >= start && cue.endTime <= end) {\n                track.removeCue(cue);\n            }\n        }\n    };\n    /**\n     * Remove duplicate cues from a track on video.js (a cue is considered a\n     * duplicate if it has the same time interval and text as another)\n     *\n     * @param {Object} track the text track to remove the duplicate cues from\n     * @private\n     */\n\n    const removeDuplicateCuesFromTrack = function (track) {\n        const cues = track.cues;\n        if (!cues) {\n            return;\n        }\n        const uniqueCues = {};\n        for (let i = cues.length - 1; i >= 0; i--) {\n            const cue = cues[i];\n            const cueKey = `${cue.startTime}-${cue.endTime}-${cue.text}`;\n            if (uniqueCues[cueKey]) {\n                track.removeCue(cue);\n            } else {\n                uniqueCues[cueKey] = cue;\n            }\n        }\n    };\n\n    /**\n     * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n     * front of current time.\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {number} currentTime\n     *        The current time\n     * @param {Double} mapping\n     *        Offset to map display time to stream presentation time\n     * @return {Array}\n     *         List of gops considered safe to append over\n     */\n\n    const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {\n        if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {\n            return [];\n        } // pts value for current time + 3 seconds to give a bit more wiggle room\n\n        const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);\n        let i;\n        for (i = 0; i < buffer.length; i++) {\n            if (buffer[i].pts > currentTimePts) {\n                break;\n            }\n        }\n        return buffer.slice(i);\n    };\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {Array} gops\n     *        List of new gop information\n     * @param {boolean} replace\n     *        If true, replace the buffer with the new gop information. If false, append the\n     *        new gop information to the buffer in the right location of time.\n     * @return {Array}\n     *         Updated list of gop information\n     */\n\n    const updateGopBuffer = (buffer, gops, replace) => {\n        if (!gops.length) {\n            return buffer;\n        }\n        if (replace) {\n            // If we are in safe append mode, then completely overwrite the gop buffer\n            // with the most recent appeneded data. This will make sure that when appending\n            // future segments, we only try to align with gops that are both ahead of current\n            // time and in the last segment appended.\n            return gops.slice();\n        }\n        const start = gops[0].pts;\n        let i = 0;\n        for (i; i < buffer.length; i++) {\n            if (buffer[i].pts >= start) {\n                break;\n            }\n        }\n        return buffer.slice(0, i).concat(gops);\n    };\n    /**\n     * Removes gop information in buffer that overlaps with provided start and end\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {Double} start\n     *        position to start the remove at\n     * @param {Double} end\n     *        position to end the remove at\n     * @param {Double} mapping\n     *        Offset to map display time to stream presentation time\n     */\n\n    const removeGopBuffer = (buffer, start, end, mapping) => {\n        const startPts = Math.ceil((start - mapping) * clock_1);\n        const endPts = Math.ceil((end - mapping) * clock_1);\n        const updatedBuffer = buffer.slice();\n        let i = buffer.length;\n        while (i--) {\n            if (buffer[i].pts <= endPts) {\n                break;\n            }\n        }\n        if (i === -1) {\n            // no removal because end of remove range is before start of buffer\n            return updatedBuffer;\n        }\n        let j = i + 1;\n        while (j--) {\n            if (buffer[j].pts <= startPts) {\n                break;\n            }\n        } // clamp remove range start to 0 index\n\n        j = Math.max(j, 0);\n        updatedBuffer.splice(j, i - j + 1);\n        return updatedBuffer;\n    };\n    const shallowEqual = function (a, b) {\n        // if both are undefined\n        // or one or the other is undefined\n        // they are not equal\n        if (!a && !b || !a && b || a && !b) {\n            return false;\n        } // they are the same object and thus, equal\n\n        if (a === b) {\n            return true;\n        } // sort keys so we can make sure they have\n        // all the same keys later.\n\n        const akeys = Object.keys(a).sort();\n        const bkeys = Object.keys(b).sort(); // different number of keys, not equal\n\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (let i = 0; i < akeys.length; i++) {\n            const key = akeys[i]; // different sorted keys, not equal\n\n            if (key !== bkeys[i]) {\n                return false;\n            } // different values, not equal\n\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // https://www.w3.org/TR/WebIDL-1/#quotaexceedederror\n    const QUOTA_EXCEEDED_ERR = 22;\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Array} segments - the segments array from a playlist.\n     * @return {number} An index of a segment from the playlist to load\n     */\n\n    const getSyncSegmentCandidate = function (currentTimeline, segments, targetTime) {\n        segments = segments || [];\n        const timelineSegments = [];\n        let time = 0;\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n            if (currentTimeline === segment.timeline) {\n                timelineSegments.push(i);\n                time += segment.duration;\n                if (time > targetTime) {\n                    return i;\n                }\n            }\n        }\n        if (timelineSegments.length === 0) {\n            return 0;\n        } // default to the last timeline segment\n\n        return timelineSegments[timelineSegments.length - 1];\n    }; // In the event of a quota exceeded error, keep at least one second of back buffer. This\n    // number was arbitrarily chosen and may be updated in the future, but seemed reasonable\n    // as a start to prevent any potential issues with removing content too close to the\n    // playhead.\n\n    const MIN_BACK_BUFFER = 1; // in ms\n\n    const CHECK_BUFFER_DELAY = 500;\n    const finite = num => typeof num === 'number' && isFinite(num); // With most content hovering around 30fps, if a segment has a duration less than a half\n    // frame at 30fps or one frame at 60fps, the bandwidth and throughput calculations will\n    // not accurately reflect the rest of the content.\n\n    const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;\n    const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {\n        // Although these checks should most likely cover non 'main' types, for now it narrows\n        // the scope of our checks.\n        if (loaderType !== 'main' || !startingMedia || !trackInfo) {\n            return null;\n        }\n        if (!trackInfo.hasAudio && !trackInfo.hasVideo) {\n            return 'Neither audio nor video found in segment.';\n        }\n        if (startingMedia.hasVideo && !trackInfo.hasVideo) {\n            return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n        }\n        if (!startingMedia.hasVideo && trackInfo.hasVideo) {\n            return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n        }\n        return null;\n    };\n    /**\n     * Calculates a time value that is safe to remove from the back buffer without interrupting\n     * playback.\n     *\n     * @param {TimeRange} seekable\n     *        The current seekable range\n     * @param {number} currentTime\n     *        The current time of the player\n     * @param {number} targetDuration\n     *        The target duration of the current playlist\n     * @return {number}\n     *         Time that is safe to remove from the back buffer without interrupting playback\n     */\n\n    const safeBackBufferTrimTime = (seekable, currentTime, targetDuration) => {\n        // 30 seconds before the playhead provides a safe default for trimming.\n        //\n        // Choosing a reasonable default is particularly important for high bitrate content and\n        // VOD videos/live streams with large windows, as the buffer may end up overfilled and\n        // throw an APPEND_BUFFER_ERR.\n        let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;\n        if (seekable.length) {\n            // Some live playlists may have a shorter window of content than the full allowed back\n            // buffer. For these playlists, don't save content that's no longer within the window.\n            trimTime = Math.max(trimTime, seekable.start(0));\n        } // Don't remove within target duration of the current time to avoid the possibility of\n        // removing the GOP currently being played, as removing it can cause playback stalls.\n\n        const maxTrimTime = currentTime - targetDuration;\n        return Math.min(maxTrimTime, trimTime);\n    };\n    const segmentInfoString = segmentInfo => {\n        const {\n            startOfSegment,\n            duration,\n            segment,\n            part,\n            playlist: {\n                mediaSequence: seq,\n                id,\n                segments = []\n            },\n            mediaIndex: index,\n            partIndex,\n            timeline\n        } = segmentInfo;\n        const segmentLen = segments.length - 1;\n        let selection = 'mediaIndex/partIndex increment';\n        if (segmentInfo.getMediaInfoForTime) {\n            selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`;\n        } else if (segmentInfo.isSyncRequest) {\n            selection = 'getSyncSegmentCandidate (isSyncRequest)';\n        }\n        if (segmentInfo.independent) {\n            selection += ` with independent ${segmentInfo.independent}`;\n        }\n        const hasPartIndex = typeof partIndex === 'number';\n        const name = segmentInfo.segment.uri ? 'segment' : 'pre-segment';\n        const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({\n            preloadSegment: segment\n        }) - 1 : 0;\n        return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : '') + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : '') + ` startOfSegment [${startOfSegment}]` + ` duration [${duration}]` + ` timeline [${timeline}]` + ` selected by [${selection}]` + ` playlist [${id}]`;\n    };\n    const timingInfoPropertyForMedia = mediaType => `${mediaType}TimingInfo`;\n    /**\n     * Returns the timestamp offset to use for the segment.\n     *\n     * @param {number} segmentTimeline\n     *        The timeline of the segment\n     * @param {number} currentTimeline\n     *        The timeline currently being followed by the loader\n     * @param {number} startOfSegment\n     *        The estimated segment start\n     * @param {TimeRange[]} buffered\n     *        The loader's buffer\n     * @param {boolean} overrideCheck\n     *        If true, no checks are made to see if the timestamp offset value should be set,\n     *        but sets it directly to a value.\n     *\n     * @return {number|null}\n     *         Either a number representing a new timestamp offset, or null if the segment is\n     *         part of the same timeline\n     */\n\n    const timestampOffsetForSegment = ({\n                                           segmentTimeline,\n                                           currentTimeline,\n                                           startOfSegment,\n                                           buffered,\n                                           overrideCheck\n                                       }) => {\n        // Check to see if we are crossing a discontinuity to see if we need to set the\n        // timestamp offset on the transmuxer and source buffer.\n        //\n        // Previously, we changed the timestampOffset if the start of this segment was less than\n        // the currently set timestampOffset, but this isn't desirable as it can produce bad\n        // behavior, especially around long running live streams.\n        if (!overrideCheck && segmentTimeline === currentTimeline) {\n            return null;\n        } // When changing renditions, it's possible to request a segment on an older timeline. For\n        // instance, given two renditions with the following:\n        //\n        // #EXTINF:10\n        // segment1\n        // #EXT-X-DISCONTINUITY\n        // #EXTINF:10\n        // segment2\n        // #EXTINF:10\n        // segment3\n        //\n        // And the current player state:\n        //\n        // current time: 8\n        // buffer: 0 => 20\n        //\n        // The next segment on the current rendition would be segment3, filling the buffer from\n        // 20s onwards. However, if a rendition switch happens after segment2 was requested,\n        // then the next segment to be requested will be segment1 from the new rendition in\n        // order to fill time 8 and onwards. Using the buffered end would result in repeated\n        // content (since it would position segment1 of the new rendition starting at 20s). This\n        // case can be identified when the new segment's timeline is a prior value. Instead of\n        // using the buffered end, the startOfSegment can be used, which, hopefully, will be\n        // more accurate to the actual start time of the segment.\n\n        if (segmentTimeline < currentTimeline) {\n            return startOfSegment;\n        } // segmentInfo.startOfSegment used to be used as the timestamp offset, however, that\n        // value uses the end of the last segment if it is available. While this value\n        // should often be correct, it's better to rely on the buffered end, as the new\n        // content post discontinuity should line up with the buffered end as if it were\n        // time 0 for the new content.\n\n        return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;\n    };\n    /**\n     * Returns whether or not the loader should wait for a timeline change from the timeline\n     * change controller before processing the segment.\n     *\n     * Primary timing in VHS goes by video. This is different from most media players, as\n     * audio is more often used as the primary timing source. For the foreseeable future, VHS\n     * will continue to use video as the primary timing source, due to the current logic and\n     * expectations built around it.\n\n     * Since the timing follows video, in order to maintain sync, the video loader is\n     * responsible for setting both audio and video source buffer timestamp offsets.\n     *\n     * Setting different values for audio and video source buffers could lead to\n     * desyncing. The following examples demonstrate some of the situations where this\n     * distinction is important. Note that all of these cases involve demuxed content. When\n     * content is muxed, the audio and video are packaged together, therefore syncing\n     * separate media playlists is not an issue.\n     *\n     * CASE 1: Audio prepares to load a new timeline before video:\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:                     ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader              ^\n     *\n     * In the above example, the audio loader is preparing to load the 6th segment, the first\n     * after a discontinuity, while the video loader is still loading the 5th segment, before\n     * the discontinuity.\n     *\n     * If the audio loader goes ahead and loads and appends the 6th segment before the video\n     * loader crosses the discontinuity, then when appended, the 6th audio segment will use\n     * the timestamp offset from timeline 0. This will likely lead to desyncing. In addition,\n     * the audio loader must provide the audioAppendStart value to trim the content in the\n     * transmuxer, and that value relies on the audio timestamp offset. Since the audio\n     * timestamp offset is set by the video (main) loader, the audio loader shouldn't load the\n     * segment until that value is provided.\n     *\n     * CASE 2: Video prepares to load a new timeline before audio:\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:             ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader                      ^\n     *\n     * In the above example, the video loader is preparing to load the 6th segment, the first\n     * after a discontinuity, while the audio loader is still loading the 5th segment, before\n     * the discontinuity.\n     *\n     * If the video loader goes ahead and loads and appends the 6th segment, then once the\n     * segment is loaded and processed, both the video and audio timestamp offsets will be\n     * set, since video is used as the primary timing source. This is to ensure content lines\n     * up appropriately, as any modifications to the video timing are reflected by audio when\n     * the video loader sets the audio and video timestamp offsets to the same value. However,\n     * setting the timestamp offset for audio before audio has had a chance to change\n     * timelines will likely lead to desyncing, as the audio loader will append segment 5 with\n     * a timestamp intended to apply to segments from timeline 1 rather than timeline 0.\n     *\n     * CASE 3: When seeking, audio prepares to load a new timeline before video\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:           ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader            ^\n     *\n     * In the above example, both audio and video loaders are loading segments from timeline\n     * 0, but imagine that the seek originated from timeline 1.\n     *\n     * When seeking to a new timeline, the timestamp offset will be set based on the expected\n     * segment start of the loaded video segment. In order to maintain sync, the audio loader\n     * must wait for the video loader to load its segment and update both the audio and video\n     * timestamp offsets before it may load and append its own segment. This is the case\n     * whether the seek results in a mismatched segment request (e.g., the audio loader\n     * chooses to load segment 3 and the video loader chooses to load segment 4) or the\n     * loaders choose to load the same segment index from each playlist, as the segments may\n     * not be aligned perfectly, even for matching segment indexes.\n     *\n     * @param {Object} timelinechangeController\n     * @param {number} currentTimeline\n     *        The timeline currently being followed by the loader\n     * @param {number} segmentTimeline\n     *        The timeline of the segment being loaded\n     * @param {('main'|'audio')} loaderType\n     *        The loader type\n     * @param {boolean} audioDisabled\n     *        Whether the audio is disabled for the loader. This should only be true when the\n     *        loader may have muxed audio in its segment, but should not append it, e.g., for\n     *        the main loader when an alternate audio playlist is active.\n     *\n     * @return {boolean}\n     *         Whether the loader should wait for a timeline change from the timeline change\n     *         controller before processing the segment\n     */\n\n    const shouldWaitForTimelineChange = ({\n                                             timelineChangeController,\n                                             currentTimeline,\n                                             segmentTimeline,\n                                             loaderType,\n                                             audioDisabled\n                                         }) => {\n        if (currentTimeline === segmentTimeline) {\n            return false;\n        }\n        if (loaderType === 'audio') {\n            const lastMainTimelineChange = timelineChangeController.lastTimelineChange({\n                type: 'main'\n            }); // Audio loader should wait if:\n            //\n            // * main hasn't had a timeline change yet (thus has not loaded its first segment)\n            // * main hasn't yet changed to the timeline audio is looking to load\n\n            return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;\n        } // The main loader only needs to wait for timeline changes if there's demuxed audio.\n        // Otherwise, there's nothing to wait for, since audio would be muxed into the main\n        // loader's segments (or the content is audio/video only and handled by the main\n        // loader).\n\n        if (loaderType === 'main' && audioDisabled) {\n            const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({\n                type: 'audio'\n            }); // Main loader should wait for the audio loader if audio is not pending a timeline\n            // change to the current timeline.\n            //\n            // Since the main loader is responsible for setting the timestamp offset for both\n            // audio and video, the main loader must wait for audio to be about to change to its\n            // timeline before setting the offset, otherwise, if audio is behind in loading,\n            // segments from the previous timeline would be adjusted by the new timestamp offset.\n            //\n            // This requirement means that video will not cross a timeline until the audio is\n            // about to cross to it, so that way audio and video will always cross the timeline\n            // together.\n            //\n            // In addition to normal timeline changes, these rules also apply to the start of a\n            // stream (going from a non-existent timeline, -1, to timeline 0). It's important\n            // that these rules apply to the first timeline change because if they did not, it's\n            // possible that the main loader will cross two timelines before the audio loader has\n            // crossed one. Logic may be implemented to handle the startup as a special case, but\n            // it's easier to simply treat all timeline changes the same.\n\n            if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    };\n    const mediaDuration = timingInfos => {\n        let maxDuration = 0;\n        ['video', 'audio'].forEach(function (type) {\n            const typeTimingInfo = timingInfos[`${type}TimingInfo`];\n            if (!typeTimingInfo) {\n                return;\n            }\n            const {\n                start,\n                end\n            } = typeTimingInfo;\n            let duration;\n            if (typeof start === 'bigint' || typeof end === 'bigint') {\n                duration = window.BigInt(end) - window.BigInt(start);\n            } else if (typeof start === 'number' && typeof end === 'number') {\n                duration = end - start;\n            }\n            if (typeof duration !== 'undefined' && duration > maxDuration) {\n                maxDuration = duration;\n            }\n        }); // convert back to a number if it is lower than MAX_SAFE_INTEGER\n        // as we only need BigInt when we are above that.\n\n        if (typeof maxDuration === 'bigint' && maxDuration < Number.MAX_SAFE_INTEGER) {\n            maxDuration = Number(maxDuration);\n        }\n        return maxDuration;\n    };\n    const segmentTooLong = ({\n                                segmentDuration,\n                                maxDuration\n                            }) => {\n        // 0 duration segments are most likely due to metadata only segments or a lack of\n        // information.\n        if (!segmentDuration) {\n            return false;\n        } // For HLS:\n        //\n        // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1\n        // The EXTINF duration of each Media Segment in the Playlist\n        // file, when rounded to the nearest integer, MUST be less than or equal\n        // to the target duration; longer segments can trigger playback stalls\n        // or other errors.\n        //\n        // For DASH, the mpd-parser uses the largest reported segment duration as the target\n        // duration. Although that reported duration is occasionally approximate (i.e., not\n        // exact), a strict check may report that a segment is too long more often in DASH.\n\n        return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;\n    };\n    const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {\n        // Right now we aren't following DASH's timing model exactly, so only perform\n        // this check for HLS content.\n        if (sourceType !== 'hls') {\n            return null;\n        }\n        const segmentDuration = mediaDuration({\n            audioTimingInfo: segmentInfo.audioTimingInfo,\n            videoTimingInfo: segmentInfo.videoTimingInfo\n        }); // Don't report if we lack information.\n        //\n        // If the segment has a duration of 0 it is either a lack of information or a\n        // metadata only segment and shouldn't be reported here.\n\n        if (!segmentDuration) {\n            return null;\n        }\n        const targetDuration = segmentInfo.playlist.targetDuration;\n        const isSegmentWayTooLong = segmentTooLong({\n            segmentDuration,\n            maxDuration: targetDuration * 2\n        });\n        const isSegmentSlightlyTooLong = segmentTooLong({\n            segmentDuration,\n            maxDuration: targetDuration\n        });\n        const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} ` + `from playlist ${segmentInfo.playlist.id} ` + `has a duration of ${segmentDuration} ` + `when the reported duration is ${segmentInfo.duration} ` + `and the target duration is ${targetDuration}. ` + 'For HLS content, a duration in excess of the target duration may result in ' + 'playback issues. See the HLS specification section on EXT-X-TARGETDURATION for ' + 'more details: ' + 'https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1';\n        if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {\n            return {\n                severity: isSegmentWayTooLong ? 'warn' : 'info',\n                message: segmentTooLongMessage\n            };\n        }\n        return null;\n    };\n    /**\n     * An object that manages segment loading and appending.\n     *\n     * @class SegmentLoader\n     * @param {Object} options required and optional options\n     * @extends videojs.EventTarget\n     */\n\n    class SegmentLoader extends videojs.EventTarget {\n        constructor(settings, options = {}) {\n            super(); // check pre-conditions\n\n            if (!settings) {\n                throw new TypeError('Initialization settings are required');\n            }\n            if (typeof settings.currentTime !== 'function') {\n                throw new TypeError('No currentTime getter specified');\n            }\n            if (!settings.mediaSource) {\n                throw new TypeError('No MediaSource specified');\n            } // public properties\n\n            this.bandwidth = settings.bandwidth;\n            this.throughput = {\n                rate: 0,\n                count: 0\n            };\n            this.roundTrip = NaN;\n            this.resetStats_();\n            this.mediaIndex = null;\n            this.partIndex = null; // private settings\n\n            this.hasPlayed_ = settings.hasPlayed;\n            this.currentTime_ = settings.currentTime;\n            this.seekable_ = settings.seekable;\n            this.seeking_ = settings.seeking;\n            this.duration_ = settings.duration;\n            this.mediaSource_ = settings.mediaSource;\n            this.vhs_ = settings.vhs;\n            this.loaderType_ = settings.loaderType;\n            this.currentMediaInfo_ = void 0;\n            this.startingMediaInfo_ = void 0;\n            this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n            this.goalBufferLength_ = settings.goalBufferLength;\n            this.sourceType_ = settings.sourceType;\n            this.sourceUpdater_ = settings.sourceUpdater;\n            this.inbandTextTracks_ = settings.inbandTextTracks;\n            this.state_ = 'INIT';\n            this.timelineChangeController_ = settings.timelineChangeController;\n            this.shouldSaveSegmentTimingInfo_ = true;\n            this.parse708captions_ = settings.parse708captions;\n            this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;\n            this.captionServices_ = settings.captionServices;\n            this.exactManifestTimings = settings.exactManifestTimings;\n            this.addMetadataToTextTrack = settings.addMetadataToTextTrack; // private instance variables\n\n            this.checkBufferTimeout_ = null;\n            this.error_ = void 0;\n            this.currentTimeline_ = -1;\n            this.shouldForceTimestampOffsetAfterResync_ = false;\n            this.pendingSegment_ = null;\n            this.xhrOptions_ = null;\n            this.pendingSegments_ = [];\n            this.audioDisabled_ = false;\n            this.isPendingTimestampOffset_ = false; // TODO possibly move gopBuffer and timeMapping info to a separate controller\n\n            this.gopBuffer_ = [];\n            this.timeMapping_ = 0;\n            this.safeAppend_ = false;\n            this.appendInitSegment_ = {\n                audio: true,\n                video: true\n            };\n            this.playlistOfLastInitSegment_ = {\n                audio: null,\n                video: null\n            };\n            this.callQueue_ = []; // If the segment loader prepares to load a segment, but does not have enough\n            // information yet to start the loading process (e.g., if the audio loader wants to\n            // load a segment from the next timeline but the main loader hasn't yet crossed that\n            // timeline), then the load call will be added to the queue until it is ready to be\n            // processed.\n\n            this.loadQueue_ = [];\n            this.metadataQueue_ = {\n                id3: [],\n                caption: []\n            };\n            this.waitingOnRemove_ = false;\n            this.quotaExceededErrorRetryTimeout_ = null; // Fragmented mp4 playback\n\n            this.activeInitSegmentId_ = null;\n            this.initSegments_ = {}; // HLSe playback\n\n            this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;\n            this.keyCache_ = {};\n            this.decrypter_ = settings.decrypter; // Manages the tracking and generation of sync-points, mappings\n            // between a time in the display time and a segment index within\n            // a playlist\n\n            this.syncController_ = settings.syncController;\n            this.syncPoint_ = {\n                segmentIndex: 0,\n                time: 0\n            };\n            this.transmuxer_ = this.createTransmuxer_();\n            this.triggerSyncInfoUpdate_ = () => this.trigger('syncinfoupdate');\n            this.syncController_.on('syncinfoupdate', this.triggerSyncInfoUpdate_);\n            this.mediaSource_.addEventListener('sourceopen', () => {\n                if (!this.isEndOfStream_()) {\n                    this.ended_ = false;\n                }\n            }); // ...for determining the fetch location\n\n            this.fetchAtBuffer_ = false;\n            this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);\n            Object.defineProperty(this, 'state', {\n                get() {\n                    return this.state_;\n                },\n                set(newState) {\n                    if (newState !== this.state_) {\n                        this.logger_(`${this.state_} -> ${newState}`);\n                        this.state_ = newState;\n                        this.trigger('statechange');\n                    }\n                }\n            });\n            this.sourceUpdater_.on('ready', () => {\n                if (this.hasEnoughInfoToAppend_()) {\n                    this.processCallQueue_();\n                }\n            }); // Only the main loader needs to listen for pending timeline changes, as the main\n            // loader should wait for audio to be ready to change its timeline so that both main\n            // and audio timelines change together. For more details, see the\n            // shouldWaitForTimelineChange function.\n\n            if (this.loaderType_ === 'main') {\n                this.timelineChangeController_.on('pendingtimelinechange', () => {\n                    if (this.hasEnoughInfoToAppend_()) {\n                        this.processCallQueue_();\n                    }\n                });\n            } // The main loader only listens on pending timeline changes, but the audio loader,\n            // since its loads follow main, needs to listen on timeline changes. For more details,\n            // see the shouldWaitForTimelineChange function.\n\n            if (this.loaderType_ === 'audio') {\n                this.timelineChangeController_.on('timelinechange', () => {\n                    if (this.hasEnoughInfoToLoad_()) {\n                        this.processLoadQueue_();\n                    }\n                    if (this.hasEnoughInfoToAppend_()) {\n                        this.processCallQueue_();\n                    }\n                });\n            }\n        }\n        createTransmuxer_() {\n            return segmentTransmuxer.createTransmuxer({\n                remux: false,\n                alignGopsAtEnd: this.safeAppend_,\n                keepOriginalTimestamps: true,\n                parse708captions: this.parse708captions_,\n                captionServices: this.captionServices_\n            });\n        }\n        /**\n         * reset all of our media stats\n         *\n         * @private\n         */\n\n        resetStats_() {\n            this.mediaBytesTransferred = 0;\n            this.mediaRequests = 0;\n            this.mediaRequestsAborted = 0;\n            this.mediaRequestsTimedout = 0;\n            this.mediaRequestsErrored = 0;\n            this.mediaTransferDuration = 0;\n            this.mediaSecondsLoaded = 0;\n            this.mediaAppends = 0;\n        }\n        /**\n         * dispose of the SegmentLoader and reset to the default state\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.state = 'DISPOSED';\n            this.pause();\n            this.abort_();\n            if (this.transmuxer_) {\n                this.transmuxer_.terminate();\n            }\n            this.resetStats_();\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            if (this.syncController_ && this.triggerSyncInfoUpdate_) {\n                this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);\n            }\n            this.off();\n        }\n        setAudio(enable) {\n            this.audioDisabled_ = !enable;\n            if (enable) {\n                this.appendInitSegment_.audio = true;\n            } else {\n                // remove current track audio if it gets disabled\n                this.sourceUpdater_.removeAudio(0, this.duration_());\n            }\n        }\n        /**\n         * abort anything that is currently doing on with the SegmentLoader\n         * and reset to a default state\n         */\n\n        abort() {\n            if (this.state !== 'WAITING') {\n                if (this.pendingSegment_) {\n                    this.pendingSegment_ = null;\n                }\n                return;\n            }\n            this.abort_(); // We aborted the requests we were waiting on, so reset the loader's state to READY\n            // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n            // when the request is aborted. This will prevent the loader from being stuck in the\n            // WAITING state indefinitely.\n\n            this.state = 'READY'; // don't wait for buffer check timeouts to begin fetching the\n            // next segment\n\n            if (!this.paused()) {\n                this.monitorBuffer_();\n            }\n        }\n        /**\n         * abort all pending xhr requests and null any pending segements\n         *\n         * @private\n         */\n\n        abort_() {\n            if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {\n                this.pendingSegment_.abortRequests();\n            } // clear out the segment being processed\n\n            this.pendingSegment_ = null;\n            this.callQueue_ = [];\n            this.loadQueue_ = [];\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n            this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);\n            this.waitingOnRemove_ = false;\n            window.clearTimeout(this.quotaExceededErrorRetryTimeout_);\n            this.quotaExceededErrorRetryTimeout_ = null;\n        }\n        checkForAbort_(requestId) {\n            // If the state is APPENDING, then aborts will not modify the state, meaning the first\n            // callback that happens should reset the state to READY so that loading can continue.\n            if (this.state === 'APPENDING' && !this.pendingSegment_) {\n                this.state = 'READY';\n                return true;\n            }\n            if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * set an error on the segment loader and null out any pending segements\n         *\n         * @param {Error} error the error to set on the SegmentLoader\n         * @return {Error} the error that was set or that is currently set\n         */\n\n        error(error) {\n            if (typeof error !== 'undefined') {\n                this.logger_('error occurred:', error);\n                this.error_ = error;\n            }\n            this.pendingSegment_ = null;\n            return this.error_;\n        }\n        endOfStream() {\n            this.ended_ = true;\n            if (this.transmuxer_) {\n                // need to clear out any cached data to prepare for the new segment\n                segmentTransmuxer.reset(this.transmuxer_);\n            }\n            this.gopBuffer_.length = 0;\n            this.pause();\n            this.trigger('ended');\n        }\n        /**\n         * Indicates which time ranges are buffered\n         *\n         * @return {TimeRange}\n         *         TimeRange object representing the current buffered ranges\n         */\n\n        buffered_() {\n            const trackInfo = this.getMediaInfo_();\n            if (!this.sourceUpdater_ || !trackInfo) {\n                return createTimeRanges();\n            }\n            if (this.loaderType_ === 'main') {\n                const {\n                    hasAudio,\n                    hasVideo,\n                    isMuxed\n                } = trackInfo;\n                if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {\n                    return this.sourceUpdater_.buffered();\n                }\n                if (hasVideo) {\n                    return this.sourceUpdater_.videoBuffered();\n                }\n            } // One case that can be ignored for now is audio only with alt audio,\n            // as we don't yet have proper support for that.\n\n            return this.sourceUpdater_.audioBuffered();\n        }\n        /**\n         * Gets and sets init segment for the provided map\n         *\n         * @param {Object} map\n         *        The map object representing the init segment to get or set\n         * @param {boolean=} set\n         *        If true, the init segment for the provided map should be saved\n         * @return {Object}\n         *         map object for desired init segment\n         */\n\n        initSegmentForMap(map, set = false) {\n            if (!map) {\n                return null;\n            }\n            const id = initSegmentId(map);\n            let storedMap = this.initSegments_[id];\n            if (set && !storedMap && map.bytes) {\n                this.initSegments_[id] = storedMap = {\n                    resolvedUri: map.resolvedUri,\n                    byterange: map.byterange,\n                    bytes: map.bytes,\n                    tracks: map.tracks,\n                    timescales: map.timescales\n                };\n            }\n            return storedMap || map;\n        }\n        /**\n         * Gets and sets key for the provided key\n         *\n         * @param {Object} key\n         *        The key object representing the key to get or set\n         * @param {boolean=} set\n         *        If true, the key for the provided key should be saved\n         * @return {Object}\n         *         Key object for desired key\n         */\n\n        segmentKey(key, set = false) {\n            if (!key) {\n                return null;\n            }\n            const id = segmentKeyId(key);\n            let storedKey = this.keyCache_[id]; // TODO: We should use the HTTP Expires header to invalidate our cache per\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3\n\n            if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {\n                this.keyCache_[id] = storedKey = {\n                    resolvedUri: key.resolvedUri,\n                    bytes: key.bytes\n                };\n            }\n            const result = {\n                resolvedUri: (storedKey || key).resolvedUri\n            };\n            if (storedKey) {\n                result.bytes = storedKey.bytes;\n            }\n            return result;\n        }\n        /**\n         * Returns true if all configuration required for loading is present, otherwise false.\n         *\n         * @return {boolean} True if the all configuration is ready for loading\n         * @private\n         */\n\n        couldBeginLoading_() {\n            return this.playlist_ && !this.paused();\n        }\n        /**\n         * load a playlist and start to fill the buffer\n         */\n\n        load() {\n            // un-pause\n            this.monitorBuffer_(); // if we don't have a playlist yet, keep waiting for one to be\n            // specified\n\n            if (!this.playlist_) {\n                return;\n            } // if all the configuration is ready, initialize and begin loading\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                return this.init_();\n            } // if we're in the middle of processing a segment already, don't\n            // kick off an additional segment request\n\n            if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n                return;\n            }\n            this.state = 'READY';\n        }\n        /**\n         * Once all the starting parameters have been specified, begin\n         * operation. This method should only be invoked from the INIT\n         * state.\n         *\n         * @private\n         */\n\n        init_() {\n            this.state = 'READY'; // if this is the audio segment loader, and it hasn't been inited before, then any old\n            // audio data from the muxed content should be removed\n\n            this.resetEverything();\n            return this.monitorBuffer_();\n        }\n        /**\n         * set a playlist on the segment loader\n         *\n         * @param {PlaylistLoader} media the playlist to set on the segment loader\n         */\n\n        playlist(newPlaylist, options = {}) {\n            if (!newPlaylist) {\n                return;\n            }\n            const oldPlaylist = this.playlist_;\n            const segmentInfo = this.pendingSegment_;\n            this.playlist_ = newPlaylist;\n            this.xhrOptions_ = options; // when we haven't started playing yet, the start of a live playlist\n            // is always our zero-time so force a sync update each time the playlist\n            // is refreshed from the server\n            //\n            // Use the INIT state to determine if playback has started, as the playlist sync info\n            // should be fixed once requests begin (as sync points are generated based on sync\n            // info), but not before then.\n\n            if (this.state === 'INIT') {\n                newPlaylist.syncInfo = {\n                    mediaSequence: newPlaylist.mediaSequence,\n                    time: 0\n                }; // Setting the date time mapping means mapping the program date time (if available)\n                // to time 0 on the player's timeline. The playlist's syncInfo serves a similar\n                // purpose, mapping the initial mediaSequence to time zero. Since the syncInfo can\n                // be updated as the playlist is refreshed before the loader starts loading, the\n                // program date time mapping needs to be updated as well.\n                //\n                // This mapping is only done for the main loader because a program date time should\n                // map equivalently between playlists.\n\n                if (this.loaderType_ === 'main') {\n                    this.syncController_.setDateTimeMappingForStart(newPlaylist);\n                }\n            }\n            let oldId = null;\n            if (oldPlaylist) {\n                if (oldPlaylist.id) {\n                    oldId = oldPlaylist.id;\n                } else if (oldPlaylist.uri) {\n                    oldId = oldPlaylist.uri;\n                }\n            }\n            this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`);\n            this.syncController_.updateMediaSequenceMap(newPlaylist, this.currentTime_(), this.loaderType_); // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n            // in LIVE, we always want to update with new playlists (including refreshes)\n\n            this.trigger('syncinfoupdate'); // if we were unpaused but waiting for a playlist, start\n            // buffering now\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                return this.init_();\n            }\n            if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n                if (this.mediaIndex !== null) {\n                    // we must reset/resync the segment loader when we switch renditions and\n                    // the segment loader is already synced to the previous rendition\n                    // We only want to reset the loader here for LLHLS playback, as resetLoader sets fetchAtBuffer_\n                    // to false, resulting in fetching segments at currentTime and causing repeated\n                    // same-segment requests on playlist change. This erroneously drives up the playback watcher\n                    // stalled segment count, as re-requesting segments at the currentTime or browser cached segments\n                    // will not change the buffer.\n                    // Reference for LLHLS fixes: https://github.com/videojs/http-streaming/pull/1201\n                    const isLLHLS = !newPlaylist.endList && typeof newPlaylist.partTargetDuration === 'number';\n                    if (isLLHLS) {\n                        this.resetLoader();\n                    } else {\n                        this.resyncLoader();\n                    }\n                }\n                this.currentMediaInfo_ = void 0;\n                this.trigger('playlistupdate'); // the rest of this function depends on `oldPlaylist` being defined\n\n                return;\n            } // we reloaded the same playlist so we are in a live scenario\n            // and we will likely need to adjust the mediaIndex\n\n            const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n            this.logger_(`live window shift [${mediaSequenceDiff}]`); // update the mediaIndex on the SegmentLoader\n            // this is important because we can abort a request and this value must be\n            // equal to the last appended mediaIndex\n\n            if (this.mediaIndex !== null) {\n                this.mediaIndex -= mediaSequenceDiff; // this can happen if we are going to load the first segment, but get a playlist\n                // update during that. mediaIndex would go from 0 to -1 if mediaSequence in the\n                // new playlist was incremented by 1.\n\n                if (this.mediaIndex < 0) {\n                    this.mediaIndex = null;\n                    this.partIndex = null;\n                } else {\n                    const segment = this.playlist_.segments[this.mediaIndex]; // partIndex should remain the same for the same segment\n                    // unless parts fell off of the playlist for this segment.\n                    // In that case we need to reset partIndex and resync\n\n                    if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {\n                        const mediaIndex = this.mediaIndex;\n                        this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);\n                        this.resetLoader(); // We want to throw away the partIndex and the data associated with it,\n                        // as the part was dropped from our current playlists segment.\n                        // The mediaIndex will still be valid so keep that around.\n\n                        this.mediaIndex = mediaIndex;\n                    }\n                }\n            } // update the mediaIndex on the SegmentInfo object\n            // this is important because we will update this.mediaIndex with this value\n            // in `handleAppendsDone_` after the segment has been successfully appended\n\n            if (segmentInfo) {\n                segmentInfo.mediaIndex -= mediaSequenceDiff;\n                if (segmentInfo.mediaIndex < 0) {\n                    segmentInfo.mediaIndex = null;\n                    segmentInfo.partIndex = null;\n                } else {\n                    // we need to update the referenced segment so that timing information is\n                    // saved for the new playlist's segment, however, if the segment fell off the\n                    // playlist, we can leave the old reference and just lose the timing info\n                    if (segmentInfo.mediaIndex >= 0) {\n                        segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n                    }\n                    if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {\n                        segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];\n                    }\n                }\n            }\n            this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n        }\n        /**\n         * Prevent the loader from fetching additional segments. If there\n         * is a segment request outstanding, it will finish processing\n         * before the loader halts. A segment loader can be unpaused by\n         * calling load().\n         */\n\n        pause() {\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n                this.checkBufferTimeout_ = null;\n            }\n        }\n        /**\n         * Returns whether the segment loader is fetching additional\n         * segments when given the opportunity. This property can be\n         * modified through calls to pause() and load().\n         */\n\n        paused() {\n            return this.checkBufferTimeout_ === null;\n        }\n        /**\n         * Delete all the buffered data and reset the SegmentLoader\n         *\n         * @param {Function} [done] an optional callback to be executed when the remove\n         * operation is complete\n         */\n\n        resetEverything(done) {\n            this.ended_ = false;\n            this.activeInitSegmentId_ = null;\n            this.appendInitSegment_ = {\n                audio: true,\n                video: true\n            };\n            this.resetLoader(); // remove from 0, the earliest point, to Infinity, to signify removal of everything.\n            // VTT Segment Loader doesn't need to do anything but in the regular SegmentLoader,\n            // we then clamp the value to duration if necessary.\n\n            this.remove(0, Infinity, done); // clears fmp4 captions\n\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearAllMp4Captions'\n                }); // reset the cache in the transmuxer\n\n                this.transmuxer_.postMessage({\n                    action: 'reset'\n                });\n            }\n        }\n        /**\n         * Force the SegmentLoader to resync and start loading around the currentTime instead\n         * of starting at the end of the buffer\n         *\n         * Useful for fast quality changes\n         */\n\n        resetLoader() {\n            this.fetchAtBuffer_ = false;\n            this.resyncLoader();\n        }\n        /**\n         * Force the SegmentLoader to restart synchronization and make a conservative guess\n         * before returning to the simple walk-forward method\n         */\n\n        resyncLoader() {\n            if (this.transmuxer_) {\n                // need to clear out any cached data to prepare for the new segment\n                segmentTransmuxer.reset(this.transmuxer_);\n            }\n            this.mediaIndex = null;\n            this.partIndex = null;\n            this.syncPoint_ = null;\n            this.isPendingTimestampOffset_ = false;\n            this.shouldForceTimestampOffsetAfterResync_ = true;\n            this.callQueue_ = [];\n            this.loadQueue_ = [];\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n            this.abort();\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearParsedMp4Captions'\n                });\n            }\n        }\n        /**\n         * Remove any data in the source buffer between start and end times\n         *\n         * @param {number} start - the start time of the region to remove from the buffer\n         * @param {number} end - the end time of the region to remove from the buffer\n         * @param {Function} [done] - an optional callback to be executed when the remove\n         * @param {boolean} force - force all remove operations to happen\n         * operation is complete\n         */\n\n        remove(start, end, done = () => {}, force = false) {\n            // clamp end to duration if we need to remove everything.\n            // This is due to a browser bug that causes issues if we remove to Infinity.\n            // videojs/videojs-contrib-hls#1225\n            if (end === Infinity) {\n                end = this.duration_();\n            } // skip removes that would throw an error\n            // commonly happens during a rendition switch at the start of a video\n            // from start 0 to end 0\n\n            if (end <= start) {\n                this.logger_('skipping remove because end ${end} is <= start ${start}');\n                return;\n            }\n            if (!this.sourceUpdater_ || !this.getMediaInfo_()) {\n                this.logger_('skipping remove because no source updater or starting media info'); // nothing to remove if we haven't processed any media\n\n                return;\n            } // set it to one to complete this function's removes\n\n            let removesRemaining = 1;\n            const removeFinished = () => {\n                removesRemaining--;\n                if (removesRemaining === 0) {\n                    done();\n                }\n            };\n            if (force || !this.audioDisabled_) {\n                removesRemaining++;\n                this.sourceUpdater_.removeAudio(start, end, removeFinished);\n            } // While it would be better to only remove video if the main loader has video, this\n            // should be safe with audio only as removeVideo will call back even if there's no\n            // video buffer.\n            //\n            // In theory we can check to see if there's video before calling the remove, but in\n            // the event that we're switching between renditions and from video to audio only\n            // (when we add support for that), we may need to clear the video contents despite\n            // what the new media will contain.\n\n            if (force || this.loaderType_ === 'main') {\n                this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n                removesRemaining++;\n                this.sourceUpdater_.removeVideo(start, end, removeFinished);\n            } // remove any captions and ID3 tags\n\n            for (const track in this.inbandTextTracks_) {\n                removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\n            }\n            removeCuesFromTrack(start, end, this.segmentMetadataTrack_); // finished this function's removes\n\n            removeFinished();\n        }\n        /**\n         * (re-)schedule monitorBufferTick_ to run as soon as possible\n         *\n         * @private\n         */\n\n        monitorBuffer_() {\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);\n        }\n        /**\n         * As long as the SegmentLoader is in the READY state, periodically\n         * invoke fillBuffer_().\n         *\n         * @private\n         */\n\n        monitorBufferTick_() {\n            if (this.state === 'READY') {\n                this.fillBuffer_();\n            }\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n        }\n        /**\n         * fill the buffer with segements unless the sourceBuffers are\n         * currently updating\n         *\n         * Note: this function should only ever be called by monitorBuffer_\n         * and never directly\n         *\n         * @private\n         */\n\n        fillBuffer_() {\n            // TODO since the source buffer maintains a queue, and we shouldn't call this function\n            // except when we're ready for the next segment, this check can most likely be removed\n            if (this.sourceUpdater_.updating()) {\n                return;\n            } // see if we need to begin loading immediately\n\n            const segmentInfo = this.chooseNextRequest_();\n            if (!segmentInfo) {\n                return;\n            }\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                this.isPendingTimestampOffset_ = false;\n                this.timelineChangeController_.pendingTimelineChange({\n                    type: this.loaderType_,\n                    from: this.currentTimeline_,\n                    to: segmentInfo.timeline\n                });\n            }\n            this.loadSegment_(segmentInfo);\n        }\n        /**\n         * Determines if we should call endOfStream on the media source based\n         * on the state of the buffer or if appened segment was the final\n         * segment in the playlist.\n         *\n         * @param {number} [mediaIndex] the media index of segment we last appended\n         * @param {Object} [playlist] a media playlist object\n         * @return {boolean} do we need to call endOfStream on the MediaSource\n         */\n\n        isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {\n            if (!playlist || !this.mediaSource_) {\n                return false;\n            }\n            const segment = typeof mediaIndex === 'number' && playlist.segments[mediaIndex]; // mediaIndex is zero based but length is 1 based\n\n            const appendedLastSegment = mediaIndex + 1 === playlist.segments.length; // true if there are no parts, or this is the last part.\n\n            const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length; // if we've buffered to the end of the video, we need to call endOfStream\n            // so that MediaSources can trigger the `ended` event when it runs out of\n            // buffered data instead of waiting for me\n\n            return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment && appendedLastPart;\n        }\n        /**\n         * Determines what request should be made given current segment loader state.\n         *\n         * @return {Object} a request object that describes the segment/part to load\n         */\n\n        chooseNextRequest_() {\n            const buffered = this.buffered_();\n            const bufferedEnd = lastBufferedEnd(buffered) || 0;\n            const bufferedTime = timeAheadOf(buffered, this.currentTime_());\n            const preloaded = !this.hasPlayed_() && bufferedTime >= 1;\n            const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();\n            const segments = this.playlist_.segments; // return no segment if:\n            // 1. we don't have segments\n            // 2. The video has not yet played and we already downloaded a segment\n            // 3. we already have enough buffered time\n\n            if (!segments.length || preloaded || haveEnoughBuffer) {\n                return null;\n            }\n            this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);\n            const next = {\n                partIndex: null,\n                mediaIndex: null,\n                startOfSegment: null,\n                playlist: this.playlist_,\n                isSyncRequest: Boolean(!this.syncPoint_)\n            };\n            if (next.isSyncRequest) {\n                next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);\n                this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${next.mediaIndex}`);\n            } else if (this.mediaIndex !== null) {\n                const segment = segments[this.mediaIndex];\n                const partIndex = typeof this.partIndex === 'number' ? this.partIndex : -1;\n                next.startOfSegment = segment.end ? segment.end : bufferedEnd;\n                if (segment.parts && segment.parts[partIndex + 1]) {\n                    next.mediaIndex = this.mediaIndex;\n                    next.partIndex = partIndex + 1;\n                } else {\n                    next.mediaIndex = this.mediaIndex + 1;\n                }\n            } else {\n                // Find the segment containing the end of the buffer or current time.\n                const {\n                    segmentIndex,\n                    startTime,\n                    partIndex\n                } = Playlist.getMediaInfoForTime({\n                    exactManifestTimings: this.exactManifestTimings,\n                    playlist: this.playlist_,\n                    currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),\n                    startingPartIndex: this.syncPoint_.partIndex,\n                    startingSegmentIndex: this.syncPoint_.segmentIndex,\n                    startTime: this.syncPoint_.time\n                });\n                next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${bufferedEnd}` : `currentTime ${this.currentTime_()}`;\n                next.mediaIndex = segmentIndex;\n                next.startOfSegment = startTime;\n                next.partIndex = partIndex;\n                this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${next.mediaIndex} `);\n            }\n            const nextSegment = segments[next.mediaIndex];\n            let nextPart = nextSegment && typeof next.partIndex === 'number' && nextSegment.parts && nextSegment.parts[next.partIndex]; // if the next segment index is invalid or\n            // the next partIndex is invalid do not choose a next segment.\n\n            if (!nextSegment || typeof next.partIndex === 'number' && !nextPart) {\n                return null;\n            } // if the next segment has parts, and we don't have a partIndex.\n            // Set partIndex to 0\n\n            if (typeof next.partIndex !== 'number' && nextSegment.parts) {\n                next.partIndex = 0;\n                nextPart = nextSegment.parts[0];\n            } // independentSegments applies to every segment in a playlist. If independentSegments appears in a main playlist,\n            // it applies to each segment in each media playlist.\n            // https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-23#section-4.3.5.1\n\n            const hasIndependentSegments = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments; // if we have no buffered data then we need to make sure\n            // that the next part we append is \"independent\" if possible.\n            // So we check if the previous part is independent, and request\n            // it if it is.\n\n            if (!bufferedTime && nextPart && !hasIndependentSegments && !nextPart.independent) {\n                if (next.partIndex === 0) {\n                    const lastSegment = segments[next.mediaIndex - 1];\n                    const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];\n                    if (lastSegmentLastPart && lastSegmentLastPart.independent) {\n                        next.mediaIndex -= 1;\n                        next.partIndex = lastSegment.parts.length - 1;\n                        next.independent = 'previous segment';\n                    }\n                } else if (nextSegment.parts[next.partIndex - 1].independent) {\n                    next.partIndex -= 1;\n                    next.independent = 'previous part';\n                }\n            }\n            const ended = this.mediaSource_ && this.mediaSource_.readyState === 'ended'; // do not choose a next segment if all of the following:\n            // 1. this is the last segment in the playlist\n            // 2. end of stream has been called on the media source already\n            // 3. the player is not seeking\n\n            if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {\n                return null;\n            }\n            if (this.shouldForceTimestampOffsetAfterResync_) {\n                this.shouldForceTimestampOffsetAfterResync_ = false;\n                next.forceTimestampOffset = true;\n                this.logger_('choose next request. Force timestamp offset after loader resync');\n            }\n            return this.generateSegmentInfo_(next);\n        }\n        generateSegmentInfo_(options) {\n            const {\n                independent,\n                playlist,\n                mediaIndex,\n                startOfSegment,\n                isSyncRequest,\n                partIndex,\n                forceTimestampOffset,\n                getMediaInfoForTime\n            } = options;\n            const segment = playlist.segments[mediaIndex];\n            const part = typeof partIndex === 'number' && segment.parts[partIndex];\n            const segmentInfo = {\n                requestId: 'segment-loader-' + Math.random(),\n                // resolve the segment URL relative to the playlist\n                uri: part && part.resolvedUri || segment.resolvedUri,\n                // the segment's mediaIndex at the time it was requested\n                mediaIndex,\n                partIndex: part ? partIndex : null,\n                // whether or not to update the SegmentLoader's state with this\n                // segment's mediaIndex\n                isSyncRequest,\n                startOfSegment,\n                // the segment's playlist\n                playlist,\n                // unencrypted bytes of the segment\n                bytes: null,\n                // when a key is defined for this segment, the encrypted bytes\n                encryptedBytes: null,\n                // The target timestampOffset for this segment when we append it\n                // to the source buffer\n                timestampOffset: null,\n                // The timeline that the segment is in\n                timeline: segment.timeline,\n                // The expected duration of the segment in seconds\n                duration: part && part.duration || segment.duration,\n                // retain the segment in case the playlist updates while doing an async process\n                segment,\n                part,\n                byteLength: 0,\n                transmuxer: this.transmuxer_,\n                // type of getMediaInfoForTime that was used to get this segment\n                getMediaInfoForTime,\n                independent\n            };\n            const overrideCheck = typeof forceTimestampOffset !== 'undefined' ? forceTimestampOffset : this.isPendingTimestampOffset_;\n            segmentInfo.timestampOffset = this.timestampOffsetForSegment_({\n                segmentTimeline: segment.timeline,\n                currentTimeline: this.currentTimeline_,\n                startOfSegment,\n                buffered: this.buffered_(),\n                overrideCheck\n            });\n            const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());\n            if (typeof audioBufferedEnd === 'number') {\n                // since the transmuxer is using the actual timing values, but the buffer is\n                // adjusted by the timestamp offset, we must adjust the value here\n                segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();\n            }\n            if (this.sourceUpdater_.videoBuffered().length) {\n                segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_,\n                    // since the transmuxer is using the actual timing values, but the time is\n                    // adjusted by the timestmap offset, we must adjust the value here\n                    this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);\n            }\n            return segmentInfo;\n        } // get the timestampoffset for a segment,\n        // added so that vtt segment loader can override and prevent\n        // adding timestamp offsets.\n\n        timestampOffsetForSegment_(options) {\n            return timestampOffsetForSegment(options);\n        }\n        /**\n         * Determines if the network has enough bandwidth to complete the current segment\n         * request in a timely manner. If not, the request will be aborted early and bandwidth\n         * updated to trigger a playlist switch.\n         *\n         * @param {Object} stats\n         *        Object containing stats about the request timing and size\n         * @private\n         */\n\n        earlyAbortWhenNeeded_(stats) {\n            if (this.vhs_.tech_.paused() ||\n                // Don't abort if the current playlist is on the lowestEnabledRendition\n                // TODO: Replace using timeout with a boolean indicating whether this playlist is\n                //       the lowestEnabledRendition.\n                !this.xhrOptions_.timeout ||\n                // Don't abort if we have no bandwidth information to estimate segment sizes\n                !this.playlist_.attributes.BANDWIDTH) {\n                return;\n            } // Wait at least 1 second since the first byte of data has been received before\n            // using the calculated bandwidth from the progress event to allow the bitrate\n            // to stabilize\n\n            if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n                return;\n            }\n            const currentTime = this.currentTime_();\n            const measuredBandwidth = stats.bandwidth;\n            const segmentDuration = this.pendingSegment_.duration;\n            const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived); // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n            // if we are only left with less than 1 second when the request completes.\n            // A negative timeUntilRebuffering indicates we are already rebuffering\n\n            const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1; // Only consider aborting early if the estimated time to finish the download\n            // is larger than the estimated time until the player runs out of forward buffer\n\n            if (requestTimeRemaining <= timeUntilRebuffer$1) {\n                return;\n            }\n            const switchCandidate = minRebufferMaxBandwidthSelector({\n                main: this.vhs_.playlists.main,\n                currentTime,\n                bandwidth: measuredBandwidth,\n                duration: this.duration_(),\n                segmentDuration,\n                timeUntilRebuffer: timeUntilRebuffer$1,\n                currentTimeline: this.currentTimeline_,\n                syncController: this.syncController_\n            });\n            if (!switchCandidate) {\n                return;\n            }\n            const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;\n            const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n            let minimumTimeSaving = 0.5; // If we are already rebuffering, increase the amount of variance we add to the\n            // potential round trip time of the new request so that we are not too aggressive\n            // with switching to a playlist that might save us a fraction of a second.\n\n            if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {\n                minimumTimeSaving = 1;\n            }\n            if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n                return;\n            } // set the bandwidth to that of the desired playlist being sure to scale by\n            // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n            // don't trigger a bandwidthupdate as the bandwidth is artifial\n\n            this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\n            this.trigger('earlyabort');\n        }\n        handleAbort_(segmentInfo) {\n            this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);\n            this.mediaRequestsAborted += 1;\n        }\n        /**\n         * XHR `progress` event handler\n         *\n         * @param {Event}\n         *        The XHR `progress` event\n         * @param {Object} simpleSegment\n         *        A simplified segment object copy\n         * @private\n         */\n\n        handleProgress_(event, simpleSegment) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            this.trigger('progress');\n        }\n        handleTrackInfo_(simpleSegment, trackInfo) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            if (this.checkForIllegalMediaSwitch(trackInfo)) {\n                return;\n            }\n            trackInfo = trackInfo || {}; // When we have track info, determine what media types this loader is dealing with.\n            // Guard against cases where we're not getting track info at all until we are\n            // certain that all streams will provide it.\n\n            if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {\n                this.appendInitSegment_ = {\n                    audio: true,\n                    video: true\n                };\n                this.startingMediaInfo_ = trackInfo;\n                this.currentMediaInfo_ = trackInfo;\n                this.logger_('trackinfo update', trackInfo);\n                this.trigger('trackinfo');\n            } // trackinfo may cause an abort if the trackinfo\n            // causes a codec change to an unsupported codec.\n\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // set trackinfo on the pending segment so that\n            // it can append.\n\n            this.pendingSegment_.trackInfo = trackInfo; // check if any calls were waiting on the track info\n\n            if (this.hasEnoughInfoToAppend_()) {\n                this.processCallQueue_();\n            }\n        }\n        handleTimingInfo_(simpleSegment, mediaType, timeType, time) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            const segmentInfo = this.pendingSegment_;\n            const timingInfoProperty = timingInfoPropertyForMedia(mediaType);\n            segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};\n            segmentInfo[timingInfoProperty][timeType] = time;\n            this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`); // check if any calls were waiting on the timing info\n\n            if (this.hasEnoughInfoToAppend_()) {\n                this.processCallQueue_();\n            }\n        }\n        handleCaptions_(simpleSegment, captionData) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // This could only happen with fmp4 segments, but\n            // should still not happen in general\n\n            if (captionData.length === 0) {\n                this.logger_('SegmentLoader received no captions from a caption event');\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // Wait until we have some video data so that caption timing\n            // can be adjusted by the timestamp offset\n\n            if (!segmentInfo.hasAppendedData_) {\n                this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));\n                return;\n            }\n            const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();\n            const captionTracks = {}; // get total start/end and captions for each track/stream\n\n            captionData.forEach(caption => {\n                // caption.stream is actually a track name...\n                // set to the existing values in tracks or default values\n                captionTracks[caption.stream] = captionTracks[caption.stream] || {\n                    // Infinity, as any other value will be less than this\n                    startTime: Infinity,\n                    captions: [],\n                    // 0 as an other value will be more than this\n                    endTime: 0\n                };\n                const captionTrack = captionTracks[caption.stream];\n                captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);\n                captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);\n                captionTrack.captions.push(caption);\n            });\n            Object.keys(captionTracks).forEach(trackName => {\n                const {\n                    startTime,\n                    endTime,\n                    captions\n                } = captionTracks[trackName];\n                const inbandTextTracks = this.inbandTextTracks_;\n                this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);\n                createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName); // clear out any cues that start and end at the same time period for the same track.\n                // We do this because a rendition change that also changes the timescale for captions\n                // will result in captions being re-parsed for certain segments. If we add them again\n                // without clearing we will have two of the same captions visible.\n\n                removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);\n                addCaptionData({\n                    captionArray: captions,\n                    inbandTextTracks,\n                    timestampOffset\n                });\n            }); // Reset stored captions since we added parsed\n            // captions to a text track at this point\n\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearParsedMp4Captions'\n                });\n            }\n        }\n        handleId3_(simpleSegment, id3Frames, dispatchType) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // we need to have appended data in order for the timestamp offset to be set\n\n            if (!segmentInfo.hasAppendedData_) {\n                this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));\n                return;\n            }\n            this.addMetadataToTextTrack(dispatchType, id3Frames, this.duration_());\n        }\n        processMetadataQueue_() {\n            this.metadataQueue_.id3.forEach(fn => fn());\n            this.metadataQueue_.caption.forEach(fn => fn());\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n        }\n        processCallQueue_() {\n            const callQueue = this.callQueue_; // Clear out the queue before the queued functions are run, since some of the\n            // functions may check the length of the load queue and default to pushing themselves\n            // back onto the queue.\n\n            this.callQueue_ = [];\n            callQueue.forEach(fun => fun());\n        }\n        processLoadQueue_() {\n            const loadQueue = this.loadQueue_; // Clear out the queue before the queued functions are run, since some of the\n            // functions may check the length of the load queue and default to pushing themselves\n            // back onto the queue.\n\n            this.loadQueue_ = [];\n            loadQueue.forEach(fun => fun());\n        }\n        /**\n         * Determines whether the loader has enough info to load the next segment.\n         *\n         * @return {boolean}\n         *         Whether or not the loader has enough info to load the next segment\n         */\n\n        hasEnoughInfoToLoad_() {\n            // Since primary timing goes by video, only the audio loader potentially needs to wait\n            // to load.\n            if (this.loaderType_ !== 'audio') {\n                return true;\n            }\n            const segmentInfo = this.pendingSegment_; // A fill buffer must have already run to establish a pending segment before there's\n            // enough info to load.\n\n            if (!segmentInfo) {\n                return false;\n            } // The first segment can and should be loaded immediately so that source buffers are\n            // created together (before appending). Source buffer creation uses the presence of\n            // audio and video data to determine whether to create audio/video source buffers, and\n            // uses processed (transmuxed or parsed) media to determine the types required.\n\n            if (!this.getCurrentMediaInfo_()) {\n                return true;\n            }\n            if (\n                // Technically, instead of waiting to load a segment on timeline changes, a segment\n                // can be requested and downloaded and only wait before it is transmuxed or parsed.\n                // But in practice, there are a few reasons why it is better to wait until a loader\n                // is ready to append that segment before requesting and downloading:\n                //\n                // 1. Because audio and main loaders cross discontinuities together, if this loader\n                //    is waiting for the other to catch up, then instead of requesting another\n                //    segment and using up more bandwidth, by not yet loading, more bandwidth is\n                //    allotted to the loader currently behind.\n                // 2. media-segment-request doesn't have to have logic to consider whether a segment\n                // is ready to be processed or not, isolating the queueing behavior to the loader.\n                // 3. The audio loader bases some of its segment properties on timing information\n                //    provided by the main loader, meaning that, if the logic for waiting on\n                //    processing was in media-segment-request, then it would also need to know how\n                //    to re-generate the segment information after the main loader caught up.\n                shouldWaitForTimelineChange({\n                    timelineChangeController: this.timelineChangeController_,\n                    currentTimeline: this.currentTimeline_,\n                    segmentTimeline: segmentInfo.timeline,\n                    loaderType: this.loaderType_,\n                    audioDisabled: this.audioDisabled_\n                })) {\n                return false;\n            }\n            return true;\n        }\n        getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {\n            return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;\n        }\n        getMediaInfo_(segmentInfo = this.pendingSegment_) {\n            return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;\n        }\n        getPendingSegmentPlaylist() {\n            return this.pendingSegment_ ? this.pendingSegment_.playlist : null;\n        }\n        hasEnoughInfoToAppend_() {\n            if (!this.sourceUpdater_.ready()) {\n                return false;\n            } // If content needs to be removed or the loader is waiting on an append reattempt,\n            // then no additional content should be appended until the prior append is resolved.\n\n            if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {\n                return false;\n            }\n            const segmentInfo = this.pendingSegment_;\n            const trackInfo = this.getCurrentMediaInfo_(); // no segment to append any data for or\n            // we do not have information on this specific\n            // segment yet\n\n            if (!segmentInfo || !trackInfo) {\n                return false;\n            }\n            const {\n                hasAudio,\n                hasVideo,\n                isMuxed\n            } = trackInfo;\n            if (hasVideo && !segmentInfo.videoTimingInfo) {\n                return false;\n            } // muxed content only relies on video timing information for now.\n\n            if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {\n                return false;\n            }\n            if (shouldWaitForTimelineChange({\n                timelineChangeController: this.timelineChangeController_,\n                currentTimeline: this.currentTimeline_,\n                segmentTimeline: segmentInfo.timeline,\n                loaderType: this.loaderType_,\n                audioDisabled: this.audioDisabled_\n            })) {\n                return false;\n            }\n            return true;\n        }\n        handleData_(simpleSegment, result) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // If there's anything in the call queue, then this data came later and should be\n            // executed after the calls currently queued.\n\n            if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {\n                this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // update the time mapping so we can translate from display time to media time\n\n            this.setTimeMapping_(segmentInfo.timeline); // for tracking overall stats\n\n            this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment); // Note that the state isn't changed from loading to appending. This is because abort\n            // logic may change behavior depending on the state, and changing state too early may\n            // inflate our estimates of bandwidth. In the future this should be re-examined to\n            // note more granular states.\n            // don't process and append data if the mediaSource is closed\n\n            if (this.mediaSource_.readyState === 'closed') {\n                return;\n            } // if this request included an initialization segment, save that data\n            // to the initSegment cache\n\n            if (simpleSegment.map) {\n                simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true); // move over init segment properties to media request\n\n                segmentInfo.segment.map = simpleSegment.map;\n            } // if this request included a segment key, save that data in the cache\n\n            if (simpleSegment.key) {\n                this.segmentKey(simpleSegment.key, true);\n            }\n            segmentInfo.isFmp4 = simpleSegment.isFmp4;\n            segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n            if (segmentInfo.isFmp4) {\n                this.trigger('fmp4');\n                segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;\n            } else {\n                const trackInfo = this.getCurrentMediaInfo_();\n                const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n                let firstVideoFrameTimeForData;\n                if (useVideoTimingInfo) {\n                    firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;\n                } // Segment loader knows more about segment timing than the transmuxer (in certain\n                // aspects), so make any changes required for a more accurate start time.\n                // Don't set the end time yet, as the segment may not be finished processing.\n\n                segmentInfo.timingInfo.start = this.trueSegmentStart_({\n                    currentStart: segmentInfo.timingInfo.start,\n                    playlist: segmentInfo.playlist,\n                    mediaIndex: segmentInfo.mediaIndex,\n                    currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),\n                    useVideoTimingInfo,\n                    firstVideoFrameTimeForData,\n                    videoTimingInfo: segmentInfo.videoTimingInfo,\n                    audioTimingInfo: segmentInfo.audioTimingInfo\n                });\n            } // Init segments for audio and video only need to be appended in certain cases. Now\n            // that data is about to be appended, we can check the final cases to determine\n            // whether we should append an init segment.\n\n            this.updateAppendInitSegmentStatus(segmentInfo, result.type); // Timestamp offset should be updated once we get new data and have its timing info,\n            // as we use the start of the segment to offset the best guess (playlist provided)\n            // timestamp offset.\n\n            this.updateSourceBufferTimestampOffset_(segmentInfo); // if this is a sync request we need to determine whether it should\n            // be appended or not.\n\n            if (segmentInfo.isSyncRequest) {\n                // first save/update our timing info for this segment.\n                // this is what allows us to choose an accurate segment\n                // and the main reason we make a sync request.\n                this.updateTimingInfoEnd_(segmentInfo);\n                this.syncController_.saveSegmentTimingInfo({\n                    segmentInfo,\n                    shouldSaveTimelineMapping: this.loaderType_ === 'main'\n                });\n                const next = this.chooseNextRequest_(); // If the sync request isn't the segment that would be requested next\n                // after taking into account its timing info, do not append it.\n\n                if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {\n                    this.logger_('sync segment was incorrect, not appending');\n                    return;\n                } // otherwise append it like any other segment as our guess was correct.\n\n                this.logger_('sync segment was correct, appending');\n            } // Save some state so that in the future anything waiting on first append (and/or\n            // timestamp offset(s)) can process immediately. While the extra state isn't optimal,\n            // we need some notion of whether the timestamp offset or other relevant information\n            // has had a chance to be set.\n\n            segmentInfo.hasAppendedData_ = true; // Now that the timestamp offset should be set, we can append any waiting ID3 tags.\n\n            this.processMetadataQueue_();\n            this.appendData_(segmentInfo, result);\n        }\n        updateAppendInitSegmentStatus(segmentInfo, type) {\n            // alt audio doesn't manage timestamp offset\n            if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' &&\n                // in the case that we're handling partial data, we don't want to append an init\n                // segment for each chunk\n                !segmentInfo.changedTimestampOffset) {\n                // if the timestamp offset changed, the timeline may have changed, so we have to re-\n                // append init segments\n                this.appendInitSegment_ = {\n                    audio: true,\n                    video: true\n                };\n            }\n            if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {\n                // make sure we append init segment on playlist changes, in case the media config\n                // changed\n                this.appendInitSegment_[type] = true;\n            }\n        }\n        getInitSegmentAndUpdateState_({\n                                          type,\n                                          initSegment,\n                                          map,\n                                          playlist\n                                      }) {\n            // \"The EXT-X-MAP tag specifies how to obtain the Media Initialization Section\n            // (Section 3) required to parse the applicable Media Segments.  It applies to every\n            // Media Segment that appears after it in the Playlist until the next EXT-X-MAP tag\n            // or until the end of the playlist.\"\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.5\n            if (map) {\n                const id = initSegmentId(map);\n                if (this.activeInitSegmentId_ === id) {\n                    // don't need to re-append the init segment if the ID matches\n                    return null;\n                } // a map-specified init segment takes priority over any transmuxed (or otherwise\n                // obtained) init segment\n                //\n                // this also caches the init segment for later use\n\n                initSegment = this.initSegmentForMap(map, true).bytes;\n                this.activeInitSegmentId_ = id;\n            } // We used to always prepend init segments for video, however, that shouldn't be\n            // necessary. Instead, we should only append on changes, similar to what we've always\n            // done for audio. This is more important (though may not be that important) for\n            // frame-by-frame appending for LHLS, simply because of the increased quantity of\n            // appends.\n\n            if (initSegment && this.appendInitSegment_[type]) {\n                // Make sure we track the playlist that we last used for the init segment, so that\n                // we can re-append the init segment in the event that we get data from a new\n                // playlist. Discontinuities and track changes are handled in other sections.\n                this.playlistOfLastInitSegment_[type] = playlist; // Disable future init segment appends for this type. Until a change is necessary.\n\n                this.appendInitSegment_[type] = false; // we need to clear out the fmp4 active init segment id, since\n                // we are appending the muxer init segment\n\n                this.activeInitSegmentId_ = null;\n                return initSegment;\n            }\n            return null;\n        }\n        handleQuotaExceededError_({\n                                      segmentInfo,\n                                      type,\n                                      bytes\n                                  }, error) {\n            const audioBuffered = this.sourceUpdater_.audioBuffered();\n            const videoBuffered = this.sourceUpdater_.videoBuffered(); // For now we're ignoring any notion of gaps in the buffer, but they, in theory,\n            // should be cleared out during the buffer removals. However, log in case it helps\n            // debug.\n\n            if (audioBuffered.length > 1) {\n                this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: ' + timeRangesToArray(audioBuffered).join(', '));\n            }\n            if (videoBuffered.length > 1) {\n                this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: ' + timeRangesToArray(videoBuffered).join(', '));\n            }\n            const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;\n            const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;\n            const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;\n            const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;\n            if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {\n                // Can't remove enough buffer to make room for new segment (or the browser doesn't\n                // allow for appends of segments this size). In the future, it may be possible to\n                // split up the segment and append in pieces, but for now, error out this playlist\n                // in an attempt to switch to a more manageable rendition.\n                this.logger_('On QUOTA_EXCEEDED_ERR, single segment too large to append to ' + 'buffer, triggering an error. ' + `Appended byte length: ${bytes.byteLength}, ` + `audio buffer: ${timeRangesToArray(audioBuffered).join(', ')}, ` + `video buffer: ${timeRangesToArray(videoBuffered).join(', ')}, `);\n                this.error({\n                    message: 'Quota exceeded error with append of a single segment of content',\n                    excludeUntil: Infinity\n                });\n                this.trigger('error');\n                return;\n            } // To try to resolve the quota exceeded error, clear back buffer and retry. This means\n            // that the segment-loader should block on future events until this one is handled, so\n            // that it doesn't keep moving onto further segments. Adding the call to the call\n            // queue will prevent further appends until waitingOnRemove_ and\n            // quotaExceededErrorRetryTimeout_ are cleared.\n            //\n            // Note that this will only block the current loader. In the case of demuxed content,\n            // the other load may keep filling as fast as possible. In practice, this should be\n            // OK, as it is a rare case when either audio has a high enough bitrate to fill up a\n            // source buffer, or video fills without enough room for audio to append (and without\n            // the availability of clearing out seconds of back buffer to make room for audio).\n            // But it might still be good to handle this case in the future as a TODO.\n\n            this.waitingOnRemove_ = true;\n            this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {\n                segmentInfo,\n                type,\n                bytes\n            }));\n            const currentTime = this.currentTime_(); // Try to remove as much audio and video as possible to make room for new content\n            // before retrying.\n\n            const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;\n            this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);\n            this.remove(0, timeToRemoveUntil, () => {\n                this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);\n                this.waitingOnRemove_ = false; // wait the length of time alotted in the back buffer to prevent wasted\n                // attempts (since we can't clear less than the minimum)\n\n                this.quotaExceededErrorRetryTimeout_ = window.setTimeout(() => {\n                    this.logger_('On QUOTA_EXCEEDED_ERR, re-processing call queue');\n                    this.quotaExceededErrorRetryTimeout_ = null;\n                    this.processCallQueue_();\n                }, MIN_BACK_BUFFER * 1000);\n            }, true);\n        }\n        handleAppendError_({\n                               segmentInfo,\n                               type,\n                               bytes\n                           }, error) {\n            // if there's no error, nothing to do\n            if (!error) {\n                return;\n            }\n            if (error.code === QUOTA_EXCEEDED_ERR) {\n                this.handleQuotaExceededError_({\n                    segmentInfo,\n                    type,\n                    bytes\n                }); // A quota exceeded error should be recoverable with a future re-append, so no need\n                // to trigger an append error.\n\n                return;\n            }\n            this.logger_('Received non QUOTA_EXCEEDED_ERR on append', error);\n            this.error(`${type} append of ${bytes.length}b failed for segment ` + `#${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`); // If an append errors, we often can't recover.\n            // (see https://w3c.github.io/media-source/#sourcebuffer-append-error).\n            //\n            // Trigger a special error so that it can be handled separately from normal,\n            // recoverable errors.\n\n            this.trigger('appenderror');\n        }\n        appendToSourceBuffer_({\n                                  segmentInfo,\n                                  type,\n                                  initSegment,\n                                  data,\n                                  bytes\n                              }) {\n            // If this is a re-append, bytes were already created and don't need to be recreated\n            if (!bytes) {\n                const segments = [data];\n                let byteLength = data.byteLength;\n                if (initSegment) {\n                    // if the media initialization segment is changing, append it before the content\n                    // segment\n                    segments.unshift(initSegment);\n                    byteLength += initSegment.byteLength;\n                } // Technically we should be OK appending the init segment separately, however, we\n                // haven't yet tested that, and prepending is how we have always done things.\n\n                bytes = concatSegments({\n                    bytes: byteLength,\n                    segments\n                });\n            }\n            this.sourceUpdater_.appendBuffer({\n                segmentInfo,\n                type,\n                bytes\n            }, this.handleAppendError_.bind(this, {\n                segmentInfo,\n                type,\n                bytes\n            }));\n        }\n        handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {\n            if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {\n                return;\n            }\n            const segment = this.pendingSegment_.segment;\n            const timingInfoProperty = `${type}TimingInfo`;\n            if (!segment[timingInfoProperty]) {\n                segment[timingInfoProperty] = {};\n            }\n            segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;\n            segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;\n            segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;\n            segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;\n            segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode; // mainly used as a reference for debugging\n\n            segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;\n        }\n        appendData_(segmentInfo, result) {\n            const {\n                type,\n                data\n            } = result;\n            if (!data || !data.byteLength) {\n                return;\n            }\n            if (type === 'audio' && this.audioDisabled_) {\n                return;\n            }\n            const initSegment = this.getInitSegmentAndUpdateState_({\n                type,\n                initSegment: result.initSegment,\n                playlist: segmentInfo.playlist,\n                map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null\n            });\n            this.appendToSourceBuffer_({\n                segmentInfo,\n                type,\n                initSegment,\n                data\n            });\n        }\n        /**\n         * load a specific segment from a request into the buffer\n         *\n         * @private\n         */\n\n        loadSegment_(segmentInfo) {\n            this.state = 'WAITING';\n            this.pendingSegment_ = segmentInfo;\n            this.trimBackBuffer_(segmentInfo);\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                if (this.transmuxer_) {\n                    this.transmuxer_.postMessage({\n                        action: 'clearAllMp4Captions'\n                    });\n                }\n            }\n            if (!this.hasEnoughInfoToLoad_()) {\n                this.loadQueue_.push(() => {\n                    // regenerate the audioAppendStart, timestampOffset, etc as they\n                    // may have changed since this function was added to the queue.\n                    const options = _extends$1({}, segmentInfo, {\n                        forceTimestampOffset: true\n                    });\n                    _extends$1(segmentInfo, this.generateSegmentInfo_(options));\n                    this.isPendingTimestampOffset_ = false;\n                    this.updateTransmuxerAndRequestSegment_(segmentInfo);\n                });\n                return;\n            }\n            this.updateTransmuxerAndRequestSegment_(segmentInfo);\n        }\n        updateTransmuxerAndRequestSegment_(segmentInfo) {\n            // We'll update the source buffer's timestamp offset once we have transmuxed data, but\n            // the transmuxer still needs to be updated before then.\n            //\n            // Even though keepOriginalTimestamps is set to true for the transmuxer, timestamp\n            // offset must be passed to the transmuxer for stream correcting adjustments.\n            if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {\n                this.gopBuffer_.length = 0; // gopsToAlignWith was set before the GOP buffer was cleared\n\n                segmentInfo.gopsToAlignWith = [];\n                this.timeMapping_ = 0; // reset values in the transmuxer since a discontinuity should start fresh\n\n                this.transmuxer_.postMessage({\n                    action: 'reset'\n                });\n                this.transmuxer_.postMessage({\n                    action: 'setTimestampOffset',\n                    timestampOffset: segmentInfo.timestampOffset\n                });\n            }\n            const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);\n            const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);\n            const isWalkingForward = this.mediaIndex !== null;\n            const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ &&\n                // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,\n                // the first timeline\n                segmentInfo.timeline > 0;\n            const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;\n            this.logger_(`Requesting ${segmentInfoString(segmentInfo)}`); // If there's an init segment associated with this segment, but it is not cached (identified by a lack of bytes),\n            // then this init segment has never been seen before and should be appended.\n            //\n            // At this point the content type (audio/video or both) is not yet known, but it should be safe to set\n            // both to true and leave the decision of whether to append the init segment to append time.\n\n            if (simpleSegment.map && !simpleSegment.map.bytes) {\n                this.logger_('going to request init segment.');\n                this.appendInitSegment_ = {\n                    video: true,\n                    audio: true\n                };\n            }\n            segmentInfo.abortRequests = mediaSegmentRequest({\n                xhr: this.vhs_.xhr,\n                xhrOptions: this.xhrOptions_,\n                decryptionWorker: this.decrypter_,\n                segment: simpleSegment,\n                abortFn: this.handleAbort_.bind(this, segmentInfo),\n                progressFn: this.handleProgress_.bind(this),\n                trackInfoFn: this.handleTrackInfo_.bind(this),\n                timingInfoFn: this.handleTimingInfo_.bind(this),\n                videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'video', segmentInfo.requestId),\n                audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'audio', segmentInfo.requestId),\n                captionsFn: this.handleCaptions_.bind(this),\n                isEndOfTimeline,\n                endedTimelineFn: () => {\n                    this.logger_('received endedtimeline callback');\n                },\n                id3Fn: this.handleId3_.bind(this),\n                dataFn: this.handleData_.bind(this),\n                doneFn: this.segmentRequestFinished_.bind(this),\n                onTransmuxerLog: ({\n                                      message,\n                                      level,\n                                      stream\n                                  }) => {\n                    this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);\n                }\n            });\n        }\n        /**\n         * trim the back buffer so that we don't have too much data\n         * in the source buffer\n         *\n         * @private\n         *\n         * @param {Object} segmentInfo - the current segment\n         */\n\n        trimBackBuffer_(segmentInfo) {\n            const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); // Chrome has a hard limit of 150MB of\n            // buffer and a very conservative \"garbage collector\"\n            // We manually clear out the old buffer to ensure\n            // we don't trigger the QuotaExceeded error\n            // on the source buffer during subsequent appends\n\n            if (removeToTime > 0) {\n                this.remove(0, removeToTime);\n            }\n        }\n        /**\n         * created a simplified copy of the segment object with just the\n         * information necessary to perform the XHR and decryption\n         *\n         * @private\n         *\n         * @param {Object} segmentInfo - the current segment\n         * @return {Object} a simplified segment object copy\n         */\n\n        createSimplifiedSegmentObj_(segmentInfo) {\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            const simpleSegment = {\n                resolvedUri: part ? part.resolvedUri : segment.resolvedUri,\n                byterange: part ? part.byterange : segment.byterange,\n                requestId: segmentInfo.requestId,\n                transmuxer: segmentInfo.transmuxer,\n                audioAppendStart: segmentInfo.audioAppendStart,\n                gopsToAlignWith: segmentInfo.gopsToAlignWith,\n                part: segmentInfo.part\n            };\n            const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];\n            if (previousSegment && previousSegment.timeline === segment.timeline) {\n                // The baseStartTime of a segment is used to handle rollover when probing the TS\n                // segment to retrieve timing information. Since the probe only looks at the media's\n                // times (e.g., PTS and DTS values of the segment), and doesn't consider the\n                // player's time (e.g., player.currentTime()), baseStartTime should reflect the\n                // media time as well. transmuxedDecodeEnd represents the end time of a segment, in\n                // seconds of media time, so should be used here. The previous segment is used since\n                // the end of the previous segment should represent the beginning of the current\n                // segment, so long as they are on the same timeline.\n                if (previousSegment.videoTimingInfo) {\n                    simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;\n                } else if (previousSegment.audioTimingInfo) {\n                    simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;\n                }\n            }\n            if (segment.key) {\n                // if the media sequence is greater than 2^32, the IV will be incorrect\n                // assuming 10s segments, that would be about 1300 years\n                const iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n                simpleSegment.key = this.segmentKey(segment.key);\n                simpleSegment.key.iv = iv;\n            }\n            if (segment.map) {\n                simpleSegment.map = this.initSegmentForMap(segment.map);\n            }\n            return simpleSegment;\n        }\n        saveTransferStats_(stats) {\n            // every request counts as a media request even if it has been aborted\n            // or canceled due to a timeout\n            this.mediaRequests += 1;\n            if (stats) {\n                this.mediaBytesTransferred += stats.bytesReceived;\n                this.mediaTransferDuration += stats.roundTripTime;\n            }\n        }\n        saveBandwidthRelatedStats_(duration, stats) {\n            // byteLength will be used for throughput, and should be based on bytes receieved,\n            // which we only know at the end of the request and should reflect total bytes\n            // downloaded rather than just bytes processed from components of the segment\n            this.pendingSegment_.byteLength = stats.bytesReceived;\n            if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n                this.logger_(`Ignoring segment's bandwidth because its duration of ${duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n                return;\n            }\n            this.bandwidth = stats.bandwidth;\n            this.roundTrip = stats.roundTripTime;\n        }\n        handleTimeout_() {\n            // although the VTT segment loader bandwidth isn't really used, it's good to\n            // maintain functinality between segment loaders\n            this.mediaRequestsTimedout += 1;\n            this.bandwidth = 1;\n            this.roundTrip = NaN;\n            this.trigger('bandwidthupdate');\n            this.trigger('timeout');\n        }\n        /**\n         * Handle the callback from the segmentRequest function and set the\n         * associated SegmentLoader state and errors if necessary\n         *\n         * @private\n         */\n\n        segmentRequestFinished_(error, simpleSegment, result) {\n            // TODO handle special cases, e.g., muxed audio/video but only audio in the segment\n            // check the call queue directly since this function doesn't need to deal with any\n            // data, and can continue even if the source buffers are not set up and we didn't get\n            // any data from the segment\n            if (this.callQueue_.length) {\n                this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));\n                return;\n            }\n            this.saveTransferStats_(simpleSegment.stats); // The request was aborted and the SegmentLoader has already been reset\n\n            if (!this.pendingSegment_) {\n                return;\n            } // the request was aborted and the SegmentLoader has already started\n            // another request. this can happen when the timeout for an aborted\n            // request triggers due to a limitation in the XHR library\n            // do not count this as any sort of request or we risk double-counting\n\n            if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n                return;\n            } // an error occurred from the active pendingSegment_ so reset everything\n\n            if (error) {\n                this.pendingSegment_ = null;\n                this.state = 'READY'; // aborts are not a true error condition and nothing corrective needs to be done\n\n                if (error.code === REQUEST_ERRORS.ABORTED) {\n                    return;\n                }\n                this.pause(); // the error is really just that at least one of the requests timed-out\n                // set the bandwidth to a very low value and trigger an ABR switch to\n                // take emergency action\n\n                if (error.code === REQUEST_ERRORS.TIMEOUT) {\n                    this.handleTimeout_();\n                    return;\n                } // if control-flow has arrived here, then the error is real\n                // emit an error event to exclude the current playlist\n\n                this.mediaRequestsErrored += 1;\n                this.error(error);\n                this.trigger('error');\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // the response was a success so set any bandwidth stats the request\n            // generated for ABR purposes\n\n            this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);\n            segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n            if (result.gopInfo) {\n                this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);\n            } // Although we may have already started appending on progress, we shouldn't switch the\n            // state away from loading until we are officially done loading the segment data.\n\n            this.state = 'APPENDING'; // used for testing\n\n            this.trigger('appending');\n            this.waitForAppendsToComplete_(segmentInfo);\n        }\n        setTimeMapping_(timeline) {\n            const timelineMapping = this.syncController_.mappingForTimeline(timeline);\n            if (timelineMapping !== null) {\n                this.timeMapping_ = timelineMapping;\n            }\n        }\n        updateMediaSecondsLoaded_(segment) {\n            if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n                this.mediaSecondsLoaded += segment.end - segment.start;\n            } else {\n                this.mediaSecondsLoaded += segment.duration;\n            }\n        }\n        shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {\n            if (timestampOffset === null) {\n                return false;\n            } // note that we're potentially using the same timestamp offset for both video and\n            // audio\n\n            if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n                return true;\n            }\n            if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n                return true;\n            }\n            return false;\n        }\n        trueSegmentStart_({\n                              currentStart,\n                              playlist,\n                              mediaIndex,\n                              firstVideoFrameTimeForData,\n                              currentVideoTimestampOffset,\n                              useVideoTimingInfo,\n                              videoTimingInfo,\n                              audioTimingInfo\n                          }) {\n            if (typeof currentStart !== 'undefined') {\n                // if start was set once, keep using it\n                return currentStart;\n            }\n            if (!useVideoTimingInfo) {\n                return audioTimingInfo.start;\n            }\n            const previousSegment = playlist.segments[mediaIndex - 1]; // The start of a segment should be the start of the first full frame contained\n            // within that segment. Since the transmuxer maintains a cache of incomplete data\n            // from and/or the last frame seen, the start time may reflect a frame that starts\n            // in the previous segment. Check for that case and ensure the start time is\n            // accurate for the segment.\n\n            if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {\n                return firstVideoFrameTimeForData;\n            }\n            return videoTimingInfo.start;\n        }\n        waitForAppendsToComplete_(segmentInfo) {\n            const trackInfo = this.getCurrentMediaInfo_(segmentInfo);\n            if (!trackInfo) {\n                this.error({\n                    message: 'No starting media returned, likely due to an unsupported media format.',\n                    playlistExclusionDuration: Infinity\n                });\n                this.trigger('error');\n                return;\n            } // Although transmuxing is done, appends may not yet be finished. Throw a marker\n            // on each queue this loader is responsible for to ensure that the appends are\n            // complete.\n\n            const {\n                hasAudio,\n                hasVideo,\n                isMuxed\n            } = trackInfo;\n            const waitForVideo = this.loaderType_ === 'main' && hasVideo;\n            const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;\n            segmentInfo.waitingOnAppends = 0; // segments with no data\n\n            if (!segmentInfo.hasAppendedData_) {\n                if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {\n                    // When there's no audio or video data in the segment, there's no audio or video\n                    // timing information.\n                    //\n                    // If there's no audio or video timing information, then the timestamp offset\n                    // can't be adjusted to the appropriate value for the transmuxer and source\n                    // buffers.\n                    //\n                    // Therefore, the next segment should be used to set the timestamp offset.\n                    this.isPendingTimestampOffset_ = true;\n                } // override settings for metadata only segments\n\n                segmentInfo.timingInfo = {\n                    start: 0\n                };\n                segmentInfo.waitingOnAppends++;\n                if (!this.isPendingTimestampOffset_) {\n                    // update the timestampoffset\n                    this.updateSourceBufferTimestampOffset_(segmentInfo); // make sure the metadata queue is processed even though we have\n                    // no video/audio data.\n\n                    this.processMetadataQueue_();\n                } // append is \"done\" instantly with no data.\n\n                this.checkAppendsDone_(segmentInfo);\n                return;\n            } // Since source updater could call back synchronously, do the increments first.\n\n            if (waitForVideo) {\n                segmentInfo.waitingOnAppends++;\n            }\n            if (waitForAudio) {\n                segmentInfo.waitingOnAppends++;\n            }\n            if (waitForVideo) {\n                this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n            }\n            if (waitForAudio) {\n                this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n            }\n        }\n        checkAppendsDone_(segmentInfo) {\n            if (this.checkForAbort_(segmentInfo.requestId)) {\n                return;\n            }\n            segmentInfo.waitingOnAppends--;\n            if (segmentInfo.waitingOnAppends === 0) {\n                this.handleAppendsDone_();\n            }\n        }\n        checkForIllegalMediaSwitch(trackInfo) {\n            const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);\n            if (illegalMediaSwitchError) {\n                this.error({\n                    message: illegalMediaSwitchError,\n                    playlistExclusionDuration: Infinity\n                });\n                this.trigger('error');\n                return true;\n            }\n            return false;\n        }\n        updateSourceBufferTimestampOffset_(segmentInfo) {\n            if (segmentInfo.timestampOffset === null ||\n                // we don't yet have the start for whatever media type (video or audio) has\n                // priority, timing-wise, so we must wait\n                typeof segmentInfo.timingInfo.start !== 'number' ||\n                // already updated the timestamp offset for this segment\n                segmentInfo.changedTimestampOffset ||\n                // the alt audio loader should not be responsible for setting the timestamp offset\n                this.loaderType_ !== 'main') {\n                return;\n            }\n            let didChange = false; // Primary timing goes by video, and audio is trimmed in the transmuxer, meaning that\n            // the timing info here comes from video. In the event that the audio is longer than\n            // the video, this will trim the start of the audio.\n            // This also trims any offset from 0 at the beginning of the media\n\n            segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({\n                videoTimingInfo: segmentInfo.segment.videoTimingInfo,\n                audioTimingInfo: segmentInfo.segment.audioTimingInfo,\n                timingInfo: segmentInfo.timingInfo\n            }); // In the event that there are part segment downloads, each will try to update the\n            // timestamp offset. Retaining this bit of state prevents us from updating in the\n            // future (within the same segment), however, there may be a better way to handle it.\n\n            segmentInfo.changedTimestampOffset = true;\n            if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n                this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);\n                didChange = true;\n            }\n            if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n                this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);\n                didChange = true;\n            }\n            if (didChange) {\n                this.trigger('timestampoffset');\n            }\n        }\n        getSegmentStartTimeForTimestampOffsetCalculation_({\n                                                              videoTimingInfo,\n                                                              audioTimingInfo,\n                                                              timingInfo\n                                                          }) {\n            if (!this.useDtsForTimestampOffset_) {\n                return timingInfo.start;\n            }\n            if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === 'number') {\n                return videoTimingInfo.transmuxedDecodeStart;\n            } // handle audio only\n\n            if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === 'number') {\n                return audioTimingInfo.transmuxedDecodeStart;\n            } // handle content not transmuxed (e.g., MP4)\n\n            return timingInfo.start;\n        }\n        updateTimingInfoEnd_(segmentInfo) {\n            segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n            const trackInfo = this.getMediaInfo_();\n            const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n            const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;\n            if (!prioritizedTimingInfo) {\n                return;\n            }\n            segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ?\n                // End time may not exist in a case where we aren't parsing the full segment (one\n                // current example is the case of fmp4), so use the rough duration to calculate an\n                // end time.\n                prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;\n        }\n        /**\n         * callback to run when appendBuffer is finished. detects if we are\n         * in a good state to do things with the data we got, or if we need\n         * to wait for more\n         *\n         * @private\n         */\n\n        handleAppendsDone_() {\n            // appendsdone can cause an abort\n            if (this.pendingSegment_) {\n                this.trigger('appendsdone');\n            }\n            if (!this.pendingSegment_) {\n                this.state = 'READY'; // TODO should this move into this.checkForAbort to speed up requests post abort in\n                // all appending cases?\n\n                if (!this.paused()) {\n                    this.monitorBuffer_();\n                }\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // Now that the end of the segment has been reached, we can set the end time. It's\n            // best to wait until all appends are done so we're sure that the primary media is\n            // finished (and we have its end time).\n\n            this.updateTimingInfoEnd_(segmentInfo);\n            if (this.shouldSaveSegmentTimingInfo_) {\n                // Timeline mappings should only be saved for the main loader. This is for multiple\n                // reasons:\n                //\n                // 1) Only one mapping is saved per timeline, meaning that if both the audio loader\n                //    and the main loader try to save the timeline mapping, whichever comes later\n                //    will overwrite the first. In theory this is OK, as the mappings should be the\n                //    same, however, it breaks for (2)\n                // 2) In the event of a live stream, the initial live point will make for a somewhat\n                //    arbitrary mapping. If audio and video streams are not perfectly in-sync, then\n                //    the mapping will be off for one of the streams, dependent on which one was\n                //    first saved (see (1)).\n                // 3) Primary timing goes by video in VHS, so the mapping should be video.\n                //\n                // Since the audio loader will wait for the main loader to load the first segment,\n                // the main loader will save the first timeline mapping, and ensure that there won't\n                // be a case where audio loads two segments without saving a mapping (thus leading\n                // to missing segment timing info).\n                this.syncController_.saveSegmentTimingInfo({\n                    segmentInfo,\n                    shouldSaveTimelineMapping: this.loaderType_ === 'main'\n                });\n            }\n            const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);\n            if (segmentDurationMessage) {\n                if (segmentDurationMessage.severity === 'warn') {\n                    videojs.log.warn(segmentDurationMessage.message);\n                } else {\n                    this.logger_(segmentDurationMessage.message);\n                }\n            }\n            this.recordThroughput_(segmentInfo);\n            this.pendingSegment_ = null;\n            this.state = 'READY';\n            if (segmentInfo.isSyncRequest) {\n                this.trigger('syncinfoupdate'); // if the sync request was not appended\n                // then it was not the correct segment.\n                // throw it away and use the data it gave us\n                // to get the correct one.\n\n                if (!segmentInfo.hasAppendedData_) {\n                    this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);\n                    return;\n                }\n            }\n            this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);\n            this.addSegmentMetadataCue_(segmentInfo);\n            this.fetchAtBuffer_ = true;\n            if (this.currentTimeline_ !== segmentInfo.timeline) {\n                this.timelineChangeController_.lastTimelineChange({\n                    type: this.loaderType_,\n                    from: this.currentTimeline_,\n                    to: segmentInfo.timeline\n                }); // If audio is not disabled, the main segment loader is responsible for updating\n                // the audio timeline as well. If the content is video only, this won't have any\n                // impact.\n\n                if (this.loaderType_ === 'main' && !this.audioDisabled_) {\n                    this.timelineChangeController_.lastTimelineChange({\n                        type: 'audio',\n                        from: this.currentTimeline_,\n                        to: segmentInfo.timeline\n                    });\n                }\n            }\n            this.currentTimeline_ = segmentInfo.timeline; // We must update the syncinfo to recalculate the seekable range before\n            // the following conditional otherwise it may consider this a bad \"guess\"\n            // and attempt to resync when the post-update seekable window and live\n            // point would mean that this was the perfect segment to fetch\n\n            this.trigger('syncinfoupdate');\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;\n            const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3; // If we previously appended a segment/part that ends more than 3 part/targetDurations before\n            // the currentTime_ that means that our conservative guess was too conservative.\n            // In that case, reset the loader state so that we try to use any information gained\n            // from the previous request to create a new, more accurate, sync-point.\n\n            if (badSegmentGuess || badPartGuess) {\n                this.logger_(`bad ${badSegmentGuess ? 'segment' : 'part'} ${segmentInfoString(segmentInfo)}`);\n                this.resetEverything();\n                return;\n            }\n            const isWalkingForward = this.mediaIndex !== null; // Don't do a rendition switch unless we have enough time to get a sync segment\n            // and conservatively guess\n\n            if (isWalkingForward) {\n                this.trigger('bandwidthupdate');\n            }\n            this.trigger('progress');\n            this.mediaIndex = segmentInfo.mediaIndex;\n            this.partIndex = segmentInfo.partIndex; // any time an update finishes and the last segment is in the\n            // buffer, end the stream. this ensures the \"ended\" event will\n            // fire if playback reaches that point.\n\n            if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {\n                this.endOfStream();\n            } // used for testing\n\n            this.trigger('appended');\n            if (segmentInfo.hasAppendedData_) {\n                this.mediaAppends++;\n            }\n            if (!this.paused()) {\n                this.monitorBuffer_();\n            }\n        }\n        /**\n         * Records the current throughput of the decrypt, transmux, and append\n         * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n         * moving average of the throughput. `throughput.count` is the number of\n         * data points in the average.\n         *\n         * @private\n         * @param {Object} segmentInfo the object returned by loadSegment\n         */\n\n        recordThroughput_(segmentInfo) {\n            if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n                this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n                return;\n            }\n            const rate = this.throughput.rate; // Add one to the time to ensure that we don't accidentally attempt to divide\n            // by zero in the case where the throughput is ridiculously high\n\n            const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1; // Multiply by 8000 to convert from bytes/millisecond to bits/second\n\n            const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000); // This is just a cumulative moving average calculation:\n            //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n\n            this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n        }\n        /**\n         * Adds a cue to the segment-metadata track with some metadata information about the\n         * segment\n         *\n         * @private\n         * @param {Object} segmentInfo\n         *        the object returned by loadSegment\n         * @method addSegmentMetadataCue_\n         */\n\n        addSegmentMetadataCue_(segmentInfo) {\n            if (!this.segmentMetadataTrack_) {\n                return;\n            }\n            const segment = segmentInfo.segment;\n            const start = segment.start;\n            const end = segment.end; // Do not try adding the cue if the start and end times are invalid.\n\n            if (!finite(start) || !finite(end)) {\n                return;\n            }\n            removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n            const Cue = window.WebKitDataCue || window.VTTCue;\n            const value = {\n                custom: segment.custom,\n                dateTimeObject: segment.dateTimeObject,\n                dateTimeString: segment.dateTimeString,\n                programDateTime: segment.programDateTime,\n                bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n                resolution: segmentInfo.playlist.attributes.RESOLUTION,\n                codecs: segmentInfo.playlist.attributes.CODECS,\n                byteLength: segmentInfo.byteLength,\n                uri: segmentInfo.uri,\n                timeline: segmentInfo.timeline,\n                playlist: segmentInfo.playlist.id,\n                start,\n                end\n            };\n            const data = JSON.stringify(value);\n            const cue = new Cue(start, end, data); // Attach the metadata to the value property of the cue to keep consistency between\n            // the differences of WebKitDataCue in safari and VTTCue in other browsers\n\n            cue.value = value;\n            this.segmentMetadataTrack_.addCue(cue);\n        }\n    }\n    function noop() {}\n    const toTitleCase = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toUpperCase());\n    };\n\n    /**\n     * @file source-updater.js\n     */\n    const bufferTypes = ['video', 'audio'];\n    const updating = (type, sourceUpdater) => {\n        const sourceBuffer = sourceUpdater[`${type}Buffer`];\n        return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];\n    };\n    const nextQueueIndexOfType = (type, queue) => {\n        for (let i = 0; i < queue.length; i++) {\n            const queueEntry = queue[i];\n            if (queueEntry.type === 'mediaSource') {\n                // If the next entry is a media source entry (uses multiple source buffers), block\n                // processing to allow it to go through first.\n                return null;\n            }\n            if (queueEntry.type === type) {\n                return i;\n            }\n        }\n        return null;\n    };\n    const shiftQueue = (type, sourceUpdater) => {\n        if (sourceUpdater.queue.length === 0) {\n            return;\n        }\n        let queueIndex = 0;\n        let queueEntry = sourceUpdater.queue[queueIndex];\n        if (queueEntry.type === 'mediaSource') {\n            if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {\n                sourceUpdater.queue.shift();\n                queueEntry.action(sourceUpdater);\n                if (queueEntry.doneFn) {\n                    queueEntry.doneFn();\n                } // Only specific source buffer actions must wait for async updateend events. Media\n                // Source actions process synchronously. Therefore, both audio and video source\n                // buffers are now clear to process the next queue entries.\n\n                shiftQueue('audio', sourceUpdater);\n                shiftQueue('video', sourceUpdater);\n            } // Media Source actions require both source buffers, so if the media source action\n            // couldn't process yet (because one or both source buffers are busy), block other\n            // queue actions until both are available and the media source action can process.\n\n            return;\n        }\n        if (type === 'mediaSource') {\n            // If the queue was shifted by a media source action (this happens when pushing a\n            // media source action onto the queue), then it wasn't from an updateend event from an\n            // audio or video source buffer, so there's no change from previous state, and no\n            // processing should be done.\n            return;\n        } // Media source queue entries don't need to consider whether the source updater is\n        // started (i.e., source buffers are created) as they don't need the source buffers, but\n        // source buffer queue entries do.\n\n        if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === 'closed' || updating(type, sourceUpdater)) {\n            return;\n        }\n        if (queueEntry.type !== type) {\n            queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);\n            if (queueIndex === null) {\n                // Either there's no queue entry that uses this source buffer type in the queue, or\n                // there's a media source queue entry before the next entry of this type, in which\n                // case wait for that action to process first.\n                return;\n            }\n            queueEntry = sourceUpdater.queue[queueIndex];\n        }\n        sourceUpdater.queue.splice(queueIndex, 1); // Keep a record that this source buffer type is in use.\n        //\n        // The queue pending operation must be set before the action is performed in the event\n        // that the action results in a synchronous event that is acted upon. For instance, if\n        // an exception is thrown that can be handled, it's possible that new actions will be\n        // appended to an empty queue and immediately executed, but would not have the correct\n        // pending information if this property was set after the action was performed.\n\n        sourceUpdater.queuePending[type] = queueEntry;\n        queueEntry.action(type, sourceUpdater);\n        if (!queueEntry.doneFn) {\n            // synchronous operation, process next entry\n            sourceUpdater.queuePending[type] = null;\n            shiftQueue(type, sourceUpdater);\n            return;\n        }\n    };\n    const cleanupBuffer = (type, sourceUpdater) => {\n        const buffer = sourceUpdater[`${type}Buffer`];\n        const titleType = toTitleCase(type);\n        if (!buffer) {\n            return;\n        }\n        buffer.removeEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n        buffer.removeEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n        sourceUpdater.codecs[type] = null;\n        sourceUpdater[`${type}Buffer`] = null;\n    };\n    const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;\n    const actions = {\n        appendBuffer: (bytes, segmentInfo, onError) => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);\n            try {\n                sourceBuffer.appendBuffer(bytes);\n            } catch (e) {\n                sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? '(QUOTA_EXCEEDED_ERR) ' : '') + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);\n                sourceUpdater.queuePending[type] = null;\n                onError(e);\n            }\n        },\n        remove: (start, end) => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);\n            try {\n                sourceBuffer.remove(start, end);\n            } catch (e) {\n                sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);\n            }\n        },\n        timestampOffset: offset => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);\n            sourceBuffer.timestampOffset = offset;\n        },\n        callback: callback => (type, sourceUpdater) => {\n            callback();\n        },\n        endOfStream: error => sourceUpdater => {\n            if (sourceUpdater.mediaSource.readyState !== 'open') {\n                return;\n            }\n            sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ''})`);\n            try {\n                sourceUpdater.mediaSource.endOfStream(error);\n            } catch (e) {\n                videojs.log.warn('Failed to call media source endOfStream', e);\n            }\n        },\n        duration: duration => sourceUpdater => {\n            sourceUpdater.logger_(`Setting mediaSource duration to ${duration}`);\n            try {\n                sourceUpdater.mediaSource.duration = duration;\n            } catch (e) {\n                videojs.log.warn('Failed to set media source duration', e);\n            }\n        },\n        abort: () => (type, sourceUpdater) => {\n            if (sourceUpdater.mediaSource.readyState !== 'open') {\n                return;\n            }\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`calling abort on ${type}Buffer`);\n            try {\n                sourceBuffer.abort();\n            } catch (e) {\n                videojs.log.warn(`Failed to abort on ${type}Buffer`, e);\n            }\n        },\n        addSourceBuffer: (type, codec) => sourceUpdater => {\n            const titleType = toTitleCase(type);\n            const mime = getMimeForCodec(codec);\n            sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);\n            const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);\n            sourceBuffer.addEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n            sourceBuffer.addEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n            sourceUpdater.codecs[type] = codec;\n            sourceUpdater[`${type}Buffer`] = sourceBuffer;\n        },\n        removeSourceBuffer: type => sourceUpdater => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`];\n            cleanupBuffer(type, sourceUpdater); // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);\n            try {\n                sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);\n            } catch (e) {\n                videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);\n            }\n        },\n        changeType: codec => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`];\n            const mime = getMimeForCodec(codec); // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            } // do not update codec if we don't need to.\n\n            if (sourceUpdater.codecs[type] === codec) {\n                return;\n            }\n            sourceUpdater.logger_(`changing ${type}Buffer codec from ${sourceUpdater.codecs[type]} to ${codec}`); // check if change to the provided type is supported\n\n            try {\n                sourceBuffer.changeType(mime);\n                sourceUpdater.codecs[type] = codec;\n            } catch (e) {\n                videojs.log.warn(`Failed to changeType on ${type}Buffer`, e);\n            }\n        }\n    };\n    const pushQueue = ({\n                           type,\n                           sourceUpdater,\n                           action,\n                           doneFn,\n                           name\n                       }) => {\n        sourceUpdater.queue.push({\n            type,\n            action,\n            doneFn,\n            name\n        });\n        shiftQueue(type, sourceUpdater);\n    };\n    const onUpdateend = (type, sourceUpdater) => e => {\n        // Although there should, in theory, be a pending action for any updateend receieved,\n        // there are some actions that may trigger updateend events without set definitions in\n        // the w3c spec. For instance, setting the duration on the media source may trigger\n        // updateend events on source buffers. This does not appear to be in the spec. As such,\n        // if we encounter an updateend without a corresponding pending action from our queue\n        // for that source buffer type, process the next action.\n        if (sourceUpdater.queuePending[type]) {\n            const doneFn = sourceUpdater.queuePending[type].doneFn;\n            sourceUpdater.queuePending[type] = null;\n            if (doneFn) {\n                // if there's an error, report it\n                doneFn(sourceUpdater[`${type}Error_`]);\n            }\n        }\n        shiftQueue(type, sourceUpdater);\n    };\n    /**\n     * A queue of callbacks to be serialized and applied when a\n     * MediaSource and its associated SourceBuffers are not in the\n     * updating state. It is used by the segment loader to update the\n     * underlying SourceBuffers when new data is loaded, for instance.\n     *\n     * @class SourceUpdater\n     * @param {MediaSource} mediaSource the MediaSource to create the SourceBuffer from\n     * @param {string} mimeType the desired MIME type of the underlying SourceBuffer\n     */\n\n    class SourceUpdater extends videojs.EventTarget {\n        constructor(mediaSource) {\n            super();\n            this.mediaSource = mediaSource;\n            this.sourceopenListener_ = () => shiftQueue('mediaSource', this);\n            this.mediaSource.addEventListener('sourceopen', this.sourceopenListener_);\n            this.logger_ = logger('SourceUpdater'); // initial timestamp offset is 0\n\n            this.audioTimestampOffset_ = 0;\n            this.videoTimestampOffset_ = 0;\n            this.queue = [];\n            this.queuePending = {\n                audio: null,\n                video: null\n            };\n            this.delayedAudioAppendQueue_ = [];\n            this.videoAppendQueued_ = false;\n            this.codecs = {};\n            this.onVideoUpdateEnd_ = onUpdateend('video', this);\n            this.onAudioUpdateEnd_ = onUpdateend('audio', this);\n            this.onVideoError_ = e => {\n                // used for debugging\n                this.videoError_ = e;\n            };\n            this.onAudioError_ = e => {\n                // used for debugging\n                this.audioError_ = e;\n            };\n            this.createdSourceBuffers_ = false;\n            this.initializedEme_ = false;\n            this.triggeredReady_ = false;\n        }\n        initializedEme() {\n            this.initializedEme_ = true;\n            this.triggerReady();\n        }\n        hasCreatedSourceBuffers() {\n            // if false, likely waiting on one of the segment loaders to get enough data to create\n            // source buffers\n            return this.createdSourceBuffers_;\n        }\n        hasInitializedAnyEme() {\n            return this.initializedEme_;\n        }\n        ready() {\n            return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();\n        }\n        createSourceBuffers(codecs) {\n            if (this.hasCreatedSourceBuffers()) {\n                // already created them before\n                return;\n            } // the intial addOrChangeSourceBuffers will always be\n            // two add buffers.\n\n            this.addOrChangeSourceBuffers(codecs);\n            this.createdSourceBuffers_ = true;\n            this.trigger('createdsourcebuffers');\n            this.triggerReady();\n        }\n        triggerReady() {\n            // only allow ready to be triggered once, this prevents the case\n            // where:\n            // 1. we trigger createdsourcebuffers\n            // 2. ie 11 synchronously initializates eme\n            // 3. the synchronous initialization causes us to trigger ready\n            // 4. We go back to the ready check in createSourceBuffers and ready is triggered again.\n            if (this.ready() && !this.triggeredReady_) {\n                this.triggeredReady_ = true;\n                this.trigger('ready');\n            }\n        }\n        /**\n         * Add a type of source buffer to the media source.\n         *\n         * @param {string} type\n         *        The type of source buffer to add.\n         *\n         * @param {string} codec\n         *        The codec to add the source buffer with.\n         */\n\n        addSourceBuffer(type, codec) {\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.addSourceBuffer(type, codec),\n                name: 'addSourceBuffer'\n            });\n        }\n        /**\n         * call abort on a source buffer.\n         *\n         * @param {string} type\n         *        The type of source buffer to call abort on.\n         */\n\n        abort(type) {\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.abort(type),\n                name: 'abort'\n            });\n        }\n        /**\n         * Call removeSourceBuffer and remove a specific type\n         * of source buffer on the mediaSource.\n         *\n         * @param {string} type\n         *        The type of source buffer to remove.\n         */\n\n        removeSourceBuffer(type) {\n            if (!this.canRemoveSourceBuffer()) {\n                videojs.log.error('removeSourceBuffer is not supported!');\n                return;\n            }\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.removeSourceBuffer(type),\n                name: 'removeSourceBuffer'\n            });\n        }\n        /**\n         * Whether or not the removeSourceBuffer function is supported\n         * on the mediaSource.\n         *\n         * @return {boolean}\n         *          if removeSourceBuffer can be called.\n         */\n\n        canRemoveSourceBuffer() {\n            // As of Firefox 83 removeSourceBuffer\n            // throws errors, so we report that it does not support this.\n            return !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === 'function';\n        }\n        /**\n         * Whether or not the changeType function is supported\n         * on our SourceBuffers.\n         *\n         * @return {boolean}\n         *         if changeType can be called.\n         */\n\n        static canChangeType() {\n            return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === 'function';\n        }\n        /**\n         * Whether or not the changeType function is supported\n         * on our SourceBuffers.\n         *\n         * @return {boolean}\n         *         if changeType can be called.\n         */\n\n        canChangeType() {\n            return this.constructor.canChangeType();\n        }\n        /**\n         * Call the changeType function on a source buffer, given the code and type.\n         *\n         * @param {string} type\n         *        The type of source buffer to call changeType on.\n         *\n         * @param {string} codec\n         *        The codec string to change type with on the source buffer.\n         */\n\n        changeType(type, codec) {\n            if (!this.canChangeType()) {\n                videojs.log.error('changeType is not supported!');\n                return;\n            }\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.changeType(codec),\n                name: 'changeType'\n            });\n        }\n        /**\n         * Add source buffers with a codec or, if they are already created,\n         * call changeType on source buffers using changeType.\n         *\n         * @param {Object} codecs\n         *        Codecs to switch to\n         */\n\n        addOrChangeSourceBuffers(codecs) {\n            if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {\n                throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');\n            }\n            Object.keys(codecs).forEach(type => {\n                const codec = codecs[type];\n                if (!this.hasCreatedSourceBuffers()) {\n                    return this.addSourceBuffer(type, codec);\n                }\n                if (this.canChangeType()) {\n                    this.changeType(type, codec);\n                }\n            });\n        }\n        /**\n         * Queue an update to append an ArrayBuffer.\n         *\n         * @param {MediaObject} object containing audioBytes and/or videoBytes\n         * @param {Function} done the function to call when done\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n         */\n\n        appendBuffer(options, doneFn) {\n            const {\n                segmentInfo,\n                type,\n                bytes\n            } = options;\n            this.processedAppend_ = true;\n            if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {\n                this.delayedAudioAppendQueue_.push([options, doneFn]);\n                this.logger_(`delayed audio append of ${bytes.length} until video append`);\n                return;\n            } // In the case of certain errors, for instance, QUOTA_EXCEEDED_ERR, updateend will\n            // not be fired. This means that the queue will be blocked until the next action\n            // taken by the segment-loader. Provide a mechanism for segment-loader to handle\n            // these errors by calling the doneFn with the specific error.\n\n            const onError = doneFn;\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.appendBuffer(bytes, segmentInfo || {\n                    mediaIndex: -1\n                }, onError),\n                doneFn,\n                name: 'appendBuffer'\n            });\n            if (type === 'video') {\n                this.videoAppendQueued_ = true;\n                if (!this.delayedAudioAppendQueue_.length) {\n                    return;\n                }\n                const queue = this.delayedAudioAppendQueue_.slice();\n                this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);\n                this.delayedAudioAppendQueue_.length = 0;\n                queue.forEach(que => {\n                    this.appendBuffer.apply(this, que);\n                });\n            }\n        }\n        /**\n         * Get the audio buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         The audio buffer's buffered time range\n         */\n\n        audioBuffered() {\n            // no media source/source buffer or it isn't in the media sources\n            // source buffer list\n            if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {\n                return createTimeRanges();\n            }\n            return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();\n        }\n        /**\n         * Get the video buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         The video buffer's buffered time range\n         */\n\n        videoBuffered() {\n            // no media source/source buffer or it isn't in the media sources\n            // source buffer list\n            if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {\n                return createTimeRanges();\n            }\n            return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();\n        }\n        /**\n         * Get a combined video/audio buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         the combined time range\n         */\n\n        buffered() {\n            const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;\n            const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;\n            if (audio && !video) {\n                return this.audioBuffered();\n            }\n            if (video && !audio) {\n                return this.videoBuffered();\n            }\n            return bufferIntersection(this.audioBuffered(), this.videoBuffered());\n        }\n        /**\n         * Add a callback to the queue that will set duration on the mediaSource.\n         *\n         * @param {number} duration\n         *        The duration to set\n         *\n         * @param {Function} [doneFn]\n         *        function to run after duration has been set.\n         */\n\n        setDuration(duration, doneFn = noop) {\n            // In order to set the duration on the media source, it's necessary to wait for all\n            // source buffers to no longer be updating. \"If the updating attribute equals true on\n            // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n            // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.duration(duration),\n                name: 'duration',\n                doneFn\n            });\n        }\n        /**\n         * Add a mediaSource endOfStream call to the queue\n         *\n         * @param {Error} [error]\n         *        Call endOfStream with an error\n         *\n         * @param {Function} [doneFn]\n         *        A function that should be called when the\n         *        endOfStream call has finished.\n         */\n\n        endOfStream(error = null, doneFn = noop) {\n            if (typeof error !== 'string') {\n                error = undefined;\n            } // In order to set the duration on the media source, it's necessary to wait for all\n            // source buffers to no longer be updating. \"If the updating attribute equals true on\n            // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n            // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.endOfStream(error),\n                name: 'endOfStream',\n                doneFn\n            });\n        }\n        /**\n         * Queue an update to remove a time range from the buffer.\n         *\n         * @param {number} start where to start the removal\n         * @param {number} end where to end the removal\n         * @param {Function} [done=noop] optional callback to be executed when the remove\n         * operation is complete\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n         */\n\n        removeAudio(start, end, done = noop) {\n            if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {\n                done();\n                return;\n            }\n            pushQueue({\n                type: 'audio',\n                sourceUpdater: this,\n                action: actions.remove(start, end),\n                doneFn: done,\n                name: 'remove'\n            });\n        }\n        /**\n         * Queue an update to remove a time range from the buffer.\n         *\n         * @param {number} start where to start the removal\n         * @param {number} end where to end the removal\n         * @param {Function} [done=noop] optional callback to be executed when the remove\n         * operation is complete\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n         */\n\n        removeVideo(start, end, done = noop) {\n            if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {\n                done();\n                return;\n            }\n            pushQueue({\n                type: 'video',\n                sourceUpdater: this,\n                action: actions.remove(start, end),\n                doneFn: done,\n                name: 'remove'\n            });\n        }\n        /**\n         * Whether the underlying sourceBuffer is updating or not\n         *\n         * @return {boolean} the updating status of the SourceBuffer\n         */\n\n        updating() {\n            // the audio/video source buffer is updating\n            if (updating('audio', this) || updating('video', this)) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Set/get the timestampoffset on the audio SourceBuffer\n         *\n         * @return {number} the timestamp offset\n         */\n\n        audioTimestampOffset(offset) {\n            if (typeof offset !== 'undefined' && this.audioBuffer &&\n                // no point in updating if it's the same\n                this.audioTimestampOffset_ !== offset) {\n                pushQueue({\n                    type: 'audio',\n                    sourceUpdater: this,\n                    action: actions.timestampOffset(offset),\n                    name: 'timestampOffset'\n                });\n                this.audioTimestampOffset_ = offset;\n            }\n            return this.audioTimestampOffset_;\n        }\n        /**\n         * Set/get the timestampoffset on the video SourceBuffer\n         *\n         * @return {number} the timestamp offset\n         */\n\n        videoTimestampOffset(offset) {\n            if (typeof offset !== 'undefined' && this.videoBuffer &&\n                // no point in updating if it's the same\n                this.videoTimestampOffset !== offset) {\n                pushQueue({\n                    type: 'video',\n                    sourceUpdater: this,\n                    action: actions.timestampOffset(offset),\n                    name: 'timestampOffset'\n                });\n                this.videoTimestampOffset_ = offset;\n            }\n            return this.videoTimestampOffset_;\n        }\n        /**\n         * Add a function to the queue that will be called\n         * when it is its turn to run in the audio queue.\n         *\n         * @param {Function} callback\n         *        The callback to queue.\n         */\n\n        audioQueueCallback(callback) {\n            if (!this.audioBuffer) {\n                return;\n            }\n            pushQueue({\n                type: 'audio',\n                sourceUpdater: this,\n                action: actions.callback(callback),\n                name: 'callback'\n            });\n        }\n        /**\n         * Add a function to the queue that will be called\n         * when it is its turn to run in the video queue.\n         *\n         * @param {Function} callback\n         *        The callback to queue.\n         */\n\n        videoQueueCallback(callback) {\n            if (!this.videoBuffer) {\n                return;\n            }\n            pushQueue({\n                type: 'video',\n                sourceUpdater: this,\n                action: actions.callback(callback),\n                name: 'callback'\n            });\n        }\n        /**\n         * dispose of the source updater and the underlying sourceBuffer\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            bufferTypes.forEach(type => {\n                this.abort(type);\n                if (this.canRemoveSourceBuffer()) {\n                    this.removeSourceBuffer(type);\n                } else {\n                    this[`${type}QueueCallback`](() => cleanupBuffer(type, this));\n                }\n            });\n            this.videoAppendQueued_ = false;\n            this.delayedAudioAppendQueue_.length = 0;\n            if (this.sourceopenListener_) {\n                this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);\n            }\n            this.off();\n        }\n    }\n    const uint8ToUtf8 = uintArray => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\n    const bufferToHexString = buffer => {\n        const uInt8Buffer = new Uint8Array(buffer);\n        return Array.from(uInt8Buffer).map(byte => byte.toString(16).padStart(2, '0')).join('');\n    };\n\n    /**\n     * @file vtt-segment-loader.js\n     */\n    const VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(char => char.charCodeAt(0)));\n    class NoVttJsError extends Error {\n        constructor() {\n            super('Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.');\n        }\n    }\n    /**\n     * An object that manages segment loading and appending.\n     *\n     * @class VTTSegmentLoader\n     * @param {Object} options required and optional options\n     * @extends videojs.EventTarget\n     */\n\n    class VTTSegmentLoader extends SegmentLoader {\n        constructor(settings, options = {}) {\n            super(settings, options); // SegmentLoader requires a MediaSource be specified or it will throw an error;\n            // however, VTTSegmentLoader has no need of a media source, so delete the reference\n\n            this.mediaSource_ = null;\n            this.subtitlesTrack_ = null;\n            this.loaderType_ = 'subtitle';\n            this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;\n            this.loadVttJs = settings.loadVttJs; // The VTT segment will have its own time mappings. Saving VTT segment timing info in\n            // the sync controller leads to improper behavior.\n\n            this.shouldSaveSegmentTimingInfo_ = false;\n        }\n        createTransmuxer_() {\n            // don't need to transmux any subtitles\n            return null;\n        }\n        /**\n         * Indicates which time ranges are buffered\n         *\n         * @return {TimeRange}\n         *         TimeRange object representing the current buffered ranges\n         */\n\n        buffered_() {\n            if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {\n                return createTimeRanges();\n            }\n            const cues = this.subtitlesTrack_.cues;\n            const start = cues[0].startTime;\n            const end = cues[cues.length - 1].startTime;\n            return createTimeRanges([[start, end]]);\n        }\n        /**\n         * Gets and sets init segment for the provided map\n         *\n         * @param {Object} map\n         *        The map object representing the init segment to get or set\n         * @param {boolean=} set\n         *        If true, the init segment for the provided map should be saved\n         * @return {Object}\n         *         map object for desired init segment\n         */\n\n        initSegmentForMap(map, set = false) {\n            if (!map) {\n                return null;\n            }\n            const id = initSegmentId(map);\n            let storedMap = this.initSegments_[id];\n            if (set && !storedMap && map.bytes) {\n                // append WebVTT line terminators to the media initialization segment if it exists\n                // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n                // requires two or more WebVTT line terminators between the WebVTT header and the\n                // rest of the file\n                const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n                const combinedSegment = new Uint8Array(combinedByteLength);\n                combinedSegment.set(map.bytes);\n                combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n                this.initSegments_[id] = storedMap = {\n                    resolvedUri: map.resolvedUri,\n                    byterange: map.byterange,\n                    bytes: combinedSegment\n                };\n            }\n            return storedMap || map;\n        }\n        /**\n         * Returns true if all configuration required for loading is present, otherwise false.\n         *\n         * @return {boolean} True if the all configuration is ready for loading\n         * @private\n         */\n\n        couldBeginLoading_() {\n            return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n        }\n        /**\n         * Once all the starting parameters have been specified, begin\n         * operation. This method should only be invoked from the INIT\n         * state.\n         *\n         * @private\n         */\n\n        init_() {\n            this.state = 'READY';\n            this.resetEverything();\n            return this.monitorBuffer_();\n        }\n        /**\n         * Set a subtitle track on the segment loader to add subtitles to\n         *\n         * @param {TextTrack=} track\n         *        The text track to add loaded subtitles to\n         * @return {TextTrack}\n         *        Returns the subtitles track\n         */\n\n        track(track) {\n            if (typeof track === 'undefined') {\n                return this.subtitlesTrack_;\n            }\n            this.subtitlesTrack_ = track; // if we were unpaused but waiting for a sourceUpdater, start\n            // buffering now\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                this.init_();\n            }\n            return this.subtitlesTrack_;\n        }\n        /**\n         * Remove any data in the source buffer between start and end times\n         *\n         * @param {number} start - the start time of the region to remove from the buffer\n         * @param {number} end - the end time of the region to remove from the buffer\n         */\n\n        remove(start, end) {\n            removeCuesFromTrack(start, end, this.subtitlesTrack_);\n        }\n        /**\n         * fill the buffer with segements unless the sourceBuffers are\n         * currently updating\n         *\n         * Note: this function should only ever be called by monitorBuffer_\n         * and never directly\n         *\n         * @private\n         */\n\n        fillBuffer_() {\n            // see if we need to begin loading immediately\n            const segmentInfo = this.chooseNextRequest_();\n            if (!segmentInfo) {\n                return;\n            }\n            if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n                // We don't have the timestamp offset that we need to sync subtitles.\n                // Rerun on a timestamp offset or user interaction.\n                const checkTimestampOffset = () => {\n                    this.state = 'READY';\n                    if (!this.paused()) {\n                        // if not paused, queue a buffer check as soon as possible\n                        this.monitorBuffer_();\n                    }\n                };\n                this.syncController_.one('timestampoffset', checkTimestampOffset);\n                this.state = 'WAITING_ON_TIMELINE';\n                return;\n            }\n            this.loadSegment_(segmentInfo);\n        } // never set a timestamp offset for vtt segments.\n\n        timestampOffsetForSegment_() {\n            return null;\n        }\n        chooseNextRequest_() {\n            return this.skipEmptySegments_(super.chooseNextRequest_());\n        }\n        /**\n         * Prevents the segment loader from requesting segments we know contain no subtitles\n         * by walking forward until we find the next segment that we don't know whether it is\n         * empty or not.\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @return {Object}\n         *         a segment info object that describes the current segment\n         */\n\n        skipEmptySegments_(segmentInfo) {\n            while (segmentInfo && segmentInfo.segment.empty) {\n                // stop at the last possible segmentInfo\n                if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {\n                    segmentInfo = null;\n                    break;\n                }\n                segmentInfo = this.generateSegmentInfo_({\n                    playlist: segmentInfo.playlist,\n                    mediaIndex: segmentInfo.mediaIndex + 1,\n                    startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,\n                    isSyncRequest: segmentInfo.isSyncRequest\n                });\n            }\n            return segmentInfo;\n        }\n        stopForError(error) {\n            this.error(error);\n            this.state = 'READY';\n            this.pause();\n            this.trigger('error');\n        }\n        /**\n         * append a decrypted segement to the SourceBuffer through a SourceUpdater\n         *\n         * @private\n         */\n\n        segmentRequestFinished_(error, simpleSegment, result) {\n            if (!this.subtitlesTrack_) {\n                this.state = 'READY';\n                return;\n            }\n            this.saveTransferStats_(simpleSegment.stats); // the request was aborted\n\n            if (!this.pendingSegment_) {\n                this.state = 'READY';\n                this.mediaRequestsAborted += 1;\n                return;\n            }\n            if (error) {\n                if (error.code === REQUEST_ERRORS.TIMEOUT) {\n                    this.handleTimeout_();\n                }\n                if (error.code === REQUEST_ERRORS.ABORTED) {\n                    this.mediaRequestsAborted += 1;\n                } else {\n                    this.mediaRequestsErrored += 1;\n                }\n                this.stopForError(error);\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // although the VTT segment loader bandwidth isn't really used, it's good to\n            // maintain functionality between segment loaders\n\n            this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats); // if this request included a segment key, save that data in the cache\n\n            if (simpleSegment.key) {\n                this.segmentKey(simpleSegment.key, true);\n            }\n            this.state = 'APPENDING'; // used for tests\n\n            this.trigger('appending');\n            const segment = segmentInfo.segment;\n            if (segment.map) {\n                segment.map.bytes = simpleSegment.map.bytes;\n            }\n            segmentInfo.bytes = simpleSegment.bytes; // Make sure that vttjs has loaded, otherwise, load it and wait till it finished loading\n\n            if (typeof window.WebVTT !== 'function' && typeof this.loadVttJs === 'function') {\n                this.state = 'WAITING_ON_VTTJS'; // should be fine to call multiple times\n                // script will be loaded once but multiple listeners will be added to the queue, which is expected.\n\n                this.loadVttJs().then(() => this.segmentRequestFinished_(error, simpleSegment, result), () => this.stopForError({\n                    message: 'Error loading vtt.js'\n                }));\n                return;\n            }\n            segment.requested = true;\n            try {\n                this.parseVTTCues_(segmentInfo);\n            } catch (e) {\n                this.stopForError({\n                    message: e.message\n                });\n                return;\n            }\n            this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n            if (segmentInfo.cues.length) {\n                segmentInfo.timingInfo = {\n                    start: segmentInfo.cues[0].startTime,\n                    end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime\n                };\n            } else {\n                segmentInfo.timingInfo = {\n                    start: segmentInfo.startOfSegment,\n                    end: segmentInfo.startOfSegment + segmentInfo.duration\n                };\n            }\n            if (segmentInfo.isSyncRequest) {\n                this.trigger('syncinfoupdate');\n                this.pendingSegment_ = null;\n                this.state = 'READY';\n                return;\n            }\n            segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n            this.mediaSecondsLoaded += segment.duration; // Create VTTCue instances for each cue in the new segment and add them to\n            // the subtitle track\n\n            segmentInfo.cues.forEach(cue => {\n                this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);\n            }); // Remove any duplicate cues from the subtitle track. The WebVTT spec allows\n            // cues to have identical time-intervals, but if the text is also identical\n            // we can safely assume it is a duplicate that can be removed (ex. when a cue\n            // \"overlaps\" VTT segments)\n\n            removeDuplicateCuesFromTrack(this.subtitlesTrack_);\n            this.handleAppendsDone_();\n        }\n        handleData_() {// noop as we shouldn't be getting video/audio data captions\n            // that we do not support here.\n        }\n        updateTimingInfoEnd_() {// noop\n        }\n        /**\n         * Uses the WebVTT parser to parse the segment response\n         *\n         * @throws NoVttJsError\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @private\n         */\n\n        parseVTTCues_(segmentInfo) {\n            let decoder;\n            let decodeBytesToString = false;\n            if (typeof window.WebVTT !== 'function') {\n                // caller is responsible for exception handling.\n                throw new NoVttJsError();\n            }\n            if (typeof window.TextDecoder === 'function') {\n                decoder = new window.TextDecoder('utf8');\n            } else {\n                decoder = window.WebVTT.StringDecoder();\n                decodeBytesToString = true;\n            }\n            const parser = new window.WebVTT.Parser(window, window.vttjs, decoder);\n            segmentInfo.cues = [];\n            segmentInfo.timestampmap = {\n                MPEGTS: 0,\n                LOCAL: 0\n            };\n            parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n            parser.ontimestampmap = map => {\n                segmentInfo.timestampmap = map;\n            };\n            parser.onparsingerror = error => {\n                videojs.log.warn('Error encountered when parsing cues: ' + error.message);\n            };\n            if (segmentInfo.segment.map) {\n                let mapData = segmentInfo.segment.map.bytes;\n                if (decodeBytesToString) {\n                    mapData = uint8ToUtf8(mapData);\n                }\n                parser.parse(mapData);\n            }\n            let segmentData = segmentInfo.bytes;\n            if (decodeBytesToString) {\n                segmentData = uint8ToUtf8(segmentData);\n            }\n            parser.parse(segmentData);\n            parser.flush();\n        }\n        /**\n         * Updates the start and end times of any cues parsed by the WebVTT parser using\n         * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n         * from the SyncController\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @param {Object} mappingObj\n         *        object containing a mapping from TS to media time\n         * @param {Object} playlist\n         *        the playlist object containing the segment\n         * @private\n         */\n\n        updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n            const segment = segmentInfo.segment;\n            if (!mappingObj) {\n                // If the sync controller does not have a mapping of TS to Media Time for the\n                // timeline, then we don't have enough information to update the cue\n                // start/end times\n                return;\n            }\n            if (!segmentInfo.cues.length) {\n                // If there are no cues, we also do not have enough information to figure out\n                // segment timing. Mark that the segment contains no cues so we don't re-request\n                // an empty segment.\n                segment.empty = true;\n                return;\n            }\n            const {\n                MPEGTS,\n                LOCAL\n            } = segmentInfo.timestampmap;\n            /**\n             * From the spec:\n             * The MPEGTS media timestamp MUST use a 90KHz timescale,\n             * even when non-WebVTT Media Segments use a different timescale.\n             */\n\n            const mpegTsInSeconds = MPEGTS / clock_1;\n            const diff = mpegTsInSeconds - LOCAL + mappingObj.mapping;\n            segmentInfo.cues.forEach(cue => {\n                const duration = cue.endTime - cue.startTime;\n                const startTime = MPEGTS === 0 ? cue.startTime + diff : this.handleRollover_(cue.startTime + diff, mappingObj.time);\n                cue.startTime = Math.max(startTime, 0);\n                cue.endTime = Math.max(startTime + duration, 0);\n            });\n            if (!playlist.syncInfo) {\n                const firstStart = segmentInfo.cues[0].startTime;\n                const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n                playlist.syncInfo = {\n                    mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n                    time: Math.min(firstStart, lastStart - segment.duration)\n                };\n            }\n        }\n        /**\n         * MPEG-TS PES timestamps are limited to 2^33.\n         * Once they reach 2^33, they roll over to 0.\n         * mux.js handles PES timestamp rollover for the following scenarios:\n         * [forward rollover(right)] ->\n         *    PES timestamps monotonically increase, and once they reach 2^33, they roll over to 0\n         * [backward rollover(left)] -->\n         *    we seek back to position before rollover.\n         *\n         * According to the HLS SPEC:\n         * When synchronizing WebVTT with PES timestamps, clients SHOULD account\n         * for cases where the 33-bit PES timestamps have wrapped and the WebVTT\n         * cue times have not.  When the PES timestamp wraps, the WebVTT Segment\n         * SHOULD have a X-TIMESTAMP-MAP header that maps the current WebVTT\n         * time to the new (low valued) PES timestamp.\n         *\n         * So we want to handle rollover here and align VTT Cue start/end time to the player's time.\n         */\n\n        handleRollover_(value, reference) {\n            if (reference === null) {\n                return value;\n            }\n            let valueIn90khz = value * clock_1;\n            const referenceIn90khz = reference * clock_1;\n            let offset;\n            if (referenceIn90khz < valueIn90khz) {\n                // - 2^33\n                offset = -8589934592;\n            } else {\n                // + 2^33\n                offset = 8589934592;\n            } // distance(value - reference) > 2^32\n\n            while (Math.abs(valueIn90khz - referenceIn90khz) > 4294967296) {\n                valueIn90khz += offset;\n            }\n            return valueIn90khz / clock_1;\n        }\n    }\n\n    /**\n     * @file ad-cue-tags.js\n     */\n    /**\n     * Searches for an ad cue that overlaps with the given mediaTime\n     *\n     * @param {Object} track\n     *        the track to find the cue for\n     *\n     * @param {number} mediaTime\n     *        the time to find the cue at\n     *\n     * @return {Object|null}\n     *         the found cue or null\n     */\n\n    const findAdCue = function (track, mediaTime) {\n        const cues = track.cues;\n        for (let i = 0; i < cues.length; i++) {\n            const cue = cues[i];\n            if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n                return cue;\n            }\n        }\n        return null;\n    };\n    const updateAdCues = function (media, track, offset = 0) {\n        if (!media.segments) {\n            return;\n        }\n        let mediaTime = offset;\n        let cue;\n        for (let i = 0; i < media.segments.length; i++) {\n            const segment = media.segments[i];\n            if (!cue) {\n                // Since the cues will span for at least the segment duration, adding a fudge\n                // factor of half segment duration will prevent duplicate cues from being\n                // created when timing info is not exact (e.g. cue start time initialized\n                // at 10.006677, but next call mediaTime is 10.003332 )\n                cue = findAdCue(track, mediaTime + segment.duration / 2);\n            }\n            if (cue) {\n                if ('cueIn' in segment) {\n                    // Found a CUE-IN so end the cue\n                    cue.endTime = mediaTime;\n                    cue.adEndTime = mediaTime;\n                    mediaTime += segment.duration;\n                    cue = null;\n                    continue;\n                }\n                if (mediaTime < cue.endTime) {\n                    // Already processed this mediaTime for this cue\n                    mediaTime += segment.duration;\n                    continue;\n                } // otherwise extend cue until a CUE-IN is found\n\n                cue.endTime += segment.duration;\n            } else {\n                if ('cueOut' in segment) {\n                    cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n                    cue.adStartTime = mediaTime; // Assumes tag format to be\n                    // #EXT-X-CUE-OUT:30\n\n                    cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n                    track.addCue(cue);\n                }\n                if ('cueOutCont' in segment) {\n                    // Entered into the middle of an ad cue\n                    // Assumes tag formate to be\n                    // #EXT-X-CUE-OUT-CONT:10/30\n                    const [adOffset, adTotal] = segment.cueOutCont.split('/').map(parseFloat);\n                    cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, '');\n                    cue.adStartTime = mediaTime - adOffset;\n                    cue.adEndTime = cue.adStartTime + adTotal;\n                    track.addCue(cue);\n                }\n            }\n            mediaTime += segment.duration;\n        }\n    };\n\n    /**\n     * @file sync-controller.js\n     */\n        // synchronize expired playlist segments.\n        // the max media sequence diff is 48 hours of live stream\n        // content with two second segments. Anything larger than that\n        // will likely be invalid.\n\n    const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;\n    const syncPointStrategies = [\n        // Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n        //                the equivalence display-time 0 === segment-index 0\n        {\n            name: 'VOD',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (duration !== Infinity) {\n                    const syncPoint = {\n                        time: 0,\n                        segmentIndex: 0,\n                        partIndex: null\n                    };\n                    return syncPoint;\n                }\n                return null;\n            }\n        }, {\n            name: 'MediaSequence',\n            /**\n             * run media sequence strategy\n             *\n             * @param {SyncController} syncController\n             * @param {Object} playlist\n             * @param {number} duration\n             * @param {number} currentTimeline\n             * @param {number} currentTime\n             * @param {string} type\n             */\n            run: (syncController, playlist, duration, currentTimeline, currentTime, type) => {\n                if (!type) {\n                    return null;\n                }\n                const mediaSequenceMap = syncController.getMediaSequenceMap(type);\n                if (!mediaSequenceMap || mediaSequenceMap.size === 0) {\n                    return null;\n                }\n                if (playlist.mediaSequence === undefined || !Array.isArray(playlist.segments) || !playlist.segments.length) {\n                    return null;\n                }\n                let currentMediaSequence = playlist.mediaSequence;\n                let segmentIndex = 0;\n                for (const segment of playlist.segments) {\n                    const range = mediaSequenceMap.get(currentMediaSequence);\n                    if (!range) {\n                        // unexpected case\n                        // we expect this playlist to be the same playlist in the map\n                        // just break from the loop and move forward to the next strategy\n                        break;\n                    }\n                    if (currentTime >= range.start && currentTime < range.end) {\n                        // we found segment\n                        if (Array.isArray(segment.parts) && segment.parts.length) {\n                            let currentPartStart = range.start;\n                            let partIndex = 0;\n                            for (const part of segment.parts) {\n                                const start = currentPartStart;\n                                const end = start + part.duration;\n                                if (currentTime >= start && currentTime < end) {\n                                    return {\n                                        time: range.start,\n                                        segmentIndex,\n                                        partIndex\n                                    };\n                                }\n                                partIndex++;\n                                currentPartStart = end;\n                            }\n                        } // no parts found, return sync point for segment\n\n                        return {\n                            time: range.start,\n                            segmentIndex,\n                            partIndex: null\n                        };\n                    }\n                    segmentIndex++;\n                    currentMediaSequence++;\n                } // we didn't find any segments for provided current time\n\n                return null;\n            }\n        },\n        // Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n        {\n            name: 'ProgramDateTime',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (!Object.keys(syncController.timelineToDatetimeMappings).length) {\n                    return null;\n                }\n                let syncPoint = null;\n                let lastDistance = null;\n                const partsAndSegments = getPartsAndSegments(playlist);\n                currentTime = currentTime || 0;\n                for (let i = 0; i < partsAndSegments.length; i++) {\n                    // start from the end and loop backwards for live\n                    // or start from the front and loop forwards for non-live\n                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n                    const partAndSegment = partsAndSegments[index];\n                    const segment = partAndSegment.segment;\n                    const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];\n                    if (!datetimeMapping || !segment.dateTimeObject) {\n                        continue;\n                    }\n                    const segmentTime = segment.dateTimeObject.getTime() / 1000;\n                    let start = segmentTime + datetimeMapping; // take part duration into account.\n\n                    if (segment.parts && typeof partAndSegment.partIndex === 'number') {\n                        for (let z = 0; z < partAndSegment.partIndex; z++) {\n                            start += segment.parts[z].duration;\n                        }\n                    }\n                    const distance = Math.abs(currentTime - start); // Once the distance begins to increase, or if distance is 0, we have passed\n                    // currentTime and can stop looking for better candidates\n\n                    if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {\n                        break;\n                    }\n                    lastDistance = distance;\n                    syncPoint = {\n                        time: start,\n                        segmentIndex: partAndSegment.segmentIndex,\n                        partIndex: partAndSegment.partIndex\n                    };\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Segment\": We have a known time mapping for a timeline and a\n        //                    segment in the current timeline with timing data\n        {\n            name: 'Segment',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                let syncPoint = null;\n                let lastDistance = null;\n                currentTime = currentTime || 0;\n                const partsAndSegments = getPartsAndSegments(playlist);\n                for (let i = 0; i < partsAndSegments.length; i++) {\n                    // start from the end and loop backwards for live\n                    // or start from the front and loop forwards for non-live\n                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n                    const partAndSegment = partsAndSegments[index];\n                    const segment = partAndSegment.segment;\n                    const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;\n                    if (segment.timeline === currentTimeline && typeof start !== 'undefined') {\n                        const distance = Math.abs(currentTime - start); // Once the distance begins to increase, we have passed\n                        // currentTime and can stop looking for better candidates\n\n                        if (lastDistance !== null && lastDistance < distance) {\n                            break;\n                        }\n                        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n                            lastDistance = distance;\n                            syncPoint = {\n                                time: start,\n                                segmentIndex: partAndSegment.segmentIndex,\n                                partIndex: partAndSegment.partIndex\n                            };\n                        }\n                    }\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Discontinuity\": We have a discontinuity with a known\n        //                          display-time\n        {\n            name: 'Discontinuity',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                let syncPoint = null;\n                currentTime = currentTime || 0;\n                if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n                    let lastDistance = null;\n                    for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n                        const segmentIndex = playlist.discontinuityStarts[i];\n                        const discontinuity = playlist.discontinuitySequence + i + 1;\n                        const discontinuitySync = syncController.discontinuities[discontinuity];\n                        if (discontinuitySync) {\n                            const distance = Math.abs(currentTime - discontinuitySync.time); // Once the distance begins to increase, we have passed\n                            // currentTime and can stop looking for better candidates\n\n                            if (lastDistance !== null && lastDistance < distance) {\n                                break;\n                            }\n                            if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n                                lastDistance = distance;\n                                syncPoint = {\n                                    time: discontinuitySync.time,\n                                    segmentIndex,\n                                    partIndex: null\n                                };\n                            }\n                        }\n                    }\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Playlist\": We have a playlist with a known mapping of\n        //                     segment index to display time\n        {\n            name: 'Playlist',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (playlist.syncInfo) {\n                    const syncPoint = {\n                        time: playlist.syncInfo.time,\n                        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,\n                        partIndex: null\n                    };\n                    return syncPoint;\n                }\n                return null;\n            }\n        }];\n    class SyncController extends videojs.EventTarget {\n        constructor(options = {}) {\n            super(); // ...for synching across variants\n\n            this.timelines = [];\n            this.discontinuities = [];\n            this.timelineToDatetimeMappings = {};\n            /**\n             * @type {Map<string, Map<number, { start: number, end: number }>>}\n             * @private\n             */\n\n            this.mediaSequenceStorage_ = new Map();\n            this.logger_ = logger('SyncController');\n        }\n        /**\n         * Get media sequence map by type\n         *\n         * @param {string} type - segment loader type\n         * @return {Map<number, { start: number, end: number }> | undefined}\n         */\n\n        getMediaSequenceMap(type) {\n            return this.mediaSequenceStorage_.get(type);\n        }\n        /**\n         * Update Media Sequence Map -> <MediaSequence, Range>\n         *\n         * @param {Object} playlist - parsed playlist\n         * @param {number} currentTime - current player's time\n         * @param {string} type - segment loader type\n         * @return {void}\n         */\n\n        updateMediaSequenceMap(playlist, currentTime, type) {\n            // we should not process this playlist if it does not have mediaSequence or segments\n            if (playlist.mediaSequence === undefined || !Array.isArray(playlist.segments) || !playlist.segments.length) {\n                return;\n            }\n            const currentMap = this.getMediaSequenceMap(type);\n            const result = new Map();\n            let currentMediaSequence = playlist.mediaSequence;\n            let currentBaseTime;\n            if (!currentMap) {\n                // first playlist setup:\n                currentBaseTime = 0;\n            } else if (currentMap.has(playlist.mediaSequence)) {\n                // further playlists setup:\n                currentBaseTime = currentMap.get(playlist.mediaSequence).start;\n            } else {\n                // it seems like we have a gap between playlists, use current time as a fallback:\n                this.logger_(`MediaSequence sync for ${type} segment loader - received a gap between playlists.\nFallback base time to: ${currentTime}.\nReceived media sequence: ${currentMediaSequence}.\nCurrent map: `, currentMap);\n                currentBaseTime = currentTime;\n            }\n            this.logger_(`MediaSequence sync for ${type} segment loader.\nReceived media sequence: ${currentMediaSequence}.\nbase time is ${currentBaseTime}\nCurrent map: `, currentMap);\n            playlist.segments.forEach(segment => {\n                const start = currentBaseTime;\n                const end = start + segment.duration;\n                const range = {\n                    start,\n                    end\n                };\n                result.set(currentMediaSequence, range);\n                currentMediaSequence++;\n                currentBaseTime = end;\n            });\n            this.mediaSequenceStorage_.set(type, result);\n        }\n        /**\n         * Find a sync-point for the playlist specified\n         *\n         * A sync-point is defined as a known mapping from display-time to\n         * a segment-index in the current playlist.\n         *\n         * @param {Playlist} playlist\n         *        The playlist that needs a sync-point\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinite if playing a live source)\n         * @param {number} currentTimeline\n         *        The last timeline from which a segment was loaded\n         * @param {number} currentTime\n         *        Current player's time\n         * @param {string} type\n         *        Segment loader type\n         * @return {Object}\n         *          A sync-point object\n         */\n\n        getSyncPoint(playlist, duration, currentTimeline, currentTime, type) {\n            // Always use VOD sync point for VOD\n            if (duration !== Infinity) {\n                const vodSyncPointStrategy = syncPointStrategies.find(({\n                                                                           name\n                                                                       }) => name === 'VOD');\n                return vodSyncPointStrategy.run(this, playlist, duration);\n            }\n            const syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime, type);\n            if (!syncPoints.length) {\n                // Signal that we need to attempt to get a sync-point manually\n                // by fetching a segment in the playlist and constructing\n                // a sync-point from that information\n                return null;\n            } // If we have exact match just return it instead of finding the nearest distance\n\n            for (const syncPointInfo of syncPoints) {\n                const {\n                    syncPoint,\n                    strategy\n                } = syncPointInfo;\n                const {\n                    segmentIndex,\n                    time\n                } = syncPoint;\n                if (segmentIndex < 0) {\n                    continue;\n                }\n                const selectedSegment = playlist.segments[segmentIndex];\n                const start = time;\n                const end = start + selectedSegment.duration;\n                this.logger_(`Strategy: ${strategy}. Current time: ${currentTime}. selected segment: ${segmentIndex}. Time: [${start} -> ${end}]}`);\n                if (currentTime >= start && currentTime < end) {\n                    this.logger_('Found sync point with exact match: ', syncPoint);\n                    return syncPoint;\n                }\n            } // Now find the sync-point that is closest to the currentTime because\n            // that should result in the most accurate guess about which segment\n            // to fetch\n\n            return this.selectSyncPoint_(syncPoints, {\n                key: 'time',\n                value: currentTime\n            });\n        }\n        /**\n         * Calculate the amount of time that has expired off the playlist during playback\n         *\n         * @param {Playlist} playlist\n         *        Playlist object to calculate expired from\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinity if playling a live source)\n         * @return {number|null}\n         *          The amount of time that has expired off the playlist during playback. Null\n         *          if no sync-points for the playlist can be found.\n         */\n\n        getExpiredTime(playlist, duration) {\n            if (!playlist || !playlist.segments) {\n                return null;\n            }\n            const syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0, 'main'); // Without sync-points, there is not enough information to determine the expired time\n\n            if (!syncPoints.length) {\n                return null;\n            }\n            const syncPoint = this.selectSyncPoint_(syncPoints, {\n                key: 'segmentIndex',\n                value: 0\n            }); // If the sync-point is beyond the start of the playlist, we want to subtract the\n            // duration from index 0 to syncPoint.segmentIndex instead of adding.\n\n            if (syncPoint.segmentIndex > 0) {\n                syncPoint.time *= -1;\n            }\n            return Math.abs(syncPoint.time + sumDurations({\n                defaultDuration: playlist.targetDuration,\n                durationList: playlist.segments,\n                startIndex: syncPoint.segmentIndex,\n                endIndex: 0\n            }));\n        }\n        /**\n         * Runs each sync-point strategy and returns a list of sync-points returned by the\n         * strategies\n         *\n         * @private\n         * @param {Playlist} playlist\n         *        The playlist that needs a sync-point\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinity if playing a live source)\n         * @param {number} currentTimeline\n         *        The last timeline from which a segment was loaded\n         * @param {number} currentTime\n         *        Current player's time\n         * @param {string} type\n         *        Segment loader type\n         * @return {Array}\n         *          A list of sync-point objects\n         */\n\n        runStrategies_(playlist, duration, currentTimeline, currentTime, type) {\n            const syncPoints = []; // Try to find a sync-point in by utilizing various strategies...\n\n            for (let i = 0; i < syncPointStrategies.length; i++) {\n                const strategy = syncPointStrategies[i];\n                const syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime, type);\n                if (syncPoint) {\n                    syncPoint.strategy = strategy.name;\n                    syncPoints.push({\n                        strategy: strategy.name,\n                        syncPoint\n                    });\n                }\n            }\n            return syncPoints;\n        }\n        /**\n         * Selects the sync-point nearest the specified target\n         *\n         * @private\n         * @param {Array} syncPoints\n         *        List of sync-points to select from\n         * @param {Object} target\n         *        Object specifying the property and value we are targeting\n         * @param {string} target.key\n         *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n         * @param {number} target.value\n         *        The value to target for the specified key.\n         * @return {Object}\n         *          The sync-point nearest the target\n         */\n\n        selectSyncPoint_(syncPoints, target) {\n            let bestSyncPoint = syncPoints[0].syncPoint;\n            let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n            let bestStrategy = syncPoints[0].strategy;\n            for (let i = 1; i < syncPoints.length; i++) {\n                const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n                if (newDistance < bestDistance) {\n                    bestDistance = newDistance;\n                    bestSyncPoint = syncPoints[i].syncPoint;\n                    bestStrategy = syncPoints[i].strategy;\n                }\n            }\n            this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy` + ` [${bestStrategy}]: [time:${bestSyncPoint.time},` + ` segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === 'number' ? `,partIndex:${bestSyncPoint.partIndex}` : '') + ']');\n            return bestSyncPoint;\n        }\n        /**\n         * Save any meta-data present on the segments when segments leave\n         * the live window to the playlist to allow for synchronization at the\n         * playlist level later.\n         *\n         * @param {Playlist} oldPlaylist - The previous active playlist\n         * @param {Playlist} newPlaylist - The updated and most current playlist\n         */\n\n        saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n            const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence; // Ignore large media sequence gaps\n\n            if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {\n                videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);\n                return;\n            } // When a segment expires from the playlist and it has a start time\n            // save that information as a possible sync-point reference in future\n\n            for (let i = mediaSequenceDiff - 1; i >= 0; i--) {\n                const lastRemovedSegment = oldPlaylist.segments[i];\n                if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n                    newPlaylist.syncInfo = {\n                        mediaSequence: oldPlaylist.mediaSequence + i,\n                        time: lastRemovedSegment.start\n                    };\n                    this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time},` + ` mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);\n                    this.trigger('syncinfoupdate');\n                    break;\n                }\n            }\n        }\n        /**\n         * Save the mapping from playlist's ProgramDateTime to display. This should only happen\n         * before segments start to load.\n         *\n         * @param {Playlist} playlist - The currently active playlist\n         */\n\n        setDateTimeMappingForStart(playlist) {\n            // It's possible for the playlist to be updated before playback starts, meaning time\n            // zero is not yet set. If, during these playlist refreshes, a discontinuity is\n            // crossed, then the old time zero mapping (for the prior timeline) would be retained\n            // unless the mappings are cleared.\n            this.timelineToDatetimeMappings = {};\n            if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\n                const firstSegment = playlist.segments[0];\n                const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;\n                this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;\n            }\n        }\n        /**\n         * Calculates and saves timeline mappings, playlist sync info, and segment timing values\n         * based on the latest timing information.\n         *\n         * @param {Object} options\n         *        Options object\n         * @param {SegmentInfo} options.segmentInfo\n         *        The current active request information\n         * @param {boolean} options.shouldSaveTimelineMapping\n         *        If there's a timeline change, determines if the timeline mapping should be\n         *        saved for timeline mapping and program date time mappings.\n         */\n\n        saveSegmentTimingInfo({\n                                  segmentInfo,\n                                  shouldSaveTimelineMapping\n                              }) {\n            const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);\n            const segment = segmentInfo.segment;\n            if (didCalculateSegmentTimeMapping) {\n                this.saveDiscontinuitySyncInfo_(segmentInfo); // If the playlist does not have sync information yet, record that information\n                // now with segment timing information\n\n                if (!segmentInfo.playlist.syncInfo) {\n                    segmentInfo.playlist.syncInfo = {\n                        mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,\n                        time: segment.start\n                    };\n                }\n            }\n            const dateTime = segment.dateTimeObject;\n            if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {\n                this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000);\n            }\n        }\n        timestampOffsetForTimeline(timeline) {\n            if (typeof this.timelines[timeline] === 'undefined') {\n                return null;\n            }\n            return this.timelines[timeline].time;\n        }\n        mappingForTimeline(timeline) {\n            if (typeof this.timelines[timeline] === 'undefined') {\n                return null;\n            }\n            return this.timelines[timeline].mapping;\n        }\n        /**\n         * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n         * save that display time to the segment.\n         *\n         * @private\n         * @param {SegmentInfo} segmentInfo\n         *        The current active request information\n         * @param {Object} timingInfo\n         *        The start and end time of the current segment in \"media time\"\n         * @param {boolean} shouldSaveTimelineMapping\n         *        If there's a timeline change, determines if the timeline mapping should be\n         *        saved in timelines.\n         * @return {boolean}\n         *          Returns false if segment time mapping could not be calculated\n         */\n\n        calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {\n            // TODO: remove side effects\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            let mappingObj = this.timelines[segmentInfo.timeline];\n            let start;\n            let end;\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                mappingObj = {\n                    time: segmentInfo.startOfSegment,\n                    mapping: segmentInfo.startOfSegment - timingInfo.start\n                };\n                if (shouldSaveTimelineMapping) {\n                    this.timelines[segmentInfo.timeline] = mappingObj;\n                    this.trigger('timestampoffset');\n                    this.logger_(`time mapping for timeline ${segmentInfo.timeline}: ` + `[time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);\n                }\n                start = segmentInfo.startOfSegment;\n                end = timingInfo.end + mappingObj.mapping;\n            } else if (mappingObj) {\n                start = timingInfo.start + mappingObj.mapping;\n                end = timingInfo.end + mappingObj.mapping;\n            } else {\n                return false;\n            }\n            if (part) {\n                part.start = start;\n                part.end = end;\n            } // If we don't have a segment start yet or the start value we got\n            // is less than our current segment.start value, save a new start value.\n            // We have to do this because parts will have segment timing info saved\n            // multiple times and we want segment start to be the earliest part start\n            // value for that segment.\n\n            if (!segment.start || start < segment.start) {\n                segment.start = start;\n            }\n            segment.end = end;\n            return true;\n        }\n        /**\n         * Each time we have discontinuity in the playlist, attempt to calculate the location\n         * in display of the start of the discontinuity and save that. We also save an accuracy\n         * value so that we save values with the most accuracy (closest to 0.)\n         *\n         * @private\n         * @param {SegmentInfo} segmentInfo - The current active request information\n         */\n\n        saveDiscontinuitySyncInfo_(segmentInfo) {\n            const playlist = segmentInfo.playlist;\n            const segment = segmentInfo.segment; // If the current segment is a discontinuity then we know exactly where\n            // the start of the range and it's accuracy is 0 (greater accuracy values\n            // mean more approximation)\n\n            if (segment.discontinuity) {\n                this.discontinuities[segment.timeline] = {\n                    time: segment.start,\n                    accuracy: 0\n                };\n            } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n                // Search for future discontinuities that we can provide better timing\n                // information for and save that information for sync purposes\n                for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n                    const segmentIndex = playlist.discontinuityStarts[i];\n                    const discontinuity = playlist.discontinuitySequence + i + 1;\n                    const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n                    const accuracy = Math.abs(mediaIndexDiff);\n                    if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n                        let time;\n                        if (mediaIndexDiff < 0) {\n                            time = segment.start - sumDurations({\n                                defaultDuration: playlist.targetDuration,\n                                durationList: playlist.segments,\n                                startIndex: segmentInfo.mediaIndex,\n                                endIndex: segmentIndex\n                            });\n                        } else {\n                            time = segment.end + sumDurations({\n                                defaultDuration: playlist.targetDuration,\n                                durationList: playlist.segments,\n                                startIndex: segmentInfo.mediaIndex + 1,\n                                endIndex: segmentIndex\n                            });\n                        }\n                        this.discontinuities[discontinuity] = {\n                            time,\n                            accuracy\n                        };\n                    }\n                }\n            }\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.off();\n        }\n    }\n\n    /**\n     * The TimelineChangeController acts as a source for segment loaders to listen for and\n     * keep track of latest and pending timeline changes. This is useful to ensure proper\n     * sync, as each loader may need to make a consideration for what timeline the other\n     * loader is on before making changes which could impact the other loader's media.\n     *\n     * @class TimelineChangeController\n     * @extends videojs.EventTarget\n     */\n\n    class TimelineChangeController extends videojs.EventTarget {\n        constructor() {\n            super();\n            this.pendingTimelineChanges_ = {};\n            this.lastTimelineChanges_ = {};\n        }\n        clearPendingTimelineChange(type) {\n            this.pendingTimelineChanges_[type] = null;\n            this.trigger('pendingtimelinechange');\n        }\n        pendingTimelineChange({\n                                  type,\n                                  from,\n                                  to\n                              }) {\n            if (typeof from === 'number' && typeof to === 'number') {\n                this.pendingTimelineChanges_[type] = {\n                    type,\n                    from,\n                    to\n                };\n                this.trigger('pendingtimelinechange');\n            }\n            return this.pendingTimelineChanges_[type];\n        }\n        lastTimelineChange({\n                               type,\n                               from,\n                               to\n                           }) {\n            if (typeof from === 'number' && typeof to === 'number') {\n                this.lastTimelineChanges_[type] = {\n                    type,\n                    from,\n                    to\n                };\n                delete this.pendingTimelineChanges_[type];\n                this.trigger('timelinechange');\n            }\n            return this.lastTimelineChanges_[type];\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.pendingTimelineChanges_ = {};\n            this.lastTimelineChanges_ = {};\n            this.off();\n        }\n    }\n\n    /* rollup-plugin-worker-factory start for worker!/home/runner/work/http-streaming/http-streaming/src/decrypter-worker.js */\n    const workerCode = transform(getWorkerString(function () {\n        /**\n         * @file stream.js\n         */\n\n        /**\n         * A lightweight readable stream implemention that handles event dispatching.\n         *\n         * @class Stream\n         */\n\n        var Stream = /*#__PURE__*/function () {\n            function Stream() {\n                this.listeners = {};\n            }\n            /**\n             * Add a listener for a specified event type.\n             *\n             * @param {string} type the event name\n             * @param {Function} listener the callback to be invoked when an event of\n             * the specified type occurs\n             */\n\n            var _proto = Stream.prototype;\n            _proto.on = function on(type, listener) {\n                if (!this.listeners[type]) {\n                    this.listeners[type] = [];\n                }\n                this.listeners[type].push(listener);\n            }\n            /**\n             * Remove a listener for a specified event type.\n             *\n             * @param {string} type the event name\n             * @param {Function} listener  a function previously registered for this\n             * type of event through `on`\n             * @return {boolean} if we could turn it off or not\n             */;\n\n            _proto.off = function off(type, listener) {\n                if (!this.listeners[type]) {\n                    return false;\n                }\n                var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n                // In Video.js we slice listener functions\n                // on trigger so that it does not mess up the order\n                // while we loop through.\n                //\n                // Here we slice on off so that the loop in trigger\n                // can continue using it's old reference to loop without\n                // messing up the order.\n\n                this.listeners[type] = this.listeners[type].slice(0);\n                this.listeners[type].splice(index, 1);\n                return index > -1;\n            }\n            /**\n             * Trigger an event of the specified type on this stream. Any additional\n             * arguments to this function are passed as parameters to event listeners.\n             *\n             * @param {string} type the event name\n             */;\n\n            _proto.trigger = function trigger(type) {\n                var callbacks = this.listeners[type];\n                if (!callbacks) {\n                    return;\n                } // Slicing the arguments on every invocation of this method\n                // can add a significant amount of overhead. Avoid the\n                // intermediate object creation for the common case of a\n                // single callback argument\n\n                if (arguments.length === 2) {\n                    var length = callbacks.length;\n                    for (var i = 0; i < length; ++i) {\n                        callbacks[i].call(this, arguments[1]);\n                    }\n                } else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var _length = callbacks.length;\n                    for (var _i = 0; _i < _length; ++_i) {\n                        callbacks[_i].apply(this, args);\n                    }\n                }\n            }\n            /**\n             * Destroys the stream and cleans up.\n             */;\n\n            _proto.dispose = function dispose() {\n                this.listeners = {};\n            }\n            /**\n             * Forwards all `data` events on this stream to the destination stream. The\n             * destination stream should provide a method `push` to receive the data\n             * events as they arrive.\n             *\n             * @param {Stream} destination the stream that will receive all `data` events\n             * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n             */;\n\n            _proto.pipe = function pipe(destination) {\n                this.on('data', function (data) {\n                    destination.push(data);\n                });\n            };\n            return Stream;\n        }();\n        /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */\n\n        /**\n         * Returns the subarray of a Uint8Array without PKCS#7 padding.\n         *\n         * @param padded {Uint8Array} unencrypted bytes that have been padded\n         * @return {Uint8Array} the unpadded bytes\n         * @see http://tools.ietf.org/html/rfc5652\n         */\n\n        function unpad(padded) {\n            return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n        }\n        /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */\n\n        /**\n         * @file aes.js\n         *\n         * This file contains an adaptation of the AES decryption algorithm\n         * from the Standford Javascript Cryptography Library. That work is\n         * covered by the following copyright and permissions notice:\n         *\n         * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n         * All rights reserved.\n         *\n         * Redistribution and use in source and binary forms, with or without\n         * modification, are permitted provided that the following conditions are\n         * met:\n         *\n         * 1. Redistributions of source code must retain the above copyright\n         *    notice, this list of conditions and the following disclaimer.\n         *\n         * 2. Redistributions in binary form must reproduce the above\n         *    copyright notice, this list of conditions and the following\n         *    disclaimer in the documentation and/or other materials provided\n         *    with the distribution.\n         *\n         * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n         * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n         * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n         * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n         * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n         * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n         * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n         * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n         * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n         *\n         * The views and conclusions contained in the software and documentation\n         * are those of the authors and should not be interpreted as representing\n         * official policies, either expressed or implied, of the authors.\n         */\n\n        /**\n         * Expand the S-box tables.\n         *\n         * @private\n         */\n\n        const precompute = function () {\n            const tables = [[[], [], [], [], []], [[], [], [], [], []]];\n            const encTable = tables[0];\n            const decTable = tables[1];\n            const sbox = encTable[4];\n            const sboxInv = decTable[4];\n            let i;\n            let x;\n            let xInv;\n            const d = [];\n            const th = [];\n            let x2;\n            let x4;\n            let x8;\n            let s;\n            let tEnc;\n            let tDec; // Compute double and third tables\n\n            for (i = 0; i < 256; i++) {\n                th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n            }\n            for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n                // Compute sbox\n                s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n                s = s >> 8 ^ s & 255 ^ 99;\n                sbox[x] = s;\n                sboxInv[s] = x; // Compute MixColumns\n\n                x8 = d[x4 = d[x2 = d[x]]];\n                tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n                tEnc = d[s] * 0x101 ^ s * 0x1010100;\n                for (i = 0; i < 4; i++) {\n                    encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n                    decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n                }\n            } // Compactify. Considerable speedup on Firefox.\n\n            for (i = 0; i < 5; i++) {\n                encTable[i] = encTable[i].slice(0);\n                decTable[i] = decTable[i].slice(0);\n            }\n            return tables;\n        };\n        let aesTables = null;\n        /**\n         * Schedule out an AES key for both encryption and decryption. This\n         * is a low-level class. Use a cipher mode to do bulk encryption.\n         *\n         * @class AES\n         * @param key {Array} The key as an array of 4, 6 or 8 words.\n         */\n\n        class AES {\n            constructor(key) {\n                /**\n                 * The expanded S-box and inverse S-box tables. These will be computed\n                 * on the client so that we don't have to send them down the wire.\n                 *\n                 * There are two tables, _tables[0] is for encryption and\n                 * _tables[1] is for decryption.\n                 *\n                 * The first 4 sub-tables are the expanded S-box with MixColumns. The\n                 * last (_tables[01][4]) is the S-box itself.\n                 *\n                 * @private\n                 */\n                // if we have yet to precompute the S-box tables\n                // do so now\n                if (!aesTables) {\n                    aesTables = precompute();\n                } // then make a copy of that object for use\n\n                this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n                let i;\n                let j;\n                let tmp;\n                const sbox = this._tables[0][4];\n                const decTable = this._tables[1];\n                const keyLen = key.length;\n                let rcon = 1;\n                if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n                    throw new Error('Invalid aes key size');\n                }\n                const encKey = key.slice(0);\n                const decKey = [];\n                this._key = [encKey, decKey]; // schedule encryption keys\n\n                for (i = keyLen; i < 4 * keyLen + 28; i++) {\n                    tmp = encKey[i - 1]; // apply sbox\n\n                    if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n                        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon\n\n                        if (i % keyLen === 0) {\n                            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n                            rcon = rcon << 1 ^ (rcon >> 7) * 283;\n                        }\n                    }\n                    encKey[i] = encKey[i - keyLen] ^ tmp;\n                } // schedule decryption keys\n\n                for (j = 0; i; j++, i--) {\n                    tmp = encKey[j & 3 ? i : i - 4];\n                    if (i <= 4 || j < 4) {\n                        decKey[j] = tmp;\n                    } else {\n                        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n                    }\n                }\n            }\n            /**\n             * Decrypt 16 bytes, specified as four 32-bit words.\n             *\n             * @param {number} encrypted0 the first word to decrypt\n             * @param {number} encrypted1 the second word to decrypt\n             * @param {number} encrypted2 the third word to decrypt\n             * @param {number} encrypted3 the fourth word to decrypt\n             * @param {Int32Array} out the array to write the decrypted words\n             * into\n             * @param {number} offset the offset into the output array to start\n             * writing results\n             * @return {Array} The plaintext.\n             */\n\n            decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n                const key = this._key[1]; // state variables a,b,c,d are loaded with pre-whitened data\n\n                let a = encrypted0 ^ key[0];\n                let b = encrypted3 ^ key[1];\n                let c = encrypted2 ^ key[2];\n                let d = encrypted1 ^ key[3];\n                let a2;\n                let b2;\n                let c2; // key.length === 2 ?\n\n                const nInnerRounds = key.length / 4 - 2;\n                let i;\n                let kIndex = 4;\n                const table = this._tables[1]; // load up the tables\n\n                const table0 = table[0];\n                const table1 = table[1];\n                const table2 = table[2];\n                const table3 = table[3];\n                const sbox = table[4]; // Inner rounds. Cribbed from OpenSSL.\n\n                for (i = 0; i < nInnerRounds; i++) {\n                    a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n                    b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n                    c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n                    d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n                    kIndex += 4;\n                    a = a2;\n                    b = b2;\n                    c = c2;\n                } // Last round.\n\n                for (i = 0; i < 4; i++) {\n                    out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n                    a2 = a;\n                    a = b;\n                    b = c;\n                    c = d;\n                    d = a2;\n                }\n            }\n        }\n        /**\n         * @file async-stream.js\n         */\n\n        /**\n         * A wrapper around the Stream class to use setTimeout\n         * and run stream \"jobs\" Asynchronously\n         *\n         * @class AsyncStream\n         * @extends Stream\n         */\n\n        class AsyncStream extends Stream {\n            constructor() {\n                super(Stream);\n                this.jobs = [];\n                this.delay = 1;\n                this.timeout_ = null;\n            }\n            /**\n             * process an async job\n             *\n             * @private\n             */\n\n            processJob_() {\n                this.jobs.shift()();\n                if (this.jobs.length) {\n                    this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n                } else {\n                    this.timeout_ = null;\n                }\n            }\n            /**\n             * push a job into the stream\n             *\n             * @param {Function} job the job to push into the stream\n             */\n\n            push(job) {\n                this.jobs.push(job);\n                if (!this.timeout_) {\n                    this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n                }\n            }\n        }\n        /**\n         * @file decrypter.js\n         *\n         * An asynchronous implementation of AES-128 CBC decryption with\n         * PKCS#7 padding.\n         */\n\n        /**\n         * Convert network-order (big-endian) bytes into their little-endian\n         * representation.\n         */\n\n        const ntoh = function (word) {\n            return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n        };\n        /**\n         * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n         *\n         * @param {Uint8Array} encrypted the encrypted bytes\n         * @param {Uint32Array} key the bytes of the decryption key\n         * @param {Uint32Array} initVector the initialization vector (IV) to\n         * use for the first round of CBC.\n         * @return {Uint8Array} the decrypted bytes\n         *\n         * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n         * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n         * @see https://tools.ietf.org/html/rfc2315\n         */\n\n        const decrypt = function (encrypted, key, initVector) {\n            // word-level access to the encrypted bytes\n            const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n            const decipher = new AES(Array.prototype.slice.call(key)); // byte and word-level access for the decrypted output\n\n            const decrypted = new Uint8Array(encrypted.byteLength);\n            const decrypted32 = new Int32Array(decrypted.buffer); // temporary variables for working with the IV, encrypted, and\n            // decrypted data\n\n            let init0;\n            let init1;\n            let init2;\n            let init3;\n            let encrypted0;\n            let encrypted1;\n            let encrypted2;\n            let encrypted3; // iteration variable\n\n            let wordIx; // pull out the words of the IV to ensure we don't modify the\n            // passed-in reference and easier access\n\n            init0 = initVector[0];\n            init1 = initVector[1];\n            init2 = initVector[2];\n            init3 = initVector[3]; // decrypt four word sequences, applying cipher-block chaining (CBC)\n            // to each decrypted block\n\n            for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n                // convert big-endian (network order) words into little-endian\n                // (javascript order)\n                encrypted0 = ntoh(encrypted32[wordIx]);\n                encrypted1 = ntoh(encrypted32[wordIx + 1]);\n                encrypted2 = ntoh(encrypted32[wordIx + 2]);\n                encrypted3 = ntoh(encrypted32[wordIx + 3]); // decrypt the block\n\n                decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx); // XOR with the IV, and restore network byte-order to obtain the\n                // plaintext\n\n                decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n                decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n                decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n                decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3); // setup the IV for the next round\n\n                init0 = encrypted0;\n                init1 = encrypted1;\n                init2 = encrypted2;\n                init3 = encrypted3;\n            }\n            return decrypted;\n        };\n        /**\n         * The `Decrypter` class that manages decryption of AES\n         * data through `AsyncStream` objects and the `decrypt`\n         * function\n         *\n         * @param {Uint8Array} encrypted the encrypted bytes\n         * @param {Uint32Array} key the bytes of the decryption key\n         * @param {Uint32Array} initVector the initialization vector (IV) to\n         * @param {Function} done the function to run when done\n         * @class Decrypter\n         */\n\n        class Decrypter {\n            constructor(encrypted, key, initVector, done) {\n                const step = Decrypter.STEP;\n                const encrypted32 = new Int32Array(encrypted.buffer);\n                const decrypted = new Uint8Array(encrypted.byteLength);\n                let i = 0;\n                this.asyncStream_ = new AsyncStream(); // split up the encryption job and do the individual chunks asynchronously\n\n                this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n                for (i = step; i < encrypted32.length; i += step) {\n                    initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n                    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n                } // invoke the done() callback when everything is finished\n\n                this.asyncStream_.push(function () {\n                    // remove pkcs#7 padding from the decrypted bytes\n                    done(null, unpad(decrypted));\n                });\n            }\n            /**\n             * a getter for step the maximum number of bytes to process at one time\n             *\n             * @return {number} the value of step 32000\n             */\n\n            static get STEP() {\n                // 4 * 8000;\n                return 32000;\n            }\n            /**\n             * @private\n             */\n\n            decryptChunk_(encrypted, key, initVector, decrypted) {\n                return function () {\n                    const bytes = decrypt(encrypted, key, initVector);\n                    decrypted.set(bytes, encrypted.byteOffset);\n                };\n            }\n        }\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n        var win;\n        if (typeof window !== \"undefined\") {\n            win = window;\n        } else if (typeof commonjsGlobal !== \"undefined\") {\n            win = commonjsGlobal;\n        } else if (typeof self !== \"undefined\") {\n            win = self;\n        } else {\n            win = {};\n        }\n        var window_1 = win;\n        var isArrayBufferView = function isArrayBufferView(obj) {\n            if (ArrayBuffer.isView === 'function') {\n                return ArrayBuffer.isView(obj);\n            }\n            return obj && obj.buffer instanceof ArrayBuffer;\n        };\n        var BigInt = window_1.BigInt || Number;\n        [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n        (function () {\n            var a = new Uint16Array([0xFFCC]);\n            var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n            if (b[0] === 0xFF) {\n                return 'big';\n            }\n            if (b[0] === 0xCC) {\n                return 'little';\n            }\n            return 'unknown';\n        })();\n        /**\n         * Creates an object for sending to a web worker modifying properties that are TypedArrays\n         * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n         *\n         * @param {Object} message\n         *        Object of properties and values to send to the web worker\n         * @return {Object}\n         *         Modified message with TypedArray values expanded\n         * @function createTransferableMessage\n         */\n\n        const createTransferableMessage = function (message) {\n            const transferable = {};\n            Object.keys(message).forEach(key => {\n                const value = message[key];\n                if (isArrayBufferView(value)) {\n                    transferable[key] = {\n                        bytes: value.buffer,\n                        byteOffset: value.byteOffset,\n                        byteLength: value.byteLength\n                    };\n                } else {\n                    transferable[key] = value;\n                }\n            });\n            return transferable;\n        };\n        /* global self */\n\n        /**\n         * Our web worker interface so that things can talk to aes-decrypter\n         * that will be running in a web worker. the scope is passed to this by\n         * webworkify.\n         */\n\n        self.onmessage = function (event) {\n            const data = event.data;\n            const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n            const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n            const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n            /* eslint-disable no-new, handle-callback-err */\n\n            new Decrypter(encrypted, key, iv, function (err, bytes) {\n                self.postMessage(createTransferableMessage({\n                    source: data.source,\n                    decrypted: bytes\n                }), [bytes.buffer]);\n            });\n            /* eslint-enable */\n        };\n    }));\n\n    var Decrypter = factory(workerCode);\n    /* rollup-plugin-worker-factory end for worker!/home/runner/work/http-streaming/http-streaming/src/decrypter-worker.js */\n\n    /**\n     * Convert the properties of an HLS track into an audioTrackKind.\n     *\n     * @private\n     */\n\n    const audioTrackKind_ = properties => {\n        let kind = properties.default ? 'main' : 'alternative';\n        if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n            kind = 'main-desc';\n        }\n        return kind;\n    };\n    /**\n     * Pause provided segment loader and playlist loader if active\n     *\n     * @param {SegmentLoader} segmentLoader\n     *        SegmentLoader to pause\n     * @param {Object} mediaType\n     *        Active media type\n     * @function stopLoaders\n     */\n\n    const stopLoaders = (segmentLoader, mediaType) => {\n        segmentLoader.abort();\n        segmentLoader.pause();\n        if (mediaType && mediaType.activePlaylistLoader) {\n            mediaType.activePlaylistLoader.pause();\n            mediaType.activePlaylistLoader = null;\n        }\n    };\n    /**\n     * Start loading provided segment loader and playlist loader\n     *\n     * @param {PlaylistLoader} playlistLoader\n     *        PlaylistLoader to start loading\n     * @param {Object} mediaType\n     *        Active media type\n     * @function startLoaders\n     */\n\n    const startLoaders = (playlistLoader, mediaType) => {\n        // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n        // playlist loader\n        mediaType.activePlaylistLoader = playlistLoader;\n        playlistLoader.load();\n    };\n    /**\n     * Returns a function to be called when the media group changes. It performs a\n     * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n     * change of group is merely a rendition switch of the same content at another encoding,\n     * rather than a change of content, such as switching audio from English to Spanish.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Handler for a non-destructive resync of SegmentLoader when the active media\n     *         group changes.\n     * @function onGroupChanged\n     */\n\n    const onGroupChanged = (type, settings) => () => {\n        const {\n            segmentLoaders: {\n                [type]: segmentLoader,\n                main: mainSegmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        const activeTrack = mediaType.activeTrack();\n        const activeGroup = mediaType.getActiveGroup();\n        const previousActiveLoader = mediaType.activePlaylistLoader;\n        const lastGroup = mediaType.lastGroup_; // the group did not change do nothing\n\n        if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) {\n            return;\n        }\n        mediaType.lastGroup_ = activeGroup;\n        mediaType.lastTrack_ = activeTrack;\n        stopLoaders(segmentLoader, mediaType);\n        if (!activeGroup || activeGroup.isMainPlaylist) {\n            // there is no group active or active group is a main playlist and won't change\n            return;\n        }\n        if (!activeGroup.playlistLoader) {\n            if (previousActiveLoader) {\n                // The previous group had a playlist loader but the new active group does not\n                // this means we are switching from demuxed to muxed audio. In this case we want to\n                // do a destructive reset of the main segment loader and not restart the audio\n                // loaders.\n                mainSegmentLoader.resetEverything();\n            }\n            return;\n        } // Non-destructive resync\n\n        segmentLoader.resyncLoader();\n        startLoaders(activeGroup.playlistLoader, mediaType);\n    };\n    const onGroupChanging = (type, settings) => () => {\n        const {\n            segmentLoaders: {\n                [type]: segmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        mediaType.lastGroup_ = null;\n        segmentLoader.abort();\n        segmentLoader.pause();\n    };\n    /**\n     * Returns a function to be called when the media track changes. It performs a\n     * destructive reset of the SegmentLoader to ensure we start loading as close to\n     * currentTime as possible.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Handler for a destructive reset of SegmentLoader when the active media\n     *         track changes.\n     * @function onTrackChanged\n     */\n\n    const onTrackChanged = (type, settings) => () => {\n        const {\n            mainPlaylistLoader,\n            segmentLoaders: {\n                [type]: segmentLoader,\n                main: mainSegmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        const activeTrack = mediaType.activeTrack();\n        const activeGroup = mediaType.getActiveGroup();\n        const previousActiveLoader = mediaType.activePlaylistLoader;\n        const lastTrack = mediaType.lastTrack_; // track did not change, do nothing\n\n        if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) {\n            return;\n        }\n        mediaType.lastGroup_ = activeGroup;\n        mediaType.lastTrack_ = activeTrack;\n        stopLoaders(segmentLoader, mediaType);\n        if (!activeGroup) {\n            // there is no group active so we do not want to restart loaders\n            return;\n        }\n        if (activeGroup.isMainPlaylist) {\n            // track did not change, do nothing\n            if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) {\n                return;\n            }\n            const pc = settings.vhs.playlistController_;\n            const newPlaylist = pc.selectPlaylist(); // media will not change do nothing\n\n            if (pc.media() === newPlaylist) {\n                return;\n            }\n            mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack.id}`);\n            mainPlaylistLoader.pause();\n            mainSegmentLoader.resetEverything();\n            pc.fastQualityChange_(newPlaylist);\n            return;\n        }\n        if (type === 'AUDIO') {\n            if (!activeGroup.playlistLoader) {\n                // when switching from demuxed audio/video to muxed audio/video (noted by no\n                // playlist loader for the audio group), we want to do a destructive reset of the\n                // main segment loader and not restart the audio loaders\n                mainSegmentLoader.setAudio(true); // don't have to worry about disabling the audio of the audio segment loader since\n                // it should be stopped\n\n                mainSegmentLoader.resetEverything();\n                return;\n            } // although the segment loader is an audio segment loader, call the setAudio\n            // function to ensure it is prepared to re-append the init segment (or handle other\n            // config changes)\n\n            segmentLoader.setAudio(true);\n            mainSegmentLoader.setAudio(false);\n        }\n        if (previousActiveLoader === activeGroup.playlistLoader) {\n            // Nothing has actually changed. This can happen because track change events can fire\n            // multiple times for a \"single\" change. One for enabling the new active track, and\n            // one for disabling the track that was active\n            startLoaders(activeGroup.playlistLoader, mediaType);\n            return;\n        }\n        if (segmentLoader.track) {\n            // For WebVTT, set the new text track in the segmentloader\n            segmentLoader.track(activeTrack);\n        } // destructive reset\n\n        segmentLoader.resetEverything();\n        startLoaders(activeGroup.playlistLoader, mediaType);\n    };\n    const onError = {\n        /**\n         * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n         * an error.\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Error handler. Logs warning (or error if the playlist is excluded) to\n         *         console and switches back to default audio track.\n         * @function onError.AUDIO\n         */\n        AUDIO: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: mediaType\n                },\n                excludePlaylist\n            } = settings; // switch back to default audio track\n\n            const activeTrack = mediaType.activeTrack();\n            const activeGroup = mediaType.activeGroup();\n            const id = (activeGroup.filter(group => group.default)[0] || activeGroup[0]).id;\n            const defaultTrack = mediaType.tracks[id];\n            if (activeTrack === defaultTrack) {\n                // Default track encountered an error. All we can do now is exclude the current\n                // rendition and hope another will switch audio groups\n                excludePlaylist({\n                    error: {\n                        message: 'Problem encountered loading the default audio track.'\n                    }\n                });\n                return;\n            }\n            videojs.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n            for (const trackId in mediaType.tracks) {\n                mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n            }\n            mediaType.onTrackChanged();\n        },\n        /**\n         * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n         * an error.\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Error handler. Logs warning to console and disables the active subtitle track\n         * @function onError.SUBTITLES\n         */\n        SUBTITLES: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: mediaType\n                }\n            } = settings;\n            videojs.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n            const track = mediaType.activeTrack();\n            if (track) {\n                track.mode = 'disabled';\n            }\n            mediaType.onTrackChanged();\n        }\n    };\n    const setupListeners = {\n        /**\n         * Setup event listeners for audio playlist loader\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {PlaylistLoader|null} playlistLoader\n         *        PlaylistLoader to register listeners on\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function setupListeners.AUDIO\n         */\n        AUDIO: (type, playlistLoader, settings) => {\n            if (!playlistLoader) {\n                // no playlist loader means audio will be muxed with the video\n                return;\n            }\n            const {\n                tech,\n                requestOptions,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                }\n            } = settings;\n            playlistLoader.on('loadedmetadata', () => {\n                const media = playlistLoader.media();\n                segmentLoader.playlist(media, requestOptions); // if the video is already playing, or if this isn't a live video and preload\n                // permits, start downloading segments\n\n                if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('loadedplaylist', () => {\n                segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n                if (!tech.paused()) {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup event listeners for subtitle playlist loader\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {PlaylistLoader|null} playlistLoader\n         *        PlaylistLoader to register listeners on\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function setupListeners.SUBTITLES\n         */\n        SUBTITLES: (type, playlistLoader, settings) => {\n            const {\n                tech,\n                requestOptions,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                mediaTypes: {\n                    [type]: mediaType\n                }\n            } = settings;\n            playlistLoader.on('loadedmetadata', () => {\n                const media = playlistLoader.media();\n                segmentLoader.playlist(media, requestOptions);\n                segmentLoader.track(mediaType.activeTrack()); // if the video is already playing, or if this isn't a live video and preload\n                // permits, start downloading segments\n\n                if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('loadedplaylist', () => {\n                segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n                if (!tech.paused()) {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('error', onError[type](type, settings));\n        }\n    };\n    const initialize = {\n        /**\n         * Setup PlaylistLoaders and AudioTracks for the audio groups\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize.AUDIO\n         */\n        'AUDIO': (type, settings) => {\n            const {\n                vhs,\n                sourceType,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                requestOptions,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks,\n                        logger_\n                    }\n                },\n                mainPlaylistLoader\n            } = settings;\n            const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main); // force a default if we have none\n\n            if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\n                mediaGroups[type] = {\n                    main: {\n                        default: {\n                            default: true\n                        }\n                    }\n                };\n                if (audioOnlyMain) {\n                    mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;\n                }\n            }\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    let properties = mediaGroups[type][groupId][variantLabel];\n                    let playlistLoader;\n                    if (audioOnlyMain) {\n                        logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);\n                        properties.isMainPlaylist = true;\n                        playlistLoader = null; // if vhs-json was provided as the source, and the media playlist was resolved,\n                        // use the resolved media playlist object\n                    } else if (sourceType === 'vhs-json' && properties.playlists) {\n                        playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);\n                    } else if (properties.resolvedUri) {\n                        playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); // TODO: dash isn't the only type with properties.playlists\n                        // should we even have properties.playlists in this check.\n                    } else if (properties.playlists && sourceType === 'dash') {\n                        playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n                    } else {\n                        // no resolvedUri means the audio is muxed with the video when using this\n                        // audio track\n                        playlistLoader = null;\n                    }\n                    properties = merge({\n                        id: variantLabel,\n                        playlistLoader\n                    }, properties);\n                    setupListeners[type](type, properties.playlistLoader, settings);\n                    groups[groupId].push(properties);\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = new videojs.AudioTrack({\n                            id: variantLabel,\n                            kind: audioTrackKind_(properties),\n                            enabled: false,\n                            language: properties.language,\n                            default: properties.default,\n                            label: variantLabel\n                        });\n                        tracks[variantLabel] = track;\n                    }\n                }\n            } // setup single error event handler for the segment loader\n\n            segmentLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup PlaylistLoaders and TextTracks for the subtitle groups\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize.SUBTITLES\n         */\n        'SUBTITLES': (type, settings) => {\n            const {\n                tech,\n                vhs,\n                sourceType,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                requestOptions,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks\n                    }\n                },\n                mainPlaylistLoader\n            } = settings;\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    if (!vhs.options_.useForcedSubtitles && mediaGroups[type][groupId][variantLabel].forced) {\n                        // Subtitle playlists with the forced attribute are not selectable in Safari.\n                        // According to Apple's HLS Authoring Specification:\n                        //   If content has forced subtitles and regular subtitles in a given language,\n                        //   the regular subtitles track in that language MUST contain both the forced\n                        //   subtitles and the regular subtitles for that language.\n                        // Because of this requirement and that Safari does not add forced subtitles,\n                        // forced subtitles are skipped here to maintain consistent experience across\n                        // all platforms\n                        continue;\n                    }\n                    let properties = mediaGroups[type][groupId][variantLabel];\n                    let playlistLoader;\n                    if (sourceType === 'hls') {\n                        playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\n                    } else if (sourceType === 'dash') {\n                        const playlists = properties.playlists.filter(p => p.excludeUntil !== Infinity);\n                        if (!playlists.length) {\n                            return;\n                        }\n                        playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n                    } else if (sourceType === 'vhs-json') {\n                        playlistLoader = new PlaylistLoader(\n                            // if the vhs-json object included the media playlist, use the media playlist\n                            // as provided, otherwise use the resolved URI to load the playlist\n                            properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);\n                    }\n                    properties = merge({\n                        id: variantLabel,\n                        playlistLoader\n                    }, properties);\n                    setupListeners[type](type, properties.playlistLoader, settings);\n                    groups[groupId].push(properties);\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = tech.addRemoteTextTrack({\n                            id: variantLabel,\n                            kind: 'subtitles',\n                            default: properties.default && properties.autoselect,\n                            language: properties.language,\n                            label: variantLabel\n                        }, false).track;\n                        tracks[variantLabel] = track;\n                    }\n                }\n            } // setup single error event handler for the segment loader\n\n            segmentLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup TextTracks for the closed-caption groups\n         *\n         * @param {String} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize['CLOSED-CAPTIONS']\n         */\n        'CLOSED-CAPTIONS': (type, settings) => {\n            const {\n                tech,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    const properties = mediaGroups[type][groupId][variantLabel]; // Look for either 608 (CCn) or 708 (SERVICEn) caption services\n\n                    if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {\n                        continue;\n                    }\n                    const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n                    let newProps = {\n                        label: variantLabel,\n                        language: properties.language,\n                        instreamId: properties.instreamId,\n                        default: properties.default && properties.autoselect\n                    };\n                    if (captionServices[newProps.instreamId]) {\n                        newProps = merge(newProps, captionServices[newProps.instreamId]);\n                    }\n                    if (newProps.default === undefined) {\n                        delete newProps.default;\n                    } // No PlaylistLoader is required for Closed-Captions because the captions are\n                    // embedded within the video stream\n\n                    groups[groupId].push(merge({\n                        id: variantLabel\n                    }, properties));\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = tech.addRemoteTextTrack({\n                            id: newProps.instreamId,\n                            kind: 'captions',\n                            default: newProps.default,\n                            language: newProps.language,\n                            label: newProps.label\n                        }, false).track;\n                        tracks[variantLabel] = track;\n                    }\n                }\n            }\n        }\n    };\n    const groupMatch = (list, media) => {\n        for (let i = 0; i < list.length; i++) {\n            if (playlistMatch(media, list[i])) {\n                return true;\n            }\n            if (list[i].playlists && groupMatch(list[i].playlists, media)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns a function used to get the active group of the provided type\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Function that returns the active media group for the provided type. Takes an\n     *         optional parameter {TextTrack} track. If no track is provided, a list of all\n     *         variants in the group, otherwise the variant corresponding to the provided\n     *         track is returned.\n     * @function activeGroup\n     */\n\n    const activeGroup = (type, settings) => track => {\n        const {\n            mainPlaylistLoader,\n            mediaTypes: {\n                [type]: {\n                    groups\n                }\n            }\n        } = settings;\n        const media = mainPlaylistLoader.media();\n        if (!media) {\n            return null;\n        }\n        let variants = null; // set to variants to main media active group\n\n        if (media.attributes[type]) {\n            variants = groups[media.attributes[type]];\n        }\n        const groupKeys = Object.keys(groups);\n        if (!variants) {\n            // find the mainPlaylistLoader media\n            // that is in a media group if we are dealing\n            // with audio only\n            if (type === 'AUDIO' && groupKeys.length > 1 && isAudioOnly(settings.main)) {\n                for (let i = 0; i < groupKeys.length; i++) {\n                    const groupPropertyList = groups[groupKeys[i]];\n                    if (groupMatch(groupPropertyList, media)) {\n                        variants = groupPropertyList;\n                        break;\n                    }\n                } // use the main group if it exists\n            } else if (groups.main) {\n                variants = groups.main; // only one group, use that one\n            } else if (groupKeys.length === 1) {\n                variants = groups[groupKeys[0]];\n            }\n        }\n        if (typeof track === 'undefined') {\n            return variants;\n        }\n        if (track === null || !variants) {\n            // An active track was specified so a corresponding group is expected. track === null\n            // means no track is currently active so there is no corresponding group\n            return null;\n        }\n        return variants.filter(props => props.id === track.id)[0] || null;\n    };\n    const activeTrack = {\n        /**\n         * Returns a function used to get the active track of type provided\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Function that returns the active media track for the provided type. Returns\n         *         null if no track is active\n         * @function activeTrack.AUDIO\n         */\n        AUDIO: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: {\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const id in tracks) {\n                if (tracks[id].enabled) {\n                    return tracks[id];\n                }\n            }\n            return null;\n        },\n        /**\n         * Returns a function used to get the active track of type provided\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Function that returns the active media track for the provided type. Returns\n         *         null if no track is active\n         * @function activeTrack.SUBTITLES\n         */\n        SUBTITLES: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: {\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const id in tracks) {\n                if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {\n                    return tracks[id];\n                }\n            }\n            return null;\n        }\n    };\n    const getActiveGroup = (type, {\n        mediaTypes\n    }) => () => {\n        const activeTrack_ = mediaTypes[type].activeTrack();\n        if (!activeTrack_) {\n            return null;\n        }\n        return mediaTypes[type].activeGroup(activeTrack_);\n    };\n    /**\n     * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n     * Closed-Captions) specified in the main manifest.\n     *\n     * @param {Object} settings\n     *        Object containing required information for setting up the media groups\n     * @param {Tech} settings.tech\n     *        The tech of the player\n     * @param {Object} settings.requestOptions\n     *        XHR request options used by the segment loaders\n     * @param {PlaylistLoader} settings.mainPlaylistLoader\n     *        PlaylistLoader for the main source\n     * @param {VhsHandler} settings.vhs\n     *        VHS SourceHandler\n     * @param {Object} settings.main\n     *        The parsed main manifest\n     * @param {Object} settings.mediaTypes\n     *        Object to store the loaders, tracks, and utility methods for each media type\n     * @param {Function} settings.excludePlaylist\n     *        Excludes the current rendition and forces a rendition switch.\n     * @function setupMediaGroups\n     */\n\n    const setupMediaGroups = settings => {\n        ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n            initialize[type](type, settings);\n        });\n        const {\n            mediaTypes,\n            mainPlaylistLoader,\n            tech,\n            vhs,\n            segmentLoaders: {\n                ['AUDIO']: audioSegmentLoader,\n                main: mainSegmentLoader\n            }\n        } = settings; // setup active group and track getters and change event handlers\n\n        ['AUDIO', 'SUBTITLES'].forEach(type => {\n            mediaTypes[type].activeGroup = activeGroup(type, settings);\n            mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n            mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n            mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);\n            mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n            mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);\n        }); // DO NOT enable the default subtitle or caption track.\n        // DO enable the default audio track\n\n        const audioGroup = mediaTypes.AUDIO.activeGroup();\n        if (audioGroup) {\n            const groupId = (audioGroup.filter(group => group.default)[0] || audioGroup[0]).id;\n            mediaTypes.AUDIO.tracks[groupId].enabled = true;\n            mediaTypes.AUDIO.onGroupChanged();\n            mediaTypes.AUDIO.onTrackChanged();\n            const activeAudioGroup = mediaTypes.AUDIO.getActiveGroup(); // a similar check for handling setAudio on each loader is run again each time the\n            // track is changed, but needs to be handled here since the track may not be considered\n            // changed on the first call to onTrackChanged\n\n            if (!activeAudioGroup.playlistLoader) {\n                // either audio is muxed with video or the stream is audio only\n                mainSegmentLoader.setAudio(true);\n            } else {\n                // audio is demuxed\n                mainSegmentLoader.setAudio(false);\n                audioSegmentLoader.setAudio(true);\n            }\n        }\n        mainPlaylistLoader.on('mediachange', () => {\n            ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanged());\n        });\n        mainPlaylistLoader.on('mediachanging', () => {\n            ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanging());\n        }); // custom audio track change event handler for usage event\n\n        const onAudioTrackChanged = () => {\n            mediaTypes.AUDIO.onTrackChanged();\n            tech.trigger({\n                type: 'usage',\n                name: 'vhs-audio-change'\n            });\n        };\n        tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n        tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n        vhs.on('dispose', () => {\n            tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n            tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n        }); // clear existing audio tracks and add the ones we just created\n\n        tech.clearTracks('audio');\n        for (const id in mediaTypes.AUDIO.tracks) {\n            tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n        }\n    };\n    /**\n     * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n     * media type\n     *\n     * @return {Object}\n     *         Object to store the loaders, tracks, and utility methods for each media type\n     * @function createMediaTypes\n     */\n\n    const createMediaTypes = () => {\n        const mediaTypes = {};\n        ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n            mediaTypes[type] = {\n                groups: {},\n                tracks: {},\n                activePlaylistLoader: null,\n                activeGroup: noop,\n                activeTrack: noop,\n                getActiveGroup: noop,\n                onGroupChanged: noop,\n                onTrackChanged: noop,\n                lastTrack_: null,\n                logger_: logger(`MediaGroups[${type}]`)\n            };\n        });\n        return mediaTypes;\n    };\n\n    /**\n     * A utility class for setting properties and maintaining the state of the content steering manifest.\n     *\n     * Content Steering manifest format:\n     * VERSION: number (required) currently only version 1 is supported.\n     * TTL: number in seconds (optional) until the next content steering manifest reload.\n     * RELOAD-URI: string (optional) uri to fetch the next content steering manifest.\n     * SERVICE-LOCATION-PRIORITY or PATHWAY-PRIORITY a non empty array of unique string values.\n     * PATHWAY-CLONES: array (optional) (HLS only) pathway clone objects to copy from other playlists.\n     */\n\n    class SteeringManifest {\n        constructor() {\n            this.priority_ = [];\n            this.pathwayClones_ = new Map();\n        }\n        set version(number) {\n            // Only version 1 is currently supported for both DASH and HLS.\n            if (number === 1) {\n                this.version_ = number;\n            }\n        }\n        set ttl(seconds) {\n            // TTL = time-to-live, default = 300 seconds.\n            this.ttl_ = seconds || 300;\n        }\n        set reloadUri(uri) {\n            if (uri) {\n                // reload URI can be relative to the previous reloadUri.\n                this.reloadUri_ = resolveUrl(this.reloadUri_, uri);\n            }\n        }\n        set priority(array) {\n            // priority must be non-empty and unique values.\n            if (array && array.length) {\n                this.priority_ = array;\n            }\n        }\n        set pathwayClones(array) {\n            // pathwayClones must be non-empty.\n            if (array && array.length) {\n                this.pathwayClones_ = new Map(array.map(clone => [clone.ID, clone]));\n            }\n        }\n        get version() {\n            return this.version_;\n        }\n        get ttl() {\n            return this.ttl_;\n        }\n        get reloadUri() {\n            return this.reloadUri_;\n        }\n        get priority() {\n            return this.priority_;\n        }\n        get pathwayClones() {\n            return this.pathwayClones_;\n        }\n    }\n    /**\n     * This class represents a content steering manifest and associated state. See both HLS and DASH specifications.\n     * HLS: https://developer.apple.com/streaming/HLSContentSteeringSpecification.pdf and\n     * https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/ section 4.4.6.6.\n     * DASH: https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n     *\n     * @param {function} xhr for making a network request from the browser.\n     * @param {function} bandwidth for fetching the current bandwidth from the main segment loader.\n     */\n\n    class ContentSteeringController extends videojs.EventTarget {\n        constructor(xhr, bandwidth) {\n            super();\n            this.currentPathway = null;\n            this.defaultPathway = null;\n            this.queryBeforeStart = false;\n            this.availablePathways_ = new Set();\n            this.steeringManifest = new SteeringManifest();\n            this.proxyServerUrl_ = null;\n            this.manifestType_ = null;\n            this.ttlTimeout_ = null;\n            this.request_ = null;\n            this.currentPathwayClones = new Map();\n            this.nextPathwayClones = new Map();\n            this.excludedSteeringManifestURLs = new Set();\n            this.logger_ = logger('Content Steering');\n            this.xhr_ = xhr;\n            this.getBandwidth_ = bandwidth;\n        }\n        /**\n         * Assigns the content steering tag properties to the steering controller\n         *\n         * @param {string} baseUrl the baseURL from the main manifest for resolving the steering manifest url\n         * @param {Object} steeringTag the content steering tag from the main manifest\n         */\n\n        assignTagProperties(baseUrl, steeringTag) {\n            this.manifestType_ = steeringTag.serverUri ? 'HLS' : 'DASH'; // serverUri is HLS serverURL is DASH\n\n            const steeringUri = steeringTag.serverUri || steeringTag.serverURL;\n            if (!steeringUri) {\n                this.logger_(`steering manifest URL is ${steeringUri}, cannot request steering manifest.`);\n                this.trigger('error');\n                return;\n            } // Content steering manifests can be encoded as a data URI. We can decode, parse and return early if that's the case.\n\n            if (steeringUri.startsWith('data:')) {\n                this.decodeDataUriManifest_(steeringUri.substring(steeringUri.indexOf(',') + 1));\n                return;\n            } // reloadUri is the resolution of the main manifest URL and steering URL.\n\n            this.steeringManifest.reloadUri = resolveUrl(baseUrl, steeringUri); // pathwayId is HLS defaultServiceLocation is DASH\n\n            this.defaultPathway = steeringTag.pathwayId || steeringTag.defaultServiceLocation; // currently only DASH supports the following properties on <ContentSteering> tags.\n\n            this.queryBeforeStart = steeringTag.queryBeforeStart;\n            this.proxyServerUrl_ = steeringTag.proxyServerURL; // trigger a steering event if we have a pathway from the content steering tag.\n            // this tells VHS which segment pathway to start with.\n            // If queryBeforeStart is true we need to wait for the steering manifest response.\n\n            if (this.defaultPathway && !this.queryBeforeStart) {\n                this.trigger('content-steering');\n            }\n        }\n        /**\n         * Requests the content steering manifest and parse the response. This should only be called after\n         * assignTagProperties was called with a content steering tag.\n         *\n         * @param {string} initialUri The optional uri to make the request with.\n         *    If set, the request should be made with exactly what is passed in this variable.\n         *    This scenario should only happen once on initalization.\n         */\n\n        requestSteeringManifest(initial) {\n            const reloadUri = this.steeringManifest.reloadUri;\n            if (!reloadUri) {\n                return;\n            } // We currently don't support passing MPD query parameters directly to the content steering URL as this requires\n            // ExtUrlQueryInfo tag support. See the DASH content steering spec section 8.1.\n            // This request URI accounts for manifest URIs that have been excluded.\n\n            const uri = initial ? reloadUri : this.getRequestURI(reloadUri); // If there are no valid manifest URIs, we should stop content steering.\n\n            if (!uri) {\n                this.logger_('No valid content steering manifest URIs. Stopping content steering.');\n                this.trigger('error');\n                this.dispose();\n                return;\n            }\n            this.request_ = this.xhr_({\n                uri\n            }, (error, errorInfo) => {\n                if (error) {\n                    // If the client receives HTTP 410 Gone in response to a manifest request,\n                    // it MUST NOT issue another request for that URI for the remainder of the\n                    // playback session. It MAY continue to use the most-recently obtained set\n                    // of Pathways.\n                    if (errorInfo.status === 410) {\n                        this.logger_(`manifest request 410 ${error}.`);\n                        this.logger_(`There will be no more content steering requests to ${uri} this session.`);\n                        this.excludedSteeringManifestURLs.add(uri);\n                        return;\n                    } // If the client receives HTTP 429 Too Many Requests with a Retry-After\n                    // header in response to a manifest request, it SHOULD wait until the time\n                    // specified by the Retry-After header to reissue the request.\n\n                    if (errorInfo.status === 429) {\n                        const retrySeconds = errorInfo.responseHeaders['retry-after'];\n                        this.logger_(`manifest request 429 ${error}.`);\n                        this.logger_(`content steering will retry in ${retrySeconds} seconds.`);\n                        this.startTTLTimeout_(parseInt(retrySeconds, 10));\n                        return;\n                    } // If the Steering Manifest cannot be loaded and parsed correctly, the\n                    // client SHOULD continue to use the previous values and attempt to reload\n                    // it after waiting for the previously-specified TTL (or 5 minutes if\n                    // none).\n\n                    this.logger_(`manifest failed to load ${error}.`);\n                    this.startTTLTimeout_();\n                    return;\n                }\n                const steeringManifestJson = JSON.parse(this.request_.responseText);\n                this.assignSteeringProperties_(steeringManifestJson);\n                this.startTTLTimeout_();\n            });\n        }\n        /**\n         * Set the proxy server URL and add the steering manifest url as a URI encoded parameter.\n         *\n         * @param {string} steeringUrl the steering manifest url\n         * @return the steering manifest url to a proxy server with all parameters set\n         */\n\n        setProxyServerUrl_(steeringUrl) {\n            const steeringUrlObject = new window.URL(steeringUrl);\n            const proxyServerUrlObject = new window.URL(this.proxyServerUrl_);\n            proxyServerUrlObject.searchParams.set('url', encodeURI(steeringUrlObject.toString()));\n            return this.setSteeringParams_(proxyServerUrlObject.toString());\n        }\n        /**\n         * Decodes and parses the data uri encoded steering manifest\n         *\n         * @param {string} dataUri the data uri to be decoded and parsed.\n         */\n\n        decodeDataUriManifest_(dataUri) {\n            const steeringManifestJson = JSON.parse(window.atob(dataUri));\n            this.assignSteeringProperties_(steeringManifestJson);\n        }\n        /**\n         * Set the HLS or DASH content steering manifest request query parameters. For example:\n         * _HLS_pathway=\"<CURRENT-PATHWAY-ID>\" and _HLS_throughput=<THROUGHPUT>\n         * _DASH_pathway and _DASH_throughput\n         *\n         * @param {string} uri to add content steering server parameters to.\n         * @return a new uri as a string with the added steering query parameters.\n         */\n\n        setSteeringParams_(url) {\n            const urlObject = new window.URL(url);\n            const path = this.getPathway();\n            const networkThroughput = this.getBandwidth_();\n            if (path) {\n                const pathwayKey = `_${this.manifestType_}_pathway`;\n                urlObject.searchParams.set(pathwayKey, path);\n            }\n            if (networkThroughput) {\n                const throughputKey = `_${this.manifestType_}_throughput`;\n                urlObject.searchParams.set(throughputKey, networkThroughput);\n            }\n            return urlObject.toString();\n        }\n        /**\n         * Assigns the current steering manifest properties and to the SteeringManifest object\n         *\n         * @param {Object} steeringJson the raw JSON steering manifest\n         */\n\n        assignSteeringProperties_(steeringJson) {\n            this.steeringManifest.version = steeringJson.VERSION;\n            if (!this.steeringManifest.version) {\n                this.logger_(`manifest version is ${steeringJson.VERSION}, which is not supported.`);\n                this.trigger('error');\n                return;\n            }\n            this.steeringManifest.ttl = steeringJson.TTL;\n            this.steeringManifest.reloadUri = steeringJson['RELOAD-URI']; // HLS = PATHWAY-PRIORITY required. DASH = SERVICE-LOCATION-PRIORITY optional\n\n            this.steeringManifest.priority = steeringJson['PATHWAY-PRIORITY'] || steeringJson['SERVICE-LOCATION-PRIORITY']; // Pathway clones to be created/updated in HLS.\n            // See section 7.2 https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/\n\n            this.steeringManifest.pathwayClones = steeringJson['PATHWAY-CLONES'];\n            this.nextPathwayClones = this.steeringManifest.pathwayClones; // 1. apply first pathway from the array.\n            // 2. if first pathway doesn't exist in manifest, try next pathway.\n            //    a. if all pathways are exhausted, ignore the steering manifest priority.\n            // 3. if segments fail from an established pathway, try all variants/renditions, then exclude the failed pathway.\n            //    a. exclude a pathway for a minimum of the last TTL duration. Meaning, from the next steering response,\n            //       the excluded pathway will be ignored.\n            //       See excludePathway usage in excludePlaylist().\n            // If there are no available pathways, we need to stop content steering.\n\n            if (!this.availablePathways_.size) {\n                this.logger_('There are no available pathways for content steering. Ending content steering.');\n                this.trigger('error');\n                this.dispose();\n            }\n            const chooseNextPathway = pathwaysByPriority => {\n                for (const path of pathwaysByPriority) {\n                    if (this.availablePathways_.has(path)) {\n                        return path;\n                    }\n                } // If no pathway matches, ignore the manifest and choose the first available.\n\n                return [...this.availablePathways_][0];\n            };\n            const nextPathway = chooseNextPathway(this.steeringManifest.priority);\n            if (this.currentPathway !== nextPathway) {\n                this.currentPathway = nextPathway;\n                this.trigger('content-steering');\n            }\n        }\n        /**\n         * Returns the pathway to use for steering decisions\n         *\n         * @return {string} returns the current pathway or the default\n         */\n\n        getPathway() {\n            return this.currentPathway || this.defaultPathway;\n        }\n        /**\n         * Chooses the manifest request URI based on proxy URIs and server URLs.\n         * Also accounts for exclusion on certain manifest URIs.\n         *\n         * @param {string} reloadUri the base uri before parameters\n         *\n         * @return {string} the final URI for the request to the manifest server.\n         */\n\n        getRequestURI(reloadUri) {\n            if (!reloadUri) {\n                return null;\n            }\n            const isExcluded = uri => this.excludedSteeringManifestURLs.has(uri);\n            if (this.proxyServerUrl_) {\n                const proxyURI = this.setProxyServerUrl_(reloadUri);\n                if (!isExcluded(proxyURI)) {\n                    return proxyURI;\n                }\n            }\n            const steeringURI = this.setSteeringParams_(reloadUri);\n            if (!isExcluded(steeringURI)) {\n                return steeringURI;\n            } // Return nothing if all valid manifest URIs are excluded.\n\n            return null;\n        }\n        /**\n         * Start the timeout for re-requesting the steering manifest at the TTL interval.\n         *\n         * @param {number} ttl time in seconds of the timeout. Defaults to the\n         *        ttl interval in the steering manifest\n         */\n\n        startTTLTimeout_(ttl = this.steeringManifest.ttl) {\n            // 300 (5 minutes) is the default value.\n            const ttlMS = ttl * 1000;\n            this.ttlTimeout_ = window.setTimeout(() => {\n                this.requestSteeringManifest();\n            }, ttlMS);\n        }\n        /**\n         * Clear the TTL timeout if necessary.\n         */\n\n        clearTTLTimeout_() {\n            window.clearTimeout(this.ttlTimeout_);\n            this.ttlTimeout_ = null;\n        }\n        /**\n         * aborts any current steering xhr and sets the current request object to null\n         */\n\n        abort() {\n            if (this.request_) {\n                this.request_.abort();\n            }\n            this.request_ = null;\n        }\n        /**\n         * aborts steering requests clears the ttl timeout and resets all properties.\n         */\n\n        dispose() {\n            this.off('content-steering');\n            this.off('error');\n            this.abort();\n            this.clearTTLTimeout_();\n            this.currentPathway = null;\n            this.defaultPathway = null;\n            this.queryBeforeStart = null;\n            this.proxyServerUrl_ = null;\n            this.manifestType_ = null;\n            this.ttlTimeout_ = null;\n            this.request_ = null;\n            this.excludedSteeringManifestURLs = new Set();\n            this.availablePathways_ = new Set();\n            this.steeringManifest = new SteeringManifest();\n        }\n        /**\n         * adds a pathway to the available pathways set\n         *\n         * @param {string} pathway the pathway string to add\n         */\n\n        addAvailablePathway(pathway) {\n            if (pathway) {\n                this.availablePathways_.add(pathway);\n            }\n        }\n        /**\n         * Clears all pathways from the available pathways set\n         */\n\n        clearAvailablePathways() {\n            this.availablePathways_.clear();\n        }\n        /**\n         * Removes a pathway from the available pathways set.\n         */\n\n        excludePathway(pathway) {\n            return this.availablePathways_.delete(pathway);\n        }\n        /**\n         * Checks the refreshed DASH manifest content steering tag for changes.\n         *\n         * @param {string} baseURL new steering tag on DASH manifest refresh\n         * @param {Object} newTag the new tag to check for changes\n         * @return a true or false whether the new tag has different values\n         */\n\n        didDASHTagChange(baseURL, newTag) {\n            return !newTag && this.steeringManifest.reloadUri || newTag && (resolveUrl(baseURL, newTag.serverURL) !== this.steeringManifest.reloadUri || newTag.defaultServiceLocation !== this.defaultPathway || newTag.queryBeforeStart !== this.queryBeforeStart || newTag.proxyServerURL !== this.proxyServerUrl_);\n        }\n        getAvailablePathways() {\n            return this.availablePathways_;\n        }\n    }\n\n    /**\n     * @file playlist-controller.js\n     */\n    const ABORT_EARLY_EXCLUSION_SECONDS = 10;\n    let Vhs$1; // SegmentLoader stats that need to have each loader's\n    // values summed to calculate the final value\n\n    const loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred', 'mediaAppends'];\n    const sumLoaderStat = function (stat) {\n        return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n    };\n    const shouldSwitchToMedia = function ({\n                                              currentPlaylist,\n                                              buffered,\n                                              currentTime,\n                                              nextPlaylist,\n                                              bufferLowWaterLine,\n                                              bufferHighWaterLine,\n                                              duration,\n                                              bufferBasedABR,\n                                              log\n                                          }) {\n        // we have no other playlist to switch to\n        if (!nextPlaylist) {\n            videojs.log.warn('We received no playlist to switch to. Please check your stream.');\n            return false;\n        }\n        const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || 'null'} -> ${nextPlaylist.id}`;\n        if (!currentPlaylist) {\n            log(`${sharedLogLine} as current playlist is not set`);\n            return true;\n        } // no need to switch if playlist is the same\n\n        if (nextPlaylist.id === currentPlaylist.id) {\n            return false;\n        } // determine if current time is in a buffered range.\n\n        const isBuffered = Boolean(findRange(buffered, currentTime).length); // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n\n        if (!currentPlaylist.endList) {\n            // For LLHLS live streams, don't switch renditions before playback has started, as it almost\n            // doubles the time to first playback.\n            if (!isBuffered && typeof currentPlaylist.partTargetDuration === 'number') {\n                log(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);\n                return false;\n            }\n            log(`${sharedLogLine} as current playlist is live`);\n            return true;\n        }\n        const forwardBuffer = timeAheadOf(buffered, currentTime);\n        const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE; // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n\n        if (duration < maxBufferLowWaterLine) {\n            log(`${sharedLogLine} as duration < max low water line (${duration} < ${maxBufferLowWaterLine})`);\n            return true;\n        }\n        const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;\n        const currBandwidth = currentPlaylist.attributes.BANDWIDTH; // when switching down, if our buffer is lower than the high water line,\n        // we can switch down\n\n        if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {\n            let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;\n            if (bufferBasedABR) {\n                logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;\n            }\n            log(logLine);\n            return true;\n        } // and if our buffer is higher than the low water line,\n        // we can switch up\n\n        if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {\n            let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;\n            if (bufferBasedABR) {\n                logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;\n            }\n            log(logLine);\n            return true;\n        }\n        log(`not ${sharedLogLine} as no switching criteria met`);\n        return false;\n    };\n    /**\n     * the main playlist controller controller all interactons\n     * between playlists and segmentloaders. At this time this mainly\n     * involves a main playlist and a series of audio playlists\n     * if they are available\n     *\n     * @class PlaylistController\n     * @extends videojs.EventTarget\n     */\n\n    class PlaylistController extends videojs.EventTarget {\n        constructor(options) {\n            super();\n            const {\n                src,\n                withCredentials,\n                tech,\n                bandwidth,\n                externVhs,\n                useCueTags,\n                playlistExclusionDuration,\n                enableLowInitialPlaylist,\n                sourceType,\n                cacheEncryptionKeys,\n                bufferBasedABR,\n                leastPixelDiffSelector,\n                captionServices\n            } = options;\n            if (!src) {\n                throw new Error('A non-empty playlist URL or JSON manifest string is required');\n            }\n            let {\n                maxPlaylistRetries\n            } = options;\n            if (maxPlaylistRetries === null || typeof maxPlaylistRetries === 'undefined') {\n                maxPlaylistRetries = Infinity;\n            }\n            Vhs$1 = externVhs;\n            this.bufferBasedABR = Boolean(bufferBasedABR);\n            this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);\n            this.withCredentials = withCredentials;\n            this.tech_ = tech;\n            this.vhs_ = tech.vhs;\n            this.sourceType_ = sourceType;\n            this.useCueTags_ = useCueTags;\n            this.playlistExclusionDuration = playlistExclusionDuration;\n            this.maxPlaylistRetries = maxPlaylistRetries;\n            this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n            if (this.useCueTags_) {\n                this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n                this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n            }\n            this.requestOptions_ = {\n                withCredentials,\n                maxPlaylistRetries,\n                timeout: null\n            };\n            this.on('error', this.pauseLoading);\n            this.mediaTypes_ = createMediaTypes();\n            this.mediaSource = new window.MediaSource();\n            this.handleDurationChange_ = this.handleDurationChange_.bind(this);\n            this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);\n            this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);\n            this.mediaSource.addEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n            this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_);\n            this.mediaSource.addEventListener('sourceended', this.handleSourceEnded_); // we don't have to handle sourceclose since dispose will handle termination of\n            // everything, and the MediaSource should not be detached without a proper disposal\n\n            this.seekable_ = createTimeRanges();\n            this.hasPlayed_ = false;\n            this.syncController_ = new SyncController(options);\n            this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n                kind: 'metadata',\n                label: 'segment-metadata'\n            }, false).track;\n            this.decrypter_ = new Decrypter();\n            this.sourceUpdater_ = new SourceUpdater(this.mediaSource);\n            this.inbandTextTracks_ = {};\n            this.timelineChangeController_ = new TimelineChangeController();\n            this.keyStatusMap_ = new Map();\n            const segmentLoaderSettings = {\n                vhs: this.vhs_,\n                parse708captions: options.parse708captions,\n                useDtsForTimestampOffset: options.useDtsForTimestampOffset,\n                captionServices,\n                mediaSource: this.mediaSource,\n                currentTime: this.tech_.currentTime.bind(this.tech_),\n                seekable: () => this.seekable(),\n                seeking: () => this.tech_.seeking(),\n                duration: () => this.duration(),\n                hasPlayed: () => this.hasPlayed_,\n                goalBufferLength: () => this.goalBufferLength(),\n                bandwidth,\n                syncController: this.syncController_,\n                decrypter: this.decrypter_,\n                sourceType: this.sourceType_,\n                inbandTextTracks: this.inbandTextTracks_,\n                cacheEncryptionKeys,\n                sourceUpdater: this.sourceUpdater_,\n                timelineChangeController: this.timelineChangeController_,\n                exactManifestTimings: options.exactManifestTimings,\n                addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)\n            }; // The source type check not only determines whether a special DASH playlist loader\n            // should be used, but also covers the case where the provided src is a vhs-json\n            // manifest object (instead of a URL). In the case of vhs-json, the default\n            // PlaylistLoader should be used.\n\n            this.mainPlaylistLoader_ = this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {\n                addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)\n            })) : new PlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {\n                addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)\n            }));\n            this.setupMainPlaylistLoaderListeners_(); // setup segment loaders\n            // combined audio/video or just video when alternate audio track is selected\n\n            this.mainSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n                segmentMetadataTrack: this.segmentMetadataTrack_,\n                loaderType: 'main'\n            }), options); // alternate audio track\n\n            this.audioSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n                loaderType: 'audio'\n            }), options);\n            this.subtitleSegmentLoader_ = new VTTSegmentLoader(merge(segmentLoaderSettings, {\n                loaderType: 'vtt',\n                featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,\n                loadVttJs: () => new Promise((resolve, reject) => {\n                    function onLoad() {\n                        tech.off('vttjserror', onError);\n                        resolve();\n                    }\n                    function onError() {\n                        tech.off('vttjsloaded', onLoad);\n                        reject();\n                    }\n                    tech.one('vttjsloaded', onLoad);\n                    tech.one('vttjserror', onError); // safe to call multiple times, script will be loaded only once:\n\n                    tech.addWebVttScript_();\n                })\n            }), options);\n            const getBandwidth = () => {\n                return this.mainSegmentLoader_.bandwidth;\n            };\n            this.contentSteeringController_ = new ContentSteeringController(this.vhs_.xhr, getBandwidth);\n            this.setupSegmentLoaderListeners_();\n            if (this.bufferBasedABR) {\n                this.mainPlaylistLoader_.one('loadedplaylist', () => this.startABRTimer_());\n                this.tech_.on('pause', () => this.stopABRTimer_());\n                this.tech_.on('play', () => this.startABRTimer_());\n            } // Create SegmentLoader stat-getters\n            // mediaRequests_\n            // mediaRequestsAborted_\n            // mediaRequestsTimedout_\n            // mediaRequestsErrored_\n            // mediaTransferDuration_\n            // mediaBytesTransferred_\n            // mediaAppends_\n\n            loaderStats.forEach(stat => {\n                this[stat + '_'] = sumLoaderStat.bind(this, stat);\n            });\n            this.logger_ = logger('pc');\n            this.triggeredFmp4Usage = false;\n            if (this.tech_.preload() === 'none') {\n                this.loadOnPlay_ = () => {\n                    this.loadOnPlay_ = null;\n                    this.mainPlaylistLoader_.load();\n                };\n                this.tech_.one('play', this.loadOnPlay_);\n            } else {\n                this.mainPlaylistLoader_.load();\n            }\n            this.timeToLoadedData__ = -1;\n            this.mainAppendsToLoadedData__ = -1;\n            this.audioAppendsToLoadedData__ = -1;\n            const event = this.tech_.preload() === 'none' ? 'play' : 'loadstart'; // start the first frame timer on loadstart or play (for preload none)\n\n            this.tech_.one(event, () => {\n                const timeToLoadedDataStart = Date.now();\n                this.tech_.one('loadeddata', () => {\n                    this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;\n                    this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;\n                    this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;\n                });\n            });\n        }\n        mainAppendsToLoadedData_() {\n            return this.mainAppendsToLoadedData__;\n        }\n        audioAppendsToLoadedData_() {\n            return this.audioAppendsToLoadedData__;\n        }\n        appendsToLoadedData_() {\n            const main = this.mainAppendsToLoadedData_();\n            const audio = this.audioAppendsToLoadedData_();\n            if (main === -1 || audio === -1) {\n                return -1;\n            }\n            return main + audio;\n        }\n        timeToLoadedData_() {\n            return this.timeToLoadedData__;\n        }\n        /**\n         * Run selectPlaylist and switch to the new playlist if we should\n         *\n         * @param {string} [reason=abr] a reason for why the ABR check is made\n         * @private\n         */\n\n        checkABR_(reason = 'abr') {\n            const nextPlaylist = this.selectPlaylist();\n            if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {\n                this.switchMedia_(nextPlaylist, reason);\n            }\n        }\n        switchMedia_(playlist, cause, delay) {\n            const oldMedia = this.media();\n            const oldId = oldMedia && (oldMedia.id || oldMedia.uri);\n            const newId = playlist && (playlist.id || playlist.uri);\n            if (oldId && oldId !== newId) {\n                this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: `vhs-rendition-change-${cause}`\n                });\n            }\n            this.mainPlaylistLoader_.media(playlist, delay);\n        }\n        /**\n         * A function that ensures we switch our playlists inside of `mediaTypes`\n         * to match the current `serviceLocation` provided by the contentSteering controller.\n         * We want to check media types of `AUDIO`, `SUBTITLES`, and `CLOSED-CAPTIONS`.\n         *\n         * This should only be called on a DASH playback scenario while using content steering.\n         * This is necessary due to differences in how media in HLS manifests are generally tied to\n         * a video playlist, where in DASH that is not always the case.\n         */\n\n        switchMediaForDASHContentSteering_() {\n            ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n                const mediaType = this.mediaTypes_[type];\n                const activeGroup = mediaType ? mediaType.activeGroup() : null;\n                const pathway = this.contentSteeringController_.getPathway();\n                if (activeGroup && pathway) {\n                    // activeGroup can be an array or a single group\n                    const mediaPlaylists = activeGroup.length ? activeGroup[0].playlists : activeGroup.playlists;\n                    const dashMediaPlaylists = mediaPlaylists.filter(p => p.attributes.serviceLocation === pathway); // Switch the current active playlist to the correct CDN\n\n                    if (dashMediaPlaylists.length) {\n                        this.mediaTypes_[type].activePlaylistLoader.media(dashMediaPlaylists[0]);\n                    }\n                }\n            });\n        }\n        /**\n         * Start a timer that periodically calls checkABR_\n         *\n         * @private\n         */\n\n        startABRTimer_() {\n            this.stopABRTimer_();\n            this.abrTimer_ = window.setInterval(() => this.checkABR_(), 250);\n        }\n        /**\n         * Stop the timer that periodically calls checkABR_\n         *\n         * @private\n         */\n\n        stopABRTimer_() {\n            // if we're scrubbing, we don't need to pause.\n            // This getter will be added to Video.js in version 7.11.\n            if (this.tech_.scrubbing && this.tech_.scrubbing()) {\n                return;\n            }\n            window.clearInterval(this.abrTimer_);\n            this.abrTimer_ = null;\n        }\n        /**\n         * Get a list of playlists for the currently selected audio playlist\n         *\n         * @return {Array} the array of audio playlists\n         */\n\n        getAudioTrackPlaylists_() {\n            const main = this.main();\n            const defaultPlaylists = main && main.playlists || []; // if we don't have any audio groups then we can only\n            // assume that the audio tracks are contained in main\n            // playlist array, use that or an empty array.\n\n            if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) {\n                return defaultPlaylists;\n            }\n            const AUDIO = main.mediaGroups.AUDIO;\n            const groupKeys = Object.keys(AUDIO);\n            let track; // get the current active track\n\n            if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {\n                track = this.mediaTypes_.AUDIO.activeTrack(); // or get the default track from main if mediaTypes_ isn't setup yet\n            } else {\n                // default group is `main` or just the first group.\n                const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];\n                for (const label in defaultGroup) {\n                    if (defaultGroup[label].default) {\n                        track = {\n                            label\n                        };\n                        break;\n                    }\n                }\n            } // no active track no playlists.\n\n            if (!track) {\n                return defaultPlaylists;\n            }\n            const playlists = []; // get all of the playlists that are possible for the\n            // active track.\n\n            for (const group in AUDIO) {\n                if (AUDIO[group][track.label]) {\n                    const properties = AUDIO[group][track.label];\n                    if (properties.playlists && properties.playlists.length) {\n                        playlists.push.apply(playlists, properties.playlists);\n                    } else if (properties.uri) {\n                        playlists.push(properties);\n                    } else if (main.playlists.length) {\n                        // if an audio group does not have a uri\n                        // see if we have main playlists that use it as a group.\n                        // if we do then add those to the playlists list.\n                        for (let i = 0; i < main.playlists.length; i++) {\n                            const playlist = main.playlists[i];\n                            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {\n                                playlists.push(playlist);\n                            }\n                        }\n                    }\n                }\n            }\n            if (!playlists.length) {\n                return defaultPlaylists;\n            }\n            return playlists;\n        }\n        /**\n         * Register event handlers on the main playlist loader. A helper\n         * function for construction time.\n         *\n         * @private\n         */\n\n        setupMainPlaylistLoaderListeners_() {\n            this.mainPlaylistLoader_.on('loadedmetadata', () => {\n                const media = this.mainPlaylistLoader_.media();\n                const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n                // timeout the request.\n\n                if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n                    this.requestOptions_.timeout = 0;\n                } else {\n                    this.requestOptions_.timeout = requestTimeout;\n                } // if this isn't a live video and preload permits, start\n                // downloading segments\n\n                if (media.endList && this.tech_.preload() !== 'none') {\n                    this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n                    this.mainSegmentLoader_.load();\n                }\n                setupMediaGroups({\n                    sourceType: this.sourceType_,\n                    segmentLoaders: {\n                        AUDIO: this.audioSegmentLoader_,\n                        SUBTITLES: this.subtitleSegmentLoader_,\n                        main: this.mainSegmentLoader_\n                    },\n                    tech: this.tech_,\n                    requestOptions: this.requestOptions_,\n                    mainPlaylistLoader: this.mainPlaylistLoader_,\n                    vhs: this.vhs_,\n                    main: this.main(),\n                    mediaTypes: this.mediaTypes_,\n                    excludePlaylist: this.excludePlaylist.bind(this)\n                });\n                this.triggerPresenceUsage_(this.main(), media);\n                this.setupFirstPlay();\n                if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) {\n                    this.trigger('selectedinitialmedia');\n                } else {\n                    // We must wait for the active audio playlist loader to\n                    // finish setting up before triggering this event so the\n                    // representations API and EME setup is correct\n                    this.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', () => {\n                        this.trigger('selectedinitialmedia');\n                    });\n                }\n            });\n            this.mainPlaylistLoader_.on('loadedplaylist', () => {\n                if (this.loadOnPlay_) {\n                    this.tech_.off('play', this.loadOnPlay_);\n                }\n                let updatedPlaylist = this.mainPlaylistLoader_.media();\n                if (!updatedPlaylist) {\n                    // Add content steering listeners on first load and init.\n                    this.attachContentSteeringListeners_();\n                    this.initContentSteeringController_(); // exclude any variants that are not supported by the browser before selecting\n                    // an initial media as the playlist selectors do not consider browser support\n\n                    this.excludeUnsupportedVariants_();\n                    let selectedMedia;\n                    if (this.enableLowInitialPlaylist) {\n                        selectedMedia = this.selectInitialPlaylist();\n                    }\n                    if (!selectedMedia) {\n                        selectedMedia = this.selectPlaylist();\n                    }\n                    if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) {\n                        return;\n                    }\n                    this.initialMedia_ = selectedMedia;\n                    this.switchMedia_(this.initialMedia_, 'initial'); // Under the standard case where a source URL is provided, loadedplaylist will\n                    // fire again since the playlist will be requested. In the case of vhs-json\n                    // (where the manifest object is provided as the source), when the media\n                    // playlist's `segments` list is already available, a media playlist won't be\n                    // requested, and loadedplaylist won't fire again, so the playlist handler must be\n                    // called on its own here.\n\n                    const haveJsonSource = this.sourceType_ === 'vhs-json' && this.initialMedia_.segments;\n                    if (!haveJsonSource) {\n                        return;\n                    }\n                    updatedPlaylist = this.initialMedia_;\n                }\n                this.handleUpdatedMediaPlaylist(updatedPlaylist);\n            });\n            this.mainPlaylistLoader_.on('error', () => {\n                const error = this.mainPlaylistLoader_.error;\n                this.excludePlaylist({\n                    playlistToExclude: error.playlist,\n                    error\n                });\n            });\n            this.mainPlaylistLoader_.on('mediachanging', () => {\n                this.mainSegmentLoader_.abort();\n                this.mainSegmentLoader_.pause();\n            });\n            this.mainPlaylistLoader_.on('mediachange', () => {\n                const media = this.mainPlaylistLoader_.media();\n                const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n                // timeout the request.\n\n                if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n                    this.requestOptions_.timeout = 0;\n                } else {\n                    this.requestOptions_.timeout = requestTimeout;\n                }\n                if (this.sourceType_ === 'dash') {\n                    // we don't want to re-request the same hls playlist right after it was changed\n                    this.mainPlaylistLoader_.load();\n                } // TODO: Create a new event on the PlaylistLoader that signals\n                // that the segments have changed in some way and use that to\n                // update the SegmentLoader instead of doing it twice here and\n                // on `loadedplaylist`\n\n                this.mainSegmentLoader_.pause();\n                this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n                if (this.waitingForFastQualityPlaylistReceived_) {\n                    this.runFastQualitySwitch_();\n                } else {\n                    this.mainSegmentLoader_.load();\n                }\n                this.tech_.trigger({\n                    type: 'mediachange',\n                    bubbles: true\n                });\n            });\n            this.mainPlaylistLoader_.on('playlistunchanged', () => {\n                const updatedPlaylist = this.mainPlaylistLoader_.media(); // ignore unchanged playlists that have already been\n                // excluded for not-changing. We likely just have a really slowly updating\n                // playlist.\n\n                if (updatedPlaylist.lastExcludeReason_ === 'playlist-unchanged') {\n                    return;\n                }\n                const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);\n                if (playlistOutdated) {\n                    // Playlist has stopped updating and we're stuck at its end. Try to\n                    // exclude it and switch to another playlist in the hope that that\n                    // one is updating (and give the player a chance to re-adjust to the\n                    // safe live point).\n                    this.excludePlaylist({\n                        error: {\n                            message: 'Playlist no longer updating.',\n                            reason: 'playlist-unchanged'\n                        }\n                    }); // useful for monitoring QoS\n\n                    this.tech_.trigger('playliststuck');\n                }\n            });\n            this.mainPlaylistLoader_.on('renditiondisabled', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-rendition-disabled'\n                });\n            });\n            this.mainPlaylistLoader_.on('renditionenabled', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-rendition-enabled'\n                });\n            });\n        }\n        /**\n         * Given an updated media playlist (whether it was loaded for the first time, or\n         * refreshed for live playlists), update any relevant properties and state to reflect\n         * changes in the media that should be accounted for (e.g., cues and duration).\n         *\n         * @param {Object} updatedPlaylist the updated media playlist object\n         *\n         * @private\n         */\n\n        handleUpdatedMediaPlaylist(updatedPlaylist) {\n            if (this.useCueTags_) {\n                this.updateAdCues_(updatedPlaylist);\n            } // TODO: Create a new event on the PlaylistLoader that signals\n            // that the segments have changed in some way and use that to\n            // update the SegmentLoader instead of doing it twice here and\n            // on `mediachange`\n\n            this.mainSegmentLoader_.pause();\n            this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);\n            if (this.waitingForFastQualityPlaylistReceived_) {\n                this.runFastQualitySwitch_();\n            }\n            this.updateDuration(!updatedPlaylist.endList); // If the player isn't paused, ensure that the segment loader is running,\n            // as it is possible that it was temporarily stopped while waiting for\n            // a playlist (e.g., in case the playlist errored and we re-requested it).\n\n            if (!this.tech_.paused()) {\n                this.mainSegmentLoader_.load();\n                if (this.audioSegmentLoader_) {\n                    this.audioSegmentLoader_.load();\n                }\n            }\n        }\n        /**\n         * A helper function for triggerring presence usage events once per source\n         *\n         * @private\n         */\n\n        triggerPresenceUsage_(main, media) {\n            const mediaGroups = main.mediaGroups || {};\n            let defaultDemuxed = true;\n            const audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n            for (const mediaGroup in mediaGroups.AUDIO) {\n                for (const label in mediaGroups.AUDIO[mediaGroup]) {\n                    const properties = mediaGroups.AUDIO[mediaGroup][label];\n                    if (!properties.uri) {\n                        defaultDemuxed = false;\n                    }\n                }\n            }\n            if (defaultDemuxed) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-demuxed'\n                });\n            }\n            if (Object.keys(mediaGroups.SUBTITLES).length) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-webvtt'\n                });\n            }\n            if (Vhs$1.Playlist.isAes(media)) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-aes'\n                });\n            }\n            if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-alternate-audio'\n                });\n            }\n            if (this.useCueTags_) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-playlist-cue-tags'\n                });\n            }\n        }\n        shouldSwitchToMedia_(nextPlaylist) {\n            const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;\n            const currentTime = this.tech_.currentTime();\n            const bufferLowWaterLine = this.bufferLowWaterLine();\n            const bufferHighWaterLine = this.bufferHighWaterLine();\n            const buffered = this.tech_.buffered();\n            return shouldSwitchToMedia({\n                buffered,\n                currentTime,\n                currentPlaylist,\n                nextPlaylist,\n                bufferLowWaterLine,\n                bufferHighWaterLine,\n                duration: this.duration(),\n                bufferBasedABR: this.bufferBasedABR,\n                log: this.logger_\n            });\n        }\n        /**\n         * Register event handlers on the segment loaders. A helper function\n         * for construction time.\n         *\n         * @private\n         */\n\n        setupSegmentLoaderListeners_() {\n            this.mainSegmentLoader_.on('bandwidthupdate', () => {\n                // Whether or not buffer based ABR or another ABR is used, on a bandwidth change it's\n                // useful to check to see if a rendition switch should be made.\n                this.checkABR_('bandwidthupdate');\n                this.tech_.trigger('bandwidthupdate');\n            });\n            this.mainSegmentLoader_.on('timeout', () => {\n                if (this.bufferBasedABR) {\n                    // If a rendition change is needed, then it would've be done on `bandwidthupdate`.\n                    // Here the only consideration is that for buffer based ABR there's no guarantee\n                    // of an immediate switch (since the bandwidth is averaged with a timeout\n                    // bandwidth value of 1), so force a load on the segment loader to keep it going.\n                    this.mainSegmentLoader_.load();\n                }\n            }); // `progress` events are not reliable enough of a bandwidth measure to trigger buffer\n            // based ABR.\n\n            if (!this.bufferBasedABR) {\n                this.mainSegmentLoader_.on('progress', () => {\n                    this.trigger('progress');\n                });\n            }\n            this.mainSegmentLoader_.on('error', () => {\n                const error = this.mainSegmentLoader_.error();\n                this.excludePlaylist({\n                    playlistToExclude: error.playlist,\n                    error\n                });\n            });\n            this.mainSegmentLoader_.on('appenderror', () => {\n                this.error = this.mainSegmentLoader_.error_;\n                this.trigger('error');\n            });\n            this.mainSegmentLoader_.on('syncinfoupdate', () => {\n                this.onSyncInfoUpdate_();\n            });\n            this.mainSegmentLoader_.on('timestampoffset', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-timestamp-offset'\n                });\n            });\n            this.audioSegmentLoader_.on('syncinfoupdate', () => {\n                this.onSyncInfoUpdate_();\n            });\n            this.audioSegmentLoader_.on('appenderror', () => {\n                this.error = this.audioSegmentLoader_.error_;\n                this.trigger('error');\n            });\n            this.mainSegmentLoader_.on('ended', () => {\n                this.logger_('main segment loader ended');\n                this.onEndOfStream();\n            });\n            this.mainSegmentLoader_.on('earlyabort', event => {\n                // never try to early abort with the new ABR algorithm\n                if (this.bufferBasedABR) {\n                    return;\n                }\n                this.delegateLoaders_('all', ['abort']);\n                this.excludePlaylist({\n                    error: {\n                        message: 'Aborted early because there isn\\'t enough bandwidth to complete ' + 'the request without rebuffering.'\n                    },\n                    playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS\n                });\n            });\n            const updateCodecs = () => {\n                if (!this.sourceUpdater_.hasCreatedSourceBuffers()) {\n                    return this.tryToCreateSourceBuffers_();\n                }\n                const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n                if (!codecs) {\n                    return;\n                }\n                this.sourceUpdater_.addOrChangeSourceBuffers(codecs);\n            };\n            this.mainSegmentLoader_.on('trackinfo', updateCodecs);\n            this.audioSegmentLoader_.on('trackinfo', updateCodecs);\n            this.mainSegmentLoader_.on('fmp4', () => {\n                if (!this.triggeredFmp4Usage) {\n                    this.tech_.trigger({\n                        type: 'usage',\n                        name: 'vhs-fmp4'\n                    });\n                    this.triggeredFmp4Usage = true;\n                }\n            });\n            this.audioSegmentLoader_.on('fmp4', () => {\n                if (!this.triggeredFmp4Usage) {\n                    this.tech_.trigger({\n                        type: 'usage',\n                        name: 'vhs-fmp4'\n                    });\n                    this.triggeredFmp4Usage = true;\n                }\n            });\n            this.audioSegmentLoader_.on('ended', () => {\n                this.logger_('audioSegmentLoader ended');\n                this.onEndOfStream();\n            });\n        }\n        mediaSecondsLoaded_() {\n            return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n        }\n        /**\n         * Call load on our SegmentLoaders\n         */\n\n        load() {\n            this.mainSegmentLoader_.load();\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                this.audioSegmentLoader_.load();\n            }\n            if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n                this.subtitleSegmentLoader_.load();\n            }\n        }\n        /**\n         * Re-tune playback quality level for the current player\n         * conditions. This method will perform destructive actions like removing\n         * already buffered content in order to readjust the currently active\n         * playlist quickly. This is good for manual quality changes\n         *\n         * @private\n         */\n\n        fastQualityChange_(media = this.selectPlaylist()) {\n            if (media && media === this.mainPlaylistLoader_.media()) {\n                this.logger_('skipping fastQualityChange because new media is same as old');\n                return;\n            }\n            this.switchMedia_(media, 'fast-quality'); // we would like to avoid race condition when we call fastQuality,\n            // reset everything and start loading segments from prev segments instead of new because new playlist is not received yet\n\n            this.waitingForFastQualityPlaylistReceived_ = true;\n        }\n        runFastQualitySwitch_() {\n            this.waitingForFastQualityPlaylistReceived_ = false; // Delete all buffered data to allow an immediate quality switch, then seek to give\n            // the browser a kick to remove any cached frames from the previous rendtion (.04 seconds\n            // ahead was roughly the minimum that will accomplish this across a variety of content\n            // in IE and Edge, but seeking in place is sufficient on all other browsers)\n            // Edge/IE bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600375/\n            // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=651904\n\n            this.mainSegmentLoader_.pause();\n            this.mainSegmentLoader_.resetEverything(() => {\n                this.tech_.setCurrentTime(this.tech_.currentTime());\n            }); // don't need to reset audio as it is reset when media changes\n        }\n        /**\n         * Begin playback.\n         */\n\n        play() {\n            if (this.setupFirstPlay()) {\n                return;\n            }\n            if (this.tech_.ended()) {\n                this.tech_.setCurrentTime(0);\n            }\n            if (this.hasPlayed_) {\n                this.load();\n            }\n            const seekable = this.tech_.seekable(); // if the viewer has paused and we fell out of the live window,\n            // seek forward to the live point\n\n            if (this.tech_.duration() === Infinity) {\n                if (this.tech_.currentTime() < seekable.start(0)) {\n                    return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n                }\n            }\n        }\n        /**\n         * Seek to the latest media position if this is a live video and the\n         * player and video are loaded and initialized.\n         */\n\n        setupFirstPlay() {\n            const media = this.mainPlaylistLoader_.media(); // Check that everything is ready to begin buffering for the first call to play\n            //  If 1) there is no active media\n            //     2) the player is paused\n            //     3) the first play has already been setup\n            // then exit early\n\n            if (!media || this.tech_.paused() || this.hasPlayed_) {\n                return false;\n            } // when the video is a live stream and/or has a start time\n\n            if (!media.endList || media.start) {\n                const seekable = this.seekable();\n                if (!seekable.length) {\n                    // without a seekable range, the player cannot seek to begin buffering at the\n                    // live or start point\n                    return false;\n                }\n                const seekableEnd = seekable.end(0);\n                let startPoint = seekableEnd;\n                if (media.start) {\n                    const offset = media.start.timeOffset;\n                    if (offset < 0) {\n                        startPoint = Math.max(seekableEnd + offset, seekable.start(0));\n                    } else {\n                        startPoint = Math.min(seekableEnd, offset);\n                    }\n                } // trigger firstplay to inform the source handler to ignore the next seek event\n\n                this.trigger('firstplay'); // seek to the live point\n\n                this.tech_.setCurrentTime(startPoint);\n            }\n            this.hasPlayed_ = true; // we can begin loading now that everything is ready\n\n            this.load();\n            return true;\n        }\n        /**\n         * handle the sourceopen event on the MediaSource\n         *\n         * @private\n         */\n\n        handleSourceOpen_() {\n            // Only attempt to create the source buffer if none already exist.\n            // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n            // after `endOfStream` has been called (in response to a seek for instance)\n            this.tryToCreateSourceBuffers_(); // if autoplay is enabled, begin playback. This is duplicative of\n            // code in video.js but is required because play() must be invoked\n            // *after* the media source has opened.\n\n            if (this.tech_.autoplay()) {\n                const playPromise = this.tech_.play(); // Catch/silence error when a pause interrupts a play request\n                // on browsers which return a promise\n\n                if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n                    playPromise.then(null, e => {});\n                }\n            }\n            this.trigger('sourceopen');\n        }\n        /**\n         * handle the sourceended event on the MediaSource\n         *\n         * @private\n         */\n\n        handleSourceEnded_() {\n            if (!this.inbandTextTracks_.metadataTrack_) {\n                return;\n            }\n            const cues = this.inbandTextTracks_.metadataTrack_.cues;\n            if (!cues || !cues.length) {\n                return;\n            }\n            const duration = this.duration();\n            cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;\n        }\n        /**\n         * handle the durationchange event on the MediaSource\n         *\n         * @private\n         */\n\n        handleDurationChange_() {\n            this.tech_.trigger('durationchange');\n        }\n        /**\n         * Calls endOfStream on the media source when all active stream types have called\n         * endOfStream\n         *\n         * @param {string} streamType\n         *        Stream type of the segment loader that called endOfStream\n         * @private\n         */\n\n        onEndOfStream() {\n            let isEndOfStream = this.mainSegmentLoader_.ended_;\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_(); // if the audio playlist loader exists, then alternate audio is active\n\n                if (!mainMediaInfo || mainMediaInfo.hasVideo) {\n                    // if we do not know if the main segment loader contains video yet or if we\n                    // definitively know the main segment loader contains video, then we need to wait\n                    // for both main and audio segment loaders to call endOfStream\n                    isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n                } else {\n                    // otherwise just rely on the audio loader\n                    isEndOfStream = this.audioSegmentLoader_.ended_;\n                }\n            }\n            if (!isEndOfStream) {\n                return;\n            }\n            this.stopABRTimer_();\n            this.sourceUpdater_.endOfStream();\n        }\n        /**\n         * Check if a playlist has stopped being updated\n         *\n         * @param {Object} playlist the media playlist object\n         * @return {boolean} whether the playlist has stopped being updated or not\n         */\n\n        stuckAtPlaylistEnd_(playlist) {\n            const seekable = this.seekable();\n            if (!seekable.length) {\n                // playlist doesn't have enough information to determine whether we are stuck\n                return false;\n            }\n            const expired = this.syncController_.getExpiredTime(playlist, this.duration());\n            if (expired === null) {\n                return false;\n            } // does not use the safe live end to calculate playlist end, since we\n            // don't want to say we are stuck while there is still content\n\n            const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            if (!buffered.length) {\n                // return true if the playhead reached the absolute end of the playlist\n                return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\n            }\n            const bufferedEnd = buffered.end(buffered.length - 1); // return true if there is too little buffer left and buffer has reached absolute\n            // end of playlist\n\n            return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\n        }\n        /**\n         * Exclude a playlist for a set amount of time, making it unavailable for selection by\n         * the rendition selection algorithm, then force a new playlist (rendition) selection.\n         *\n         * @param {Object=} playlistToExclude\n         *                  the playlist to exclude, defaults to the currently selected playlist\n         * @param {Object=} error\n         *                  an optional error\n         * @param {number=} playlistExclusionDuration\n         *                  an optional number of seconds to exclude the playlist\n         */\n\n        excludePlaylist({\n                            playlistToExclude = this.mainPlaylistLoader_.media(),\n                            error = {},\n                            playlistExclusionDuration\n                        }) {\n            // If the `error` was generated by the playlist loader, it will contain\n            // the playlist we were trying to load (but failed) and that should be\n            // excluded instead of the currently selected playlist which is likely\n            // out-of-date in this scenario\n            playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();\n            playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration; // If there is no current playlist, then an error occurred while we were\n            // trying to load the main OR while we were disposing of the tech\n\n            if (!playlistToExclude) {\n                this.error = error;\n                if (this.mediaSource.readyState !== 'open') {\n                    this.trigger('error');\n                } else {\n                    this.sourceUpdater_.endOfStream('network');\n                }\n                return;\n            }\n            playlistToExclude.playlistErrors_++;\n            const playlists = this.mainPlaylistLoader_.main.playlists;\n            const enabledPlaylists = playlists.filter(isEnabled);\n            const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude; // Don't exclude the only playlist unless it was excluded\n            // forever\n\n            if (playlists.length === 1 && playlistExclusionDuration !== Infinity) {\n                videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. ` + 'Trying again since it is the only playlist.');\n                this.tech_.trigger('retryplaylist'); // if this is a final rendition, we should delay\n\n                return this.mainPlaylistLoader_.load(isFinalRendition);\n            }\n            if (isFinalRendition) {\n                // If we're content steering, try other pathways.\n                if (this.main().contentSteering) {\n                    const pathway = this.pathwayAttribute_(playlistToExclude); // Ignore at least 1 steering manifest refresh.\n\n                    const reIncludeDelay = this.contentSteeringController_.steeringManifest.ttl * 1000;\n                    this.contentSteeringController_.excludePathway(pathway);\n                    this.excludeThenChangePathway_();\n                    setTimeout(() => {\n                        this.contentSteeringController_.addAvailablePathway(pathway);\n                    }, reIncludeDelay);\n                    return;\n                } // Since we're on the final non-excluded playlist, and we're about to exclude\n                // it, instead of erring the player or retrying this playlist, clear out the current\n                // exclusion list. This allows other playlists to be attempted in case any have been\n                // fixed.\n\n                let reincluded = false;\n                playlists.forEach(playlist => {\n                    // skip current playlist which is about to be excluded\n                    if (playlist === playlistToExclude) {\n                        return;\n                    }\n                    const excludeUntil = playlist.excludeUntil; // a playlist cannot be reincluded if it wasn't excluded to begin with.\n\n                    if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {\n                        reincluded = true;\n                        delete playlist.excludeUntil;\n                    }\n                });\n                if (reincluded) {\n                    videojs.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.'); // Technically we are retrying a playlist, in that we are simply retrying a previous\n                    // playlist. This is needed for users relying on the retryplaylist event to catch a\n                    // case where the player might be stuck and looping through \"dead\" playlists.\n\n                    this.tech_.trigger('retryplaylist');\n                }\n            } // Exclude this playlist\n\n            let excludeUntil;\n            if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) {\n                excludeUntil = Infinity;\n            } else {\n                excludeUntil = Date.now() + playlistExclusionDuration * 1000;\n            }\n            playlistToExclude.excludeUntil = excludeUntil;\n            if (error.reason) {\n                playlistToExclude.lastExcludeReason_ = error.reason;\n            }\n            this.tech_.trigger('excludeplaylist');\n            this.tech_.trigger({\n                type: 'usage',\n                name: 'vhs-rendition-excluded'\n            }); // TODO: only load a new playlist if we're excluding the current playlist\n            // If this function was called with a playlist that's not the current active playlist\n            // (e.g., media().id !== playlistToExclude.id),\n            // then a new playlist should not be selected and loaded, as there's nothing wrong with the current playlist.\n\n            const nextPlaylist = this.selectPlaylist();\n            if (!nextPlaylist) {\n                this.error = 'Playback cannot continue. No available working or supported playlists.';\n                this.trigger('error');\n                return;\n            }\n            const logFn = error.internal ? this.logger_ : videojs.log.warn;\n            const errorMessage = error.message ? ' ' + error.message : '';\n            logFn(`${error.internal ? 'Internal problem' : 'Problem'} encountered with playlist ${playlistToExclude.id}.` + `${errorMessage} Switching to playlist ${nextPlaylist.id}.`); // if audio group changed reset audio loaders\n\n            if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) {\n                this.delegateLoaders_('audio', ['abort', 'pause']);\n            } // if subtitle group changed reset subtitle loaders\n\n            if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) {\n                this.delegateLoaders_('subtitle', ['abort', 'pause']);\n            }\n            this.delegateLoaders_('main', ['abort', 'pause']);\n            const delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5 * 1000;\n            const shouldDelay = typeof nextPlaylist.lastRequest === 'number' && Date.now() - nextPlaylist.lastRequest <= delayDuration; // delay if it's a final rendition or if the last refresh is sooner than half targetDuration\n\n            return this.switchMedia_(nextPlaylist, 'exclude', isFinalRendition || shouldDelay);\n        }\n        /**\n         * Pause all segment/playlist loaders\n         */\n\n        pauseLoading() {\n            this.delegateLoaders_('all', ['abort', 'pause']);\n            this.stopABRTimer_();\n        }\n        /**\n         * Call a set of functions in order on playlist loaders, segment loaders,\n         * or both types of loaders.\n         *\n         * @param {string} filter\n         *        Filter loaders that should call fnNames using a string. Can be:\n         *        * all - run on all loaders\n         *        * audio - run on all audio loaders\n         *        * subtitle - run on all subtitle loaders\n         *        * main - run on the main loaders\n         *\n         * @param {Array|string} fnNames\n         *        A string or array of function names to call.\n         */\n\n        delegateLoaders_(filter, fnNames) {\n            const loaders = [];\n            const dontFilterPlaylist = filter === 'all';\n            if (dontFilterPlaylist || filter === 'main') {\n                loaders.push(this.mainPlaylistLoader_);\n            }\n            const mediaTypes = [];\n            if (dontFilterPlaylist || filter === 'audio') {\n                mediaTypes.push('AUDIO');\n            }\n            if (dontFilterPlaylist || filter === 'subtitle') {\n                mediaTypes.push('CLOSED-CAPTIONS');\n                mediaTypes.push('SUBTITLES');\n            }\n            mediaTypes.forEach(mediaType => {\n                const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;\n                if (loader) {\n                    loaders.push(loader);\n                }\n            });\n            ['main', 'audio', 'subtitle'].forEach(name => {\n                const loader = this[`${name}SegmentLoader_`];\n                if (loader && (filter === name || filter === 'all')) {\n                    loaders.push(loader);\n                }\n            });\n            loaders.forEach(loader => fnNames.forEach(fnName => {\n                if (typeof loader[fnName] === 'function') {\n                    loader[fnName]();\n                }\n            }));\n        }\n        /**\n         * set the current time on all segment loaders\n         *\n         * @param {TimeRange} currentTime the current time to set\n         * @return {TimeRange} the current time\n         */\n\n        setCurrentTime(currentTime) {\n            const buffered = findRange(this.tech_.buffered(), currentTime);\n            if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) {\n                // return immediately if the metadata is not ready yet\n                return 0;\n            } // it's clearly an edge-case but don't thrown an error if asked to\n            // seek within an empty playlist\n\n            if (!this.mainPlaylistLoader_.media().segments) {\n                return 0;\n            } // if the seek location is already buffered, continue buffering as usual\n\n            if (buffered && buffered.length) {\n                return currentTime;\n            } // cancel outstanding requests so we begin buffering at the new\n            // location\n\n            this.mainSegmentLoader_.pause();\n            this.mainSegmentLoader_.resetEverything();\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                this.audioSegmentLoader_.pause();\n                this.audioSegmentLoader_.resetEverything();\n            }\n            if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n                this.subtitleSegmentLoader_.pause();\n                this.subtitleSegmentLoader_.resetEverything();\n            } // start segment loader loading in case they are paused\n\n            this.load();\n        }\n        /**\n         * get the current duration\n         *\n         * @return {TimeRange} the duration\n         */\n\n        duration() {\n            if (!this.mainPlaylistLoader_) {\n                return 0;\n            }\n            const media = this.mainPlaylistLoader_.media();\n            if (!media) {\n                // no playlists loaded yet, so can't determine a duration\n                return 0;\n            } // Don't rely on the media source for duration in the case of a live playlist since\n            // setting the native MediaSource's duration to infinity ends up with consequences to\n            // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n            //\n            // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n            // however, few browsers have support for setLiveSeekableRange()\n            // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n            //\n            // Until a time when the duration of the media source can be set to infinity, and a\n            // seekable range specified across browsers, just return Infinity.\n\n            if (!media.endList) {\n                return Infinity;\n            } // Since this is a VOD video, it is safe to rely on the media source's duration (if\n            // available). If it's not available, fall back to a playlist-calculated estimate.\n\n            if (this.mediaSource) {\n                return this.mediaSource.duration;\n            }\n            return Vhs$1.Playlist.duration(media);\n        }\n        /**\n         * check the seekable range\n         *\n         * @return {TimeRange} the seekable range\n         */\n\n        seekable() {\n            return this.seekable_;\n        }\n        onSyncInfoUpdate_() {\n            let audioSeekable; // TODO check for creation of both source buffers before updating seekable\n            //\n            // A fix was made to this function where a check for\n            // this.sourceUpdater_.hasCreatedSourceBuffers\n            // was added to ensure that both source buffers were created before seekable was\n            // updated. However, it originally had a bug where it was checking for a true and\n            // returning early instead of checking for false. Setting it to check for false to\n            // return early though created other issues. A call to play() would check for seekable\n            // end without verifying that a seekable range was present. In addition, even checking\n            // for that didn't solve some issues, as handleFirstPlay is sometimes worked around\n            // due to a media update calling load on the segment loaders, skipping a seek to live,\n            // thereby starting live streams at the beginning of the stream rather than at the end.\n            //\n            // This conditional should be fixed to wait for the creation of two source buffers at\n            // the same time as the other sections of code are fixed to properly seek to live and\n            // not throw an error due to checking for a seekable end when no seekable range exists.\n            //\n            // For now, fall back to the older behavior, with the understanding that the seekable\n            // range may not be completely correct, leading to a suboptimal initial live point.\n\n            if (!this.mainPlaylistLoader_) {\n                return;\n            }\n            let media = this.mainPlaylistLoader_.media();\n            if (!media) {\n                return;\n            }\n            let expired = this.syncController_.getExpiredTime(media, this.duration());\n            if (expired === null) {\n                // not enough information to update seekable\n                return;\n            }\n            const main = this.mainPlaylistLoader_.main;\n            const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n            if (mainSeekable.length === 0) {\n                return;\n            }\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n                expired = this.syncController_.getExpiredTime(media, this.duration());\n                if (expired === null) {\n                    return;\n                }\n                audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n                if (audioSeekable.length === 0) {\n                    return;\n                }\n            }\n            let oldEnd;\n            let oldStart;\n            if (this.seekable_ && this.seekable_.length) {\n                oldEnd = this.seekable_.end(0);\n                oldStart = this.seekable_.start(0);\n            }\n            if (!audioSeekable) {\n                // seekable has been calculated based on buffering video data so it\n                // can be returned directly\n                this.seekable_ = mainSeekable;\n            } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n                // seekables are pretty far off, rely on main\n                this.seekable_ = mainSeekable;\n            } else {\n                this.seekable_ = createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n            } // seekable is the same as last time\n\n            if (this.seekable_ && this.seekable_.length) {\n                if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {\n                    return;\n                }\n            }\n            this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);\n            this.tech_.trigger('seekablechanged');\n        }\n        /**\n         * Update the player duration\n         */\n\n        updateDuration(isLive) {\n            if (this.updateDuration_) {\n                this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n                this.updateDuration_ = null;\n            }\n            if (this.mediaSource.readyState !== 'open') {\n                this.updateDuration_ = this.updateDuration.bind(this, isLive);\n                this.mediaSource.addEventListener('sourceopen', this.updateDuration_);\n                return;\n            }\n            if (isLive) {\n                const seekable = this.seekable();\n                if (!seekable.length) {\n                    return;\n                } // Even in the case of a live playlist, the native MediaSource's duration should not\n                // be set to Infinity (even though this would be expected for a live playlist), since\n                // setting the native MediaSource's duration to infinity ends up with consequences to\n                // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n                //\n                // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n                // however, few browsers have support for setLiveSeekableRange()\n                // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n                //\n                // Until a time when the duration of the media source can be set to infinity, and a\n                // seekable range specified across browsers, the duration should be greater than or\n                // equal to the last possible seekable value.\n                // MediaSource duration starts as NaN\n                // It is possible (and probable) that this case will never be reached for many\n                // sources, since the MediaSource reports duration as the highest value without\n                // accounting for timestamp offset. For example, if the timestamp offset is -100 and\n                // we buffered times 0 to 100 with real times of 100 to 200, even though current\n                // time will be between 0 and 100, the native media source may report the duration\n                // as 200. However, since we report duration separate from the media source (as\n                // Infinity), and as long as the native media source duration value is greater than\n                // our reported seekable range, seeks will work as expected. The large number as\n                // duration for live is actually a strategy used by some players to work around the\n                // issue of live seekable ranges cited above.\n\n                if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {\n                    this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));\n                }\n                return;\n            }\n            const buffered = this.tech_.buffered();\n            let duration = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());\n            if (buffered.length > 0) {\n                duration = Math.max(duration, buffered.end(buffered.length - 1));\n            }\n            if (this.mediaSource.duration !== duration) {\n                this.sourceUpdater_.setDuration(duration);\n            }\n        }\n        /**\n         * dispose of the PlaylistController and everything\n         * that it controls\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.decrypter_.terminate();\n            this.mainPlaylistLoader_.dispose();\n            this.mainSegmentLoader_.dispose();\n            this.contentSteeringController_.dispose();\n            this.keyStatusMap_.clear();\n            if (this.loadOnPlay_) {\n                this.tech_.off('play', this.loadOnPlay_);\n            }\n            ['AUDIO', 'SUBTITLES'].forEach(type => {\n                const groups = this.mediaTypes_[type].groups;\n                for (const id in groups) {\n                    groups[id].forEach(group => {\n                        if (group.playlistLoader) {\n                            group.playlistLoader.dispose();\n                        }\n                    });\n                }\n            });\n            this.audioSegmentLoader_.dispose();\n            this.subtitleSegmentLoader_.dispose();\n            this.sourceUpdater_.dispose();\n            this.timelineChangeController_.dispose();\n            this.stopABRTimer_();\n            if (this.updateDuration_) {\n                this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n            }\n            this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n            this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);\n            this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);\n            this.off();\n        }\n        /**\n         * return the main playlist object if we have one\n         *\n         * @return {Object} the main playlist object that we parsed\n         */\n\n        main() {\n            return this.mainPlaylistLoader_.main;\n        }\n        /**\n         * return the currently selected playlist\n         *\n         * @return {Object} the currently selected playlist object that we parsed\n         */\n\n        media() {\n            // playlist loader will not return media if it has not been fully loaded\n            return this.mainPlaylistLoader_.media() || this.initialMedia_;\n        }\n        areMediaTypesKnown_() {\n            const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n            const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_(); // if we are not using an audio loader, then we have audio media info\n            // otherwise check on the segment loader.\n\n            const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_(); // one or both loaders has not loaded sufficently to get codecs\n\n            if (!hasMainMediaInfo || !hasAudioMediaInfo) {\n                return false;\n            }\n            return true;\n        }\n        getCodecsOrExclude_() {\n            const media = {\n                main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},\n                audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}\n            };\n            const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media(); // set \"main\" media equal to video\n\n            media.video = media.main;\n            const playlistCodecs = codecsForPlaylist(this.main(), playlist);\n            const codecs = {};\n            const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n            if (media.main.hasVideo) {\n                codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;\n            }\n            if (media.main.isMuxed) {\n                codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;\n            }\n            if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {\n                codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC; // set audio isFmp4 so we use the correct \"supports\" function below\n\n                media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;\n            } // no codecs, no playback.\n\n            if (!codecs.audio && !codecs.video) {\n                this.excludePlaylist({\n                    playlistToExclude: playlist,\n                    error: {\n                        message: 'Could not determine codecs for playlist.'\n                    },\n                    playlistExclusionDuration: Infinity\n                });\n                return;\n            } // fmp4 relies on browser support, while ts relies on muxer support\n\n            const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);\n            const unsupportedCodecs = {};\n            let unsupportedAudio;\n            ['video', 'audio'].forEach(function (type) {\n                if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {\n                    const supporter = media[type].isFmp4 ? 'browser' : 'muxer';\n                    unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];\n                    unsupportedCodecs[supporter].push(codecs[type]);\n                    if (type === 'audio') {\n                        unsupportedAudio = supporter;\n                    }\n                }\n            });\n            if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {\n                const audioGroup = playlist.attributes.AUDIO;\n                this.main().playlists.forEach(variant => {\n                    const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;\n                    if (variantAudioGroup === audioGroup && variant !== playlist) {\n                        variant.excludeUntil = Infinity;\n                    }\n                });\n                this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): \"${codecs.audio}\"`);\n            } // if we have any unsupported codecs exclude this playlist.\n\n            if (Object.keys(unsupportedCodecs).length) {\n                const message = Object.keys(unsupportedCodecs).reduce((acc, supporter) => {\n                    if (acc) {\n                        acc += ', ';\n                    }\n                    acc += `${supporter} does not support codec(s): \"${unsupportedCodecs[supporter].join(',')}\"`;\n                    return acc;\n                }, '') + '.';\n                this.excludePlaylist({\n                    playlistToExclude: playlist,\n                    error: {\n                        internal: true,\n                        message\n                    },\n                    playlistExclusionDuration: Infinity\n                });\n                return;\n            } // check if codec switching is happening\n\n            if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {\n                const switchMessages = [];\n                ['video', 'audio'].forEach(type => {\n                    const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || '')[0] || {}).type;\n                    const oldCodec = (parseCodecs(codecs[type] || '')[0] || {}).type;\n                    if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {\n                        switchMessages.push(`\"${this.sourceUpdater_.codecs[type]}\" -> \"${codecs[type]}\"`);\n                    }\n                });\n                if (switchMessages.length) {\n                    this.excludePlaylist({\n                        playlistToExclude: playlist,\n                        error: {\n                            message: `Codec switching not supported: ${switchMessages.join(', ')}.`,\n                            internal: true\n                        },\n                        playlistExclusionDuration: Infinity\n                    });\n                    return;\n                }\n            } // TODO: when using the muxer shouldn't we just return\n            // the codecs that the muxer outputs?\n\n            return codecs;\n        }\n        /**\n         * Create source buffers and exlude any incompatible renditions.\n         *\n         * @private\n         */\n\n        tryToCreateSourceBuffers_() {\n            // media source is not ready yet or sourceBuffers are already\n            // created.\n            if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.hasCreatedSourceBuffers()) {\n                return;\n            }\n            if (!this.areMediaTypesKnown_()) {\n                return;\n            }\n            const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n            if (!codecs) {\n                return;\n            }\n            this.sourceUpdater_.createSourceBuffers(codecs);\n            const codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');\n            this.excludeIncompatibleVariants_(codecString);\n        }\n        /**\n         * Excludes playlists with codecs that are unsupported by the muxer and browser.\n         */\n\n        excludeUnsupportedVariants_() {\n            const playlists = this.main().playlists;\n            const ids = []; // TODO: why don't we have a property to loop through all\n            // playlist? Why did we ever mix indexes and keys?\n\n            Object.keys(playlists).forEach(key => {\n                const variant = playlists[key]; // check if we already processed this playlist.\n\n                if (ids.indexOf(variant.id) !== -1) {\n                    return;\n                }\n                ids.push(variant.id);\n                const codecs = codecsForPlaylist(this.main, variant);\n                const unsupported = [];\n                if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {\n                    unsupported.push(`audio codec ${codecs.audio}`);\n                }\n                if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {\n                    unsupported.push(`video codec ${codecs.video}`);\n                }\n                if (codecs.text && codecs.text === 'stpp.ttml.im1t') {\n                    unsupported.push(`text codec ${codecs.text}`);\n                }\n                if (unsupported.length) {\n                    variant.excludeUntil = Infinity;\n                    this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(', ')}`);\n                }\n            });\n        }\n        /**\n         * Exclude playlists that are known to be codec or\n         * stream-incompatible with the SourceBuffer configuration. For\n         * instance, Media Source Extensions would cause the video element to\n         * stall waiting for video data if you switched from a variant with\n         * video and audio to an audio-only one.\n         *\n         * @param {Object} media a media playlist compatible with the current\n         * set of SourceBuffers. Variants in the current main playlist that\n         * do not appear to have compatible codec or stream configurations\n         * will be excluded from the default playlist selection algorithm\n         * indefinitely.\n         * @private\n         */\n\n        excludeIncompatibleVariants_(codecString) {\n            const ids = [];\n            const playlists = this.main().playlists;\n            const codecs = unwrapCodecList(parseCodecs(codecString));\n            const codecCount_ = codecCount(codecs);\n            const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;\n            const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;\n            Object.keys(playlists).forEach(key => {\n                const variant = playlists[key]; // check if we already processed this playlist.\n                // or it if it is already excluded forever.\n\n                if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {\n                    return;\n                }\n                ids.push(variant.id);\n                const exclusionReasons = []; // get codecs from the playlist for this variant\n\n                const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);\n                const variantCodecCount = codecCount(variantCodecs); // if no codecs are listed, we cannot determine that this\n                // variant is incompatible. Wait for mux.js to probe\n\n                if (!variantCodecs.audio && !variantCodecs.video) {\n                    return;\n                } // TODO: we can support this by removing the\n                // old media source and creating a new one, but it will take some work.\n                // The number of streams cannot change\n\n                if (variantCodecCount !== codecCount_) {\n                    exclusionReasons.push(`codec count \"${variantCodecCount}\" !== \"${codecCount_}\"`);\n                } // only exclude playlists by codec change, if codecs cannot switch\n                // during playback.\n\n                if (!this.sourceUpdater_.canChangeType()) {\n                    const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;\n                    const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null; // the video codec cannot change\n\n                    if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {\n                        exclusionReasons.push(`video codec \"${variantVideoDetails.type}\" !== \"${videoDetails.type}\"`);\n                    } // the audio codec cannot change\n\n                    if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {\n                        exclusionReasons.push(`audio codec \"${variantAudioDetails.type}\" !== \"${audioDetails.type}\"`);\n                    }\n                }\n                if (exclusionReasons.length) {\n                    variant.excludeUntil = Infinity;\n                    this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(' && ')}`);\n                }\n            });\n        }\n        updateAdCues_(media) {\n            let offset = 0;\n            const seekable = this.seekable();\n            if (seekable.length) {\n                offset = seekable.start(0);\n            }\n            updateAdCues(media, this.cueTagsTrack_, offset);\n        }\n        /**\n         * Calculates the desired forward buffer length based on current time\n         *\n         * @return {number} Desired forward buffer length in seconds\n         */\n\n        goalBufferLength() {\n            const currentTime = this.tech_.currentTime();\n            const initial = Config.GOAL_BUFFER_LENGTH;\n            const rate = Config.GOAL_BUFFER_LENGTH_RATE;\n            const max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\n            return Math.min(initial + currentTime * rate, max);\n        }\n        /**\n         * Calculates the desired buffer low water line based on current time\n         *\n         * @return {number} Desired buffer low water line in seconds\n         */\n\n        bufferLowWaterLine() {\n            const currentTime = this.tech_.currentTime();\n            const initial = Config.BUFFER_LOW_WATER_LINE;\n            const rate = Config.BUFFER_LOW_WATER_LINE_RATE;\n            const max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\n            const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);\n            return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);\n        }\n        bufferHighWaterLine() {\n            return Config.BUFFER_HIGH_WATER_LINE;\n        }\n        addDateRangesToTextTrack_(dateRanges) {\n            createMetadataTrackIfNotExists(this.inbandTextTracks_, 'com.apple.streaming', this.tech_);\n            addDateRangeMetadata({\n                inbandTextTracks: this.inbandTextTracks_,\n                dateRanges\n            });\n        }\n        addMetadataToTextTrack(dispatchType, metadataArray, videoDuration) {\n            const timestampOffset = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset(); // There's potentially an issue where we could double add metadata if there's a muxed\n            // audio/video source with a metadata track, and an alt audio with a metadata track.\n            // However, this probably won't happen, and if it does it can be handled then.\n\n            createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.tech_);\n            addMetadata({\n                inbandTextTracks: this.inbandTextTracks_,\n                metadataArray,\n                timestampOffset,\n                videoDuration\n            });\n        }\n        /**\n         * Utility for getting the pathway or service location from an HLS or DASH playlist.\n         *\n         * @param {Object} playlist for getting pathway from.\n         * @return the pathway attribute of a playlist\n         */\n\n        pathwayAttribute_(playlist) {\n            return playlist.attributes['PATHWAY-ID'] || playlist.attributes.serviceLocation;\n        }\n        /**\n         * Initialize available pathways and apply the tag properties.\n         */\n\n        initContentSteeringController_() {\n            const main = this.main();\n            if (!main.contentSteering) {\n                return;\n            }\n            for (const playlist of main.playlists) {\n                this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(playlist));\n            }\n            this.contentSteeringController_.assignTagProperties(main.uri, main.contentSteering); // request the steering manifest immediately if queryBeforeStart is set.\n\n            if (this.contentSteeringController_.queryBeforeStart) {\n                // When queryBeforeStart is true, initial request should omit steering parameters.\n                this.contentSteeringController_.requestSteeringManifest(true);\n                return;\n            } // otherwise start content steering after playback starts\n\n            this.tech_.one('canplay', () => {\n                this.contentSteeringController_.requestSteeringManifest();\n            });\n        }\n        /**\n         * Reset the content steering controller and re-init.\n         */\n\n        resetContentSteeringController_() {\n            this.contentSteeringController_.clearAvailablePathways();\n            this.contentSteeringController_.dispose();\n            this.initContentSteeringController_();\n        }\n        /**\n         * Attaches the listeners for content steering.\n         */\n\n        attachContentSteeringListeners_() {\n            this.contentSteeringController_.on('content-steering', this.excludeThenChangePathway_.bind(this));\n            if (this.sourceType_ === 'dash') {\n                this.mainPlaylistLoader_.on('loadedplaylist', () => {\n                    const main = this.main(); // check if steering tag or pathways changed.\n\n                    const didDashTagChange = this.contentSteeringController_.didDASHTagChange(main.uri, main.contentSteering);\n                    const didPathwaysChange = () => {\n                        const availablePathways = this.contentSteeringController_.getAvailablePathways();\n                        const newPathways = [];\n                        for (const playlist of main.playlists) {\n                            const serviceLocation = playlist.attributes.serviceLocation;\n                            if (serviceLocation) {\n                                newPathways.push(serviceLocation);\n                                if (!availablePathways.has(serviceLocation)) {\n                                    return true;\n                                }\n                            }\n                        } // If we have no new serviceLocations and previously had availablePathways\n\n                        if (!newPathways.length && availablePathways.size) {\n                            return true;\n                        }\n                        return false;\n                    };\n                    if (didDashTagChange || didPathwaysChange()) {\n                        this.resetContentSteeringController_();\n                    }\n                });\n            }\n        }\n        /**\n         * Simple exclude and change playlist logic for content steering.\n         */\n\n        excludeThenChangePathway_() {\n            const currentPathway = this.contentSteeringController_.getPathway();\n            if (!currentPathway) {\n                return;\n            }\n            this.handlePathwayClones_();\n            const main = this.main();\n            const playlists = main.playlists;\n            const ids = new Set();\n            let didEnablePlaylists = false;\n            Object.keys(playlists).forEach(key => {\n                const variant = playlists[key];\n                const pathwayId = this.pathwayAttribute_(variant);\n                const differentPathwayId = pathwayId && currentPathway !== pathwayId;\n                const steeringExclusion = variant.excludeUntil === Infinity && variant.lastExcludeReason_ === 'content-steering';\n                if (steeringExclusion && !differentPathwayId) {\n                    delete variant.excludeUntil;\n                    delete variant.lastExcludeReason_;\n                    didEnablePlaylists = true;\n                }\n                const noExcludeUntil = !variant.excludeUntil && variant.excludeUntil !== Infinity;\n                const shouldExclude = !ids.has(variant.id) && differentPathwayId && noExcludeUntil;\n                if (!shouldExclude) {\n                    return;\n                }\n                ids.add(variant.id);\n                variant.excludeUntil = Infinity;\n                variant.lastExcludeReason_ = 'content-steering'; // TODO: kind of spammy, maybe move this.\n\n                this.logger_(`excluding ${variant.id} for ${variant.lastExcludeReason_}`);\n            });\n            if (this.contentSteeringController_.manifestType_ === 'DASH') {\n                Object.keys(this.mediaTypes_).forEach(key => {\n                    const type = this.mediaTypes_[key];\n                    if (type.activePlaylistLoader) {\n                        const currentPlaylist = type.activePlaylistLoader.media_; // Check if the current media playlist matches the current CDN\n\n                        if (currentPlaylist && currentPlaylist.attributes.serviceLocation !== currentPathway) {\n                            didEnablePlaylists = true;\n                        }\n                    }\n                });\n            }\n            if (didEnablePlaylists) {\n                this.changeSegmentPathway_();\n            }\n        }\n        /**\n         * Add, update, or delete playlists and media groups for\n         * the pathway clones for HLS Content Steering.\n         *\n         * See https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/\n         *\n         * NOTE: Pathway cloning does not currently support the `PER_VARIANT_URIS` and\n         * `PER_RENDITION_URIS` as we do not handle `STABLE-VARIANT-ID` or\n         * `STABLE-RENDITION-ID` values.\n         */\n\n        handlePathwayClones_() {\n            const main = this.main();\n            const playlists = main.playlists;\n            const currentPathwayClones = this.contentSteeringController_.currentPathwayClones;\n            const nextPathwayClones = this.contentSteeringController_.nextPathwayClones;\n            const hasClones = currentPathwayClones && currentPathwayClones.size || nextPathwayClones && nextPathwayClones.size;\n            if (!hasClones) {\n                return;\n            }\n            for (const [id, clone] of currentPathwayClones.entries()) {\n                const newClone = nextPathwayClones.get(id); // Delete the old pathway clone.\n\n                if (!newClone) {\n                    this.mainPlaylistLoader_.updateOrDeleteClone(clone);\n                    this.contentSteeringController_.excludePathway(id);\n                }\n            }\n            for (const [id, clone] of nextPathwayClones.entries()) {\n                const oldClone = currentPathwayClones.get(id); // Create a new pathway if it is a new pathway clone object.\n\n                if (!oldClone) {\n                    const playlistsToClone = playlists.filter(p => {\n                        return p.attributes['PATHWAY-ID'] === clone['BASE-ID'];\n                    });\n                    playlistsToClone.forEach(p => {\n                        this.mainPlaylistLoader_.addClonePathway(clone, p);\n                    });\n                    this.contentSteeringController_.addAvailablePathway(id);\n                    continue;\n                } // There have not been changes to the pathway clone object, so skip.\n\n                if (this.equalPathwayClones_(oldClone, clone)) {\n                    continue;\n                } // Update a preexisting cloned pathway.\n                // True is set for the update flag.\n\n                this.mainPlaylistLoader_.updateOrDeleteClone(clone, true);\n                this.contentSteeringController_.addAvailablePathway(id);\n            } // Deep copy contents of next to current pathways.\n\n            this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...nextPathwayClones])));\n        }\n        /**\n         * Determines whether two pathway clone objects are equivalent.\n         *\n         * @param {Object} a The first pathway clone object.\n         * @param {Object} b The second pathway clone object.\n         * @return {boolean} True if the pathway clone objects are equal, false otherwise.\n         */\n\n        equalPathwayClones_(a, b) {\n            if (a['BASE-ID'] !== b['BASE-ID'] || a.ID !== b.ID || a['URI-REPLACEMENT'].HOST !== b['URI-REPLACEMENT'].HOST) {\n                return false;\n            }\n            const aParams = a['URI-REPLACEMENT'].PARAMS;\n            const bParams = b['URI-REPLACEMENT'].PARAMS; // We need to iterate through both lists of params because one could be\n            // missing a parameter that the other has.\n\n            for (const p in aParams) {\n                if (aParams[p] !== bParams[p]) {\n                    return false;\n                }\n            }\n            for (const p in bParams) {\n                if (aParams[p] !== bParams[p]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Changes the current playlists for audio, video and subtitles after a new pathway\n         * is chosen from content steering.\n         */\n\n        changeSegmentPathway_() {\n            const nextPlaylist = this.selectPlaylist();\n            this.pauseLoading(); // Switch audio and text track playlists if necessary in DASH\n\n            if (this.contentSteeringController_.manifestType_ === 'DASH') {\n                this.switchMediaForDASHContentSteering_();\n            }\n            this.switchMedia_(nextPlaylist, 'content-steering');\n        }\n        /**\n         * Iterates through playlists and check their keyId set and compare with the\n         * keyStatusMap, only enable playlists that have a usable key. If the playlist\n         * has no keyId leave it enabled by default.\n         */\n\n        excludeNonUsablePlaylistsByKeyId_() {\n            if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main) {\n                return;\n            }\n            let nonUsableKeyStatusCount = 0;\n            const NON_USABLE = 'non-usable';\n            this.mainPlaylistLoader_.main.playlists.forEach(playlist => {\n                const keyIdSet = this.mainPlaylistLoader_.getKeyIdSet(playlist); // If the playlist doesn't have keyIDs lets not exclude it.\n\n                if (!keyIdSet || !keyIdSet.size) {\n                    return;\n                }\n                keyIdSet.forEach(key => {\n                    const USABLE = 'usable';\n                    const hasUsableKeyStatus = this.keyStatusMap_.has(key) && this.keyStatusMap_.get(key) === USABLE;\n                    const nonUsableExclusion = playlist.lastExcludeReason_ === NON_USABLE && playlist.excludeUntil === Infinity;\n                    if (!hasUsableKeyStatus) {\n                        // Only exclude playlists that haven't already been excluded as non-usable.\n                        if (playlist.excludeUntil !== Infinity && playlist.lastExcludeReason_ !== NON_USABLE) {\n                            playlist.excludeUntil = Infinity;\n                            playlist.lastExcludeReason_ = NON_USABLE;\n                            this.logger_(`excluding playlist ${playlist.id} because the key ID ${key} doesn't exist in the keyStatusMap or is not ${USABLE}`);\n                        } // count all nonUsableKeyStatus\n\n                        nonUsableKeyStatusCount++;\n                    } else if (hasUsableKeyStatus && nonUsableExclusion) {\n                        delete playlist.excludeUntil;\n                        delete playlist.lastExcludeReason_;\n                        this.logger_(`enabling playlist ${playlist.id} because key ID ${key} is ${USABLE}`);\n                    }\n                });\n            }); // If for whatever reason every playlist has a non usable key status. Lets try re-including the SD renditions as a failsafe.\n\n            if (nonUsableKeyStatusCount >= this.mainPlaylistLoader_.main.playlists.length) {\n                this.mainPlaylistLoader_.main.playlists.forEach(playlist => {\n                    const isNonHD = playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height < 720;\n                    const excludedForNonUsableKey = playlist.excludeUntil === Infinity && playlist.lastExcludeReason_ === NON_USABLE;\n                    if (isNonHD && excludedForNonUsableKey) {\n                        // Only delete the excludeUntil so we don't try and re-exclude these playlists.\n                        delete playlist.excludeUntil;\n                        videojs.log.warn(`enabling non-HD playlist ${playlist.id} because all playlists were excluded due to ${NON_USABLE} key IDs`);\n                    }\n                });\n            }\n        }\n        /**\n         * Adds a keystatus to the keystatus map, tries to convert to string if necessary.\n         *\n         * @param {any} keyId the keyId to add a status for\n         * @param {string} status the status of the keyId\n         */\n\n        addKeyStatus_(keyId, status) {\n            const isString = typeof keyId === 'string';\n            const keyIdHexString = isString ? keyId : bufferToHexString(keyId);\n            const formattedKeyIdString = keyIdHexString.slice(0, 32).toLowerCase();\n            this.logger_(`KeyStatus '${status}' with key ID ${formattedKeyIdString} added to the keyStatusMap`);\n            this.keyStatusMap_.set(formattedKeyIdString, status);\n        }\n        /**\n         * Utility function for adding key status to the keyStatusMap and filtering usable encrypted playlists.\n         *\n         * @param {any} keyId the keyId from the keystatuschange event\n         * @param {string} status the key status string\n         */\n\n        updatePlaylistByKeyStatus(keyId, status) {\n            this.addKeyStatus_(keyId, status);\n            if (!this.waitingForFastQualityPlaylistReceived_) {\n                this.excludeNonUsableThenChangePlaylist_();\n            } // Listen to loadedplaylist with a single listener and check for new contentProtection elements when a playlist is updated.\n\n            this.mainPlaylistLoader_.off('loadedplaylist', this.excludeNonUsableThenChangePlaylist_.bind(this));\n            this.mainPlaylistLoader_.on('loadedplaylist', this.excludeNonUsableThenChangePlaylist_.bind(this));\n        }\n        excludeNonUsableThenChangePlaylist_() {\n            this.excludeNonUsablePlaylistsByKeyId_();\n            this.fastQualityChange_();\n        }\n    }\n\n    /**\n     * Returns a function that acts as the Enable/disable playlist function.\n     *\n     * @param {PlaylistLoader} loader - The main playlist loader\n     * @param {string} playlistID - id of the playlist\n     * @param {Function} changePlaylistFn - A function to be called after a\n     * playlist's enabled-state has been changed. Will NOT be called if a\n     * playlist's enabled-state is unchanged\n     * @param {boolean=} enable - Value to set the playlist enabled-state to\n     * or if undefined returns the current enabled-state for the playlist\n     * @return {Function} Function for setting/getting enabled\n     */\n\n    const enableFunction = (loader, playlistID, changePlaylistFn) => enable => {\n        const playlist = loader.main.playlists[playlistID];\n        const incompatible = isIncompatible(playlist);\n        const currentlyEnabled = isEnabled(playlist);\n        if (typeof enable === 'undefined') {\n            return currentlyEnabled;\n        }\n        if (enable) {\n            delete playlist.disabled;\n        } else {\n            playlist.disabled = true;\n        }\n        if (enable !== currentlyEnabled && !incompatible) {\n            // Ensure the outside world knows about our changes\n            changePlaylistFn();\n            if (enable) {\n                loader.trigger('renditionenabled');\n            } else {\n                loader.trigger('renditiondisabled');\n            }\n        }\n        return enable;\n    };\n    /**\n     * The representation object encapsulates the publicly visible information\n     * in a media playlist along with a setter/getter-type function (enabled)\n     * for changing the enabled-state of a particular playlist entry\n     *\n     * @class Representation\n     */\n\n    class Representation {\n        constructor(vhsHandler, playlist, id) {\n            const {\n                playlistController_: pc\n            } = vhsHandler;\n            const qualityChangeFunction = pc.fastQualityChange_.bind(pc); // some playlist attributes are optional\n\n            if (playlist.attributes) {\n                const resolution = playlist.attributes.RESOLUTION;\n                this.width = resolution && resolution.width;\n                this.height = resolution && resolution.height;\n                this.bandwidth = playlist.attributes.BANDWIDTH;\n                this.frameRate = playlist.attributes['FRAME-RATE'];\n            }\n            this.codecs = codecsForPlaylist(pc.main(), playlist);\n            this.playlist = playlist; // The id is simply the ordinality of the media playlist\n            // within the main playlist\n\n            this.id = id; // Partially-apply the enableFunction to create a playlist-\n            // specific variant\n\n            this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);\n        }\n    }\n    /**\n     * A mixin function that adds the `representations` api to an instance\n     * of the VhsHandler class\n     *\n     * @param {VhsHandler} vhsHandler - An instance of VhsHandler to add the\n     * representation API into\n     */\n\n    const renditionSelectionMixin = function (vhsHandler) {\n        // Add a single API-specific function to the VhsHandler instance\n        vhsHandler.representations = () => {\n            const main = vhsHandler.playlistController_.main();\n            const playlists = isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;\n            if (!playlists) {\n                return [];\n            }\n            return playlists.filter(media => !isIncompatible(media)).map((e, i) => new Representation(vhsHandler, e, e.id));\n        };\n    };\n\n    /**\n     * @file playback-watcher.js\n     *\n     * Playback starts, and now my watch begins. It shall not end until my death. I shall\n     * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n     * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n     * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n     * my life and honor to the Playback Watch, for this Player and all the Players to come.\n     */\n\n    const timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n    /**\n     * @class PlaybackWatcher\n     */\n\n    class PlaybackWatcher {\n        /**\n         * Represents an PlaybackWatcher object.\n         *\n         * @class\n         * @param {Object} options an object that includes the tech and settings\n         */\n        constructor(options) {\n            this.playlistController_ = options.playlistController;\n            this.tech_ = options.tech;\n            this.seekable = options.seekable;\n            this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;\n            this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;\n            this.media = options.media;\n            this.consecutiveUpdates = 0;\n            this.lastRecordedTime = null;\n            this.checkCurrentTimeTimeout_ = null;\n            this.logger_ = logger('PlaybackWatcher');\n            this.logger_('initialize');\n            const playHandler = () => this.monitorCurrentTime_();\n            const canPlayHandler = () => this.monitorCurrentTime_();\n            const waitingHandler = () => this.techWaiting_();\n            const cancelTimerHandler = () => this.resetTimeUpdate_();\n            const pc = this.playlistController_;\n            const loaderTypes = ['main', 'subtitle', 'audio'];\n            const loaderChecks = {};\n            loaderTypes.forEach(type => {\n                loaderChecks[type] = {\n                    reset: () => this.resetSegmentDownloads_(type),\n                    updateend: () => this.checkSegmentDownloads_(type)\n                };\n                pc[`${type}SegmentLoader_`].on('appendsdone', loaderChecks[type].updateend); // If a rendition switch happens during a playback stall where the buffer\n                // isn't changing we want to reset. We cannot assume that the new rendition\n                // will also be stalled, until after new appends.\n\n                pc[`${type}SegmentLoader_`].on('playlistupdate', loaderChecks[type].reset); // Playback stalls should not be detected right after seeking.\n                // This prevents one segment playlists (single vtt or single segment content)\n                // from being detected as stalling. As the buffer will not change in those cases, since\n                // the buffer is the entire video duration.\n\n                this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);\n            });\n            /**\n             * We check if a seek was into a gap through the following steps:\n             * 1. We get a seeking event and we do not get a seeked event. This means that\n             *    a seek was attempted but not completed.\n             * 2. We run `fixesBadSeeks_` on segment loader appends. This means that we already\n             *    removed everything from our buffer and appended a segment, and should be ready\n             *    to check for gaps.\n             */\n\n            const setSeekingHandlers = fn => {\n                ['main', 'audio'].forEach(type => {\n                    pc[`${type}SegmentLoader_`][fn]('appended', this.seekingAppendCheck_);\n                });\n            };\n            this.seekingAppendCheck_ = () => {\n                if (this.fixesBadSeeks_()) {\n                    this.consecutiveUpdates = 0;\n                    this.lastRecordedTime = this.tech_.currentTime();\n                    setSeekingHandlers('off');\n                }\n            };\n            this.clearSeekingAppendCheck_ = () => setSeekingHandlers('off');\n            this.watchForBadSeeking_ = () => {\n                this.clearSeekingAppendCheck_();\n                setSeekingHandlers('on');\n            };\n            this.tech_.on('seeked', this.clearSeekingAppendCheck_);\n            this.tech_.on('seeking', this.watchForBadSeeking_);\n            this.tech_.on('waiting', waitingHandler);\n            this.tech_.on(timerCancelEvents, cancelTimerHandler);\n            this.tech_.on('canplay', canPlayHandler);\n            /*\n        An edge case exists that results in gaps not being skipped when they exist at the beginning of a stream. This case\n        is surfaced in one of two ways:\n         1)  The `waiting` event is fired before the player has buffered content, making it impossible\n            to find or skip the gap. The `waiting` event is followed by a `play` event. On first play\n            we can check if playback is stalled due to a gap, and skip the gap if necessary.\n        2)  A source with a gap at the beginning of the stream is loaded programatically while the player\n            is in a playing state. To catch this case, it's important that our one-time play listener is setup\n            even if the player is in a playing state\n      */\n\n            this.tech_.one('play', playHandler); // Define the dispose function to clean up our events\n\n            this.dispose = () => {\n                this.clearSeekingAppendCheck_();\n                this.logger_('dispose');\n                this.tech_.off('waiting', waitingHandler);\n                this.tech_.off(timerCancelEvents, cancelTimerHandler);\n                this.tech_.off('canplay', canPlayHandler);\n                this.tech_.off('play', playHandler);\n                this.tech_.off('seeking', this.watchForBadSeeking_);\n                this.tech_.off('seeked', this.clearSeekingAppendCheck_);\n                loaderTypes.forEach(type => {\n                    pc[`${type}SegmentLoader_`].off('appendsdone', loaderChecks[type].updateend);\n                    pc[`${type}SegmentLoader_`].off('playlistupdate', loaderChecks[type].reset);\n                    this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);\n                });\n                if (this.checkCurrentTimeTimeout_) {\n                    window.clearTimeout(this.checkCurrentTimeTimeout_);\n                }\n                this.resetTimeUpdate_();\n            };\n        }\n        /**\n         * Periodically check current time to see if playback stopped\n         *\n         * @private\n         */\n\n        monitorCurrentTime_() {\n            this.checkCurrentTime_();\n            if (this.checkCurrentTimeTimeout_) {\n                window.clearTimeout(this.checkCurrentTimeTimeout_);\n            } // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n\n            this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);\n        }\n        /**\n         * Reset stalled download stats for a specific type of loader\n         *\n         * @param {string} type\n         *        The segment loader type to check.\n         *\n         * @listens SegmentLoader#playlistupdate\n         * @listens Tech#seeking\n         * @listens Tech#seeked\n         */\n\n        resetSegmentDownloads_(type) {\n            const loader = this.playlistController_[`${type}SegmentLoader_`];\n            if (this[`${type}StalledDownloads_`] > 0) {\n                this.logger_(`resetting possible stalled download count for ${type} loader`);\n            }\n            this[`${type}StalledDownloads_`] = 0;\n            this[`${type}Buffered_`] = loader.buffered_();\n        }\n        /**\n         * Checks on every segment `appendsdone` to see\n         * if segment appends are making progress. If they are not\n         * and we are still downloading bytes. We exclude the playlist.\n         *\n         * @param {string} type\n         *        The segment loader type to check.\n         *\n         * @listens SegmentLoader#appendsdone\n         */\n\n        checkSegmentDownloads_(type) {\n            const pc = this.playlistController_;\n            const loader = pc[`${type}SegmentLoader_`];\n            const buffered = loader.buffered_();\n            const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);\n            this[`${type}Buffered_`] = buffered; // if another watcher is going to fix the issue or\n            // the buffered value for this loader changed\n            // appends are working\n\n            if (isBufferedDifferent) {\n                this.resetSegmentDownloads_(type);\n                return;\n            }\n            this[`${type}StalledDownloads_`]++;\n            this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {\n                playlistId: loader.playlist_ && loader.playlist_.id,\n                buffered: timeRangesToArray(buffered)\n            }); // after 10 possibly stalled appends with no reset, exclude\n\n            if (this[`${type}StalledDownloads_`] < 10) {\n                return;\n            }\n            this.logger_(`${type} loader stalled download exclusion`);\n            this.resetSegmentDownloads_(type);\n            this.tech_.trigger({\n                type: 'usage',\n                name: `vhs-${type}-download-exclusion`\n            });\n            if (type === 'subtitle') {\n                return;\n            } // TODO: should we exclude audio tracks rather than main tracks\n            // when type is audio?\n\n            pc.excludePlaylist({\n                error: {\n                    message: `Excessive ${type} segment downloading detected.`\n                },\n                playlistExclusionDuration: Infinity\n            });\n        }\n        /**\n         * The purpose of this function is to emulate the \"waiting\" event on\n         * browsers that do not emit it when they are waiting for more\n         * data to continue playback\n         *\n         * @private\n         */\n\n        checkCurrentTime_() {\n            if (this.tech_.paused() || this.tech_.seeking()) {\n                return;\n            }\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n                // If current time is at the end of the final buffered region, then any playback\n                // stall is most likely caused by buffering in a low bandwidth environment. The tech\n                // should fire a `waiting` event in this scenario, but due to browser and tech\n                // inconsistencies. Calling `techWaiting_` here allows us to simulate\n                // responding to a native `waiting` event when the tech fails to emit one.\n                return this.techWaiting_();\n            }\n            if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n                this.consecutiveUpdates++;\n                this.waiting_();\n            } else if (currentTime === this.lastRecordedTime) {\n                this.consecutiveUpdates++;\n            } else {\n                this.consecutiveUpdates = 0;\n                this.lastRecordedTime = currentTime;\n            }\n        }\n        /**\n         * Resets the 'timeupdate' mechanism designed to detect that we are stalled\n         *\n         * @private\n         */\n\n        resetTimeUpdate_() {\n            this.consecutiveUpdates = 0;\n        }\n        /**\n         * Fixes situations where there's a bad seek\n         *\n         * @return {boolean} whether an action was taken to fix the seek\n         * @private\n         */\n\n        fixesBadSeeks_() {\n            const seeking = this.tech_.seeking();\n            if (!seeking) {\n                return false;\n            } // TODO: It's possible that these seekable checks should be moved out of this function\n            // and into a function that runs on seekablechange. It's also possible that we only need\n            // afterSeekableWindow as the buffered check at the bottom is good enough to handle before\n            // seekable range.\n\n            const seekable = this.seekable();\n            const currentTime = this.tech_.currentTime();\n            const isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);\n            let seekTo;\n            if (isAfterSeekableRange) {\n                const seekableEnd = seekable.end(seekable.length - 1); // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n\n                seekTo = seekableEnd;\n            }\n            if (this.beforeSeekableWindow_(seekable, currentTime)) {\n                const seekableStart = seekable.start(0); // sync to the beginning of the live window\n                // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n\n                seekTo = seekableStart + (\n                    // if the playlist is too short and the seekable range is an exact time (can\n                    // happen in live with a 3 segment playlist), then don't use a time delta\n                    seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);\n            }\n            if (typeof seekTo !== 'undefined') {\n                this.logger_(`Trying to seek outside of seekable at time ${currentTime} with ` + `seekable range ${printableRange(seekable)}. Seeking to ` + `${seekTo}.`);\n                this.tech_.setCurrentTime(seekTo);\n                return true;\n            }\n            const sourceUpdater = this.playlistController_.sourceUpdater_;\n            const buffered = this.tech_.buffered();\n            const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;\n            const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;\n            const media = this.media(); // verify that at least two segment durations or one part duration have been\n            // appended before checking for a gap.\n\n            const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2; // verify that at least two segment durations have been\n            // appended before checking for a gap.\n\n            const bufferedToCheck = [audioBuffered, videoBuffered];\n            for (let i = 0; i < bufferedToCheck.length; i++) {\n                // skip null buffered\n                if (!bufferedToCheck[i]) {\n                    continue;\n                }\n                const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime); // if we are less than two video/audio segment durations or one part\n                // duration behind we haven't appended enough to call this a bad seek.\n\n                if (timeAhead < minAppendedDuration) {\n                    return false;\n                }\n            }\n            const nextRange = findNextRange(buffered, currentTime); // we have appended enough content, but we don't have anything buffered\n            // to seek over the gap\n\n            if (nextRange.length === 0) {\n                return false;\n            }\n            seekTo = nextRange.start(0) + SAFE_TIME_DELTA;\n            this.logger_(`Buffered region starts (${nextRange.start(0)}) ` + ` just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);\n            this.tech_.setCurrentTime(seekTo);\n            return true;\n        }\n        /**\n         * Handler for situations when we determine the player is waiting.\n         *\n         * @private\n         */\n\n        waiting_() {\n            if (this.techWaiting_()) {\n                return;\n            } // All tech waiting checks failed. Use last resort correction\n\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            const currentRange = findRange(buffered, currentTime); // Sometimes the player can stall for unknown reasons within a contiguous buffered\n            // region with no indication that anything is amiss (seen in Firefox). Seeking to\n            // currentTime is usually enough to kickstart the player. This checks that the player\n            // is currently within a buffered region before attempting a corrective seek.\n            // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n            // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n            // make sure there is ~3 seconds of forward buffer before taking any corrective action\n            // to avoid triggering an `unknownwaiting` event when the network is slow.\n\n            if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(currentTime);\n                this.logger_(`Stopped at ${currentTime} while inside a buffered region ` + `[${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume ` + 'playback by seeking to the current time.'); // unknown waiting corrections may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-unknown-waiting'\n                });\n                return;\n            }\n        }\n        /**\n         * Handler for situations when the tech fires a `waiting` event\n         *\n         * @return {boolean}\n         *         True if an action (or none) was needed to correct the waiting. False if no\n         *         checks passed\n         * @private\n         */\n\n        techWaiting_() {\n            const seekable = this.seekable();\n            const currentTime = this.tech_.currentTime();\n            if (this.tech_.seeking()) {\n                // Tech is seeking or already waiting on another action, no action needed\n                return true;\n            }\n            if (this.beforeSeekableWindow_(seekable, currentTime)) {\n                const livePoint = seekable.end(seekable.length - 1);\n                this.logger_(`Fell out of live window at time ${currentTime}. Seeking to ` + `live point (seekable end) ${livePoint}`);\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(livePoint); // live window resyncs may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-live-resync'\n                });\n                return true;\n            }\n            const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;\n            const buffered = this.tech_.buffered();\n            const videoUnderflow = this.videoUnderflow_({\n                audioBuffered: sourceUpdater.audioBuffered(),\n                videoBuffered: sourceUpdater.videoBuffered(),\n                currentTime\n            });\n            if (videoUnderflow) {\n                // Even though the video underflowed and was stuck in a gap, the audio overplayed\n                // the gap, leading currentTime into a buffered range. Seeking to currentTime\n                // allows the video to catch up to the audio position without losing any audio\n                // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(currentTime); // video underflow may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-video-underflow'\n                });\n                return true;\n            }\n            const nextRange = findNextRange(buffered, currentTime); // check for gap\n\n            if (nextRange.length > 0) {\n                this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);\n                this.resetTimeUpdate_();\n                this.skipTheGap_(currentTime);\n                return true;\n            } // All checks failed. Returning false to indicate failure to correct waiting\n\n            return false;\n        }\n        afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {\n            if (!seekable.length) {\n                // we can't make a solid case if there's no seekable, default to false\n                return false;\n            }\n            let allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;\n            const isLive = !playlist.endList;\n            const isLLHLS = typeof playlist.partTargetDuration === 'number';\n            if (isLive && (isLLHLS || allowSeeksWithinUnsafeLiveWindow)) {\n                allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;\n            }\n            if (currentTime > allowedEnd) {\n                return true;\n            }\n            return false;\n        }\n        beforeSeekableWindow_(seekable, currentTime) {\n            if (seekable.length &&\n                // can't fall before 0 and 0 seekable start identifies VOD stream\n                seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) {\n                return true;\n            }\n            return false;\n        }\n        videoUnderflow_({\n                            videoBuffered,\n                            audioBuffered,\n                            currentTime\n                        }) {\n            // audio only content will not have video underflow :)\n            if (!videoBuffered) {\n                return;\n            }\n            let gap; // find a gap in demuxed content.\n\n            if (videoBuffered.length && audioBuffered.length) {\n                // in Chrome audio will continue to play for ~3s when we run out of video\n                // so we have to check that the video buffer did have some buffer in the\n                // past.\n                const lastVideoRange = findRange(videoBuffered, currentTime - 3);\n                const videoRange = findRange(videoBuffered, currentTime);\n                const audioRange = findRange(audioBuffered, currentTime);\n                if (audioRange.length && !videoRange.length && lastVideoRange.length) {\n                    gap = {\n                        start: lastVideoRange.end(0),\n                        end: audioRange.end(0)\n                    };\n                } // find a gap in muxed content.\n            } else {\n                const nextRange = findNextRange(videoBuffered, currentTime); // Even if there is no available next range, there is still a possibility we are\n                // stuck in a gap due to video underflow.\n\n                if (!nextRange.length) {\n                    gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);\n                }\n            }\n            if (gap) {\n                this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. ` + `Seeking to current time ${currentTime}`);\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Timer callback. If playback still has not proceeded, then we seek\n         * to the start of the next buffered region.\n         *\n         * @private\n         */\n\n        skipTheGap_(scheduledCurrentTime) {\n            const buffered = this.tech_.buffered();\n            const currentTime = this.tech_.currentTime();\n            const nextRange = findNextRange(buffered, currentTime);\n            this.resetTimeUpdate_();\n            if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n                return;\n            }\n            this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0)); // only seek if we still have not played\n\n            this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\n            this.tech_.trigger({\n                type: 'usage',\n                name: 'vhs-gap-skip'\n            });\n        }\n        gapFromVideoUnderflow_(buffered, currentTime) {\n            // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n            // playing for ~3 seconds after the video gap starts. This is done to account for\n            // video buffer underflow/underrun (note that this is not done when there is audio\n            // buffer underflow/underrun -- in that case the video will stop as soon as it\n            // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n            // video stalls). The player's time will reflect the playthrough of audio, so the\n            // time will appear as if we are in a buffered region, even if we are stuck in a\n            // \"gap.\"\n            //\n            // Example:\n            // video buffer:   0 => 10.1, 10.2 => 20\n            // audio buffer:   0 => 20\n            // overall buffer: 0 => 10.1, 10.2 => 20\n            // current time: 13\n            //\n            // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n            // however, the audio continued playing until it reached ~3 seconds past the gap\n            // (13 seconds), at which point it stops as well. Since current time is past the\n            // gap, findNextRange will return no ranges.\n            //\n            // To check for this issue, we see if there is a gap that starts somewhere within\n            // a 3 second range (3 seconds +/- 1 second) back from our current time.\n            const gaps = findGaps(buffered);\n            for (let i = 0; i < gaps.length; i++) {\n                const start = gaps.start(i);\n                const end = gaps.end(i); // gap is starts no more than 4 seconds back\n\n                if (currentTime - start < 4 && currentTime - start > 2) {\n                    return {\n                        start,\n                        end\n                    };\n                }\n            }\n            return null;\n        }\n    }\n    const defaultOptions = {\n        errorInterval: 30,\n        getSource(next) {\n            const tech = this.tech({\n                IWillNotUseThisInPlugins: true\n            });\n            const sourceObj = tech.currentSource_ || this.currentSource();\n            return next(sourceObj);\n        }\n    };\n    /**\n     * Main entry point for the plugin\n     *\n     * @param {Player} player a reference to a videojs Player instance\n     * @param {Object} [options] an object with plugin options\n     * @private\n     */\n\n    const initPlugin = function (player, options) {\n        let lastCalled = 0;\n        let seekTo = 0;\n        const localOptions = merge(defaultOptions, options);\n        player.ready(() => {\n            player.trigger({\n                type: 'usage',\n                name: 'vhs-error-reload-initialized'\n            });\n        });\n        /**\n         * Player modifications to perform that must wait until `loadedmetadata`\n         * has been triggered\n         *\n         * @private\n         */\n\n        const loadedMetadataHandler = function () {\n            if (seekTo) {\n                player.currentTime(seekTo);\n            }\n        };\n        /**\n         * Set the source on the player element, play, and seek if necessary\n         *\n         * @param {Object} sourceObj An object specifying the source url and mime-type to play\n         * @private\n         */\n\n        const setSource = function (sourceObj) {\n            if (sourceObj === null || sourceObj === undefined) {\n                return;\n            }\n            seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n            player.one('loadedmetadata', loadedMetadataHandler);\n            player.src(sourceObj);\n            player.trigger({\n                type: 'usage',\n                name: 'vhs-error-reload'\n            });\n            player.play();\n        };\n        /**\n         * Attempt to get a source from either the built-in getSource function\n         * or a custom function provided via the options\n         *\n         * @private\n         */\n\n        const errorHandler = function () {\n            // Do not attempt to reload the source if a source-reload occurred before\n            // 'errorInterval' time has elapsed since the last source-reload\n            if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n                player.trigger({\n                    type: 'usage',\n                    name: 'vhs-error-reload-canceled'\n                });\n                return;\n            }\n            if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n                videojs.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n                return;\n            }\n            lastCalled = Date.now();\n            return localOptions.getSource.call(player, setSource);\n        };\n        /**\n         * Unbind any event handlers that were bound by the plugin\n         *\n         * @private\n         */\n\n        const cleanupEvents = function () {\n            player.off('loadedmetadata', loadedMetadataHandler);\n            player.off('error', errorHandler);\n            player.off('dispose', cleanupEvents);\n        };\n        /**\n         * Cleanup before re-initializing the plugin\n         *\n         * @param {Object} [newOptions] an object with plugin options\n         * @private\n         */\n\n        const reinitPlugin = function (newOptions) {\n            cleanupEvents();\n            initPlugin(player, newOptions);\n        };\n        player.on('error', errorHandler);\n        player.on('dispose', cleanupEvents); // Overwrite the plugin function so that we can correctly cleanup before\n        // initializing the plugin\n\n        player.reloadSourceOnError = reinitPlugin;\n    };\n    /**\n     * Reload the source when an error is detected as long as there\n     * wasn't an error previously within the last 30 seconds\n     *\n     * @param {Object} [options] an object with plugin options\n     */\n\n    const reloadSourceOnError = function (options) {\n        initPlugin(this, options);\n    };\n    var version$4 = \"3.10.0\";\n    var version$3 = \"7.0.2\";\n    var version$2 = \"1.3.0\";\n    var version$1 = \"7.1.0\";\n    var version = \"4.0.1\";\n\n    /**\n     * @file videojs-http-streaming.js\n     *\n     * The main file for the VHS project.\n     * License: https://github.com/videojs/videojs-http-streaming/blob/main/LICENSE\n     */\n    const Vhs = {\n        PlaylistLoader,\n        Playlist,\n        utils,\n        STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\n        INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\n        lastBandwidthSelector,\n        movingAverageBandwidthSelector,\n        comparePlaylistBandwidth,\n        comparePlaylistResolution,\n        xhr: xhrFactory()\n    }; // Define getter/setters for config properties\n\n    Object.keys(Config).forEach(prop => {\n        Object.defineProperty(Vhs, prop, {\n            get() {\n                videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n                return Config[prop];\n            },\n            set(value) {\n                videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n                if (typeof value !== 'number' || value < 0) {\n                    videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);\n                    return;\n                }\n                Config[prop] = value;\n            }\n        });\n    });\n    const LOCAL_STORAGE_KEY = 'videojs-vhs';\n    /**\n     * Updates the selectedIndex of the QualityLevelList when a mediachange happens in vhs.\n     *\n     * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n     * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n     * @function handleVhsMediaChange\n     */\n\n    const handleVhsMediaChange = function (qualityLevels, playlistLoader) {\n        const newPlaylist = playlistLoader.media();\n        let selectedIndex = -1;\n        for (let i = 0; i < qualityLevels.length; i++) {\n            if (qualityLevels[i].id === newPlaylist.id) {\n                selectedIndex = i;\n                break;\n            }\n        }\n        qualityLevels.selectedIndex_ = selectedIndex;\n        qualityLevels.trigger({\n            selectedIndex,\n            type: 'change'\n        });\n    };\n    /**\n     * Adds quality levels to list once playlist metadata is available\n     *\n     * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n     * @param {Object} vhs Vhs object to listen to for media events.\n     * @function handleVhsLoadedMetadata\n     */\n\n    const handleVhsLoadedMetadata = function (qualityLevels, vhs) {\n        vhs.representations().forEach(rep => {\n            qualityLevels.addQualityLevel(rep);\n        });\n        handleVhsMediaChange(qualityLevels, vhs.playlists);\n    }; // VHS is a source handler, not a tech. Make sure attempts to use it\n    // as one do not cause exceptions.\n\n    Vhs.canPlaySource = function () {\n        return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n    };\n    const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {\n        if (!keySystemOptions) {\n            return keySystemOptions;\n        }\n        let codecs = {};\n        if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {\n            codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));\n        }\n        if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {\n            codecs.audio = audioPlaylist.attributes.CODECS;\n        }\n        const videoContentType = getMimeForCodec(codecs.video);\n        const audioContentType = getMimeForCodec(codecs.audio); // upsert the content types based on the selected playlist\n\n        const keySystemContentTypes = {};\n        for (const keySystem in keySystemOptions) {\n            keySystemContentTypes[keySystem] = {};\n            if (audioContentType) {\n                keySystemContentTypes[keySystem].audioContentType = audioContentType;\n            }\n            if (videoContentType) {\n                keySystemContentTypes[keySystem].videoContentType = videoContentType;\n            } // Default to using the video playlist's PSSH even though they may be different, as\n            // videojs-contrib-eme will only accept one in the options.\n            //\n            // This shouldn't be an issue for most cases as early intialization will handle all\n            // unique PSSH values, and if they aren't, then encrypted events should have the\n            // specific information needed for the unique license.\n\n            if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {\n                keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;\n            } // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\n            // so we need to prevent overwriting the URL entirely\n\n            if (typeof keySystemOptions[keySystem] === 'string') {\n                keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\n            }\n        }\n        return merge(keySystemOptions, keySystemContentTypes);\n    };\n    /**\n     * @typedef {Object} KeySystems\n     *\n     * keySystems configuration for https://github.com/videojs/videojs-contrib-eme\n     * Note: not all options are listed here.\n     *\n     * @property {Uint8Array} [pssh]\n     *           Protection System Specific Header\n     */\n\n    /**\n     * Goes through all the playlists and collects an array of KeySystems options objects\n     * containing each playlist's keySystems and their pssh values, if available.\n     *\n     * @param {Object[]} playlists\n     *        The playlists to look through\n     * @param {string[]} keySystems\n     *        The keySystems to collect pssh values for\n     *\n     * @return {KeySystems[]}\n     *         An array of KeySystems objects containing available key systems and their\n     *         pssh values\n     */\n\n    const getAllPsshKeySystemsOptions = (playlists, keySystems) => {\n        return playlists.reduce((keySystemsArr, playlist) => {\n            if (!playlist.contentProtection) {\n                return keySystemsArr;\n            }\n            const keySystemsOptions = keySystems.reduce((keySystemsObj, keySystem) => {\n                const keySystemOptions = playlist.contentProtection[keySystem];\n                if (keySystemOptions && keySystemOptions.pssh) {\n                    keySystemsObj[keySystem] = {\n                        pssh: keySystemOptions.pssh\n                    };\n                }\n                return keySystemsObj;\n            }, {});\n            if (Object.keys(keySystemsOptions).length) {\n                keySystemsArr.push(keySystemsOptions);\n            }\n            return keySystemsArr;\n        }, []);\n    };\n    /**\n     * Returns a promise that waits for the\n     * [eme plugin](https://github.com/videojs/videojs-contrib-eme) to create a key session.\n     *\n     * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449 in non-IE11\n     * browsers.\n     *\n     * As per the above ticket, this is particularly important for Chrome, where, if\n     * unencrypted content is appended before encrypted content and the key session has not\n     * been created, a MEDIA_ERR_DECODE will be thrown once the encrypted content is reached\n     * during playback.\n     *\n     * @param {Object} player\n     *        The player instance\n     * @param {Object[]} sourceKeySystems\n     *        The key systems options from the player source\n     * @param {Object} [audioMedia]\n     *        The active audio media playlist (optional)\n     * @param {Object[]} mainPlaylists\n     *        The playlists found on the main playlist object\n     *\n     * @return {Object}\n     *         Promise that resolves when the key session has been created\n     */\n\n    const waitForKeySessionCreation = ({\n                                           player,\n                                           sourceKeySystems,\n                                           audioMedia,\n                                           mainPlaylists\n                                       }) => {\n        if (!player.eme.initializeMediaKeys) {\n            return Promise.resolve();\n        } // TODO should all audio PSSH values be initialized for DRM?\n        //\n        // All unique video rendition pssh values are initialized for DRM, but here only\n        // the initial audio playlist license is initialized. In theory, an encrypted\n        // event should be fired if the user switches to an alternative audio playlist\n        // where a license is required, but this case hasn't yet been tested. In addition, there\n        // may be many alternate audio playlists unlikely to be used (e.g., multiple different\n        // languages).\n\n        const playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;\n        const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));\n        const initializationFinishedPromises = [];\n        const keySessionCreatedPromises = []; // Since PSSH values are interpreted as initData, EME will dedupe any duplicates. The\n        // only place where it should not be deduped is for ms-prefixed APIs, but\n        // the existence of modern EME APIs in addition to\n        // ms-prefixed APIs on Edge should prevent this from being a concern.\n        // initializeMediaKeys also won't use the webkit-prefixed APIs.\n\n        keySystemsOptionsArr.forEach(keySystemsOptions => {\n            keySessionCreatedPromises.push(new Promise((resolve, reject) => {\n                player.tech_.one('keysessioncreated', resolve);\n            }));\n            initializationFinishedPromises.push(new Promise((resolve, reject) => {\n                player.eme.initializeMediaKeys({\n                    keySystems: keySystemsOptions\n                }, err => {\n                    if (err) {\n                        reject(err);\n                        return;\n                    }\n                    resolve();\n                });\n            }));\n        }); // The reasons Promise.race is chosen over Promise.any:\n        //\n        // * Promise.any is only available in Safari 14+.\n        // * None of these promises are expected to reject. If they do reject, it might be\n        //   better here for the race to surface the rejection, rather than mask it by using\n        //   Promise.any.\n\n        return Promise.race([\n            // If a session was previously created, these will all finish resolving without\n            // creating a new session, otherwise it will take until the end of all license\n            // requests, which is why the key session check is used (to make setup much faster).\n            Promise.all(initializationFinishedPromises),\n            // Once a single session is created, the browser knows DRM will be used.\n            Promise.race(keySessionCreatedPromises)]);\n    };\n    /**\n     * If the [eme](https://github.com/videojs/videojs-contrib-eme) plugin is available, and\n     * there are keySystems on the source, sets up source options to prepare the source for\n     * eme.\n     *\n     * @param {Object} player\n     *        The player instance\n     * @param {Object[]} sourceKeySystems\n     *        The key systems options from the player source\n     * @param {Object} media\n     *        The active media playlist\n     * @param {Object} [audioMedia]\n     *        The active audio media playlist (optional)\n     *\n     * @return {boolean}\n     *         Whether or not options were configured and EME is available\n     */\n\n    const setupEmeOptions = ({\n                                 player,\n                                 sourceKeySystems,\n                                 media,\n                                 audioMedia\n                             }) => {\n        const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);\n        if (!sourceOptions) {\n            return false;\n        }\n        player.currentSource().keySystems = sourceOptions; // eme handles the rest of the setup, so if it is missing\n        // do nothing.\n\n        if (sourceOptions && !player.eme) {\n            videojs.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');\n            return false;\n        }\n        return true;\n    };\n    const getVhsLocalStorage = () => {\n        if (!window.localStorage) {\n            return null;\n        }\n        const storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n        if (!storedObject) {\n            return null;\n        }\n        try {\n            return JSON.parse(storedObject);\n        } catch (e) {\n            // someone may have tampered with the value\n            return null;\n        }\n    };\n    const updateVhsLocalStorage = options => {\n        if (!window.localStorage) {\n            return false;\n        }\n        let objectToStore = getVhsLocalStorage();\n        objectToStore = objectToStore ? merge(objectToStore, options) : options;\n        try {\n            window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));\n        } catch (e) {\n            // Throws if storage is full (e.g., always on iOS 5+ Safari private mode, where\n            // storage is set to 0).\n            // https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem#Exceptions\n            // No need to perform any operation.\n            return false;\n        }\n        return objectToStore;\n    };\n    /**\n     * Parses VHS-supported media types from data URIs. See\n     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n     * for information on data URIs.\n     *\n     * @param {string} dataUri\n     *        The data URI\n     *\n     * @return {string|Object}\n     *         The parsed object/string, or the original string if no supported media type\n     *         was found\n     */\n\n    const expandDataUri = dataUri => {\n        if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {\n            return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));\n        } // no known case for this data URI, return the string as-is\n\n        return dataUri;\n    };\n    /**\n     * Adds a request hook to an xhr object\n     *\n     * @param {Object} xhr object to add the onRequest hook to\n     * @param {function} callback hook function for an xhr request\n     */\n\n    const addOnRequestHook = (xhr, callback) => {\n        if (!xhr._requestCallbackSet) {\n            xhr._requestCallbackSet = new Set();\n        }\n        xhr._requestCallbackSet.add(callback);\n    };\n    /**\n     * Adds a response hook to an xhr object\n     *\n     * @param {Object} xhr object to add the onResponse hook to\n     * @param {function} callback hook function for an xhr response\n     */\n\n    const addOnResponseHook = (xhr, callback) => {\n        if (!xhr._responseCallbackSet) {\n            xhr._responseCallbackSet = new Set();\n        }\n        xhr._responseCallbackSet.add(callback);\n    };\n    /**\n     * Removes a request hook on an xhr object, deletes the onRequest set if empty.\n     *\n     * @param {Object} xhr object to remove the onRequest hook from\n     * @param {function} callback hook function to remove\n     */\n\n    const removeOnRequestHook = (xhr, callback) => {\n        if (!xhr._requestCallbackSet) {\n            return;\n        }\n        xhr._requestCallbackSet.delete(callback);\n        if (!xhr._requestCallbackSet.size) {\n            delete xhr._requestCallbackSet;\n        }\n    };\n    /**\n     * Removes a response hook on an xhr object, deletes the onResponse set if empty.\n     *\n     * @param {Object} xhr object to remove the onResponse hook from\n     * @param {function} callback hook function to remove\n     */\n\n    const removeOnResponseHook = (xhr, callback) => {\n        if (!xhr._responseCallbackSet) {\n            return;\n        }\n        xhr._responseCallbackSet.delete(callback);\n        if (!xhr._responseCallbackSet.size) {\n            delete xhr._responseCallbackSet;\n        }\n    };\n    /**\n     * Whether the browser has built-in HLS support.\n     */\n\n    Vhs.supportsNativeHls = function () {\n        if (!document || !document.createElement) {\n            return false;\n        }\n        const video = document.createElement('video'); // native HLS is definitely not supported if HTML5 video isn't\n\n        if (!videojs.getTech('Html5').isSupported()) {\n            return false;\n        } // HLS manifests can go by many mime-types\n\n        const canPlay = [\n            // Apple santioned\n            'application/vnd.apple.mpegurl',\n            // Apple sanctioned for backwards compatibility\n            'audio/mpegurl',\n            // Very common\n            'audio/x-mpegurl',\n            // Very common\n            'application/x-mpegurl',\n            // Included for completeness\n            'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n        return canPlay.some(function (canItPlay) {\n            return /maybe|probably/i.test(video.canPlayType(canItPlay));\n        });\n    }();\n    Vhs.supportsNativeDash = function () {\n        if (!document || !document.createElement || !videojs.getTech('Html5').isSupported()) {\n            return false;\n        }\n        return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));\n    }();\n    Vhs.supportsTypeNatively = type => {\n        if (type === 'hls') {\n            return Vhs.supportsNativeHls;\n        }\n        if (type === 'dash') {\n            return Vhs.supportsNativeDash;\n        }\n        return false;\n    };\n    /**\n     * VHS is a source handler, not a tech. Make sure attempts to use it\n     * as one do not cause exceptions.\n     */\n\n    Vhs.isSupported = function () {\n        return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n    };\n    /**\n     * A global function for setting an onRequest hook\n     *\n     * @param {function} callback for request modifiction\n     */\n\n    Vhs.xhr.onRequest = function (callback) {\n        addOnRequestHook(Vhs.xhr, callback);\n    };\n    /**\n     * A global function for setting an onResponse hook\n     *\n     * @param {callback} callback for response data retrieval\n     */\n\n    Vhs.xhr.onResponse = function (callback) {\n        addOnResponseHook(Vhs.xhr, callback);\n    };\n    /**\n     * Deletes a global onRequest callback if it exists\n     *\n     * @param {function} callback to delete from the global set\n     */\n\n    Vhs.xhr.offRequest = function (callback) {\n        removeOnRequestHook(Vhs.xhr, callback);\n    };\n    /**\n     * Deletes a global onResponse callback if it exists\n     *\n     * @param {function} callback to delete from the global set\n     */\n\n    Vhs.xhr.offResponse = function (callback) {\n        removeOnResponseHook(Vhs.xhr, callback);\n    };\n    const Component = videojs.getComponent('Component');\n    /**\n     * The Vhs Handler object, where we orchestrate all of the parts\n     * of VHS to interact with video.js\n     *\n     * @class VhsHandler\n     * @extends videojs.Component\n     * @param {Object} source the soruce object\n     * @param {Tech} tech the parent tech object\n     * @param {Object} options optional and required options\n     */\n\n    class VhsHandler extends Component {\n        constructor(source, tech, options) {\n            super(tech, options.vhs); // if a tech level `initialBandwidth` option was passed\n            // use that over the VHS level `bandwidth` option\n\n            if (typeof options.initialBandwidth === 'number') {\n                this.options_.bandwidth = options.initialBandwidth;\n            }\n            this.logger_ = logger('VhsHandler'); // we need access to the player in some cases,\n            // so, get it from Video.js via the `playerId`\n\n            if (tech.options_ && tech.options_.playerId) {\n                const _player = videojs.getPlayer(tech.options_.playerId);\n                this.player_ = _player;\n            }\n            this.tech_ = tech;\n            this.source_ = source;\n            this.stats = {};\n            this.ignoreNextSeekingEvent_ = false;\n            this.setOptions_();\n            if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\n                tech.overrideNativeAudioTracks(true);\n                tech.overrideNativeVideoTracks(true);\n            } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n                // overriding native VHS only works if audio tracks have been emulated\n                // error early if we're misconfigured\n                throw new Error('Overriding native VHS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n            } // listen for fullscreenchange events for this player so that we\n            // can adjust our quality selection quickly\n\n            this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], event => {\n                const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n                if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) {\n                    this.playlistController_.fastQualityChange_();\n                } else {\n                    // When leaving fullscreen, since the in page pixel dimensions should be smaller\n                    // than full screen, see if there should be a rendition switch down to preserve\n                    // bandwidth.\n                    this.playlistController_.checkABR_();\n                }\n            });\n            this.on(this.tech_, 'seeking', function () {\n                if (this.ignoreNextSeekingEvent_) {\n                    this.ignoreNextSeekingEvent_ = false;\n                    return;\n                }\n                this.setCurrentTime(this.tech_.currentTime());\n            });\n            this.on(this.tech_, 'error', function () {\n                // verify that the error was real and we are loaded\n                // enough to have pc loaded.\n                if (this.tech_.error() && this.playlistController_) {\n                    this.playlistController_.pauseLoading();\n                }\n            });\n            this.on(this.tech_, 'play', this.play);\n        }\n        /**\n         * Set VHS options based on options from configuration, as well as partial\n         * options to be passed at a later time.\n         *\n         * @param {Object} options A partial chunk of config options\n         */\n\n        setOptions_(options = {}) {\n            this.options_ = merge(this.options_, options); // defaults\n\n            this.options_.withCredentials = this.options_.withCredentials || false;\n            this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;\n            this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;\n            this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;\n            this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || false;\n            this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;\n            this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;\n            this.options_.customTagParsers = this.options_.customTagParsers || [];\n            this.options_.customTagMappers = this.options_.customTagMappers || [];\n            this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;\n            this.options_.llhls = this.options_.llhls === false ? false : true;\n            this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;\n            if (typeof this.options_.playlistExclusionDuration !== 'number') {\n                this.options_.playlistExclusionDuration = 60;\n            }\n            if (typeof this.options_.bandwidth !== 'number') {\n                if (this.options_.useBandwidthFromLocalStorage) {\n                    const storedObject = getVhsLocalStorage();\n                    if (storedObject && storedObject.bandwidth) {\n                        this.options_.bandwidth = storedObject.bandwidth;\n                        this.tech_.trigger({\n                            type: 'usage',\n                            name: 'vhs-bandwidth-from-local-storage'\n                        });\n                    }\n                    if (storedObject && storedObject.throughput) {\n                        this.options_.throughput = storedObject.throughput;\n                        this.tech_.trigger({\n                            type: 'usage',\n                            name: 'vhs-throughput-from-local-storage'\n                        });\n                    }\n                }\n            } // if bandwidth was not set by options or pulled from local storage, start playlist\n            // selection at a reasonable bandwidth\n\n            if (typeof this.options_.bandwidth !== 'number') {\n                this.options_.bandwidth = Config.INITIAL_BANDWIDTH;\n            } // If the bandwidth number is unchanged from the initial setting\n            // then this takes precedence over the enableLowInitialPlaylist option\n\n            this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH; // grab options passed to player.src\n\n            ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'customTagParsers', 'customTagMappers', 'cacheEncryptionKeys', 'playlistSelector', 'initialPlaylistSelector', 'bufferBasedABR', 'liveRangeSafeTimeDelta', 'llhls', 'useForcedSubtitles', 'useNetworkInformationApi', 'useDtsForTimestampOffset', 'exactManifestTimings', 'leastPixelDiffSelector'].forEach(option => {\n                if (typeof this.source_[option] !== 'undefined') {\n                    this.options_[option] = this.source_[option];\n                }\n            });\n            this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;\n            this.useDevicePixelRatio = this.options_.useDevicePixelRatio;\n        } // alias for public method to set options\n\n        setOptions(options = {}) {\n            this.setOptions_(options);\n        }\n        /**\n         * called when player.src gets called, handle a new source\n         *\n         * @param {Object} src the source object to handle\n         */\n\n        src(src, type) {\n            // do nothing if the src is falsey\n            if (!src) {\n                return;\n            }\n            this.setOptions_(); // add main playlist controller options\n\n            this.options_.src = expandDataUri(this.source_.src);\n            this.options_.tech = this.tech_;\n            this.options_.externVhs = Vhs;\n            this.options_.sourceType = simpleTypeFromSourceType(type); // Whenever we seek internally, we should update the tech\n\n            this.options_.seekTo = time => {\n                this.tech_.setCurrentTime(time);\n            };\n            this.playlistController_ = new PlaylistController(this.options_);\n            const playbackWatcherOptions = merge({\n                liveRangeSafeTimeDelta: SAFE_TIME_DELTA\n            }, this.options_, {\n                seekable: () => this.seekable(),\n                media: () => this.playlistController_.media(),\n                playlistController: this.playlistController_\n            });\n            this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);\n            this.playlistController_.on('error', () => {\n                const player = videojs.players[this.tech_.options_.playerId];\n                let error = this.playlistController_.error;\n                if (typeof error === 'object' && !error.code) {\n                    error.code = 3;\n                } else if (typeof error === 'string') {\n                    error = {\n                        message: error,\n                        code: 3\n                    };\n                }\n                player.error(error);\n            });\n            const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR; // `this` in selectPlaylist should be the VhsHandler for backwards\n            // compatibility with < v2\n\n            this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);\n            this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this); // re-expose some internal objects for backwards compatibility with < v2\n\n            this.playlists = this.playlistController_.mainPlaylistLoader_;\n            this.mediaSource = this.playlistController_.mediaSource; // Proxy assignment of some properties to the main playlist\n            // controller. Using a custom property for backwards compatibility\n            // with < v2\n\n            Object.defineProperties(this, {\n                selectPlaylist: {\n                    get() {\n                        return this.playlistController_.selectPlaylist;\n                    },\n                    set(selectPlaylist) {\n                        this.playlistController_.selectPlaylist = selectPlaylist.bind(this);\n                    }\n                },\n                throughput: {\n                    get() {\n                        return this.playlistController_.mainSegmentLoader_.throughput.rate;\n                    },\n                    set(throughput) {\n                        this.playlistController_.mainSegmentLoader_.throughput.rate = throughput; // By setting `count` to 1 the throughput value becomes the starting value\n                        // for the cumulative average\n\n                        this.playlistController_.mainSegmentLoader_.throughput.count = 1;\n                    }\n                },\n                bandwidth: {\n                    get() {\n                        let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;\n                        const networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\n                        const tenMbpsAsBitsPerSecond = 10e6;\n                        if (this.options_.useNetworkInformationApi && networkInformation) {\n                            // downlink returns Mbps\n                            // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlink\n                            const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1000 * 1000; // downlink maxes out at 10 Mbps. In the event that both networkInformationApi and the player\n                            // estimate a bandwidth greater than 10 Mbps, use the larger of the two estimates to ensure that\n                            // high quality streams are not filtered out.\n\n                            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {\n                                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);\n                            } else {\n                                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;\n                            }\n                        }\n                        return playerBandwidthEst;\n                    },\n                    set(bandwidth) {\n                        this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth; // setting the bandwidth manually resets the throughput counter\n                        // `count` is set to zero that current value of `rate` isn't included\n                        // in the cumulative average\n\n                        this.playlistController_.mainSegmentLoader_.throughput = {\n                            rate: 0,\n                            count: 0\n                        };\n                    }\n                },\n                /**\n                 * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n                 * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n                 * the entire process after that - decryption, transmuxing, and appending - provided\n                 * by `throughput`.\n                 *\n                 * Since the two process are serial, the overall system bandwidth is given by:\n                 *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n                 */\n                systemBandwidth: {\n                    get() {\n                        const invBandwidth = 1 / (this.bandwidth || 1);\n                        let invThroughput;\n                        if (this.throughput > 0) {\n                            invThroughput = 1 / this.throughput;\n                        } else {\n                            invThroughput = 0;\n                        }\n                        const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n                        return systemBitrate;\n                    },\n                    set() {\n                        videojs.log.error('The \"systemBandwidth\" property is read-only');\n                    }\n                }\n            });\n            if (this.options_.bandwidth) {\n                this.bandwidth = this.options_.bandwidth;\n            }\n            if (this.options_.throughput) {\n                this.throughput = this.options_.throughput;\n            }\n            Object.defineProperties(this.stats, {\n                bandwidth: {\n                    get: () => this.bandwidth || 0,\n                    enumerable: true\n                },\n                mediaRequests: {\n                    get: () => this.playlistController_.mediaRequests_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsAborted: {\n                    get: () => this.playlistController_.mediaRequestsAborted_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsTimedout: {\n                    get: () => this.playlistController_.mediaRequestsTimedout_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsErrored: {\n                    get: () => this.playlistController_.mediaRequestsErrored_() || 0,\n                    enumerable: true\n                },\n                mediaTransferDuration: {\n                    get: () => this.playlistController_.mediaTransferDuration_() || 0,\n                    enumerable: true\n                },\n                mediaBytesTransferred: {\n                    get: () => this.playlistController_.mediaBytesTransferred_() || 0,\n                    enumerable: true\n                },\n                mediaSecondsLoaded: {\n                    get: () => this.playlistController_.mediaSecondsLoaded_() || 0,\n                    enumerable: true\n                },\n                mediaAppends: {\n                    get: () => this.playlistController_.mediaAppends_() || 0,\n                    enumerable: true\n                },\n                mainAppendsToLoadedData: {\n                    get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                audioAppendsToLoadedData: {\n                    get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                appendsToLoadedData: {\n                    get: () => this.playlistController_.appendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                timeToLoadedData: {\n                    get: () => this.playlistController_.timeToLoadedData_() || 0,\n                    enumerable: true\n                },\n                buffered: {\n                    get: () => timeRangesToArray(this.tech_.buffered()),\n                    enumerable: true\n                },\n                currentTime: {\n                    get: () => this.tech_.currentTime(),\n                    enumerable: true\n                },\n                currentSource: {\n                    get: () => this.tech_.currentSource_,\n                    enumerable: true\n                },\n                currentTech: {\n                    get: () => this.tech_.name_,\n                    enumerable: true\n                },\n                duration: {\n                    get: () => this.tech_.duration(),\n                    enumerable: true\n                },\n                main: {\n                    get: () => this.playlists.main,\n                    enumerable: true\n                },\n                playerDimensions: {\n                    get: () => this.tech_.currentDimensions(),\n                    enumerable: true\n                },\n                seekable: {\n                    get: () => timeRangesToArray(this.tech_.seekable()),\n                    enumerable: true\n                },\n                timestamp: {\n                    get: () => Date.now(),\n                    enumerable: true\n                },\n                videoPlaybackQuality: {\n                    get: () => this.tech_.getVideoPlaybackQuality(),\n                    enumerable: true\n                }\n            });\n            this.tech_.one('canplay', this.playlistController_.setupFirstPlay.bind(this.playlistController_));\n            this.tech_.on('bandwidthupdate', () => {\n                if (this.options_.useBandwidthFromLocalStorage) {\n                    updateVhsLocalStorage({\n                        bandwidth: this.bandwidth,\n                        throughput: Math.round(this.throughput)\n                    });\n                }\n            });\n            this.playlistController_.on('selectedinitialmedia', () => {\n                // Add the manual rendition mix-in to VhsHandler\n                renditionSelectionMixin(this);\n            });\n            this.playlistController_.sourceUpdater_.on('createdsourcebuffers', () => {\n                this.setupEme_();\n            }); // the bandwidth of the primary segment loader is our best\n            // estimate of overall bandwidth\n\n            this.on(this.playlistController_, 'progress', function () {\n                this.tech_.trigger('progress');\n            }); // In the live case, we need to ignore the very first `seeking` event since\n            // that will be the result of the seek-to-live behavior\n\n            this.on(this.playlistController_, 'firstplay', function () {\n                this.ignoreNextSeekingEvent_ = true;\n            });\n            this.setupQualityLevels_(); // do nothing if the tech has been disposed already\n            // this can occur if someone sets the src in player.ready(), for instance\n\n            if (!this.tech_.el()) {\n                return;\n            }\n            this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource);\n            this.tech_.src(this.mediaSourceUrl_);\n        }\n        createKeySessions_() {\n            const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n            this.logger_('waiting for EME key session creation');\n            waitForKeySessionCreation({\n                player: this.player_,\n                sourceKeySystems: this.source_.keySystems,\n                audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),\n                mainPlaylists: this.playlists.main.playlists\n            }).then(() => {\n                this.logger_('created EME key session');\n                this.playlistController_.sourceUpdater_.initializedEme();\n            }).catch(err => {\n                this.logger_('error while creating EME key session', err);\n                this.player_.error({\n                    message: 'Failed to initialize media keys for EME',\n                    code: 3\n                });\n            });\n        }\n        handleWaitingForKey_() {\n            // If waitingforkey is fired, it's possible that the data that's necessary to retrieve\n            // the key is in the manifest. While this should've happened on initial source load, it\n            // may happen again in live streams where the keys change, and the manifest info\n            // reflects the update.\n            //\n            // Because videojs-contrib-eme compares the PSSH data we send to that of PSSH data it's\n            // already requested keys for, we don't have to worry about this generating extraneous\n            // requests.\n            this.logger_('waitingforkey fired, attempting to create any new key sessions');\n            this.createKeySessions_();\n        }\n        /**\n         * If necessary and EME is available, sets up EME options and waits for key session\n         * creation.\n         *\n         * This function also updates the source updater so taht it can be used, as for some\n         * browsers, EME must be configured before content is appended (if appending unencrypted\n         * content before encrypted content).\n         */\n\n        setupEme_() {\n            const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n            const didSetupEmeOptions = setupEmeOptions({\n                player: this.player_,\n                sourceKeySystems: this.source_.keySystems,\n                media: this.playlists.media(),\n                audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()\n            });\n            this.player_.tech_.on('keystatuschange', e => {\n                this.playlistController_.updatePlaylistByKeyStatus(e.keyId, e.status);\n            });\n            this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);\n            this.player_.tech_.on('waitingforkey', this.handleWaitingForKey_);\n            if (!didSetupEmeOptions) {\n                // If EME options were not set up, we've done all we could to initialize EME.\n                this.playlistController_.sourceUpdater_.initializedEme();\n                return;\n            }\n            this.createKeySessions_();\n        }\n        /**\n         * Initializes the quality levels and sets listeners to update them.\n         *\n         * @method setupQualityLevels_\n         * @private\n         */\n\n        setupQualityLevels_() {\n            const player = videojs.players[this.tech_.options_.playerId]; // if there isn't a player or there isn't a qualityLevels plugin\n            // or qualityLevels_ listeners have already been setup, do nothing.\n\n            if (!player || !player.qualityLevels || this.qualityLevels_) {\n                return;\n            }\n            this.qualityLevels_ = player.qualityLevels();\n            this.playlistController_.on('selectedinitialmedia', () => {\n                handleVhsLoadedMetadata(this.qualityLevels_, this);\n            });\n            this.playlists.on('mediachange', () => {\n                handleVhsMediaChange(this.qualityLevels_, this.playlists);\n            });\n        }\n        /**\n         * return the version\n         */\n\n        static version() {\n            return {\n                '@videojs/http-streaming': version$4,\n                'mux.js': version$3,\n                'mpd-parser': version$2,\n                'm3u8-parser': version$1,\n                'aes-decrypter': version\n            };\n        }\n        /**\n         * return the version\n         */\n\n        version() {\n            return this.constructor.version();\n        }\n        canChangeType() {\n            return SourceUpdater.canChangeType();\n        }\n        /**\n         * Begin playing the video.\n         */\n\n        play() {\n            this.playlistController_.play();\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        setCurrentTime(currentTime) {\n            this.playlistController_.setCurrentTime(currentTime);\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        duration() {\n            return this.playlistController_.duration();\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        seekable() {\n            return this.playlistController_.seekable();\n        }\n        /**\n         * Abort all outstanding work and cleanup.\n         */\n\n        dispose() {\n            if (this.playbackWatcher_) {\n                this.playbackWatcher_.dispose();\n            }\n            if (this.playlistController_) {\n                this.playlistController_.dispose();\n            }\n            if (this.qualityLevels_) {\n                this.qualityLevels_.dispose();\n            }\n            if (this.tech_ && this.tech_.vhs) {\n                delete this.tech_.vhs;\n            }\n            if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {\n                window.URL.revokeObjectURL(this.mediaSourceUrl_);\n                this.mediaSourceUrl_ = null;\n            }\n            if (this.tech_) {\n                this.tech_.off('waitingforkey', this.handleWaitingForKey_);\n            }\n            super.dispose();\n        }\n        convertToProgramTime(time, callback) {\n            return getProgramTime({\n                playlist: this.playlistController_.media(),\n                time,\n                callback\n            });\n        } // the player must be playing before calling this\n\n        seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {\n            return seekToProgramTime({\n                programTime,\n                playlist: this.playlistController_.media(),\n                retryCount,\n                pauseAfterSeek,\n                seekTo: this.options_.seekTo,\n                tech: this.options_.tech,\n                callback\n            });\n        }\n        /**\n         * Adds the onRequest, onResponse, offRequest and offResponse functions\n         * to the VhsHandler xhr Object.\n         */\n\n        setupXhrHooks_() {\n            /**\n             * A player function for setting an onRequest hook\n             *\n             * @param {function} callback for request modifiction\n             */\n            this.xhr.onRequest = callback => {\n                addOnRequestHook(this.xhr, callback);\n            };\n            /**\n             * A player function for setting an onResponse hook\n             *\n             * @param {callback} callback for response data retrieval\n             */\n\n            this.xhr.onResponse = callback => {\n                addOnResponseHook(this.xhr, callback);\n            };\n            /**\n             * Deletes a player onRequest callback if it exists\n             *\n             * @param {function} callback to delete from the player set\n             */\n\n            this.xhr.offRequest = callback => {\n                removeOnRequestHook(this.xhr, callback);\n            };\n            /**\n             * Deletes a player onResponse callback if it exists\n             *\n             * @param {function} callback to delete from the player set\n             */\n\n            this.xhr.offResponse = callback => {\n                removeOnResponseHook(this.xhr, callback);\n            }; // Trigger an event on the player to notify the user that vhs is ready to set xhr hooks.\n            // This allows hooks to be set before the source is set to vhs when handleSource is called.\n\n            this.player_.trigger('xhr-hooks-ready');\n        }\n    }\n    /**\n     * The Source Handler object, which informs video.js what additional\n     * MIME types are supported and sets up playback. It is registered\n     * automatically to the appropriate tech based on the capabilities of\n     * the browser it is running in. It is not necessary to use or modify\n     * this object in normal usage.\n     */\n\n    const VhsSourceHandler = {\n        name: 'videojs-http-streaming',\n        VERSION: version$4,\n        canHandleSource(srcObj, options = {}) {\n            const localOptions = merge(videojs.options, options);\n            return VhsSourceHandler.canPlayType(srcObj.type, localOptions);\n        },\n        handleSource(source, tech, options = {}) {\n            const localOptions = merge(videojs.options, options);\n            tech.vhs = new VhsHandler(source, tech, localOptions);\n            tech.vhs.xhr = xhrFactory();\n            tech.vhs.setupXhrHooks_();\n            tech.vhs.src(source.src, source.type);\n            return tech.vhs;\n        },\n        canPlayType(type, options) {\n            const simpleType = simpleTypeFromSourceType(type);\n            if (!simpleType) {\n                return '';\n            }\n            const overrideNative = VhsSourceHandler.getOverrideNative(options);\n            const supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);\n            const canUseMsePlayback = !supportsTypeNatively || overrideNative;\n            return canUseMsePlayback ? 'maybe' : '';\n        },\n        getOverrideNative(options = {}) {\n            const {\n                vhs = {}\n            } = options;\n            const defaultOverrideNative = !(videojs.browser.IS_ANY_SAFARI || videojs.browser.IS_IOS);\n            const {\n                overrideNative = defaultOverrideNative\n            } = vhs;\n            return overrideNative;\n        }\n    };\n    /**\n     * Check to see if the native MediaSource object exists and supports\n     * an MP4 container with both H.264 video and AAC-LC audio.\n     *\n     * @return {boolean} if  native media sources are supported\n     */\n\n    const supportsNativeMediaSources = () => {\n        return browserSupportsCodec('avc1.4d400d,mp4a.40.2');\n    }; // register source handlers with the appropriate techs\n\n    if (supportsNativeMediaSources()) {\n        videojs.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);\n    }\n    videojs.VhsHandler = VhsHandler;\n    videojs.VhsSourceHandler = VhsSourceHandler;\n    videojs.Vhs = Vhs;\n    if (!videojs.use) {\n        videojs.registerComponent('Vhs', Vhs);\n    }\n    videojs.options.vhs = videojs.options.vhs || {};\n    if (!videojs.getPlugin || !videojs.getPlugin('reloadSourceOnError')) {\n        videojs.registerPlugin('reloadSourceOnError', reloadSourceOnError);\n    }\n\n    return videojs;\n\n}));\n"],"names":["global","factory","exports","module","define","amd","globalThis","self","videojs","this","hooks_","hooks","type","fn","concat","removeHook","index","indexOf","slice","splice","FullscreenApi","prefixed","apiMap","specApi","browserApi","i","length","document","history","LogByTypeFactory","name","log","styles","level","args","lvl","levels","lvlRegExp","RegExp","resultName","unshift","toUpperCase","push","window","console","info","test","Array","isArray","log$1","createLogger$1","logByType","delimiter","createLogger","subName","subDelimiter","subStyles","resultDelimiter","undefined","resultStyles","createNewLogger","newName","newDelimiter","newStyles","all","off","debug","warn","error","DEFAULT","hasOwnProperty","Error","filter","fname","historyItem","clear","disable","enable","toString$1","Object","prototype","toString","keys","object","isObject$1","each","forEach","key","reduce","initial","accum","value","isPlain","call","constructor","merge$2","result","sources","source","values$1","defineLazyProperty","obj","getValue","setter","set","defineProperty","enumerable","writable","options","configurable","get","Obj","freeze","__proto__","isObject","merge","values","ANDROID_VERSION","IS_IPOD","IOS_VERSION","IS_ANDROID","IS_FIREFOX","IS_EDGE","IS_CHROMIUM","IS_CHROME","CHROMIUM_VERSION","CHROME_VERSION","IE_VERSION","IS_SAFARI","IS_WINDOWS","IS_IPAD","IS_IPHONE","TOUCH_ENABLED","Boolean","isReal","navigator","maxTouchPoints","DocumentTouch","UAD","userAgentData","platform","brands","find","b","brand","version","USER_AGENT","userAgent","match","major","parseFloat","minor","exec","IS_IOS","IS_ANY_SAFARI","browser","isNonBlankString","str","trim","isEl","nodeType","isInFrame","parent","x","createQuerier","method","selector","context","querySelector","ctx","createEl","tagName","properties","attributes","content","el","createElement","getOwnPropertyNames","propName","val","textContent","attrName","setAttribute","appendContent","text","innerText","prependTo","child","firstChild","insertBefore","appendChild","hasClass","element","classToCheck","throwIfWhitespace","classList","contains","addClass","classesToAdd","add","prev","current","split","removeClass","classesToRemove","remove","toggleClass","classToToggle","predicate","className","toggle","setAttributes","attrValue","removeAttribute","getAttributes","tag","knownBooleans","attrs","attrVal","includes","getAttribute","attribute","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","k","height","computedStyle","width","findPosition","offsetParent","left","top","offsetWidth","offsetHeight","fullscreenElement","offsetLeft","offsetTop","getPointerPosition","event","translated","y","item","nodeName","toLowerCase","transform","map","Number","position","boxTarget","target","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","Math","max","min","isTextNode$1","emptyEl","removeChild","normalizeContent","createTextNode","node","insertContent","isSingleLeftClick","button","buttons","$","$$","prop","getComputedStyle","computedStyleValue","e","getPropertyValue","copyStyleSheetsToWindow","win","styleSheets","styleSheet","cssRules","rule","cssText","join","style","head","link","rel","media","mediaText","href","Dom","isTextNode","videojs$1","_windowLoaded","autoSetup","vids","getElementsByTagName","audios","divs","mediaEls","mediaEl","autoSetupTimeout","player","wait","vjs","setTimeout","setWindowLoaded","removeEventListener","readyState","addEventListener","createStyleElement","setTextContent","DomData","WeakMap","_supportsPassive","_guid","newGUID","_cleanUpEvents","elem","has","data","handlers","dispatcher","detachEvent","disabled","delete","_handleMultipleEvents","types","callback","fixEvent","fixed_","returnTrue","returnFalse","isPropagationStopped","isImmediatePropagationStopped","old","preventDefault","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","clientX","doc","documentElement","scrollLeft","clientLeft","clientY","scrollTop","clientTop","which","charCode","keyCode","passiveEvents","on","guid","hash","handlersCopy","m","n","opts","supportsPassive","passive","attachEvent","removeType","t","trigger","elemData","ownerDocument","bubbles","targetData","one","func","apply","arguments","any","Events","bind_","uid","bound","bind","throttle","last","performance","now","debounce","immediate","timeout","cancel","clearTimeout","debounced","later","Fn","UPDATE_REFRESH_INTERVAL","EVENT_MAP","EventTarget$2","ael","allowedEvents_","queueTrigger","Map","oldTimeout","size","dispatchEvent","objName","name_","isEvented","eventBusEl_","every","isValidEventType","validateTarget","fnName","validateEventType","validateListener","listener","normalizeListenArgs","isTargetingSelf","shift","listen","EventedMixin","removeListenerOnDispose","removeRemoverOnTargetDispose","wrapper","_this","largs","_this2","targetOrType","typeOrListener","evented","eventBusKey","assign","eventedCallbacks","el_","StatefulMixin","state","setState","stateUpdates","changes","from","to","stateful","defaultState","handleStateChanged","string","replace","w","toTitleCase$1","titleCaseEquals","str1","str2","Str","toTitleCase","commonjsGlobal","createCommonjsModule","keycode","searchInput","hasKeyCode","names","foundNamedKey","search","String","codes","aliases","charCodeAt","isEventKey","nameOrCode","code","fromCharCode","title","alias","Component$1","ready","play","player_","isDisposed_","parentComponent_","options_","id_","id","c","handleLanguagechange","children_","childIndex_","childNameIndex_","setTimeoutIds_","Set","setIntervalIds_","rafIds_","namedRafs_","clearingTimersOnDispose_","initChildren","reportTouchActivity","enableTouchActivity","dispose","readyQueue_","restoreEl","replaceChild","isDisposed","localize","tokens","defaultValue","language","languages","primaryCode","primaryLang","localizedString","ret","contentEl","contentEl_","children","getChildById","getChild","getDescendant","acc","currentChild","setIcon","iconName","experimentalSvgIcons","xmlnsURL","iconContainer","svgEl","createElementNS","setAttributeNS","useEl","iconIsSet_","addChild","component","componentName","componentClassName","componentClass","ComponentClass","getComponent","refNode","childFound","compEl","parentOptions","handleAdd","playerOptions","newChild","workingChildren","Tech","some","wchild","isTech","buildCSSClass","sync","isReady_","triggerReady","readyQueue","show","hide","lockShowing","unlockShowing","num","skipListeners","dimension","dimensions","widthOrHeight","pxIndex","parseInt","currentDimension","computedWidthOrHeight","isNaN","currentDimensions","currentWidth","currentHeight","blur","handleKeyDown","handleKeyPress","emitTapEvents","touchStart","firstTouch","couldBeTap","touches","xdiff","ydiff","sqrt","noTap","reportUserActivity","report","touchHolding","clearInterval","setInterval","touchEnd","timeoutId","clearTimersOnDispose_","interval","intervalId","requestAnimationFrame","requestNamedAnimationFrame","cancelNamedAnimationFrame","cancelAnimationFrame","_ref4","idName","cancelName","ComponentToRegister","isComp","isPrototypeOf","reason","components_","Player","players","playerNames","pname","getRange","valueIndex","ranges","rangeIndex","maxIndex","rangeCheck","createTimeRangesObj","timeRangesObj","start","end","Symbol","iterator","createTimeRanges$1","registerComponent","defaultImplementation","seconds","guide","s","floor","h","gm","gh","Infinity","implementation","setFormatTime","customImplementation","resetFormatTime","formatTime","Time","createTimeRanges","createTimeRange","bufferedPercent","buffered","duration","bufferedDuration","MediaError","message","defaultMessages","status","errorTypes","errNum","tuple","reviver","json","JSON","parse","err","isPromise","then","silencePromise","trackToJson_","track","cues","cue","startTime","endTime","textTrackConverter","tech","trackEls","trackObjs","trackEl","src","textTracks","addedTrack","addRemoteTextTrack","addCue","ModalDialog","handleKeyDown_","close_","close","opened_","hasBeenOpened_","hasBeenFilled_","closeable","uncloseable","role","descEl_","description","super","tabIndex","label","previouslyActiveEl_","desc","open","fillAlways","fill","wasPlaying_","paused","pauseOnOpen","pause","hadControls_","controls","conditionalFocus_","opened","conditionalBlur_","temporary","closeable_","temp","controlText","fillWith","parentEl","nextSiblingEl","nextSibling","empty","closeButton","content_","activeEl","activeElement","playerEl","focusableEls","focusableEls_","focusIndex","shiftKey","allChildren","querySelectorAll","HTMLAnchorElement","HTMLAreaElement","hasAttribute","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLButtonElement","HTMLIFrameElement","HTMLObjectElement","HTMLEmbedElement","TrackList","tracks","tracks_","addTrack","labelchange_","removeTrack","rtrack","l","getTrackById","change","addtrack","removetrack","labelchange","disableOthers$1","list","enabled","disableOthers","selected","TextTrackList","queueChange_","triggerSelectedlanguagechange","triggerSelectedlanguagechange_","kind","selectedlanguagechange_","TextTrackCueList","setCues_","length_","oldLength","cues_","defineProp","getCueById","VideoTrackKind","alternative","captions","main","sign","subtitles","commentary","AudioTrackKind","TextTrackKind","descriptions","chapters","metadata","TextTrackMode","hidden","showing","Track","trackProps","newLabel","parseUrl","url","props","a","details","protocol","host","location","getAbsoluteURL","getFileExtension","path","pathParts","pop","isCrossOrigin","winLoc","urlInfo","srcProtocol","crossOrigin","Url","window_1","_extends_1","_extends","__esModule","_extends$1","isFunction_1","alert","confirm","prompt","httpHandler","decodeResponseBody","response","responseBody","statusCode","cause","TextDecoder","charset","contentTypeHeader","contentType","_contentType$split","getCharset","headers","decode","Uint8Array","createXHR","lib","default_1","initParams","uri","params","_createXHR","called","getBody","xhr","responseText","responseType","responseXML","firefoxBugTakenEffect","getXml","isJson","errorFunc","evt","timeoutTimer","failureResponse","loadFunc","aborted","useXDR","rawRequest","getAllResponseHeaders","row","parseHeaders","cors","XDomainRequest","XMLHttpRequest","stringify","onreadystatechange","onload","onerror","onprogress","onabort","ontimeout","username","password","withCredentials","abort","setRequestHeader","isEmpty","beforeSend","send","array","forEachArray","default","parseCues","srcContent","parser","WebVTT","Parser","vttjs","StringDecoder","errors","oncue","onparsingerror","onflush","groupCollapsed","groupEnd","flush","loadTrack","tech_","loaded_","TextTrack","settings","srclang","mode","default_","activeCues_","preload_","preloadTextTracks","activeCues","changed","timeupdateHandler","rvf_","requestVideoFrameCallback","stopTracking","startTracking","defineProperties","newMode","ct","currentTime","active","cancelVideoFrameCallback","originalCue","VTTCue","originalCue_","removeCue","cuechange","AudioTrack","newEnabled","VideoTrack","newSelected","HTMLTrackElement","NONE","LOADED","load","LOADING","ERROR","NORMAL","audio","ListClass","changing_","enabledChange_","TrackClass","capitalName","video","selectedChange_","getterName","privateName","REMOTE","remoteText","remoteTextEl","trackElements","trackElements_","addTrackElement_","trackElement","getTrackElementByTrack_","trackElement_","removeTrackElement_","ALL","doccy","topLevel","document_1","_objCreate","create","F","o","ParsingError","errorData","parseTimeStamp","input","computeSeconds","f","Settings","parseOptions","keyValueDelim","groupDelim","groups","kv","parseCue","regionList","oInput","consumeTimeStamp","ts","Errors","BadTimeStamp","skipWhitespace","substr","v","region","alt","vals","vals0","integer","percent","vertical","line","lineAlign","snapToLines","align","center","middle","right","positionAlign","consumeCueSettings","BadSignature","dflt","defaultKey","TEXTAREA_ELEMENT","TAG_NAME","u","ruby","rt","lang","DEFAULT_COLOR_CLASS","white","lime","cyan","red","yellow","magenta","blue","black","TAG_ANNOTATION","NEEDS_PARENT","parseContent","nextToken","shouldAdd","localName","annotation","rootDiv","tagStack","innerHTML","createProcessingInstruction","classes","cl","bgColor","colorName","propValue","strongRTLRanges","isStrongRTLChar","currentRange","determineBidi","cueDiv","nodeStack","childNodes","pushNodes","nextTextNode","StyleBox","CueStyleBox","styleOptions","color","backgroundColor","bottom","display","writingMode","unicodeBidi","applyStyles","div","direction","textAlign","font","whiteSpace","textPos","formatStyle","move","BoxPosition","lh","rects","getClientRects","lineHeight","moveBoxToLinePosition","styleBox","containerBox","boxPositions","boxPosition","linePos","textTrackList","mediaElement","trackList","count","computeLinePos","axis","step","round","maxPosition","initialAxis","abs","ceil","reverse","calculatedPercentage","bestPosition","specifiedPosition","percentage","overlapsOppositeAxis","within","overlapsAny","p","intersectPercentage","findBestPosition","toCSSCompatValues","WebVTT$1","unit","toMove","overlaps","b2","boxes","container","reference","getSimpleBoxPosition","decodeURIComponent","encodeURIComponent","convertCueToDOMTree","cuetext","processCues","overlay","paddedOverlay","margin","hasBeenReset","displayState","shouldCompute","fontSize","decoder","buffer","reportOrThrowError","collectNextLine","pos","parseHeader","ontimestampmap","parseTimestampMap","xy","anchor","VTTRegion","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","onregion","parseRegion","stream","alreadyCollectedLine","hasSubstring","vtt","directionSetting","alignSetting","findAlignSetting","_id","_pauseOnExit","_startTime","_endTime","_text","_region","_vertical","_snapToLines","_line","_lineAlign","_position","_positionAlign","_size","_align","TypeError","setting","findDirectionSetting","SyntaxError","getCueAsHTML","vttcue","scrollSetting","isValidPercentValue","vttregion","_width","_lines","_regionAnchorX","_regionAnchorY","_viewportAnchorX","_viewportAnchorY","_scroll","findScrollSetting","browserIndex","cueShim","regionShim","nativeVTTCue","nativeVTTRegion","shim","restore","onDurationChange_","onDurationChange","trackProgress_","trackProgress","trackCurrentTime_","trackCurrentTime","stopTrackingCurrentTime_","stopTrackingCurrentTime","disposeSourceHandler_","disposeSourceHandler","queuedHanders_","hasStarted_","featuresProgressEvents","manualProgressOn","featuresTimeupdateEvents","manualTimeUpdatesOn","nativeCaptions","nativeTextTracks","featuresNativeTextTracks","emulateTextTracks","autoRemoteTextTracks_","initTrackListeners","nativeControlsForTouch","triggerSourceset","manualProgress","manualProgressOff","stopTrackingProgress","progressInterval","numBufferedPercent","bufferedPercent_","duration_","manualTimeUpdates","manualTimeUpdatesOff","currentTimeInterval","manuallyTriggered","clearTracks","removeRemoteTextTrack","cleanupAutoTextTracks","reset","setCrossOrigin","error_","played","setScrubbing","_isScrubbing","scrubbing","setCurrentTime","_seconds","trackListChanges","addWebVttScript_","script","remoteTracks","remoteTextTracks","handleAddTrack","handleRemoveTrack","updateDisplay","textTracksChanges","addTextTrack","createTrackHelper","createRemoteTextTrack","manualCleanup","htmlTrackElement","remoteTextTrackEls","getVideoPlaybackQuality","requestPictureInPicture","Promise","reject","disablePictureInPicture","setDisablePictureInPicture","cb","setPoster","playsinline","setPlaysinline","overrideNativeAudioTracks","override","overrideNativeVideoTracks","canPlayType","_type","srcObj","techs_","canPlaySource","defaultTechOrder_","featuresVolumeControl","featuresMuteControl","featuresFullscreenResize","featuresPlaybackRate","featuresSourceset","featuresVideoFrameCallback","withSourceHandlers","_Tech","registerSourceHandler","handler","sourceHandlers","can","selectSourceHandler","canHandleSource","sh","originalFn","sourceHandler_","setSource","nativeSourceHandler","currentSource_","handleSource","registerTech","middlewares","middlewareInstances","TERMINATOR","next","setSourceHelper","mediate","middleware","arg","callMethod","middlewareValue","middlewareIterator","terminated","executeRight","allowedGetters","muted","seekable","volume","ended","allowedSetters","setMuted","setVolume","allowedMediators","mw","mws","getOrCreateFactory","mwFactory","mwf","mwi","lastRun","mwrest","_src","MimetypesKind","opus","ogv","mp4","mov","m4v","mkv","m4a","mp3","aac","caf","flac","oga","wav","m3u8","mpd","jpg","jpeg","gif","png","svg","webp","getMimetype","ext","mimetype","filterSource","newsrc","srcobj","fixSource","j","techOrder","techName","getTech","isSupported","loadTech_","ClickableComponent","handleMouseOver_","handleMouseOver","handleMouseOut_","handleMouseOut","handleClick_","handleClick","tabIndex_","createControlTextEl","controlTextEl_","controlText_","localizedText","nonIconControl","noUITitleAttributes","enabled_","clickHandler","PosterImage","update","update_","crossorigin","poster","setSrc","loading","fontMap","monospace","sansSerif","serif","monospaceSansSerif","monospaceSerif","proportionalSansSerif","proportionalSerif","casual","smallcaps","constructColor","opacity","hex","tryUpdateStyle","getCSSPositionValue","updateDisplayHandler","updateDisplayOverlay","toggleDisplay","preselectTrack","screenOrientation","screen","orientation","changeOrientationEvent","modes","userPref","cache_","selectedLanguage","firstDesc","firstCaptions","preferredTrack","clearDisplay","allowMultipleShowingTracks","showingTracks","updateForTrack","descriptionsTrack","captionsSubtitlesTrack","videoHeight","CSS","supports","playerWidth","playerHeight","playerAspectRatio","videoAspectRatio","videoWidth","insetInlineMatch","insetBlockMatch","updateDisplayState","overrides","textTrackSettings","getValues","textOpacity","backgroundOpacity","windowColor","windowOpacity","edgeStyle","textShadow","fontPercent","fontFamily","fontVariant","cueEl","isAudio","playerType","dir","Button","BigPlayButton","mouseused_","handleMouseDown","playPromise","playToggle","playFocus","PlayToggle","replay","handlePlay","handlePause","handleEnded","handleSeeked","TimeDisplay","updateTextNode_","span","labelText_","textNode_","enableSmoothSeeking","updateContent","time","formattedTime_","oldNode","CurrentTimeDisplay","getCache","DurationDisplay","RemainingTimeDisplay","displayNegative","remainingTimeDisplay","remainingTime","updateShowing","SeekToLive","updateLiveEdgeStatus","liveTracker","updateLiveEdgeStatusHandler_","textEl_","atLiveEdge","seekToLiveEdge","clamp","number","Num","Slider","handleMouseDown_","handleMouseUp_","handleMouseUp","handleMouseMove_","handleMouseMove","bar","barName","playerEvent","progress","getProgress","progress_","sizeKey","toFixed","getPercent","calculateDistance","stepBack","stepForward","bool","vertical_","percentify","partEls_","loadedText","separator","percentageEl_","isLive","seekableEnd","bufferedEnd","percent_","part","dataset","seekBarRect","seekBarPoint","tooltipRect","playerRect","seekBarPointPx","spaceLeftOfPoint","spaceRightOfPoint","pullTooltipBy","write","updateTime","liveWindow","secondsBehind","PlayProgressBar","timeTooltip","MouseTimeDisplay","SeekBar","setEventHandlers_","updateInterval","enableIntervalHandler_","enableInterval_","disableIntervalHandler_","disableInterval_","toggleVisibility_","visibilityState","getCurrentTime_","liveCurrentTime","currentTime_","userSeek_","nextSeekedFromUser","seekableStart","videoWasPlaying","newTime","mouseDown","distance","mouseTimeDisplay","handleAction","gotoFraction","STEP_SECONDS","ProgressControl","throttledHandleMouseSeek","handleMouseSeek","handleMouseUpHandler_","handleMouseDownHandler_","seekBar","playProgressBar","seekBarEl","removeListenersAddedOnMousedownAndTouchstart","PictureInPictureToggle","handlePictureInPictureChange","handlePictureInPictureEnabledChange","handlePictureInPictureAudioModeChange","currentType","substring","audioPosterMode","audioOnlyMode","isInPictureInPicture","exitPictureInPicture","pictureInPictureEnabled","enableDocumentPictureInPicture","FullscreenToggle","handleFullscreenChange","fsApi_","fullscreenEnabled","isFullscreen","exitFullscreen","requestFullscreen","rangeBarRect","rangeBarPoint","volumeBarPointPx","updateVolume","MouseVolumeLevelDisplay","VolumeBar","updateLastVolume_","updateARIAAttributes","mouseVolumeLevelDisplay","volumeBarEl","volumeBarRect","volumeBarPoint","checkMuted","ariaValue","volumeAsPercentage_","volumeBeforeDrag","lastVolume_","VolumeControl","volumeBar","checkVolumeSupport","throttledHandleMouseMove","orientationClass","MuteToggle","checkMuteSupport","vol","lastVolume","volumeToSet","updateIcon_","updateControlText_","VolumePanel","inline","volumeControl","handleKeyPressHandler_","volumePanelState_","muteToggle","handleVolumeControlKeyUp","sliderActive_","sliderInactive_","SkipForward","validOptions","skipTime","getSkipForwardTime","controlBar","skipButtons","forward","currentVideoTime","SkipBackward","getSkipBackwardTime","backward","Menu","menuButton_","menuButton","focusedChild_","boundHandleBlur_","handleBlur","boundHandleTapClick_","handleTapClick","addEventListenerForItem","removeEventListenerForItem","addItem","childComponent","contentElType","append","btn","buttonPressed_","unpressButton","childComponents","foundComponent","stepChild","MenuButton","buttonClass","handleMenuKeyUp_","handleMenuKeyUp","menu","handleMouseLeave","handleSubmenuKeyDown","createMenu","items","hideThreshold_","titleEl","titleComponent","createItems","buildWrapperCSSClass","menuButtonClass","pressButton","handleSubmenuKeyPress","TrackButton","updateHandler","MenuKeys","MenuItem","selectable","isSelected_","multiSelectable","menuItemEl","TextTrackMenuItem","kinds","changeHandler","_this3","handleTracksChange","selectedLanguageChangeHandler","handleSelectedLanguageChange","onchange","Event","createEvent","initEvent","referenceTrack","shouldBeSelected","OffTextTrackMenuItem","allHidden","TextTrackButton","TrackMenuItem","label_","kinds_","kind_","ChaptersTrackMenuItem","ChaptersButton","selectCurrentItem_","track_","findChaptersTrack","setTrack","updateHandler_","remoteTextTrackEl","getMenuCaption","mi","DescriptionsButton","SubtitlesButton","CaptionSettingsMenuItem","CaptionsButton","SubsCapsMenuItem","parentSpan","SubsCapsButton","language_","AudioTrackMenuItem","audioTracks","_this4","featuresNativeAudioTracks","AudioTrackButton","PlaybackRateMenuItem","rate","playbackRate","PlaybackRateMenuButton","labelElId_","updateVisibility","updateLabel","handlePlaybackRateschange","labelEl_","rates","playbackRates","playbackRateSupported","Spacer","ControlBar","ErrorDisplay","COLOR_BLACK","COLOR_BLUE","COLOR_CYAN","COLOR_GREEN","COLOR_MAGENTA","COLOR_RED","COLOR_WHITE","COLOR_YELLOW","OPACITY_OPAQUE","OPACITY_SEMI","OPACITY_TRANS","selectConfigs","parseOptionValue","endDialog","setDefaults","persistTextTrackSettings","saveSettings","config","restoreSettings","createElSelect_","legendId","selectLabelledbyIds","optionId","createElFgColor_","createElBgColor_","createElWinColor_","createElColors_","createElFont_","createElControls_","defaultsDescription","selectedIndex","setValues","setSelectedOption","localStorage","getItem","setItem","removeItem","ttDisplay","subsCapsBtn","subsCapsButton","ccBtn","captionsButton","RESIZE_OBSERVER_AVAILABLE","ResizeObserver","loadListener_","resizeObserver_","debouncedHandler_","resizeHandler","observe","contentWindow","unloadListener_","unobserve","disconnect","resizeObserver","defaults","trackingThreshold","liveTolerance","trackLiveHandler_","trackLive_","handlePlay_","handleFirstTimeupdate_","handleFirstTimeupdate","handleSeeked_","seekToLiveEdge_","reset_","handleDurationchange","toggleTracking","deltaTime","lastTime_","pastSeekEnd_","pastSeekEnd","isBehind","seekedBehindLive_","timeupdateSeen_","behindLiveEdge_","liveui","isTracking","hasStarted","trackingInterval_","timeDiff","nextSeekedFromUser_","lastSeekEnd_","seekableEnds","sort","seekableStarts","behindLiveEdge","updateDom_","els","techEl","techAriaAttrs","techAriaAttr","sourcesetLoad","srcUrls","innerHTMLDescriptorPolyfill","cloneNode","dummy","docFrag","createDocumentFragment","Element","getDescriptor","priority","descriptor","getOwnPropertyDescriptor","firstSourceWatch","resetSourceWatch_","innerDescriptor","HTMLMediaElement","getInnerHTMLDescriptor","appendWrapper","appendFn","retval","srcDescriptorPolyfill","setupSourceset","resetSourceset_","srcDescriptor","getSrcDescriptor","oldSetAttribute","oldLoad","currentSrc","Html5","crossoriginTracks","initNetworkState_","handleLateInit_","enableSourceset","setupSourcesetHandling_","isScrubbing_","hasChildNodes","nodes","nodesLength","removeNodes","proxyNativeTracks_","restoreMetadataTracksInIOSNativePlayer_","setControls","proxyWebkitFullscreen_","disposeMediaElement","metadataTracksPreFullscreenState","takeMetadataTrackSnapshot","storedMode","restoreTrackMode","storedTrack","overrideNative_","lowerCaseType","eventName","proxyNativeTracksForType_","elTracks","techTracks","listeners","currentTarget","removeOldTracks","removeTracks","found","playerElIngest","movingMediaElementInDOM","clone","techId","class","playerId","preload","settingsAttrs","attr","networkState","loadstartFired","setLoadstartFired","triggerLoadstart","eventsToTrigger","isScrubbing","fastSeek","checkProgress","NaN","endFn","beginFn","webkitPresentationMode","nativeIOSFullscreen","supportsFullScreen","webkitEnterFullScreen","enterFullScreen","HAVE_METADATA","exitFullScreen","webkitDisplayingFullscreen","webkitExitFullScreen","webkitKeys","resetMediaElement","videoPlaybackQuality","webkitDroppedFrameCount","webkitDecodedFrameCount","droppedVideoFrames","totalVideoFrames","creationTime","TEST_VID","canControlVolume","canControl","canMuteVolume","canControlPlaybackRate","canOverrideAttributes","noop","supportsNativeTextTracks","supportsNativeVideoTracks","videoTracks","supportsNativeAudioTracks","TECH_EVENTS_RETRIGGER","TECH_EVENTS_QUEUE","canplay","canplaythrough","playing","seeked","BREAKPOINT_ORDER","BREAKPOINT_CLASSES","charAt","DEFAULT_BREAKPOINTS","tiny","xsmall","small","medium","large","xlarge","huge","getTagSettings","closest","boundDocumentFullscreenChange_","documentFullscreenChange_","boundFullWindowOnEscKey_","fullWindowOnEscKey","boundUpdateStyleEl_","updateStyleEl_","boundApplyInitTime_","applyInitTime_","boundUpdateCurrentBreakpoint_","updateCurrentBreakpoint_","boundHandleTechClick_","handleTechClick_","boundHandleTechDoubleClick_","handleTechDoubleClick_","boundHandleTechTouchStart_","handleTechTouchStart_","boundHandleTechTouchMove_","handleTechTouchMove_","boundHandleTechTouchEnd_","handleTechTouchEnd_","boundHandleTechTap_","handleTechTap_","isFullscreen_","isPosterFromTech_","queuedCallbacks_","userActive_","debugEnabled_","audioOnlyMode_","audioPosterMode_","audioOnlyCache_","hiddenChildren","tagAttributes","languagesToLower","languages_","resetCache_","poster_","controls_","changingSrc_","playCallbacks_","playTerminatedQueue_","autoplay","plugins","scrubbing_","fullscreenchange","fluid_","playerOptionsCopy","middleware_","parsedSVG","DOMParser","parseFromString","sprite","majorVersion","userActive","listenForUserActivity_","breakpoints","responsive","styleEl_","playerElIngest_","divEmbed","tabindex","VIDEOJS_NO_DYNAMIC_STYLE","defaultsStyleEl","fill_","fluid","aspectRatio","links","linkEl","techGet_","techCall_","posterImage","privDimension","parsedVal","ratio","aspectRatio_","width_","height_","idClass","ratioParts","ratioMultiplier","unloadTech_","titleTechName","camelTechName","techName_","normalizeAutoplay","techOptions","loop","techCanOverridePoster","TechClass","handleTechReady_","textTracksJson_","eventObj","seeking","handleTechLoadStart_","handleTechSourceset_","handleTechWaiting_","handleTechEnded_","handleTechSeeking_","handleTechPlay_","handleTechPause_","handleTechDurationChange_","handleTechFullscreenChange_","handleTechFullscreenError_","handleTechEnterPictureInPicture_","handleTechLeavePictureInPicture_","handleTechError_","handleTechPosterChange_","handleTechTextData_","handleTechRateChange_","usingNativeControls","addTechControlsListeners_","safety","removeTechControlsListeners_","manualAutoplay_","resolveMuted","previouslyMuted","restoreMuted","mutedPromise","catch","promise","updateSourceCaches_","matchingSources","findMimetype","sourceElSources","sourceEls","matchingSourceEls","sourceObj","updateSourceCaches","playerSrc","currentSource","eventSrc","lastSource_","techSrc","request","lastPlaybackRate","queued","timeWhenWaiting","timeUpdateListener","handleTechCanPlay_","handleTechCanPlayThrough_","handleTechPlaying_","handleTechSeeked_","userActions","click","doubleClick","userWasActive","cancelable","toggleFullscreenClass_","targetPlayer","isFs","matches","fullscreen","togglePictureInPictureClass_","initTime","inactivityTimeout","defaultPlaybackRate","reduceRight","resolve","play_","isSrcReady","isSafariOrIOS","waitToPlay_","resetProgressBar_","runPlayTerminatedQueue_","runPlayCallbacks_","queue","q","callbacks","isFinite","percentAsDecimal","defaultMuted","isFS","oldValue","fullscreenOptions","offHandler","errorHandler","requestFullscreenHelper_","fsOptions","preferFullWindow","enterFullWindow","exitFullscreenHelper_","exitFullWindow","isFullWindow","docOrigOverflow","overflow","isPiP","isInPictureInPicture_","documentPictureInPicture","pipContainer","titleBar","requestWindow","pipWindow","pipVideo","hotkeys","isContentEditable","excludeElement","handleHotkeys","fullscreenKey","keydownEvent","muteKey","playPauseKey","FSToggle","selectSource","techs","_ref6","findFirstPassingTechSourcePair","outerArray","innerArray","tester","outerChoice","innerChoice","foundSourceAndTech","finder","sourceOrder","handleSrc_","isRetry","resetRetryOnError_","middlewareSource","src_","notSupportedMessage","setTech","retry","stopListeningForErrors","sourceTech","vhs","doReset_","resetControlBarUI_","resetPlaybackRate_","resetVolumeBar_","currentTimeDisplay","durationDisplay","progressControl","loadProgressBar","currentSources","techAutoplay","newPoster","usingNativeControls_","hookFunction","newErr","suppressNotSupportedError","triggerSuppressedError","errorDisplay","userActivity_","mouseInProgress","lastMoveX","lastMoveY","handleActivity","handleMouseUpAndMouseLeave","screenX","screenY","isAudio_","enableAudioOnlyUI_","playerChildren","controlBarHeight","disableAudioOnlyUI_","exitPromises","enablePosterModeUI_","disablePosterModeUI_","toJSON","createModal","modal","currentBreakpoint","candidateBreakpoint","breakpoints_","breakpoint_","removeCurrentBreakpoint_","currentBreakpointClass","responsive_","loadMedia","artist","artwork","tt","getMedia","baseOptions","tagOptions","dataSetup","childName","previousLogLevel_","newRates","html5","userLanguage","navigationUI","pluginStorage","pluginExists","getPlugin","markPluginAsActive","triggerSetupEvent","before","createPluginFactory","PluginSubClass","plugin","instance","getEventHash","Plugin","VERSION","isBasic","basicPluginWrapper","createBasicPlugin","deprecateForMajor","oldName","warned","deprecate","BASE_PLUGIN_NAME","registerPlugin","usingPlugin","hasPlugin","normalizeId","getPlayer","rootNode","getRootNode","ShadowRoot","defaultView","PlayerComponent","hook","hookOnce","original","getPlayers","nId","getAllPlayers","comp","use","writeable","mergeOptions","deregisterPlugin","getPlugins","getPluginVersion","addLanguage","EventTarget","dom","_interopDefaultLegacy","videojs__default","QualityLevel","representation","bitrate","bandwidth","frameRate","QualityLevelList","levels_","selectedIndex_","addQualityLevel","qualityLevel","getQualityLevelById","removeQualityLevel","removed","addqualitylevel","removequalitylevel","initPlugin","originalPluginFn","qualityLevels","qualityLevelList","disposeHandler","urlToolkit","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","alwaysNormalize","basePartsForNormalise","parseURL","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","builtParts","query","fragment","baseURLPath","newPath","lastIndexOf","parts","resolveUrl$1","baseUrl","relativeUrl","nativeURL","URL","protocolLess","removeLocation","newUrl","Stream","_proto","_length","_i","pipe","destination","decodeB64ToUint8Array$1","b64Text","decodedString","atob","Buffer","LineStream","nextNewline","TAB","parseByterange","byterangeString","offset","parseAttributes$1","ParseStream","customParsers","tagMappers","mapper","mappedLine","newLine","tagType","playlistType","allowed","URI","BYTERANGE","byterange","RESOLUTION","resolution","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","Uint32Array","PRECISE","subkey","clientAttributePattern","isHexaDecimal","isDecimalFloating","addParser","expression","customType","dataParser","segment","addTagMapper","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","hb","phb","minTargetDuration","minPartDuration","lineStream","parseStream","lastProgramDateTime","uris","currentMap","currentUri","hasParts","defaultMediaGroups","currentTimeline","allowCache","discontinuityStarts","dateRanges","segments","lastByterangeEnd","lastPartByterangeEnd","dateRangeTags","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","KEYID","schemeIdUri","keyId","pssh","iv","playlist","playlists","mediaGroups","TYPE","NAME","mediaGroupType","autoselect","AUTOSELECT","LANGUAGE","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","getTime","programDateTime","targetduration","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","partIndex","renditionReports","r","canBlockReload","canSkipDateranges","hint","isPart","otherHint","required","partInf","partTarget","dateRange","endDate","startDate","plannedDuration","endOnNextYes","endOnNext","newDateInSeconds","dateRangeWithSameId","findIndex","dateRangeToFind","independentSegments","contentSteering","comment","custom","identifier","missing","chunk","regexs","webm","ogg","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","orig","profile","avcLevel","parseCodecs","codecString","codecs","codecType","mediaType","isAudioCodec","getMimeForCodec","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","MPEGURL_REGEX","DASH_REGEX","simpleTypeFromSourceType","isArrayBufferView","ArrayBuffer","isView","toUint8","bytes","byteOffset","byteLength","BigInt","BYTE_TABLE","Uint16Array","bytesToNumber","_temp","_ref","_ref$signed","signed","_ref$le","le","total","byte","exponent","numberToBytes","_temp2","_ref2$le","byteCount","countBits","countBytes","byteIndex","stringToBytes","stringIsBytes","unescape","view","bytesMatch","_temp3","_ref3","_ref3$offset","_ref3$mask","mask","bByte","decodeB64ToUint8Array","oc","MIME_TYPE","HTML","isHTML","XML_APPLICATION","XML_TEXT","XML_XHTML_APPLICATION","XML_SVG_IMAGE","NAMESPACE$3","SVG","XML","XMLNS","conventions","ac","NAMESPACE","NAMESPACE$2","notEmptyString","orderedSetReducer","toOrderedSet","splitOnASCIIWhitespace","copy","dest","Class","Super","pt","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","ExceptionCode","ExceptionMessage","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","DOMException","captureStackTrace","NodeList","LiveNodeList","refresh","_node","_refresh","_updateLiveList","inc","_inc","ls","__set__","$$length","NamedNodeMap","_findNodeIndex","_addNamedNode","newAttr","oldAttr","ownerElement","_onRemoveAttribute","namespaceURI","_nsMap","prefix","_onAddAttribute","_removeNamedNode","lastIndex","DOMImplementation$1","Node","_xmlEncoder","_visitNode","Document","_onUpdateChild","cs","_removeChild","previous","previousSibling","lastChild","isDocTypeNode","isElementNode","isElementInsertionPossible","parentChildNodes","docTypeNode","isElementReplacementPossible","assertPreInsertionValidity1to5","hasValidParentNodeType","hasInsertableNodeType","assertPreInsertionValidityInDocument","nodeChildNodes","nodeChildElements","parentElementChild","assertPreReplacementValidityInDocument","hasDoctypeChildThatIsNotChild","_insertBefore","_inDocumentAssertion","cp","newFirst","newLast","pre","Attr","CharacterData","Text","Comment","CDATASection","DocumentType","Notation","Entity","EntityReference","DocumentFragment","ProcessingInstruction","XMLSerializer","nodeSerializeToString","isHtml","nodeFilter","buf","lookupPrefix","visibleNamespaces","namespace","serializeToString","needNamespaceDefine","ns","addSerializedAttribute","qualifiedName","len","prefixedNodeName","defaultNS","ai","nsi","pubid","publicId","sysid","systemId","sub","internalSubset","importNode","deep","node2","attrs2","_ownerElement","setAttributeNode","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","getNamedItem","setNamedItem","setNamedItemNS","getNamedItemNS","removeNamedItem","removeNamedItemNS","hasFeature","feature","createDocument","doctype","root","createDocumentType","nodeValue","refChild","oldChild","normalize","appendData","hasAttributes","lookupNamespaceURI","isDefaultNamespace","importedNode","getElementById","rtv","getElementsByClassName","classNames","classNamesSet","base","nodeClassNames","nodeClassNamesSet","createComment","createCDATASection","createAttribute","specified","createEntityReference","pl","createAttributeNS","getAttributeNode","removeAttributeNode","_appendSingleChild","setAttributeNodeNS","removeAttributeNS","getAttributeNodeNS","hasAttributeNS","getAttributeNS","getElementsByTagNameNS","substringData","insertData","replaceData","deleteData","splitText","newText","newNode","getTextContent","DOMImplementation","entities","XML_ENTITIES","amp","apos","gt","lt","quot","HTML_ENTITIES","Aacute","aacute","Abreve","abreve","acd","acE","Acirc","acirc","acute","Acy","acy","AElig","aelig","af","Afr","afr","Agrave","agrave","alefsym","aleph","Alpha","alpha","Amacr","amacr","amalg","AMP","And","and","andand","andd","andslope","andv","ang","ange","angle","angmsd","angmsdaa","angmsdab","angmsdac","angmsdad","angmsdae","angmsdaf","angmsdag","angmsdah","angrt","angrtvb","angrtvbd","angsph","angst","angzarr","Aogon","aogon","Aopf","aopf","ap","apacir","apE","ape","apid","ApplyFunction","approx","approxeq","Aring","aring","Ascr","ascr","Assign","ast","asymp","asympeq","Atilde","atilde","Auml","auml","awconint","awint","backcong","backepsilon","backprime","backsim","backsimeq","Backslash","Barv","barvee","Barwed","barwed","barwedge","bbrk","bbrktbrk","bcong","Bcy","bcy","bdquo","becaus","Because","because","bemptyv","bepsi","bernou","Bernoullis","Beta","beta","beth","between","Bfr","bfr","bigcap","bigcirc","bigcup","bigodot","bigoplus","bigotimes","bigsqcup","bigstar","bigtriangledown","bigtriangleup","biguplus","bigvee","bigwedge","bkarow","blacklozenge","blacksquare","blacktriangle","blacktriangledown","blacktriangleleft","blacktriangleright","blank","blk12","blk14","blk34","block","bne","bnequiv","bNot","bnot","Bopf","bopf","bot","bowtie","boxbox","boxDL","boxDl","boxdL","boxdl","boxDR","boxDr","boxdR","boxdr","boxh","boxHD","boxHd","boxhD","boxhd","boxHU","boxHu","boxhU","boxhu","boxminus","boxplus","boxtimes","boxUL","boxUl","boxuL","boxul","boxUR","boxUr","boxuR","boxur","boxV","boxv","boxVH","boxVh","boxvH","boxvh","boxVL","boxVl","boxvL","boxvl","boxVR","boxVr","boxvR","boxvr","bprime","Breve","breve","brvbar","Bscr","bscr","bsemi","bsim","bsime","bsol","bsolb","bsolhsub","bull","bullet","bump","bumpE","bumpe","Bumpeq","bumpeq","Cacute","cacute","Cap","cap","capand","capbrcup","capcap","capcup","capdot","CapitalDifferentialD","caps","caret","caron","Cayleys","ccaps","Ccaron","ccaron","Ccedil","ccedil","Ccirc","ccirc","Cconint","ccups","ccupssm","Cdot","cdot","cedil","Cedilla","cemptyv","cent","CenterDot","centerdot","Cfr","cfr","CHcy","chcy","check","checkmark","Chi","chi","cir","circ","circeq","circlearrowleft","circlearrowright","circledast","circledcirc","circleddash","CircleDot","circledR","circledS","CircleMinus","CirclePlus","CircleTimes","cirE","cire","cirfnint","cirmid","cirscir","ClockwiseContourIntegral","CloseCurlyDoubleQuote","CloseCurlyQuote","clubs","clubsuit","Colon","colon","Colone","colone","coloneq","comma","commat","compfn","complement","complexes","cong","congdot","Congruent","Conint","conint","ContourIntegral","Copf","copf","coprod","Coproduct","COPY","copysr","CounterClockwiseContourIntegral","crarr","Cross","cross","Cscr","cscr","csub","csube","csup","csupe","ctdot","cudarrl","cudarrr","cuepr","cuesc","cularr","cularrp","Cup","cup","cupbrcap","CupCap","cupcap","cupcup","cupdot","cupor","cups","curarr","curarrm","curlyeqprec","curlyeqsucc","curlyvee","curlywedge","curren","curvearrowleft","curvearrowright","cuvee","cuwed","cwconint","cwint","cylcty","Dagger","dagger","daleth","Darr","dArr","darr","dash","Dashv","dashv","dbkarow","dblac","Dcaron","dcaron","Dcy","dcy","DD","dd","ddagger","ddarr","DDotrahd","ddotseq","deg","Del","Delta","delta","demptyv","dfisht","Dfr","dfr","dHar","dharl","dharr","DiacriticalAcute","DiacriticalDot","DiacriticalDoubleAcute","DiacriticalGrave","DiacriticalTilde","diam","Diamond","diamond","diamondsuit","diams","die","DifferentialD","digamma","disin","divide","divideontimes","divonx","DJcy","djcy","dlcorn","dlcrop","dollar","Dopf","dopf","Dot","dot","DotDot","doteq","doteqdot","DotEqual","dotminus","dotplus","dotsquare","doublebarwedge","DoubleContourIntegral","DoubleDot","DoubleDownArrow","DoubleLeftArrow","DoubleLeftRightArrow","DoubleLeftTee","DoubleLongLeftArrow","DoubleLongLeftRightArrow","DoubleLongRightArrow","DoubleRightArrow","DoubleRightTee","DoubleUpArrow","DoubleUpDownArrow","DoubleVerticalBar","DownArrow","Downarrow","downarrow","DownArrowBar","DownArrowUpArrow","DownBreve","downdownarrows","downharpoonleft","downharpoonright","DownLeftRightVector","DownLeftTeeVector","DownLeftVector","DownLeftVectorBar","DownRightTeeVector","DownRightVector","DownRightVectorBar","DownTee","DownTeeArrow","drbkarow","drcorn","drcrop","Dscr","dscr","DScy","dscy","dsol","Dstrok","dstrok","dtdot","dtri","dtrif","duarr","duhar","dwangle","DZcy","dzcy","dzigrarr","Eacute","eacute","easter","Ecaron","ecaron","ecir","Ecirc","ecirc","ecolon","Ecy","ecy","eDDot","Edot","eDot","edot","ee","efDot","Efr","efr","eg","Egrave","egrave","egs","egsdot","elinters","ell","elsdot","Emacr","emacr","emptyset","EmptySmallSquare","emptyv","EmptyVerySmallSquare","emsp","emsp13","emsp14","ENG","eng","ensp","Eogon","eogon","Eopf","eopf","epar","eparsl","eplus","epsi","Epsilon","epsilon","epsiv","eqcirc","eqcolon","eqsim","eqslantgtr","eqslantless","Equal","equals","EqualTilde","equest","Equilibrium","equiv","equivDD","eqvparsl","erarr","erDot","Escr","escr","esdot","Esim","esim","Eta","eta","ETH","eth","Euml","euml","euro","excl","exist","Exists","expectation","ExponentialE","exponentiale","fallingdotseq","Fcy","fcy","female","ffilig","fflig","ffllig","Ffr","ffr","filig","FilledSmallSquare","FilledVerySmallSquare","fjlig","flat","fllig","fltns","fnof","Fopf","fopf","ForAll","forall","fork","forkv","Fouriertrf","fpartint","frac12","frac13","frac14","frac15","frac16","frac18","frac23","frac25","frac34","frac35","frac38","frac45","frac56","frac58","frac78","frasl","frown","Fscr","fscr","gacute","Gamma","gamma","Gammad","gammad","gap","Gbreve","gbreve","Gcedil","Gcirc","gcirc","Gcy","gcy","Gdot","gdot","gE","ge","gEl","gel","geq","geqq","geqslant","ges","gescc","gesdot","gesdoto","gesdotol","gesl","gesles","Gfr","gfr","Gg","gg","ggg","gimel","GJcy","gjcy","gl","gla","glE","glj","gnap","gnapprox","gnE","gne","gneq","gneqq","gnsim","Gopf","gopf","grave","GreaterEqual","GreaterEqualLess","GreaterFullEqual","GreaterGreater","GreaterLess","GreaterSlantEqual","GreaterTilde","Gscr","gscr","gsim","gsime","gsiml","Gt","GT","gtcc","gtcir","gtdot","gtlPar","gtquest","gtrapprox","gtrarr","gtrdot","gtreqless","gtreqqless","gtrless","gtrsim","gvertneqq","gvnE","Hacek","hairsp","half","hamilt","HARDcy","hardcy","hArr","harr","harrcir","harrw","Hat","hbar","Hcirc","hcirc","hearts","heartsuit","hellip","hercon","Hfr","hfr","HilbertSpace","hksearow","hkswarow","hoarr","homtht","hookleftarrow","hookrightarrow","Hopf","hopf","horbar","HorizontalLine","Hscr","hscr","hslash","Hstrok","hstrok","HumpDownHump","HumpEqual","hybull","hyphen","Iacute","iacute","ic","Icirc","icirc","Icy","icy","Idot","IEcy","iecy","iexcl","iff","Ifr","ifr","Igrave","igrave","ii","iiiint","iiint","iinfin","iiota","IJlig","ijlig","Im","Imacr","imacr","image","ImaginaryI","imagline","imagpart","imath","imof","imped","Implies","in","incare","infin","infintie","inodot","Int","int","intcal","integers","Integral","intercal","Intersection","intlarhk","intprod","InvisibleComma","InvisibleTimes","IOcy","iocy","Iogon","iogon","Iopf","iopf","Iota","iota","iprod","iquest","Iscr","iscr","isin","isindot","isinE","isins","isinsv","isinv","it","Itilde","itilde","Iukcy","iukcy","Iuml","iuml","Jcirc","jcirc","Jcy","jcy","Jfr","jfr","jmath","Jopf","jopf","Jscr","jscr","Jsercy","jsercy","Jukcy","jukcy","Kappa","kappa","kappav","Kcedil","kcedil","Kcy","kcy","Kfr","kfr","kgreen","KHcy","khcy","KJcy","kjcy","Kopf","kopf","Kscr","kscr","lAarr","Lacute","lacute","laemptyv","lagran","Lambda","lambda","Lang","langd","langle","lap","Laplacetrf","laquo","Larr","lArr","larr","larrb","larrbfs","larrfs","larrhk","larrlp","larrpl","larrsim","larrtl","lat","lAtail","latail","late","lates","lBarr","lbarr","lbbrk","lbrace","lbrack","lbrke","lbrksld","lbrkslu","Lcaron","lcaron","Lcedil","lcedil","lceil","lcub","Lcy","lcy","ldca","ldquo","ldquor","ldrdhar","ldrushar","ldsh","lE","LeftAngleBracket","LeftArrow","Leftarrow","leftarrow","LeftArrowBar","LeftArrowRightArrow","leftarrowtail","LeftCeiling","LeftDoubleBracket","LeftDownTeeVector","LeftDownVector","LeftDownVectorBar","LeftFloor","leftharpoondown","leftharpoonup","leftleftarrows","LeftRightArrow","Leftrightarrow","leftrightarrow","leftrightarrows","leftrightharpoons","leftrightsquigarrow","LeftRightVector","LeftTee","LeftTeeArrow","LeftTeeVector","leftthreetimes","LeftTriangle","LeftTriangleBar","LeftTriangleEqual","LeftUpDownVector","LeftUpTeeVector","LeftUpVector","LeftUpVectorBar","LeftVector","LeftVectorBar","lEg","leg","leq","leqq","leqslant","les","lescc","lesdot","lesdoto","lesdotor","lesg","lesges","lessapprox","lessdot","lesseqgtr","lesseqqgtr","LessEqualGreater","LessFullEqual","LessGreater","lessgtr","LessLess","lesssim","LessSlantEqual","LessTilde","lfisht","lfloor","Lfr","lfr","lg","lgE","lHar","lhard","lharu","lharul","lhblk","LJcy","ljcy","Ll","ll","llarr","llcorner","Lleftarrow","llhard","lltri","Lmidot","lmidot","lmoust","lmoustache","lnap","lnapprox","lnE","lne","lneq","lneqq","lnsim","loang","loarr","lobrk","LongLeftArrow","Longleftarrow","longleftarrow","LongLeftRightArrow","Longleftrightarrow","longleftrightarrow","longmapsto","LongRightArrow","Longrightarrow","longrightarrow","looparrowleft","looparrowright","lopar","Lopf","lopf","loplus","lotimes","lowast","lowbar","LowerLeftArrow","LowerRightArrow","loz","lozenge","lozf","lpar","lparlt","lrarr","lrcorner","lrhar","lrhard","lrm","lrtri","lsaquo","Lscr","lscr","Lsh","lsh","lsim","lsime","lsimg","lsqb","lsquo","lsquor","Lstrok","lstrok","Lt","LT","ltcc","ltcir","ltdot","lthree","ltimes","ltlarr","ltquest","ltri","ltrie","ltrif","ltrPar","lurdshar","luruhar","lvertneqq","lvnE","macr","male","malt","maltese","mapsto","mapstodown","mapstoleft","mapstoup","marker","mcomma","Mcy","mcy","mdash","mDDot","measuredangle","MediumSpace","Mellintrf","Mfr","mfr","mho","micro","mid","midast","midcir","middot","minus","minusb","minusd","minusdu","MinusPlus","mlcp","mldr","mnplus","models","Mopf","mopf","mp","Mscr","mscr","mstpos","Mu","mu","multimap","mumap","nabla","Nacute","nacute","nang","nap","napE","napid","napos","napprox","natur","natural","naturals","nbsp","nbump","nbumpe","ncap","Ncaron","ncaron","Ncedil","ncedil","ncong","ncongdot","ncup","Ncy","ncy","ndash","ne","nearhk","neArr","nearr","nearrow","nedot","NegativeMediumSpace","NegativeThickSpace","NegativeThinSpace","NegativeVeryThinSpace","nequiv","nesear","nesim","NestedGreaterGreater","NestedLessLess","NewLine","nexist","nexists","Nfr","nfr","ngE","nge","ngeq","ngeqq","ngeqslant","nges","nGg","ngsim","nGt","ngt","ngtr","nGtv","nhArr","nharr","nhpar","ni","nis","nisd","niv","NJcy","njcy","nlArr","nlarr","nldr","nlE","nle","nLeftarrow","nleftarrow","nLeftrightarrow","nleftrightarrow","nleq","nleqq","nleqslant","nles","nless","nLl","nlsim","nLt","nlt","nltri","nltrie","nLtv","nmid","NoBreak","NonBreakingSpace","Nopf","nopf","Not","not","NotCongruent","NotCupCap","NotDoubleVerticalBar","NotElement","NotEqual","NotEqualTilde","NotExists","NotGreater","NotGreaterEqual","NotGreaterFullEqual","NotGreaterGreater","NotGreaterLess","NotGreaterSlantEqual","NotGreaterTilde","NotHumpDownHump","NotHumpEqual","notin","notindot","notinE","notinva","notinvb","notinvc","NotLeftTriangle","NotLeftTriangleBar","NotLeftTriangleEqual","NotLess","NotLessEqual","NotLessGreater","NotLessLess","NotLessSlantEqual","NotLessTilde","NotNestedGreaterGreater","NotNestedLessLess","notni","notniva","notnivb","notnivc","NotPrecedes","NotPrecedesEqual","NotPrecedesSlantEqual","NotReverseElement","NotRightTriangle","NotRightTriangleBar","NotRightTriangleEqual","NotSquareSubset","NotSquareSubsetEqual","NotSquareSuperset","NotSquareSupersetEqual","NotSubset","NotSubsetEqual","NotSucceeds","NotSucceedsEqual","NotSucceedsSlantEqual","NotSucceedsTilde","NotSuperset","NotSupersetEqual","NotTilde","NotTildeEqual","NotTildeFullEqual","NotTildeTilde","NotVerticalBar","npar","nparallel","nparsl","npart","npolint","npr","nprcue","npre","nprec","npreceq","nrArr","nrarr","nrarrc","nrarrw","nRightarrow","nrightarrow","nrtri","nrtrie","nsc","nsccue","nsce","Nscr","nscr","nshortmid","nshortparallel","nsim","nsime","nsimeq","nsmid","nspar","nsqsube","nsqsupe","nsub","nsubE","nsube","nsubset","nsubseteq","nsubseteqq","nsucc","nsucceq","nsup","nsupE","nsupe","nsupset","nsupseteq","nsupseteqq","ntgl","Ntilde","ntilde","ntlg","ntriangleleft","ntrianglelefteq","ntriangleright","ntrianglerighteq","Nu","nu","numero","numsp","nvap","nVDash","nVdash","nvDash","nvdash","nvge","nvgt","nvHarr","nvinfin","nvlArr","nvle","nvlt","nvltrie","nvrArr","nvrtrie","nvsim","nwarhk","nwArr","nwarr","nwarrow","nwnear","Oacute","oacute","oast","ocir","Ocirc","ocirc","Ocy","ocy","odash","Odblac","odblac","odiv","odot","odsold","OElig","oelig","ofcir","Ofr","ofr","ogon","Ograve","ograve","ogt","ohbar","ohm","oint","olarr","olcir","olcross","oline","olt","Omacr","omacr","Omega","omega","Omicron","omicron","omid","ominus","Oopf","oopf","opar","OpenCurlyDoubleQuote","OpenCurlyQuote","operp","oplus","Or","or","orarr","ord","order","orderof","ordf","ordm","origof","oror","orslope","orv","oS","Oscr","oscr","Oslash","oslash","osol","Otilde","otilde","Otimes","otimes","otimesas","Ouml","ouml","ovbar","OverBar","OverBrace","OverBracket","OverParenthesis","par","para","parallel","parsim","parsl","PartialD","Pcy","pcy","percnt","period","permil","perp","pertenk","Pfr","pfr","Phi","phi","phiv","phmmat","phone","Pi","pi","pitchfork","piv","planck","planckh","plankv","plus","plusacir","plusb","pluscir","plusdo","plusdu","pluse","PlusMinus","plusmn","plussim","plustwo","pm","Poincareplane","pointint","Popf","popf","pound","Pr","pr","prap","prcue","prE","prec","precapprox","preccurlyeq","Precedes","PrecedesEqual","PrecedesSlantEqual","PrecedesTilde","preceq","precnapprox","precneqq","precnsim","precsim","Prime","prime","primes","prnap","prnE","prnsim","prod","Product","profalar","profline","profsurf","Proportion","Proportional","propto","prsim","prurel","Pscr","pscr","Psi","psi","puncsp","Qfr","qfr","qint","Qopf","qopf","qprime","Qscr","qscr","quaternions","quatint","quest","questeq","QUOT","rAarr","race","Racute","racute","radic","raemptyv","Rang","rang","rangd","range","rangle","raquo","Rarr","rArr","rarr","rarrap","rarrb","rarrbfs","rarrc","rarrfs","rarrhk","rarrlp","rarrpl","rarrsim","Rarrtl","rarrtl","rarrw","rAtail","ratail","rationals","RBarr","rBarr","rbarr","rbbrk","rbrace","rbrack","rbrke","rbrksld","rbrkslu","Rcaron","rcaron","Rcedil","rcedil","rceil","rcub","Rcy","rcy","rdca","rdldhar","rdquo","rdquor","rdsh","Re","real","realine","realpart","reals","REG","reg","ReverseElement","ReverseEquilibrium","ReverseUpEquilibrium","rfisht","rfloor","Rfr","rfr","rHar","rhard","rharu","rharul","Rho","rho","rhov","RightAngleBracket","RightArrow","Rightarrow","rightarrow","RightArrowBar","RightArrowLeftArrow","rightarrowtail","RightCeiling","RightDoubleBracket","RightDownTeeVector","RightDownVector","RightDownVectorBar","RightFloor","rightharpoondown","rightharpoonup","rightleftarrows","rightleftharpoons","rightrightarrows","rightsquigarrow","RightTee","RightTeeArrow","RightTeeVector","rightthreetimes","RightTriangle","RightTriangleBar","RightTriangleEqual","RightUpDownVector","RightUpTeeVector","RightUpVector","RightUpVectorBar","RightVector","RightVectorBar","ring","risingdotseq","rlarr","rlhar","rlm","rmoust","rmoustache","rnmid","roang","roarr","robrk","ropar","Ropf","ropf","roplus","rotimes","RoundImplies","rpar","rpargt","rppolint","rrarr","Rrightarrow","rsaquo","Rscr","rscr","Rsh","rsh","rsqb","rsquo","rsquor","rthree","rtimes","rtri","rtrie","rtrif","rtriltri","RuleDelayed","ruluhar","rx","Sacute","sacute","sbquo","Sc","sc","scap","Scaron","scaron","sccue","scE","sce","Scedil","scedil","Scirc","scirc","scnap","scnE","scnsim","scpolint","scsim","Scy","scy","sdot","sdotb","sdote","searhk","seArr","searr","searrow","sect","semi","seswar","setminus","setmn","sext","Sfr","sfr","sfrown","sharp","SHCHcy","shchcy","SHcy","shcy","ShortDownArrow","ShortLeftArrow","shortmid","shortparallel","ShortRightArrow","ShortUpArrow","shy","Sigma","sigma","sigmaf","sigmav","sim","simdot","sime","simeq","simg","simgE","siml","simlE","simne","simplus","simrarr","slarr","SmallCircle","smallsetminus","smashp","smeparsl","smid","smile","smt","smte","smtes","SOFTcy","softcy","sol","solb","solbar","Sopf","sopf","spades","spadesuit","spar","sqcap","sqcaps","sqcup","sqcups","Sqrt","sqsub","sqsube","sqsubset","sqsubseteq","sqsup","sqsupe","sqsupset","sqsupseteq","squ","Square","square","SquareIntersection","SquareSubset","SquareSubsetEqual","SquareSuperset","SquareSupersetEqual","SquareUnion","squarf","squf","srarr","Sscr","sscr","ssetmn","ssmile","sstarf","Star","star","starf","straightepsilon","straightphi","strns","Sub","subdot","subE","sube","subedot","submult","subnE","subne","subplus","subrarr","Subset","subset","subseteq","subseteqq","SubsetEqual","subsetneq","subsetneqq","subsim","subsub","subsup","succ","succapprox","succcurlyeq","Succeeds","SucceedsEqual","SucceedsSlantEqual","SucceedsTilde","succeq","succnapprox","succneqq","succnsim","succsim","SuchThat","Sum","sum","sung","Sup","sup","sup1","sup2","sup3","supdot","supdsub","supE","supe","supedot","Superset","SupersetEqual","suphsol","suphsub","suplarr","supmult","supnE","supne","supplus","Supset","supset","supseteq","supseteqq","supsetneq","supsetneqq","supsim","supsub","supsup","swarhk","swArr","swarr","swarrow","swnwar","szlig","Tab","Tau","tau","tbrk","Tcaron","tcaron","Tcedil","tcedil","Tcy","tcy","tdot","telrec","Tfr","tfr","there4","Therefore","therefore","Theta","theta","thetasym","thetav","thickapprox","thicksim","ThickSpace","thinsp","ThinSpace","thkap","thksim","THORN","thorn","Tilde","tilde","TildeEqual","TildeFullEqual","TildeTilde","times","timesb","timesbar","timesd","tint","toea","topbot","topcir","Topf","topf","topfork","tosa","tprime","TRADE","trade","triangle","triangledown","triangleleft","trianglelefteq","triangleq","triangleright","trianglerighteq","tridot","trie","triminus","TripleDot","triplus","trisb","tritime","trpezium","Tscr","tscr","TScy","tscy","TSHcy","tshcy","Tstrok","tstrok","twixt","twoheadleftarrow","twoheadrightarrow","Uacute","uacute","Uarr","uArr","uarr","Uarrocir","Ubrcy","ubrcy","Ubreve","ubreve","Ucirc","ucirc","Ucy","ucy","udarr","Udblac","udblac","udhar","ufisht","Ufr","ufr","Ugrave","ugrave","uHar","uharl","uharr","uhblk","ulcorn","ulcorner","ulcrop","ultri","Umacr","umacr","uml","UnderBar","UnderBrace","UnderBracket","UnderParenthesis","Union","UnionPlus","Uogon","uogon","Uopf","uopf","UpArrow","Uparrow","uparrow","UpArrowBar","UpArrowDownArrow","UpDownArrow","Updownarrow","updownarrow","UpEquilibrium","upharpoonleft","upharpoonright","uplus","UpperLeftArrow","UpperRightArrow","Upsi","upsi","upsih","Upsilon","upsilon","UpTee","UpTeeArrow","upuparrows","urcorn","urcorner","urcrop","Uring","uring","urtri","Uscr","uscr","utdot","Utilde","utilde","utri","utrif","uuarr","Uuml","uuml","uwangle","vangrt","varepsilon","varkappa","varnothing","varphi","varpi","varpropto","vArr","varr","varrho","varsigma","varsubsetneq","varsubsetneqq","varsupsetneq","varsupsetneqq","vartheta","vartriangleleft","vartriangleright","Vbar","vBar","vBarv","Vcy","vcy","VDash","Vdash","vDash","vdash","Vdashl","Vee","vee","veebar","veeeq","vellip","Verbar","verbar","Vert","vert","VerticalBar","VerticalLine","VerticalSeparator","VerticalTilde","VeryThinSpace","Vfr","vfr","vltri","vnsub","vnsup","Vopf","vopf","vprop","vrtri","Vscr","vscr","vsubnE","vsubne","vsupnE","vsupne","Vvdash","vzigzag","Wcirc","wcirc","wedbar","Wedge","wedge","wedgeq","weierp","Wfr","wfr","Wopf","wopf","wp","wr","wreath","Wscr","wscr","xcap","xcirc","xcup","xdtri","Xfr","xfr","xhArr","xharr","Xi","xi","xlArr","xlarr","xmap","xnis","xodot","Xopf","xopf","xoplus","xotime","xrArr","xrarr","Xscr","xscr","xsqcup","xuplus","xutri","xvee","xwedge","Yacute","yacute","YAcy","yacy","Ycirc","ycirc","Ycy","ycy","yen","Yfr","yfr","YIcy","yicy","Yopf","yopf","Yscr","yscr","YUcy","yucy","Yuml","yuml","Zacute","zacute","Zcaron","zcaron","Zcy","zcy","Zdot","zdot","zeetrf","ZeroWidthSpace","Zeta","zeta","Zfr","zfr","ZHcy","zhcy","zigrarr","Zopf","zopf","Zscr","zscr","zwj","zwnj","entityMap","NAMESPACE$1","nameStartChar","nameChar","tagNamePattern","ParseError$1","locator","XMLReader$1","copyLocator","lineNumber","columnNumber","parseElementStartPart","currentNSMap","entityReplacer","addAttribute","qname","startIndex","attributeNames","fatalError","addValue","warning","setTagName","closed","appendElement$1","domBuilder","localNSMap","qName","nsp","nsPrefix","_copy","startPrefixMapping","startElement","endElement","endPrefixMapping","parseHtmlSpecialContent","elStartEnd","elEndStart","characters","fixSelfClosed","closeMap","parseDCC","startCDATA","endCDATA","matchs","lastMatch","startDTD","endDTD","parseInstruction","processingInstruction","ElementAttributes","defaultNSMap","startDocument","defaultNSMapCopy","fixedFromCharCode","surrogate1","surrogate2","appendText","xt","lineEnd","linePattern","lineStart","parseStack","tagStart","currentElement","endMatch","locator2","parse$1","endDocument","getLocalName","getLocator","getQName","getURI","sax","XMLReader","ParseError","normalizeLineEndings","DOMParser$1","DOMHandler","cdata","_locator","_toString","chars","java","appendElement","hander","mimeType","xmlns","setDocumentLocator","errorImpl","isCallback","Function","build","msg","buildErrorHandler","xml","documentURI","ins","ignorableWhitespace","ch","charNode","skippedEntity","comm","impl","dt","__DOMHandler","merge$1","objects","flatten","lists","urlTypeToSegment","_ref10","indexRange","resolvedUri","startRange","endRange","MAX_SAFE_INTEGER","parseEndNumber","endNumber","segmentRange","static","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","periodStart","minimumUpdatePeriod","timeShiftBufferDepth","periodStartWC","segmentCount","availableStart","availableEnd","parseByDuration","startNumber","toSegments","sectionDuration","segmentsFromBase","initialization","presentationTime","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","sidx","sidxByteRange","sidxEnd","mediaReferences","references","referenceType","firstOffset","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","getUniqueTimelineStarts","timelineStarts","keyFunction","_ref11","getMediaGroupPlaylists","mediaGroupPlaylists","master","group","groupKey","labelKey","mediaProperties","updateMediaSequenceForPlaylist","_ref12","positionManifestOnTimeline","_ref15","oldManifest","newManifest","oldPlaylists","newPlaylists","_ref13","oldPlaylist","findPlaylistWithName","firstNewSegment","oldMatchingSegmentIndex","oldSegment","updateSequenceNumbers","generateSidxKey","byteRangeToString","mergeDiscontiguousPlaylists","playlistsByBaseUrl","cur","allPlaylists","playlistGroup","mergedPlaylists","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatAudioPlaylist","isAudioOnly","CODECS","serviceLocation","AUDIO","SUBTITLES","formatVttPlaylist","_ref17","m3u8Attributes","vttPlaylist","formatVideoPlaylist","_ref18","videoOnly","_ref19","audioOnly","_ref20","vttOnly","_ref21","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref23","dashPlaylists","locations","previousManifest","eventStream","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captionServices","VIDEO","organizedAudioGroup","mainPlaylist","formattedPlaylists","roleLabel","formatted","organizeAudioPlaylists","organizedVttGroup","organizeVttPlaylists","playlistTimelineStarts","_ref24","subs","cc","svcObj","svc","service","channel","easyReader","getLiveRValue","parseByTimeline","segmentTimeline","sIndex","S","d","repeat","segmentTime","nextS","identifierPattern","constructTemplateUrl","format","identifierReplacement","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","parseTemplateInfo","presentationTimeOffset","segmentsFromList","segmentUrls","segmentUrlMap","segmentUrlObject","segmentUrl","mediaRange","SegmentURLToSegmentObject","generateSegments","_ref25","segmentAttributes","segmentsFn","segmentInfo","template","segmentsInfo","toPlaylists","representations","findChildren","_ref26","getContent","parseDuration","year","month","day","hour","minute","second","parsers","mediaPresentationDuration","parseDivisionValue","parsedValue","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","baseUrlElements","baseUrlElement","initialBaseUrl","resolvedBaseUrl","finalBaseUrl","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","toEventStream","eventStreamAttributes","eventAttributes","messageData","contentEncoding","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","adaptationSetAttributes","adaptationSetBaseUrls","roleAttributes","accessibility","flags","opt","parseCaptionServiceMetadata","labelVal","keySystem","psshNode","adaptationSetSegmentInfo","repBaseUrlElements","repBaseUrls","representationSegmentInfo","inheritBaseUrls","toAdaptationSets","mpdAttributes","mpdBaseUrls","adaptationSets","generateContentSteeringInformation","contentSteeringNodes","eventHandler","infoFromContentSteeringTag","serverURL","queryBeforeStart","getPeriodStart","_ref27","priorPeriodAttributes","mpdType","inheritAttributes","manifestUri","periodNodes","periods","priorPeriod","contentSteeringInfo","representationInfo","stringToMpdXml","manifestString","parseUTCTiming","UTCTimingNode","parseUTCTimingScheme","MAX_UINT32","pow","getUint64","uint8","dv","DataView","getBigUint64","getUint32","parseSidx_1","subarray","referenceId","earliestPresentationTime","referenceCount","getUint16","startsWithSap","sapType","sapDeltaTime","ID3","getId3Offset","returnSize","getId3Size","normalizePath$1","findBox","paths","complete","normalizePaths$1","results","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getvint","removeLength","getLength","valueBytes","getInfinityDataSize","innerid","dataHeader","findEbml","normalizePaths","dataStart","dataEnd","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","positions","newLength","newData","sourceIndex","findNal","dataType","nalLimit","nalStart","nalsFound","nalOffset","nalType","CONSTANTS","_isLikely","docType","matroska","fmp4","moof","moov","ac3","avi","riff","findH264Nal","findH265Nal","isLikelyTypes","isLikelyFn","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","isLikely","detectContainerForBytes","sampleRate","timestamp","clock_1","resolveUrl","resolveManifestRedirect","req","responseURL","logger","filterRanges","timeRanges","findRange","TIME_FUDGE_FACTOR","findNextRange","printableRange","strArr","timeRangesToArray","timeRangesList","lastBufferedEnd","timeAheadOf","segmentDurationWithParts","getPartsAndSegments","si","getLastParts","lastSegment","getKnownPartCount","_ref28","partCount","liveEdgeDelay","partHoldBack","holdBack","intervalDuration","endSequence","expired","backwardDuration","forwardDuration","totalDuration","sumDurations","defaultDuration","durationList","durations","playlistEnd","useSafeLiveEnd","liveEdgePadding","lastSegmentEndTime","isExcluded","excludeUntil","isIncompatible","isEnabled","excluded","isLowestEnabledRendition","currentBandwidth","MAX_VALUE","playlistMatch","someAudioVariant","groupName","variant","Playlist","getMediaInfoForTime","startingSegmentIndex","startingPartIndex","exactManifestTimings","partsAndSegments","partAndSegment","isExtremelyCloseToTheEnd","isDisabled","isAes","estimateSegmentRequestTime","bytesReceived","createPlaylistID","groupID","forEachMediaGroup","setupMediaPlaylist","_ref32","playlistErrors_","setupMediaPlaylists","resolveMediaGroupUris","addPropertiesToMain","createGroupID","phonyUri","audioOnlyMain","groupId","DateRangesStorage","offset_","pendingDateRanges_","processedDateRanges_","setOffset","firstSegment","setPendingDateRanges","trimProcessedDateRanges_","pendingDateRange","processDateRange","getDateRangesToProcess","dateRangeClasses","dateRangesToProcess","classListIndex","EventTarget$1","updateSegment","skipped","updateSegments","oldSegments","newSegments","newIndex","newSegment","resolveSegmentUris","baseUri","getAllSegments","isPlaylistUnchanged","updateMain$1","newMedia","unchangedCheck","oldMedia","mergedPlaylist","skippedSegments","refreshDelay","lastPart","lastDuration","PlaylistLoader","logger_","vhs_","addDateRangesToTextTrack_","addDateRangesToTextTrack","vhsOptions","customTagParsers","customTagMappers","llhls","dateRangesStorage_","handleMediaupdatetimeout_","handleLoadedPlaylist_","mediaPlaylist","availableDateRanges","parameters","nextMSN","nextPart","_HLS_part","_HLS_msn","canSkipUntil","_HLS_skip","parsedUri","searchParams","addLLHLSQueryDirectives","playlistRequestError","haveMetadata","playlistString","startingState","parseManifest_","_ref31","onwarn","oninfo","customParser","parseManifest","_ref34","_ref35","playlistObject","lastRequest","pendingMedia_","media_","updateMediaUpdateTimeout_","stopRequest","mediaUpdateTimeout","finalRenditionTimeout","oldRequest","shouldDelay","delay","mediaChange","mainPlaylistRef","started","setupInitialPlaylist","srcUri","mainForMedia","updateOrDeleteClone","isUpdate","pathway","ID","oldPlaylistUri","oldPlaylistId","newPlaylistUri","createCloneURI_","newPlaylistId","createCloneAttributes_","updatedPlaylist","createClonePlaylist_","updateOrDeleteCloneMedia","oldMediaPlaylist","createClonedMediaGroups_","addClonePathway","basePlaylist","playlistId","baseID","newUri","newPlaylistID","newMediaPlaylist","newProps","baseURI","hostname","HOST","PARAMS","oldAttributes","getKeyIdSet","keyIds","keysystem","videojsXHR","callbackWrapper","reqResponse","responseTime","roundTripTime","requestTime","responseHeaders","timedout","xhrFactory","XhrFunction","beforeRequest","Vhs","_requestCallbackSet","_responseCallbackSet","xhrMethod","beforeRequestOptions","requestSet","newOptions","requestCallback","callAllRequestHooks","responseSet","responseCallback","callAllResponseHooks","originalAbort","segmentXhrHeaders","Range","byterangeEnd","byterangeStart","byterangeStr","textRange","formatHexString","formatAsciiString","createTransferableMessage","transferable","initSegmentId","segmentKeyId","hexDump","ascii","utils","tagDump","_ref37","textRanges","getProgramTime","_ref38","matchedSegment","segmentEnd","videoTimingInfo","transmuxedPresentationEnd","estimatedStart","transmuxedPresentationStart","findSegmentForPlayerTime","seekTime","programTimeObject","mediaSeconds","programTime","playerTime","transmuxerPrependedSeconds","offsetFromSegmentStart","playerTimeToProgramTime","toISOString","seekToProgramTime","_ref39","retryCount","seekTo","pauseAfterSeek","verifyProgramDateTimeTags","lastSegmentStart","lastSegmentDuration","findSegmentForProgramTime","mediaOffset","comparisonTimeStamp","segmentDateTime","segmentTimeEpoch","getOffsetFromTimestamp","seekToTime","callbackOnCompleted","containerRequest","id3Offset","finished","endRequestAndCallback","_bytes","progressListener","newPart","_len","buffers","_key","totalLen","tempBuffer","concatTypedArrays","overrideMimeType","loaded","dashPlaylistUnchanged","aSegment","bSegment","aByterange","bByterange","dashGroupId","parseMainXml","_ref41","mainXml","srcUrl","parsedManifestInfo","updateMain","oldMain","newMain","noChanges","playlistUpdate","removeOldMediaGroupLabels","equivalentSidx","compareSidxEntry","oldSidxMapping","newSidxMapping","currentSidxInfo","savedSidxInfo","sidxInfo","DashPlaylistLoader","srcUrlOrPlaylist","mainPlaylistLoader","mainPlaylistLoader_","isMain_","addMetadataToTextTrack","refreshXml_","refreshMedia_","loadedPlaylists_","sidxMapping_","childPlaylist_","requestErrored_","addSidxSegments_","mediaRequest_","fin","internal","playlistExclusionDuration","minimumUpdatePeriodTimeout_","createMupOnMedia_","hasPendingRequest","sidxChanged","isFinalRendition","updateMinimumUpdatePeriodTimeout_","requestMain_","mainChanged","haveMain_","mainXml_","date","mainLoaded_","handleMain_","syncClientServerClock_","done","utcTiming","clientOffset_","serverTime","addEventStreamToMetadataTrack_","mpl","mup","createMUPTimeout_","mediaGroupSidx","filterChangedSidxMappings","mediaID","mediaChanged","createMediaUpdateTimeout","metadataArray","eventStreamNode","cueTime","frames","defaultKID","Config","GOAL_BUFFER_LENGTH","MAX_GOAL_BUFFER_LENGTH","BACK_BUFFER_LENGTH","GOAL_BUFFER_LENGTH_RATE","INITIAL_BANDWIDTH","BANDWIDTH_VARIANCE","BUFFER_LOW_WATER_LINE","MAX_BUFFER_LOW_WATER_LINE","EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","BUFFER_HIGH_WATER_LINE","browserWorkerPolyFill","workerObj","objectUrl","createObjectURL","Blob","blob","BlobBuilder","getBlob","worker","Worker","objURL","terminate","revokeObjectURL","getWorkerString","workerCode$1","Stream$8","init","flushSource","partialFlush","endTimeline","dinf","esds","ftyp","mfhd","minf","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","MAX_UINT32$1","numbers","avc1","avcC","btrt","dref","mdat","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","payload","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","samplerate","sequenceNumber","trackFragments","samples","dependsOn","isDependedOn","hasRedundancy","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","profileIdc","profileCompatibility","levelIdc","sarRatio","hSpacing","vSpacing","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","silence","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","mp4Generator","fileType","movie","sampleForFrame","frame","dataOffset","pts","dts","keyFrame","frameUtils$1","groupNalsIntoFrames","nalUnits","currentNal","currentFrame","nalCount","nalUnitType","groupFramesIntoGops","currentGop","gops","extendFirstKeyFrame","generateSampleTable","baseDataOffset","concatenateNalData","nalsByteLength","numberOfNals","generateSampleTableForFrame","concatenateNalDataForFrame","highPrefix","lowPrefix","zeroFill","timelineStartPts","keepOriginalTimestamps","clock$2","ONE_SECOND_IN_TS","coneOfSilence","metaTable","arr","clock$1","audioFrameUtils$1","prefixWithSilence","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","silentFrame","firstFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","minSegmentPts","concatenateFrameData","sumFrameByteLengths","ONE_SECOND_IN_TS$3","trackDecodeInfo$1","clearDtsInfo","maxSegmentDts","maxSegmentPts","calculateTrackBaseMediaDecodeTime","timelineStartInfo","collectDtsInfo","captionPacketParser","parseSei","payloadType","payloadSize","parseUserData","sei","parseCaptionPackets","userData","ccData","emulationPreventionBytesPositions","USER_DATA_REGISTERED_ITU_T_T35","Stream$7","cea708Parser","CaptionStream$2","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","newCaptionPackets","escapedRBSP","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","idx","presortIndex","packet","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","rowIdx","beforeRowOverflow","addText","backspace","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","setCurrentWindow","textDecoder_","serviceProps","captionServiceEncodings","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","flushDisplayed","char","charCodeArray","newCode","isMultiByte","extended","currentByte","nextByte","unicode","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","ROWS","createDisplayBuffer","BOTTOM_ROW","indent","field","dataChannel","field_","dataChannel_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","indentations","isColorPAC","isNormalChar","logWarning","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","newBaseRow","popOn","baseRow","rollUp","paintOn","captionStream","CaptionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","Stream$6","handleRollover$1","TimestampRolloverStream$1","lastDTS","referenceDTS","type_","MetadataStream","timestampRolloverStream","TimestampRolloverStream","handleRollover","typedArray","fromIndex","currentIndex","typedArrayIndexOf","textEncodingDescriptionByte","percentEncode$1","parseUtf8","parseIso88591$1","parseSyncSafeInteger$1","frameParsers","mimeTypeEndIndex","descriptionEndIndex","pictureType","pictureData","owner","privateData","parseId3","parseId3Frames","frameSize","frameStart","tagSize","parseSyncSafeInteger","StreamTypes$3","id3","bufferSize","dispatchType","dataAlignmentIndicator","timeStamp","TransportPacketStream","TransportParseStream","ElementaryStream","metadataStream","Stream$4","CaptionStream$1","StreamTypes$2","bytesInBuffer","everything","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","h264","adts","segmentHadPmt","timedMetadata","forceFlush","packetFlushable","trackId","pes","ptsDtsFlags","startPrefix","packetLength","parsePes","flushStreams_","m2ts$1","PAT_PID","MP2T_PACKET_LENGTH","AdtsStream$1","m2ts_1","ONE_SECOND_IN_TS$2","ADTS_SAMPLING_FREQUENCIES$1","handlePartialSegments","frameNum","skipWarn_","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","ExpGolomb$1","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBits","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","H264Stream$1","NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","Stream$2","ExpGolomb","syncPoint","swapBuffer","currentPts","currentDts","readSequenceParameterSet","skipScalingList","nalByteStream","nalUnitTypeCode","expGolombDecoder","lastScale","nextScale","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","AacStream$1","H264Stream","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","isLikelyAacData","parseAdtsSize","lowThree","parseType","parseSampleRate","parseAacTimestamp","percentEncode","aacUtils","setTimestamp","bytesLeft","tempLength","VideoSegmentStream","AudioSegmentStream","Transmuxer","CoalesceStream","frameUtils","audioFrameUtils","trackDecodeInfo","m2ts","clock","AdtsStream","AacStream","ONE_SECOND_IN_TS$1","AUDIO_PROPERTIES","VIDEO_PROPERTIES","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","firstSequenceNumber","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","videoClockCyclesOfSilencePrefixed","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","dtsDistance","nearestGopObj","currentGopObj","nearestDistance","alignIndex","gopIndex","alignEndIndex","matchFound","trimIndex","alignGopsWith","newGopsToAlignWith","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","caption","captionStreams","setRemux","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","getTracks","getTimescaleFromMediaHeader","getEmsgID3","bin","parseType_1","toUnsigned$2","parseType$2","findBox$2","subresults","toUnsigned$1","getUint64$2","parseTfdt$2","parseSampleFlags","parseTrun$2","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTfhd$2","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","findBox$1","parseTfdt$1","parseTrun$1","parseTfhd$1","window$2","mapToSample","approximateOffset","parseCaptionNals","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","truns","allSamples","parseSamples","avcStream","seiNal","lastMatchedSample","avcView","logs","seiNals","matchingSample","findSeiNals","captionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isPartial","isNewInit","videoTrackIds","timescales","parsedData","cachedSegment","trackNals","parseEmbeddedCaptions","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","uint8ToCString","curChar","retString","getUint64$1","isValidEmsgBox","emsg","hasScheme","scheme_id_uri","isValidV0Box","isDefined","presentation_time_delta","isValidV1Box","presentation_time","emsg$1","parseEmsgBox","boxData","event_duration","emsgBox","message_data","scaleTime","timeDelta","toUnsigned","toHexString","parseType$1","parseTfhd","parseTrun","parseTfdt","window$1","lowestTime","baseTime","scale","traks","tkhdVersion","getUint8","sampleDescriptions","codecConfig","codecBox","segmentData","emsgBoxes","parsedBox","parsedId3Frames","probe$2","StreamTypes$1","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","parseNalUnitType","probe$1","pusi","payloadOffset","parsePesType","parsePesTime","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","StreamTypes","probe","parseAudioPes_","pesType","parsed","endLoop","table","parseVideoPes_","firstKeyFrame","inspectTs_","parsePsi_","tsInspector","baseTimestamp","audioCount","audioTimescale","inspectAac_","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","adjustTimestamp_","MessageHandlers","initArray","postMessage","action","gopInfo","timingInfo","videoSegmentTimingInfo","presentation","audioSegmentTimingInfo","trackInfo","audioTimingInfo","wireTransmuxerEvents","pushMp4Captions","trackIds","probeMp4StartTime","probeMp4Tracks","probeEmsgID3","id3Frames","emsgData","probeTs","baseStartTime","tsStartTime","timeInfo","videoStart","audioStart","clearAllMp4Captions","clearParsedMp4Captions","setTimestampOffset","timestampOffset","appendStart","onmessage","messageHandlers","TransmuxWorker","processTransmux","audioAppendStart","onData","onTrackInfo","onAudioTimingInfo","onVideoTimingInfo","onVideoSegmentTimingInfo","onAudioSegmentTimingInfo","onId3","onCaptions","onDone","onEndedTimeline","onTransmuxerLog","isEndOfTimeline","transmuxedData","waitForEndedTimelineEvent","currentTransmux","videoFrameDtsTime","videoFramePtsTime","handleData_","handleGopInfo_","_ref47","handleDone_","dequeue","transmuxQueue","processAction","enqueueAction","transmux","segmentTransmuxer","term","workerCallback","endAction","listenForEndEvent","isArrayBuffer","transfers","REQUEST_ERRORS","abortAll","activeXhrs","handleErrors","handleKeyResponse","finishProcessingFn","errorObj","parseInitSegment","_ref48","handleSegmentResponse","_ref50","newBytes","stringToArrayBuffer","lastReachedChar","stats","getRequestStats","encryptedBytes","transmuxAndNotify","_ref51","trackInfoFn","timingInfoFn","videoSegmentTimingInfoFn","audioSegmentTimingInfoFn","id3Fn","captionsFn","endedTimelineFn","dataFn","doneFn","fmp4Tracks","isMuxed","audioStartFn","audioEndFn","videoStartFn","videoEndFn","probeResult","handleSegmentBytes","_ref52","bytesAsUint8Array","isLikelyFmp4MediaSegment","isFmp4","audioCodec","videoCodec","finishLoading","_ref53","_ref54","decrypt","decryptionWorker","decryptionHandler","decrypted","keyBytes","encrypted","waitForCompletion","_ref57","didError","segmentFinish","_ref56","requestId","decryptedBytes","decryptSegment","endOfAllRequests","parseError","handleProgress","_ref59","progressFn","progressEvent","getProgressStats","firstBytesReceivedAt","mediaSegmentRequest","_ref60","xhrOptions","abortFn","keyXhr","mapKeyXhr","initSegmentOptions","initSegmentRequestCallback","_ref49","handleInitSegmentResponse","initSegmentXhr","segmentRequestOptions","segmentXhr","loadendState","activeXhr","_ref58","calledAbortFn","handleLoadEnd","logFn$1","isMaat","mediaAttributes","unwrapCodecList","codecList","_ref61","codecCount","codecObj","codecsForPlaylist","codecInfo","getCodecs","audioGroup","defaultCodecs","audioGroupId","audioType","codecsFromDefault","logFn","representationToString","safeGetComputedStyle","property","stableSort","sortFn","newArray","cmp","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","simpleSelector","playerBandwidth","limitRenditionByPlayerDimensions","playlistController","getAudioTrackPlaylists_","sortedPlaylistReps","rep","enabledPlaylistReps","bandwidthPlaylistReps","highestRemainingBandwidthRep","bandwidthBestRep","chosenRep","haveResolution","resolutionBestRepList","resolutionBestRep","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","leastPixelDiffRep","leastPixelDiffSelector","leastPixelDiffList","pixelDiff","lastBandwidthSelector","pixelRatio","useDevicePixelRatio","devicePixelRatio","systemBandwidth","playlistController_","addMetadata","_ref63","inbandTextTracks","videoDuration","Cue","WebKitDataCue","metadataTrack","metadataTrack_","deprecateOldCue","cuesArray","cuesGroupedByStartTime","timeSlot","sortedStartTimes","cueGroup","finiteDuration","nextTime","dateRangeAttr","scte35Out","scte35In","dateRangeKeysToOmit","createMetadataTrackIfNotExists","inBandMetadataTrackDispatchType","removeCuesFromTrack","finite","segmentInfoString","startOfSegment","mediaIndex","segmentLen","selection","isSyncRequest","independent","hasPartIndex","zeroBasedPartCount","timingInfoPropertyForMedia","shouldWaitForTimelineChange","_ref66","timelineChangeController","loaderType","audioDisabled","lastMainTimelineChange","lastTimelineChange","pendingAudioTimelineChange","pendingTimelineChange","segmentTooLong","_ref67","maxDuration","getTroublesomeSegmentDurationMessage","sourceType","timingInfos","typeTimingInfo","mediaDuration","isSegmentWayTooLong","isSegmentSlightlyTooLong","segmentTooLongMessage","severity","SegmentLoader","mediaSource","throughput","roundTrip","resetStats_","hasPlayed_","hasPlayed","seekable_","seeking_","mediaSource_","loaderType_","currentMediaInfo_","startingMediaInfo_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","sourceType_","sourceUpdater_","sourceUpdater","inbandTextTracks_","state_","timelineChangeController_","shouldSaveSegmentTimingInfo_","useDtsForTimestampOffset_","useDtsForTimestampOffset","captionServices_","checkBufferTimeout_","currentTimeline_","shouldForceTimestampOffsetAfterResync_","pendingSegment_","xhrOptions_","pendingSegments_","audioDisabled_","isPendingTimestampOffset_","gopBuffer_","timeMapping_","safeAppend_","appendInitSegment_","playlistOfLastInitSegment_","callQueue_","loadQueue_","metadataQueue_","waitingOnRemove_","quotaExceededErrorRetryTimeout_","activeInitSegmentId_","initSegments_","cacheEncryptionKeys_","cacheEncryptionKeys","keyCache_","decrypter_","decrypter","syncController_","syncController","syncPoint_","transmuxer_","createTransmuxer_","triggerSyncInfoUpdate_","isEndOfStream_","ended_","fetchAtBuffer_","newState","hasEnoughInfoToAppend_","processCallQueue_","hasEnoughInfoToLoad_","processLoadQueue_","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","mediaAppends","abort_","setAudio","removeAudio","monitorBuffer_","abortRequests","clearPendingTimelineChange","checkForAbort_","endOfStream","buffered_","getMediaInfo_","videoBuffered","audioBuffered","initSegmentForMap","storedMap","segmentKey","storedKey","couldBeginLoading_","playlist_","init_","resetEverything","newPlaylist","syncInfo","setDateTimeMappingForStart","oldId","updateMediaSequenceMap","resetLoader","resyncLoader","mediaSequenceDiff","saveExpiredSegmentInfo","force","removesRemaining","removeFinished","mapping","updatedBuffer","removeGopBuffer","removeVideo","monitorBufferTick_","fillBuffer_","updating","chooseNextRequest_","loadSegment_","appendedLastSegment","appendedLastPart","bufferedTime","preloaded","haveEnoughBuffer","getSyncPoint","targetTime","timelineSegments","getSyncSegmentCandidate","nextSegment","hasIndependentSegments","lastSegmentLastPart","forceTimestampOffset","generateSegmentInfo_","random","overrideCheck","timestampOffsetForSegment_","audioBufferedEnd","audioTimestampOffset","currentTimePts","gopsSafeToAlignWith","videoTimestampOffset","_ref65","timestampOffsetForSegment","earlyAbortWhenNeeded_","measuredBandwidth","requestTimeRemaining","timeUntilRebuffer$1","timeUntilRebuffer","switchCandidate","compatiblePlaylists","enabledPlaylists","rebufferingEstimates","numRequests","rebufferingImpact","noRebufferingPlaylists","estimate","minRebufferMaxBandwidthSelector","timeSavedBySwitching","minimumTimeSaving","handleAbort_","handleProgress_","simpleSegment","handleTrackInfo_","checkForIllegalMediaSwitch","akeys","bkeys","shallowEqual","handleTimingInfo_","timeType","timingInfoProperty","handleCaptions_","captionData","hasAppendedData_","captionTracks","captionTrack","trackName","def","captionService","createCaptionsTrackIfNotExists","captionArray","addCaptionData","handleId3_","processMetadataQueue_","callQueue","fun","loadQueue","getCurrentMediaInfo_","getPendingSegmentPlaylist","setTimeMapping_","updateMediaSecondsLoaded_","useVideoTimingInfo","firstVideoFrameTimeForData","trueSegmentStart_","currentStart","currentVideoTimestampOffset","updateAppendInitSegmentStatus","updateSourceBufferTimestampOffset_","updateTimingInfoEnd_","saveSegmentTimingInfo","shouldSaveTimelineMapping","appendData_","changedTimestampOffset","getInitSegmentAndUpdateState_","handleQuotaExceededError_","audioBufferStart","audioBufferEnd","videoBufferStart","videoBufferEnd","appendToSourceBuffer_","timeToRemoveUntil","MIN_BACK_BUFFER","handleAppendError_","segmentObj","concatSegments","appendBuffer","handleSegmentTimingInfo_","segmentTimingInfo","transmuxedDecodeStart","transmuxedDecodeEnd","trimBackBuffer_","updateTransmuxerAndRequestSegment_","shouldUpdateTransmuxerTimestampOffset_","createSimplifiedSegmentObj_","isEndOfStream","isWalkingForward","isDiscontinuity","segmentRequestFinished_","_ref72","removeToTime","trimTime","maxTrimTime","safeBackBufferTrimTime","previousSegment","saveTransferStats_","saveBandwidthRelatedStats_","handleTimeout_","updateGopBuffer","waitForAppendsToComplete_","timelineMapping","mappingForTimeline","waitForVideo","waitForAudio","waitingOnAppends","checkAppendsDone_","videoQueueCallback","audioQueueCallback","handleAppendsDone_","illegalMediaSwitchError","startingMedia","illegalMediaSwitch","didChange","getSegmentStartTimeForTimestampOffsetCalculation_","prioritizedTimingInfo","segmentDurationMessage","recordThroughput_","addSegmentMetadataCue_","badSegmentGuess","badPartGuess","segmentProcessingTime","segmentProcessingThroughput","bufferTypes","sourceBuffer","queuePending","shiftQueue","queueIndex","queueEntry","nextQueueIndexOfType","cleanupBuffer","titleType","inSourceBuffers","sourceBuffers","actions","onError","mime","addSourceBuffer","removeSourceBuffer","changeType","pushQueue","_ref75","onUpdateend","SourceUpdater","sourceopenListener_","audioTimestampOffset_","videoTimestampOffset_","delayedAudioAppendQueue_","videoAppendQueued_","onVideoUpdateEnd_","onAudioUpdateEnd_","onVideoError_","videoError_","onAudioError_","audioError_","createdSourceBuffers_","initializedEme_","triggeredReady_","initializedEme","hasCreatedSourceBuffers","hasInitializedAnyEme","createSourceBuffers","addOrChangeSourceBuffers","canRemoveSourceBuffer","SourceBuffer","canChangeType","processedAppend_","videoBuffer","que","audioBuffer","bufferA","bufferB","arity","extents","bufferIntersection","setDuration","uint8ToUtf8","uintArray","escape","VTT_LINE_TERMINATORS","NoVttJsError","VTTSegmentLoader","subtitlesTrack_","featuresNativeTextTracks_","loadVttJs","combinedByteLength","combinedSegment","timestampOffsetForTimeline","checkTimestampOffset","skipEmptySegments_","stopForError","requested","parseVTTCues_","updateTimeMapping_","timelines","uniqueCues","cueKey","removeDuplicateCuesFromTrack","decodeBytesToString","timestampmap","MPEGTS","LOCAL","mapData","mappingObj","diff","handleRollover_","firstStart","lastStart","valueIn90khz","referenceIn90khz","findAdCue","mediaTime","adStartTime","adEndTime","syncPointStrategies","run","mediaSequenceMap","getMediaSequenceMap","currentMediaSequence","currentPartStart","timelineToDatetimeMappings","lastDistance","datetimeMapping","z","discontinuitySync","discontinuities","SyncController","mediaSequenceStorage_","currentBaseTime","_ref76","syncPoints","runStrategies_","syncPointInfo","strategy","selectSyncPoint_","getExpiredTime","bestSyncPoint","bestDistance","bestStrategy","newDistance","lastRemovedSegment","playlistTimestamp","didCalculateSegmentTimeMapping","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","dateTime","accuracy","mediaIndexDiff","TimelineChangeController","pendingTimelineChanges_","lastTimelineChanges_","workerCode","aesTables","AES","tmp","tables","encTable","decTable","sbox","sboxInv","xInv","th","x2","x4","x8","tEnc","tDec","precompute","_tables","keyLen","rcon","encKey","decKey","encrypted0","encrypted1","encrypted2","encrypted3","out","a2","c2","nInnerRounds","kIndex","table0","table1","table2","table3","AsyncStream","jobs","timeout_","processJob_","job","ntoh","word","Decrypter","initVector","STEP","encrypted32","Int32Array","asyncStream_","decryptChunk_","padded","decipher","decrypted32","init0","init1","init2","init3","wordIx","audioTrackKind_","stopLoaders","segmentLoader","activePlaylistLoader","startLoaders","playlistLoader","excludePlaylist","activeTrack","activeGroup","defaultTrack","onTrackChanged","setupListeners","requestOptions","segmentLoaders","initialize","variantLabel","isMainPlaylist","useForcedSubtitles","groupMatch","setupMediaGroups","audioSegmentLoader","mainSegmentLoader","variants","groupKeys","groupPropertyList","onGroupChanged","getActiveGroup","previousActiveLoader","lastGroup","lastGroup_","lastTrack_","onGroupChanging","lastTrack","pc","selectPlaylist","fastQualityChange_","activeTrack_","onAudioTrackChanged","SteeringManifest","priority_","pathwayClones_","version_","ttl","ttl_","reloadUri","reloadUri_","pathwayClones","ContentSteeringController","currentPathway","defaultPathway","availablePathways_","steeringManifest","proxyServerUrl_","manifestType_","ttlTimeout_","request_","currentPathwayClones","nextPathwayClones","excludedSteeringManifestURLs","xhr_","getBandwidth_","assignTagProperties","steeringTag","serverUri","steeringUri","startsWith","decodeDataUriManifest_","pathwayId","defaultServiceLocation","proxyServerURL","requestSteeringManifest","getRequestURI","errorInfo","retrySeconds","startTTLTimeout_","steeringManifestJson","assignSteeringProperties_","setProxyServerUrl_","steeringUrl","steeringUrlObject","proxyServerUrlObject","encodeURI","setSteeringParams_","dataUri","urlObject","getPathway","networkThroughput","pathwayKey","throughputKey","steeringJson","TTL","nextPathway","pathwaysByPriority","chooseNextPathway","proxyURI","steeringURI","ttlMS","clearTTLTimeout_","addAvailablePathway","clearAvailablePathways","excludePathway","didDASHTagChange","newTag","getAvailablePathways","Vhs$1","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","PlaylistController","externVhs","useCueTags","enableLowInitialPlaylist","bufferBasedABR","maxPlaylistRetries","useCueTags_","cueTagsTrack_","requestOptions_","pauseLoading","mediaTypes_","createMediaTypes","handleDurationChange_","handleSourceOpen_","handleSourceEnded_","keyStatusMap_","segmentLoaderSettings","setupMainPlaylistLoaderListeners_","subtitleSegmentLoader_","onLoad","contentSteeringController_","setupSegmentLoaderListeners_","startABRTimer_","stopABRTimer_","triggeredFmp4Usage","loadOnPlay_","timeToLoadedData__","mainAppendsToLoadedData__","audioAppendsToLoadedData__","timeToLoadedDataStart","mainAppendsToLoadedData_","audioAppendsToLoadedData_","appendsToLoadedData_","timeToLoadedData_","checkABR_","nextPlaylist","shouldSwitchToMedia_","switchMedia_","newId","switchMediaForDASHContentSteering_","dashMediaPlaylists","abrTimer_","defaultPlaylists","defaultGroup","requestTimeout","triggerPresenceUsage_","setupFirstPlay","selectedMedia","attachContentSteeringListeners_","initContentSteeringController_","excludeUnsupportedVariants_","selectInitialPlaylist","initialMedia_","handleUpdatedMediaPlaylist","playlistToExclude","waitingForFastQualityPlaylistReceived_","runFastQualitySwitch_","lastExcludeReason_","stuckAtPlaylistEnd_","updateAdCues_","updateDuration","defaultDemuxed","audioGroupKeys","currentPlaylist","bufferLowWaterLine","bufferHighWaterLine","sharedLogLine","isBuffered","forwardBuffer","maxBufferLowWaterLine","nextBandwidth","currBandwidth","logLine","shouldSwitchToMedia","onSyncInfoUpdate_","onEndOfStream","delegateLoaders_","updateCodecs","tryToCreateSourceBuffers_","getCodecsOrExclude_","mediaSecondsLoaded_","startPoint","mainMediaInfo","absolutePlaylistEnd","pathwayAttribute_","reIncludeDelay","excludeThenChangePathway_","reincluded","errorMessage","delayDuration","fnNames","loaders","dontFilterPlaylist","loader","audioSeekable","mainSeekable","oldEnd","oldStart","updateDuration_","areMediaTypesKnown_","usingAudioLoader","hasMainMediaInfo","hasAudioMediaInfo","playlistCodecs","unsupportedCodecs","unsupportedAudio","supporter","switchMessages","newCodec","oldCodec","excludeIncompatibleVariants_","ids","unsupported","codecCount_","videoDetails","audioDetails","exclusionReasons","variantCodecs","variantCodecCount","variantVideoDetails","variantAudioDetails","adOffset","adTotal","updateAdCues","newMax","_ref64","addDateRangeMetadata","resetContentSteeringController_","availablePathways","newPathways","didPathwaysChange","handlePathwayClones_","didEnablePlaylists","differentPathwayId","noExcludeUntil","changeSegmentPathway_","entries","oldClone","equalPathwayClones_","aParams","bParams","excludeNonUsablePlaylistsByKeyId_","nonUsableKeyStatusCount","keyIdSet","hasUsableKeyStatus","nonUsableExclusion","isNonHD","excludedForNonUsableKey","addKeyStatus_","formattedKeyIdString","uInt8Buffer","padStart","bufferToHexString","updatePlaylistByKeyStatus","excludeNonUsableThenChangePlaylist_","Representation","vhsHandler","qualityChangeFunction","playlistID","changePlaylistFn","incompatible","currentlyEnabled","timerCancelEvents","PlaybackWatcher","allowSeeksWithinUnsafeLiveWindow","liveRangeSafeTimeDelta","consecutiveUpdates","lastRecordedTime","checkCurrentTimeTimeout_","playHandler","monitorCurrentTime_","canPlayHandler","waitingHandler","techWaiting_","cancelTimerHandler","resetTimeUpdate_","loaderTypes","loaderChecks","resetSegmentDownloads_","updateend","checkSegmentDownloads_","setSeekingHandlers","seekingAppendCheck_","fixesBadSeeks_","clearSeekingAppendCheck_","watchForBadSeeking_","checkCurrentTime_","isBufferedDifferent","isRangeDifferent","waiting_","afterSeekableWindow_","beforeSeekableWindow_","minAppendedDuration","bufferedToCheck","nextRange","livePoint","videoUnderflow_","skipTheGap_","allowedEnd","isLLHLS","lastVideoRange","videoRange","audioRange","gapFromVideoUnderflow_","scheduledCurrentTime","gaps","findGaps","defaultOptions","errorInterval","getSource","IWillNotUseThisInPlugins","lastCalled","localOptions","loadedMetadataHandler","cleanupEvents","reloadSourceOnError","STANDARD_PLAYLIST_SELECTOR","INITIAL_PLAYLIST_SELECTOR","movingAverageBandwidthSelector","decay","average","lastSystemBandwidth","comparePlaylistResolution","leftWidth","rightWidth","handleVhsMediaChange","waitForKeySessionCreation","_ref84","sourceKeySystems","audioMedia","mainPlaylists","eme","initializeMediaKeys","keySystemsOptionsArr","keySystems","keySystemsArr","keySystemsOptions","keySystemsObj","keySystemOptions","getAllPsshKeySystemsOptions","initializationFinishedPromises","keySessionCreatedPromises","setupEmeOptions","_ref85","sourceOptions","audioPlaylist","videoContentType","audioContentType","keySystemContentTypes","emeKeySystems","getVhsLocalStorage","storedObject","addOnRequestHook","addOnResponseHook","removeOnRequestHook","removeOnResponseHook","supportsNativeHls","canItPlay","supportsNativeDash","supportsTypeNatively","onRequest","onResponse","offRequest","offResponse","Component","VhsHandler","initialBandwidth","_player","source_","ignoreNextSeekingEvent_","setOptions_","overrideNative","featuresNativeVideoTracks","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","useBandwidthFromLocalStorage","useNetworkInformationApi","option","setOptions","playbackWatcherOptions","playbackWatcher_","defaultSelector","playerBandwidthEst","networkInformation","connection","mozConnection","webkitConnection","networkInfoBandwidthEstBitsPerSec","downlink","invBandwidth","invThroughput","mediaRequests_","mediaRequestsAborted_","mediaRequestsTimedout_","mediaRequestsErrored_","mediaTransferDuration_","mediaBytesTransferred_","mediaAppends_","mainAppendsToLoadedData","audioAppendsToLoadedData","appendsToLoadedData","timeToLoadedData","currentTech","playerDimensions","objectToStore","updateVhsLocalStorage","setupEme_","setupQualityLevels_","mediaSourceUrl_","createKeySessions_","audioPlaylistLoader","handleWaitingForKey_","didSetupEmeOptions","qualityLevels_","convertToProgramTime","setupXhrHooks_","VhsSourceHandler","simpleType","getOverrideNative","defaultOverrideNative"],"mappings":"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AAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAQ,MAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,O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"}