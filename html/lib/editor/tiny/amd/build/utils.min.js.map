{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {renderForPromise} from 'core/templates';\nimport {getFilePicker} from './options';\nimport {getString} from 'core/str';\n\n/**\n * Get the image path for the specified image.\n *\n * @param {string} identifier The name of the image\n * @param {string} component The component name\n * @return {string} The image URL path\n */\nexport const getImagePath = (identifier, component = 'editor_tiny') => Promise.resolve(M.util.image_url(identifier, component));\n\nexport const getButtonImage = async(identifier, component = 'editor_tiny') => renderForPromise('editor_tiny/toolbar_button', {\n    image: await getImagePath(identifier, component),\n});\n\n/**\n * Helper to display a filepicker and return a Promise.\n *\n * The Promise will resolve when a file is selected, or reject if the file type is not found.\n *\n * @param {TinyMCE} editor\n * @param {string} filetype\n * @returns {Promise<object>} The file object returned by the filepicker\n */\nexport const displayFilepicker = (editor, filetype) => new Promise((resolve, reject) => {\n    const configuration = getFilePicker(editor, filetype);\n    if (configuration) {\n        const options = {\n            ...configuration,\n            formcallback: resolve,\n            previousActiveElement: document.activeElement,\n        };\n        M.core_filepicker.show(Y, options);\n        return;\n    }\n    reject(`Unknown filetype ${filetype}`);\n});\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified button to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {string} button\n * @param {string|null} [after=null]\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButton = (toolbar, section, button, after = null) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: [button],\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            if (after) {\n                // Insert new button after the specified button.\n                let index = item.items.findIndex(value => value == after);\n                if (index !== -1) {\n                    item.items.splice(index + 1, 0, button);\n                }\n            } else {\n                // Append button to end of button section.\n                item.items.push(button);\n            }\n        }\n\n        return item;\n    });\n};\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified buttons to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {Array} buttons\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButtons = (toolbar, section, buttons) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: buttons,\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            buttons.forEach(button => item.items.push(button));\n        }\n\n        return item;\n    });\n};\n\n/**\n * Insert a new section into the toolbar.\n *\n * @param {array} toolbar The TinyMCE.editor.settings.toolbar configuration\n * @param {string} name The new section name to add\n * @param {string} relativeTo Insert relative to this section name\n * @param {boolean} append Append or Prepend\n * @returns {array}\n */\nexport const addToolbarSection = (toolbar, name, relativeTo, append = true) => {\n    const newSection = {\n        name,\n        items: [],\n    };\n    const sectionInserted = toolbar.some((section, index) => {\n        if (section.name === relativeTo) {\n            if (append) {\n                toolbar.splice(index + 1, 0, newSection);\n            } else {\n                toolbar.splice(index, 0, newSection);\n            }\n            return true;\n        }\n        return false;\n    });\n\n    if (!sectionInserted) {\n        // Relative section not found.\n        if (append) {\n            toolbar.push(newSection);\n        } else {\n            toolbar.unshift(newSection);\n        }\n    }\n\n    return toolbar;\n};\n\n/**\n * Given a TinyMCE Menubar configuration, add the specified button to the named section.\n *\n * @param {object} menubar\n * @param {string} section\n * @param {string} menuitem\n * @param {string|null} [after=null]\n * @returns {object}\n */\nexport const addMenubarItem = (menubar, section, menuitem, after = null) => {\n    if (!menubar) {\n        const emptyMenubar = {};\n        emptyMenubar[section] = {\n            title: section,\n            items: menuitem,\n        };\n    }\n\n    const mutatedMenubar = JSON.parse(JSON.stringify(menubar));\n    Array.from(Object.entries(mutatedMenubar)).forEach(([name, menu]) => {\n        if (name === section) {\n            if (after) {\n                // Insert new item after the specified menu item.\n                let index = menu.items.indexOf(after);\n                if (index !== -1) {\n                    index += after.length;\n                    menu.items = menu.items.slice(0, index) + ` ${menuitem}` + menu.items.slice(index);\n                }\n            } else {\n                // Append item to end of the menu section.\n                menu.items = `${menu.items} ${menuitem}`;\n            }\n        }\n    });\n\n    return mutatedMenubar;\n};\n\n/**\n * Given a TinyMCE contextmenu configuration, add the specified button to the end.\n *\n * @param {string} contextmenu\n * @param {string[]} menuitems\n * @returns {string}\n */\nexport const addContextmenuItem = (contextmenu, ...menuitems) => {\n    const contextmenuItems = (contextmenu || '').split(' ');\n\n    return contextmenuItems\n        .concat(menuitems)\n        .filter((item) => item !== '')\n        .join(' ');\n};\n\n/**\n * Given a TinyMCE quickbars configuration, add items to the menu.\n *\n * @param {string} quicktoolbar\n * @param {string[]} toolbaritems\n * @returns {string}\n */\nexport const addQuickbarsToolbarItem = (quicktoolbar, ...toolbaritems) => {\n    const quicktoolbarItems = (quicktoolbar || '').split(' ');\n\n    return quicktoolbarItems\n        .concat(toolbaritems)\n        .filter((item) => item !== '')\n        .join(' ');\n};\n\n/**\n * This function will calculate and add items to toolbar with below logic:\n * 1. If the number of the items is larger than one, it will add all the items to a menu button.\n * 2. If the number of the items is one, it will add the item directly to the toolbar.\n *\n * @param {TinyMCE} editor\n * @param {Array} items\n * @param {String} menuName\n * @param {String} menuIcon\n * @param {String} menuIconText\n * @param {String} singleIcon\n * @param {String} singleIconText\n * @param {String} singleAction\n */\nexport const addDynamicToolbarMenu = (editor, items, menuName, menuIcon,\n        menuIconText, singleIcon, singleIconText, singleAction) => {\n    if (items.length > 1) {\n        // Use context menu.\n        editor.ui.registry.addMenuButton(menuName, {\n            icon: menuIcon,\n            tooltip: menuIconText,\n            fetch: callback => callback(`${items.join(' ')}`),\n        });\n    } else {\n        // Use single button.\n        editor.ui.registry.addButton(menuName, {\n            icon: singleIcon,\n            tooltip: singleIconText,\n            onAction: singleAction,\n        });\n    }\n};\n\n/**\n * Get the link to the user documentation for the named plugin.\n *\n * @param {string} pluginName\n * @returns {string}\n */\nexport const getDocumentationLink = (pluginName) => `https://docs.moodle.org/en/editor_tiny/${pluginName}`;\n\n/**\n * Get the default plugin metadata for the named plugin.\n * If no URL is provided, then a URL is generated pointing to the standard Moodle Documentation.\n *\n * @param {string} component The component name\n * @param {string} pluginName The plugin name\n * @param {string|null} [url=null] An optional URL to the plugin documentation\n * @returns {object}\n */\nexport const getPluginMetadata = async(component, pluginName, url = null) => {\n    const name = await getString('pluginname', component);\n    return {\n        getMetadata: () => ({\n            name,\n            url: url ?? getDocumentationLink(pluginName),\n        }),\n    };\n};\n\n/**\n * Ensure that the editor is still in the DOM, removing it if it is not.\n *\n * @param {TinyMCE} editor\n * @returns {TinyMCE|null}\n */\nexport const ensureEditorIsValid = (editor) => {\n    // TinyMCE uses the element ID as a map key internally, even if the target has changed.\n    // In cases such as where an editor is in a modal form which has been detached from the DOM, but the editor not removed,\n    // we need to manually destroy the editor.\n    // We could theoretically do this with a Mutation Observer, but in some cases the Node may be moved,\n    // or added back elsewhere in the DOM.\n    if (!editor.getElement().isConnected) {\n        return null;\n    }\n\n    return editor;\n};\n\n/**\n * Given a TinyMCE Toolbar configuration, remove the specified button from the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {string} button\n * @returns {object} The toolbar configuration\n */\n export const removeToolbarButton = (toolbar, section, button) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: [button],\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            item.items.splice(item.items.indexOf(button), 1);\n        }\n\n        return item;\n    });\n};\n\n/**\n * Given a TinyMCE Toolbar configuration, remove the specified buttons from the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {Array} buttons\n * @returns {object} The toolbar configuration\n */\n export const removeToolbarButtons = (toolbar, section, buttons) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: buttons,\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            buttons.forEach(button => item.items.splice(item.items.indexOf(button), 1));\n        }\n\n        return item;\n    });\n};\n\n/**\n * Remove the specified sub-menu item from the named section.\n * Recreate a menu with the same sub-menu items but remove the specified item.\n *\n * @param {TinyMCE} editor\n * @param {string} section\n * @param {string} submenuitem The text of sub-menu that we want to removed\n */\nexport const removeSubmenuItem = async(editor, section, submenuitem) => {\n    // Get menu items.\n    const menuItems = editor.ui.registry.getAll().menuItems[section];\n\n    // Because we will match between title strings,\n    // we make sure no problems arise while applying multi-language.\n    const submenuitemtitle = await getString(submenuitem, 'editor_tiny');\n\n    // Overriding the menu items,\n    // by recreating them but excluding the specified sub-menu.\n    if (menuItems) {\n        editor.ui.registry.addNestedMenuItem(\n            section,\n            {\n                text: menuItems.text,\n                getSubmenuItems: () => {\n                    let newSubmenu = [];\n                    menuItems.getSubmenuItems().forEach((item) => {\n                        // Need to trim the text because some of the sub-menus use space to replace an icon.\n                        if (item.text.trim() != submenuitemtitle) {\n                            newSubmenu.push(item);\n                        }\n                    });\n                    return newSubmenu;\n                }\n            }\n        );\n    }\n};\n\n/**\n * Given a TinyMCE Menubar configuration, remove the specified menu from the named section.\n *\n * @param {string} menubar\n * @param {string} section\n * @param {string} menuitem\n * @returns {object}\n */\nexport const removeMenubarItem = (menubar, section, menuitem) => {\n    menubar[section].items = menubar[section].items\n        .replace(menuitem, '');\n\n    return menubar;\n};\n\n/**\n * Given a TinyMCE Menubar configuration, remove the specified menu from the named section.\n *\n * @param {string} menubar\n * @param {string} section\n * @param {Array} menuitems\n * @returns {object}\n */\nexport const removeMenubarItems = (menubar, section, menuitems) => {\n    // Create RegExp pattern.\n    const regexPattern = new RegExp(menuitems.join('|'), \"ig\");\n\n    // Remove menuitems.\n    menubar[section].items = menubar[section].items.replace(regexPattern, '');\n\n    return menubar;\n};\n\n/**\n * Updates the state of the editor.\n *\n * @param {TinyMCE} editor\n * @param {HTMLElement} target\n */\nexport const updateEditorState = (editor, target) => {\n    if (target.hasAttribute('readonly')) {\n        editor.mode.set(\"readonly\");\n    } else {\n        editor.mode.set(\"design\");\n    }\n};\n"],"names":["getImagePath","identifier","component","Promise","resolve","M","util","image_url","async","image","editor","filetype","reject","configuration","options","formcallback","previousActiveElement","document","activeElement","core_filepicker","show","Y","toolbar","section","button","after","name","items","mutatedToolbar","JSON","parse","stringify","map","item","index","findIndex","value","splice","push","buttons","forEach","relativeTo","append","newSection","sectionInserted","some","unshift","menubar","menuitem","title","mutatedMenubar","Array","from","Object","entries","_ref","menu","indexOf","length","slice","contextmenu","contextmenuItems","split","menuitems","concat","filter","join","quicktoolbar","quicktoolbarItems","toolbaritems","menuName","menuIcon","menuIconText","singleIcon","singleIconText","singleAction","ui","registry","addMenuButton","icon","tooltip","fetch","callback","addButton","onAction","getDocumentationLink","pluginName","url","getMetadata","getElement","isConnected","submenuitem","menuItems","getAll","submenuitemtitle","addNestedMenuItem","text","getSubmenuItems","newSubmenu","trim","replace","regexPattern","RegExp","target","hasAttribute","mode","set"],"mappings":"4sBA0BaA,aAAe,SAACC,gBAAYC,iEAAY,qBAAkBC,QAAQC,QAAQC,EAAEC,KAAKC,UAAUN,WAAYC,wEAEtFM,eAAMP,gBAAYC,iEAAY,qBAAkB,+BAAiB,6BAA8B,CACzHO,YAAaT,aAAaC,WAAYC,yCAYT,CAACQ,OAAQC,WAAa,IAAIR,SAAQ,CAACC,QAASQ,gBACnEC,eAAgB,0BAAcH,OAAQC,aACxCE,qBACMC,QAAU,IACTD,cACHE,aAAcX,QACdY,sBAAuBC,SAASC,eAEpCb,EAAEc,gBAAgBC,KAAKC,EAAGP,cAG9BF,kCAA2BD,wCAYC,SAACW,QAASC,QAASC,YAAQC,6DAAQ,SAC1DH,cACM,CAAC,CACJI,KAAMH,QACNI,MAAO,CAACH,gBAIVI,eAAiBC,KAAKC,MAAMD,KAAKE,UAAUT,iBAC1CM,eAAeI,KAAKC,UACnBA,KAAKP,OAASH,WACVE,MAAO,KAEHS,MAAQD,KAAKN,MAAMQ,WAAUC,OAASA,OAASX,SACpC,IAAXS,OACAD,KAAKN,MAAMU,OAAOH,MAAQ,EAAG,EAAGV,aAIpCS,KAAKN,MAAMW,KAAKd,eAIjBS,oCAYkB,CAACX,QAASC,QAASgB,eAC3CjB,cACM,CAAC,CACJI,KAAMH,QACNI,MAAOY,iBAIQV,KAAKC,MAAMD,KAAKE,UAAUT,UAC3BU,KAAKC,OACnBA,KAAKP,OAASH,SACdgB,QAAQC,SAAQhB,QAAUS,KAAKN,MAAMW,KAAKd,UAGvCS,oCAakB,SAACX,QAASI,KAAMe,gBAAYC,wEACnDC,WAAa,CACfjB,KAAAA,KACAC,MAAO,IAELiB,gBAAkBtB,QAAQuB,MAAK,CAACtB,QAASW,QACvCX,QAAQG,OAASe,aACbC,OACApB,QAAQe,OAAOH,MAAQ,EAAG,EAAGS,YAE7BrB,QAAQe,OAAOH,MAAO,EAAGS,aAEtB,YAKVC,kBAEGF,OACApB,QAAQgB,KAAKK,YAEbrB,QAAQwB,QAAQH,aAIjBrB,iCAYmB,SAACyB,QAASxB,QAASyB,cAAUvB,6DAAQ,SAC1DsB,QAAS,EACW,IACRxB,SAAW,CACpB0B,MAAO1B,QACPI,MAAOqB,gBAITE,eAAiBrB,KAAKC,MAAMD,KAAKE,UAAUgB,iBACjDI,MAAMC,KAAKC,OAAOC,QAAQJ,iBAAiBV,SAAQe,WAAE7B,KAAM8B,cACnD9B,OAASH,WACLE,MAAO,KAEHS,MAAQsB,KAAK7B,MAAM8B,QAAQhC,QAChB,IAAXS,QACAA,OAAST,MAAMiC,OACfF,KAAK7B,MAAQ6B,KAAK7B,MAAMgC,MAAM,EAAGzB,kBAAac,UAAaQ,KAAK7B,MAAMgC,MAAMzB,aAIhFsB,KAAK7B,gBAAW6B,KAAK7B,kBAASqB,aAKnCE,4CAUuB,SAACU,mBACzBC,kBAAoBD,aAAe,IAAIE,MAAM,mCADJC,6DAAAA,yCAGxCF,iBACFG,OAAOD,WACPE,QAAQhC,MAAkB,KAATA,OACjBiC,KAAK,uCAUyB,SAACC,oBAC9BC,mBAAqBD,cAAgB,IAAIL,MAAM,oCADAO,sEAAAA,8CAG9CD,kBACFJ,OAAOK,cACPJ,QAAQhC,MAAkB,KAATA,OACjBiC,KAAK,qCAiBuB,CAACxD,OAAQiB,MAAO2C,SAAUC,SACvDC,aAAcC,WAAYC,eAAgBC,gBAC1ChD,MAAM+B,OAAS,EAEfhD,OAAOkE,GAAGC,SAASC,cAAcR,SAAU,CACvCS,KAAMR,SACNS,QAASR,aACTS,MAAOC,UAAYA,mBAAYvD,MAAMuC,KAAK,SAI9CxD,OAAOkE,GAAGC,SAASM,UAAUb,SAAU,CACnCS,KAAMN,WACNO,QAASN,eACTU,SAAUT,sBAWTU,qBAAwBC,6DAAyDA,0FAW7D9E,eAAMN,UAAWoF,gBAAYC,2DAAM,WAC1D7D,WAAa,kBAAU,aAAcxB,iBACpC,CACHsF,YAAa,MACT9D,KAAAA,KACA6D,IAAKA,MAAAA,IAAAA,IAAOF,qBAAqBC,6CAWT5E,QAM3BA,OAAO+E,aAAaC,YAIlBhF,OAHI,kCAcqB,CAACY,QAASC,QAASC,cAC9CF,cACM,CAAC,CACJI,KAAMH,QACNI,MAAO,CAACH,iBAIOK,KAAKC,MAAMD,KAAKE,UAAUT,UAC3BU,KAAKC,OACnBA,KAAKP,OAASH,SACdU,KAAKN,MAAMU,OAAOJ,KAAKN,MAAM8B,QAAQjC,QAAS,GAG3CS,uCAYsB,CAACX,QAASC,QAASgB,eAC/CjB,cACM,CAAC,CACJI,KAAMH,QACNI,MAAOY,iBAIQV,KAAKC,MAAMD,KAAKE,UAAUT,UAC3BU,KAAKC,OACnBA,KAAKP,OAASH,SACdgB,QAAQC,SAAQhB,QAAUS,KAAKN,MAAMU,OAAOJ,KAAKN,MAAM8B,QAAQjC,QAAS,KAGrES,oCAYkBzB,MAAME,OAAQa,QAASoE,qBAE9CC,UAAYlF,OAAOkE,GAAGC,SAASgB,SAASD,UAAUrE,SAIlDuE,uBAAyB,kBAAUH,YAAa,eAIlDC,WACAlF,OAAOkE,GAAGC,SAASkB,kBACfxE,QACA,CACIyE,KAAMJ,UAAUI,KAChBC,gBAAiB,SACTC,WAAa,UACjBN,UAAUK,kBAAkBzD,SAASP,OAE7BA,KAAK+D,KAAKG,QAAUL,kBACpBI,WAAW5D,KAAKL,SAGjBiE,0CAeM,CAACnD,QAASxB,QAASyB,YAChDD,QAAQxB,SAASI,MAAQoB,QAAQxB,SAASI,MACrCyE,QAAQpD,SAAU,IAEhBD,qCAWuB,CAACA,QAASxB,QAASwC,mBAE3CsC,aAAe,IAAIC,OAAOvC,UAAUG,KAAK,KAAM,aAGrDnB,QAAQxB,SAASI,MAAQoB,QAAQxB,SAASI,MAAMyE,QAAQC,aAAc,IAE/DtD,oCASsB,CAACrC,OAAQ6F,UAClCA,OAAOC,aAAa,YACpB9F,OAAO+F,KAAKC,IAAI,YAEhBhG,OAAO+F,KAAKC,IAAI"}