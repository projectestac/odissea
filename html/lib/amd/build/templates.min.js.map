{"version":3,"file":"templates.min.js","sources":["../src/templates.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Template renderer for Moodle. Load and render Moodle templates with Mustache.\n *\n * @module     core/templates\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      2.9\n */\n\nimport $ from 'jquery';\nimport * as config from 'core/config';\nimport * as filterEvents from 'core_filters/events';\nimport * as Y from 'core/yui';\nimport Renderer from './local/templates/renderer';\nimport {getNormalisedComponent} from 'core/utils';\n\n/**\n * Execute a block of JS returned from a template.\n * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\n *\n * @method runTemplateJS\n * @param {string} source - A block of javascript.\n */\nconst runTemplateJS = (source) => {\n    if (source.trim() !== '') {\n        // Note. We continue to use jQuery here because people are doing some dumb things\n        // and we need to find, seek, and destroy first.\n        // In particular, people are providing a mixture of JS, and HTML content here.\n        // jQuery is someohow, magically, detecting this and putting tags into tags.\n        const newScript = $('<script>').attr('type', 'text/javascript').html(source);\n        $('head').append(newScript);\n        if (newScript.find('script').length) {\n            window.console.error(\n                'Template JS contains a script tag. This is not allowed. Only raw JS should be present here.',\n                source,\n            );\n        }\n    }\n};\n\n/**\n * Do some DOM replacement and trigger correct events and fire javascript.\n *\n * @method domReplace\n * @param {JQuery} element - Element or selector to replace.\n * @param {String} newHTML - HTML to insert / replace.\n * @param {String} newJS - Javascript to run after the insertion.\n * @param {Boolean} replaceChildNodes - Replace only the childnodes, alternative is to replace the entire node.\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nconst domReplace = (element, newHTML, newJS, replaceChildNodes) => {\n    const replaceNode = $(element);\n    if (!replaceNode.length) {\n        return [];\n    }\n    // First create the dom nodes so we have a reference to them.\n    const newNodes = $(newHTML);\n    // Do the replacement in the page.\n    if (replaceChildNodes) {\n        // Cleanup any YUI event listeners attached to any of these nodes.\n        const yuiNodes = new Y.NodeList(replaceNode.children().get());\n        yuiNodes.destroy(true);\n\n        // JQuery will cleanup after itself.\n        replaceNode.empty();\n        replaceNode.append(newNodes);\n    } else {\n        // Cleanup any YUI event listeners attached to any of these nodes.\n        const yuiNodes = new Y.NodeList(replaceNode.get());\n        yuiNodes.destroy(true);\n\n        // JQuery will cleanup after itself.\n        replaceNode.replaceWith(newNodes);\n    }\n    // Run any javascript associated with the new HTML.\n    runTemplateJS(newJS);\n    // Notify all filters about the new content.\n    filterEvents.notifyFilterContentUpdated(newNodes);\n\n    return newNodes.get();\n};\n\n/**\n * Prepend some HTML to a node and trigger events and fire javascript.\n *\n * @method domPrepend\n * @param {jQuery|String} element - Element or selector to prepend HTML to\n * @param {String} html - HTML to prepend\n * @param {String} js - Javascript to run after we prepend the html\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nconst domPrepend = (element, html, js) => {\n    const node = $(element);\n    if (!node.length) {\n        return [];\n    }\n\n    // Prepend the html.\n    const newContent = $(html);\n    node.prepend(newContent);\n    // Run any javascript associated with the new HTML.\n    runTemplateJS(js);\n    // Notify all filters about the new content.\n    filterEvents.notifyFilterContentUpdated(node);\n\n    return newContent.get();\n};\n\n/**\n * Append some HTML to a node and trigger events and fire javascript.\n *\n * @method domAppend\n * @param {jQuery|String} element - Element or selector to append HTML to\n * @param {String} html - HTML to append\n * @param {String} js - Javascript to run after we append the html\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nconst domAppend = (element, html, js) => {\n    const node = $(element);\n    if (!node.length) {\n        return [];\n    }\n    // Append the html.\n    const newContent = $(html);\n    node.append(newContent);\n    // Run any javascript associated with the new HTML.\n    runTemplateJS(js);\n    // Notify all filters about the new content.\n    filterEvents.notifyFilterContentUpdated(node);\n\n    return newContent.get();\n};\n\nconst wrapPromiseInWhenable = (promise) => $.when(new Promise((resolve, reject) => {\n    promise.then(resolve).catch(reject);\n}));\n\nexport default {\n    // Public variables and functions.\n    /**\n     * Every call to render creates a new instance of the class and calls render on it. This\n     * means each render call has it's own class variables.\n     *\n     * @method render\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {Object} context - Could be array, string or simple value for the context of the template.\n     * @param {string} themeName - Name of the current theme.\n     * @return {Promise} JQuery promise object resolved when the template has been rendered.\n     */\n    render: (templateName, context, themeName = config.theme) => {\n        const renderer = new Renderer();\n\n        // Turn the Native Promise into a jQuery Promise for backwards compatability.\n        return $.when(new Promise((resolve, reject) => {\n            renderer.render(templateName, context, themeName)\n            .then(resolve)\n            .catch(reject);\n        }))\n        .then(({html, js}) => $.Deferred().resolve(html, js));\n    },\n\n    /**\n     * Prefetch a set of templates without rendering them.\n     *\n     * @method getTemplate\n     * @param {Array} templateNames The list of templates to fetch\n     * @param {String} [themeName=config.themeName] The name of the theme to use\n     * @returns {Promise}\n     */\n    prefetchTemplates: (templateNames, themeName = config.theme) => {\n        const Loader = Renderer.getLoader();\n\n        return Loader.prefetchTemplates(templateNames, themeName);\n    },\n\n    /**\n     * Every call to render creates a new instance of the class and calls render on it. This\n     * means each render call has it's own class variables.\n     *\n     * This alernate to the standard .render() function returns the html and js in a single object suitable for a\n     * native Promise.\n     *\n     * @method renderForPromise\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {Object} context - Could be array, string or simple value for the context of the template.\n     * @param {string} themeName - Name of the current theme.\n     * @return {Promise} JQuery promise object resolved when the template has been rendered.\n     */\n    renderForPromise: (templateName, context, themeName) => {\n        const renderer = new Renderer();\n        return renderer.render(templateName, context, themeName);\n    },\n\n    /**\n     * Every call to renderIcon creates a new instance of the class and calls renderIcon on it. This\n     * means each render call has it's own class variables.\n     *\n     * @method renderPix\n     * @param {string} key - Icon key.\n     * @param {string} component - Icon component\n     * @param {string} title - Icon title\n     * @return {Promise} JQuery promise object resolved when the pix has been rendered.\n     */\n    renderPix: (key, component, title) => {\n        const renderer = new Renderer();\n        return wrapPromiseInWhenable(renderer.renderIcon(\n            key,\n            getNormalisedComponent(component),\n            title\n        ));\n    },\n\n    /**\n     * Execute a block of JS returned from a template.\n     * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\n     *\n     * @method runTemplateJS\n     * @param {string} source - A block of javascript.\n     */\n    runTemplateJS: runTemplateJS,\n\n    /**\n     * Replace a node in the page with some new HTML and run the JS.\n     *\n     * @method replaceNodeContents\n     * @param {JQuery} element - Element or selector to replace.\n     * @param {String} newHTML - HTML to insert / replace.\n     * @param {String} newJS - Javascript to run after the insertion.\n     * @return {Array} The list of new DOM Nodes\n     */\n    replaceNodeContents: (element, newHTML, newJS) => domReplace(element, newHTML, newJS, true),\n\n    /**\n     * Insert a node in the page with some new HTML and run the JS.\n     *\n     * @method replaceNode\n     * @param {JQuery} element - Element or selector to replace.\n     * @param {String} newHTML - HTML to insert / replace.\n     * @param {String} newJS - Javascript to run after the insertion.\n     * @return {Array} The list of new DOM Nodes\n     */\n    replaceNode: (element, newHTML, newJS) => domReplace(element, newHTML, newJS, false),\n\n    /**\n     * Prepend some HTML to a node and trigger events and fire javascript.\n     *\n     * @method prependNodeContents\n     * @param {jQuery|String} element - Element or selector to prepend HTML to\n     * @param {String} html - HTML to prepend\n     * @param {String} js - Javascript to run after we prepend the html\n     * @return {Array} The list of new DOM Nodes\n     */\n    prependNodeContents: (element, html, js) => domPrepend(element, html, js),\n\n    /**\n     * Append some HTML to a node and trigger events and fire javascript.\n     *\n     * @method appendNodeContents\n     * @param {jQuery|String} element - Element or selector to append HTML to\n     * @param {String} html - HTML to append\n     * @param {String} js - Javascript to run after we append the html\n     * @return {Array} The list of new DOM Nodes\n     */\n    appendNodeContents: (element, html, js) => domAppend(element, html, js),\n};\n"],"names":["runTemplateJS","source","trim","newScript","attr","html","append","find","length","window","console","error","domReplace","element","newHTML","newJS","replaceChildNodes","replaceNode","newNodes","Y","NodeList","children","get","destroy","empty","replaceWith","filterEvents","notifyFilterContentUpdated","render","templateName","context","themeName","config","theme","renderer","Renderer","$","when","Promise","resolve","reject","then","catch","_ref","js","Deferred","prefetchTemplates","templateNames","Loader","getLoader","renderForPromise","renderPix","key","component","title","promise","renderIcon","replaceNodeContents","prependNodeContents","node","newContent","prepend","domPrepend","appendNodeContents","domAppend"],"mappings":";;;;;;;;sSAsCMA,cAAiBC,YACG,KAAlBA,OAAOC,OAAe,OAKhBC,WAAY,mBAAE,YAAYC,KAAK,OAAQ,mBAAmBC,KAAKJ,4BACnE,QAAQK,OAAOH,WACbA,UAAUI,KAAK,UAAUC,QACzBC,OAAOC,QAAQC,MACX,8FACAV,UAiBVW,WAAa,CAACC,QAASC,QAASC,MAAOC,2BACnCC,aAAc,mBAAEJ,aACjBI,YAAYT,aACN,SAGLU,UAAW,mBAAEJ,YAEfE,kBAAmB,CAEF,IAAIG,EAAEC,SAASH,YAAYI,WAAWC,OAC9CC,SAAQ,GAGjBN,YAAYO,QACZP,YAAYX,OAAOY,cAChB,CAEc,IAAIC,EAAEC,SAASH,YAAYK,OACnCC,SAAQ,GAGjBN,YAAYQ,YAAYP,iBAG5BlB,cAAce,OAEdW,aAAaC,2BAA2BT,UAEjCA,SAASI,oBA4DL,CAcXM,OAAQ,SAACC,aAAcC,aAASC,iEAAYC,OAAOC,YACzCC,SAAW,IAAIC,yBAGdC,gBAAEC,KAAK,IAAIC,SAAQ,CAACC,QAASC,UAChCN,SAASN,OAAOC,aAAcC,QAASC,WACtCU,KAAKF,SACLG,MAAMF,YAEVC,MAAKE,WAACtC,KAACA,KAADuC,GAAOA,gBAAQR,gBAAES,WAAWN,QAAQlC,KAAMuC,QAWrDE,kBAAmB,SAACC,mBAAehB,iEAAYC,OAAOC,YAC5Ce,OAASb,kBAASc,mBAEjBD,OAAOF,kBAAkBC,cAAehB,YAkBnDmB,iBAAkB,CAACrB,aAAcC,QAASC,aACrB,IAAII,mBACLP,OAAOC,aAAcC,QAASC,WAalDoB,UAAW,CAACC,IAAKC,UAAWC,eAClBpB,SAAW,IAAIC,yBA3EEoB,QA4EMrB,SAASsB,WAClCJ,KACA,iCAAuBC,WACvBC,OA/E+BlB,gBAAEC,KAAK,IAAIC,SAAQ,CAACC,QAASC,UACpEe,QAAQd,KAAKF,SAASG,MAAMF,YADDe,IAAAA,SA0F3BvD,cAAeA,cAWfyD,oBAAqB,CAAC5C,QAASC,QAASC,QAAUH,WAAWC,QAASC,QAASC,OAAO,GAWtFE,YAAa,CAACJ,QAASC,QAASC,QAAUH,WAAWC,QAASC,QAASC,OAAO,GAW9E2C,oBAAqB,CAAC7C,QAASR,KAAMuC,KAtKtB,EAAC/B,QAASR,KAAMuC,YACzBe,MAAO,mBAAE9C,aACV8C,KAAKnD,aACC,SAILoD,YAAa,mBAAEvD,aACrBsD,KAAKE,QAAQD,YAEb5D,cAAc4C,IAEdlB,aAAaC,2BAA2BgC,MAEjCC,WAAWtC,OAwJ0BwC,CAAWjD,QAASR,KAAMuC,IAWtEmB,mBAAoB,CAAClD,QAASR,KAAMuC,KAtJtB,EAAC/B,QAASR,KAAMuC,YACxBe,MAAO,mBAAE9C,aACV8C,KAAKnD,aACC,SAGLoD,YAAa,mBAAEvD,aACrBsD,KAAKrD,OAAOsD,YAEZ5D,cAAc4C,IAEdlB,aAAaC,2BAA2BgC,MAEjCC,WAAWtC,OAyIyB0C,CAAUnD,QAASR,KAAMuC"}