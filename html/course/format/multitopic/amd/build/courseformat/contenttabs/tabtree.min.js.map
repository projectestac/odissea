{"version":3,"file":"tabtree.min.js","sources":["../../../src/courseformat/contenttabs/tabtree.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {BaseComponent} from 'core/reactive';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport Tab from 'format_multitopic/courseformat/contenttabs/tab';\nimport Templates from 'core/templates';\n\n\n/**\n * Course section tabs updater.\n *\n * @module     format_multitopic/courseformat/contenttabs/tabtree\n * @class      format_multitopic/courseformat/contenttabs/tabtree\n * @copyright  2022 Jeremy FitzPatrick and Te WƒÅnanga o Aotearoa\n * @copyright  2023 onwards James Calder and Otago Polytechnic\n * @copyright  based on work by 2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport default class Component extends BaseComponent {\n\n    /**\n     * Constructor hook.\n     */\n    create() {\n        // Optional component name for debugging.\n        this.name = 'contenttabs';\n        // Default query selectors.\n        this.selectors = {\n            TAB: `ul:first-of-type li`,\n            CHILDTAB: `ul:nth-child(2) li`,\n            SECTION_ITEM: `a.nav-link`,\n        };\n        // Default classes\n        this.classes = {\n            ACTIVETAB: 'active'\n        };\n        // Objects to keep tabs on the tabs\n        this.tabs = {};\n        this.childtabs = {};\n        this.activetab = [null, null];\n\n        this.originalsinglesectionid = document.querySelector(\"ul.sections\").dataset.originalsinglesectionid;\n    }\n\n    static init(target) {\n        return new this({\n            element: document.getElementById(target),\n            reactive: getCurrentCourseEditor(),\n        });\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     */\n    stateReady() {\n        this._indexContents();\n    }\n\n    getWatchers() {\n        return [\n            // Sections sorting.\n            {watch: `course.sectionlist:updated`, handler: this._refreshCourseSectionTabs},\n        ];\n    }\n\n    /**\n     * Refresh the section tabs.\n     *\n     * @param {object} param\n     * @param {Object} param.element\n     */\n    async _refreshCourseSectionTabs({element}) {\n\n        const originalSingleSection = this.reactive.get(\"section\", this.originalsinglesectionid);\n        let singleSectionId;\n        let singleSection;\n        if (originalSingleSection) {\n            singleSectionId = (originalSingleSection.levelsan < 2) ? originalSingleSection.id : originalSingleSection.pageid;\n            singleSection = (singleSectionId == originalSingleSection.id) ?\n                            originalSingleSection : this.reactive.get(\"section\", singleSectionId);\n        } else {\n            singleSectionId = null;\n            singleSection = null;\n        }\n\n        let newActiveTab0id;\n        if (singleSection) {\n            newActiveTab0id = (singleSection.levelsan >= 1) ? singleSection.parentid : singleSection.id;\n        } else {\n            newActiveTab0id = null;\n        }\n\n        // Add/remove the second-level tabs, if necessary.\n        let tabsSecondRowDom = this.element.querySelector('ul:nth-of-type(2)');\n        const tabsSecondRowShow = singleSection\n                            && ((element.tabsdata.length > 1)\n                                || (element.tabsdata[0].subtree.length > 1));\n        if (tabsSecondRowShow && !tabsSecondRowDom) {\n            // Create tab row.\n            this.element.querySelector('ul:first-of-type').insertAdjacentElement(\n                'afterend', tabsSecondRowDom = document.createElement('ul')\n            );\n            tabsSecondRowDom.className = 'nav nav-tabs mb-3';\n            // Create add tab.\n            const addTab0Dom = this.element.querySelector('ul:first-of-type li:last-of-type');\n            let data = {\n                \"level\": 1,\n                \"active\": false,\n                \"inactive\": false,\n                \"link\": [{\n                    \"link\": addTab0Dom.querySelector('a').getAttribute('href').replace(/\\binsertlevel=0\\b/, 'insertlevel=1'),\n                }],\n                \"title\": addTab0Dom.getAttribute('title'),\n                \"text\": '<i class=\"icon fa fa-plus fa-fw\" title=\"' + addTab0Dom.getAttribute('title') + '\"></i>',\n            };\n            let item = document.createElement(\"li\");\n            tabsSecondRowDom.insertAdjacentElement('beforeend', item);\n            let html = await Templates.render(\"format_multitopic/courseformat/contenttabs/tab\", data);\n            item = Templates.replaceNode(item, html, \"\")[0];\n        } else if (tabsSecondRowDom && !tabsSecondRowShow) {\n            tabsSecondRowDom.remove();\n        }\n\n        let toptabslist = [];\n        let childtabslist = [];\n        for (let tabdata of element.tabsdata) {\n            toptabslist.push(tabdata.sectionid);\n            if (tabdata.sectionid == newActiveTab0id) {\n                for (let tabdata2 of tabdata.subtree) {\n                    childtabslist.push(tabdata2.sectionid);\n                }\n            }\n        }\n\n        // Do things that make the first row tabs match firstsectionlist.\n        let toptabs = this.element.querySelector('ul:first-of-type');\n        await this._fixOrder(toptabs, toptabslist, this.selectors.TAB, 0, element.tabsdata[0].subtree.length > 1);\n\n        // And the second row tabs match secondsectionlist.\n        if (tabsSecondRowShow) {\n            let childtabs = this.element.querySelector('ul:nth-of-type(2)');\n            await this._fixOrder(childtabs, childtabslist, this.selectors.CHILDTAB, 1, false);\n        }\n\n        this._changeActiveTabs(newActiveTab0id, tabsSecondRowShow ? singleSection.id : null);\n\n        this._indexContents();\n    }\n\n    /**\n     * Change active tabs, if necessary.\n     *\n     * @param {int|null} newActiveTab0id\n     * @param {int|null} newActiveTab1id\n     */\n    _changeActiveTabs(newActiveTab0id, newActiveTab1id) {\n\n        // Change the active top-level tab, if necessary.\n        if (newActiveTab0id != this.activetab[0]) {\n            let anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]')?.parentElement;\n            if (anchor) {\n                let section = this.reactive.get(\"section\", this.activetab[0]);\n                anchor.classList.remove(\"active\");\n                anchor.href = section.sectionurl.replace(\"&amp;\", \"&\");\n            }\n            this.activetab[0] = newActiveTab0id;\n            anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]')?.parentElement;\n            if (anchor) {\n                anchor.classList.add(\"active\");\n                anchor.removeAttribute(\"href\");\n            }\n            // Change the second-level add tab, if necessary.\n            if (newActiveTab1id) {\n                const addAnchor = this.element.querySelector('ul:nth-of-type(2) li:last-of-type a');\n                const addLink = addAnchor.href.replace(/\\binsertparentid=\\d+\\b/, \"insertparentid=\" + this.activetab[0]);\n                addAnchor.setAttribute(\"href\", addLink);\n            }\n        }\n\n        // Change the active second-level tab, if necessary.\n        if (newActiveTab1id && newActiveTab1id != this.activetab[1]) {\n            let anchor = this.element.querySelector('ul:nth-of-type(2) div[data-itemid=\"' + this.activetab[1] + '\"]')\n                            ?.parentElement;\n            if (anchor) {\n                let section = this.reactive.get(\"section\", this.activetab[1]);\n                anchor.classList.remove(\"active\");\n                anchor.href = section.sectionurl.replace(\"&amp;\", \"&\");\n            }\n            this.activetab[1] = newActiveTab1id;\n            anchor = this.element.querySelector('ul:nth-of-type(2) div[data-itemid=\"' + this.activetab[1] + '\"]')?.parentElement;\n            if (anchor) {\n                anchor.classList.add(\"active\");\n                anchor.removeAttribute(\"href\");\n            }\n        }\n        this.activetab[1] = newActiveTab1id;\n\n    }\n\n    /**\n     * Regenerate content indexes.\n     *\n     * This method is used when a legacy action refresh some content element.\n     */\n    _indexContents() {\n        // Find unindexed tabs.\n        this._scanIndex(\n            this.selectors.TAB,\n            this.tabs,\n            (item) => {\n                return new Tab(item);\n            },\n            0\n        );\n\n        // Find unindexed child tabs.\n        this._scanIndex(\n            this.selectors.CHILDTAB,\n            this.childtabs,\n            (item) => {\n                return new Tab(item);\n            },\n            1\n        );\n    }\n\n    /**\n     * Reindex a tab.\n     *\n     * This method is used internally by _indexContents.\n     *\n     * @param {string} selector the DOM selector to scan\n     * @param {*} index the index attribute to update\n     * @param {*} creationhandler method to create a new indexed element\n     * @param {int} level tab level\n     */\n    _scanIndex(selector, index, creationhandler, level) {\n        const items = this.getElements(`${selector}:not([data-indexed])`);\n        items.forEach((item) => {\n            if (!item?.dataset?.id) {\n                return;\n            }\n            // Delete previous item component.\n            if (index[item.dataset.id] !== undefined) {\n                index[item.dataset.id].unregister();\n            }\n            // Create the new component.\n            index[item.dataset.id] = creationhandler({\n                ...this,\n                element: item,\n            });\n            // Update selected tab\n            let classes = item.querySelector(\"a\").classList;\n            if (classes.contains(this.classes.ACTIVETAB)) {\n                this.activetab[level] = item.dataset.id;\n            }\n            // Mark as indexed.\n            item.dataset.indexed = true;\n        });\n    }\n\n    /**\n     * Fix/reorder the section or cms order.\n     *\n     * @param {Element} container the HTML element to reorder.\n     * @param {Array} neworder an array with the ids order\n     * @param {string} selector the element selector\n     * @param {int} level the tab level\n     * @param {boolean} hassubtree\n     */\n    async _fixOrder(container, neworder, selector, level, hassubtree) {\n\n        // Empty lists should not be visible.\n        if (!neworder.length) {\n            container.classList.add('hidden');\n            container.innerHTML = '';\n            return;\n        }\n\n        // Grant the list is visible (in case it was empty).\n        container.classList.remove('hidden');\n\n        // Move the elements in order at the beginning of the list.\n        for (const [index, itemid] of Object.entries(neworder)) {\n            const section = this.reactive.get(\"section\", itemid);\n            const visible = (section.visible && section.available || section.section == 0)\n                && (neworder.length > 1 || hassubtree);\n            const current = (section.currentnestedlevel != undefined && section.currentnestedlevel >= level);\n            let item = this.getElement(selector, itemid);\n            if (item === null) {\n                // If we don't have an item, create it.\n                let data = {\n                    \"sectionid\": itemid,\n                    \"level\": level,\n                    \"active\": 0,\n                    \"inactive\": 0,\n                    \"link\": [{\n                        \"link\": section.sectionurl\n                    }],\n                    \"title\": section.name,\n                    \"text\": '<div class=\"tab_content' + (visible ? '' : ' dimmed') + (current ? ' marker' : '')\n                        + '\" data-itemid=\"' + section.id + '\">' + section.title + '</div>'\n                };\n                item = document.createElement(\"li\");\n                container.insertBefore(item, container.lastElementChild);\n                let html = await Templates.render(\"format_multitopic/courseformat/contenttabs/tab\", data);\n                item = Templates.replaceNode(item, html, \"\")[0];\n            }\n\n            // Update visibility & current marker\n            const content = item.querySelector(\"div.tab_content\");\n            if (content && content.classList.contains(\"dimmed\") == visible) {\n                if (visible) {\n                    content.classList.remove(\"dimmed\");\n                } else {\n                    content.classList.add(\"dimmed\");\n                }\n            }\n            if (content && content.classList.contains(\"marker\") != current) {\n                if (current) {\n                    content.classList.add(\"marker\");\n                } else {\n                    content.classList.remove(\"marker\");\n                }\n            }\n\n            // Get the current element at that position.\n            const currentitem = container.children[index];\n            if (currentitem === undefined) {\n                container.append(item);\n                return;\n            }\n            if (currentitem !== item) {\n                container.insertBefore(item, currentitem);\n            }\n        }\n        // Remove the remaining elements.\n        // But we don't want the \"Add\" blown away.\n        while (container.children.length > neworder.length + 1) {\n                container.removeChild(container.lastElementChild.previousSibling);\n        }\n\n    }\n\n}"],"names":["Component","BaseComponent","create","name","selectors","TAB","CHILDTAB","SECTION_ITEM","classes","ACTIVETAB","tabs","childtabs","activetab","originalsinglesectionid","document","querySelector","dataset","target","this","element","getElementById","reactive","stateReady","_indexContents","getWatchers","watch","handler","_refreshCourseSectionTabs","originalSingleSection","get","singleSectionId","singleSection","newActiveTab0id","levelsan","id","pageid","parentid","tabsSecondRowDom","tabsSecondRowShow","tabsdata","length","subtree","insertAdjacentElement","createElement","className","addTab0Dom","data","getAttribute","replace","item","html","Templates","render","replaceNode","remove","toptabslist","childtabslist","tabdata","push","sectionid","tabdata2","toptabs","_fixOrder","_changeActiveTabs","newActiveTab1id","anchor","_this$element$querySe","parentElement","section","classList","href","sectionurl","_this$element$querySe2","add","removeAttribute","addAnchor","addLink","setAttribute","_this$element$querySe3","_this$element$querySe4","_scanIndex","Tab","selector","index","creationhandler","level","getElements","forEach","_item$dataset","undefined","unregister","contains","indexed","container","neworder","hassubtree","innerHTML","itemid","Object","entries","visible","available","current","currentnestedlevel","getElement","title","insertBefore","lastElementChild","content","currentitem","children","append","removeChild","previousSibling"],"mappings":"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"}