{"version":3,"file":"loader.min.js","sources":["../src/loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/ //\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Mathjax JS Loader.\n *\n * @module filter_mathjaxloader/loader\n * @copyright 2014 Damyon Wiese  <damyon@moodle.com>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {\n    eventTypes,\n    notifyFilterContentRenderingComplete,\n} from 'core_filters/events';\n\n/**\n * The users current language - this can't be set until MathJax is loaded - so we need to store it.\n * @property {string} lang\n * @default ''\n * @private\n */\nlet lang = '';\n\n/**\n * Used to prevent configuring MathJax twice.\n * @property {boolean} configured\n * @default false\n * @private\n */\nlet configured = false;\n\n/**\n * Called by the filter when it is active on any page.\n * This does not load MathJAX yet - it addes the configuration to the head incase it gets loaded later.\n * It also subscribes to the filter-content-updated event so MathJax can respond to content loaded by Ajax.\n *\n * @param {Object} params List of configuration params containing mathjaxconfig (text) and lang\n */\nexport const configure = (params) => {\n    // Add a js configuration object to the head.\n    // See \"https://docs.mathjax.org/en/v2.7-latest/advanced/dynamic.html\"\n    const script = document.createElement(\"script\");\n    script.type = \"text/x-mathjax-config\";\n    script[(window.opera ? \"innerHTML\" : \"text\")] = params.mathjaxconfig;\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n\n    // Save the lang config until MathJax is actually loaded.\n    lang = params.lang;\n\n    // Listen for events triggered when new text is added to a page that needs\n    // processing by a filter.\n    document.addEventListener(eventTypes.filterContentUpdated, contentUpdated);\n};\n\n/**\n * Set the correct language for the MathJax menus. Only do this once.\n *\n * @private\n */\nconst setLocale = () => {\n    if (!configured) {\n        if (typeof window.MathJax !== \"undefined\") {\n            window.MathJax.Hub.Queue(function() {\n                window.MathJax.Localization.setLocale(lang);\n            });\n            window.MathJax.Hub.Configured();\n            configured = true;\n        }\n    }\n};\n\n/**\n * Add the node to the typeset queue.\n *\n * @param {HTMLElement} node The Node to be processed by MathJax\n * @private\n */\nconst typesetNode = (node) => {\n    if (!(node instanceof HTMLElement)) {\n        // We may have been passed a #text node.\n        // These cannot be formatted.\n        return;\n    }\n\n    // MathJax 2.X does not notify when complete. The best we can do, according to their docs, is to queue a callback.\n    // See https://docs.mathjax.org/en/v2.7-latest/advanced/typeset.html\n    // Note that the MathJax.Hub.Queue() method will return immediately, regardless of whether the typesetting has taken place\n    // or not, so you can not assume that the mathematics is visible after you make this call.\n    // That means that things like the size of the container for the mathematics may not yet reflect the size of the\n    // typeset mathematics. If you need to perform actions that depend on the mathematics being typeset, you should push those\n    // actions onto the MathJax.Hub.queue as well.\n    window.MathJax.Hub.Queue([\"Typeset\", window.MathJax.Hub, node]);\n    window.MathJax.Hub.Queue([(node) => {\n        // The notifyFilterContentRenderingComplete event takes an Array of NodeElements or a NodeList.\n        // We cannot create a NodeList so we use an HTMLElement[].\n        notifyFilterContentRenderingComplete([node]);\n    }, node]);\n};\n\n/**\n * Called by the filter when an equation is found while rendering the page.\n */\nexport const typeset = () => {\n    if (!configured) {\n        setLocale();\n        const elements = document.getElementsByClassName('filter_mathjaxloader_equation');\n        for (const element of elements) {\n            if (typeof window.MathJax !== \"undefined\") {\n                typesetNode(element);\n            }\n        }\n    }\n};\n\n/**\n * Handle content updated events - typeset the new content.\n *\n * @param {CustomEvent} event - Custom event with \"nodes\" indicating the root of the updated nodes.\n */\nexport const contentUpdated = (event) => {\n    if (typeof window.MathJax === \"undefined\") {\n        return;\n    }\n\n    let listOfElementContainMathJax = [];\n    let hasMathJax = false;\n    // The list of HTMLElements in an Array.\n    event.detail.nodes.forEach((node) => {\n        if (!(node instanceof HTMLElement)) {\n            // We may have been passed a #text node.\n            return;\n        }\n        const mathjaxElements = node.querySelectorAll('.filter_mathjaxloader_equation');\n        if (mathjaxElements.length > 0) {\n            hasMathJax = true;\n        }\n        listOfElementContainMathJax.push(mathjaxElements);\n    });\n    if (!hasMathJax) {\n        return;\n    }\n    const processDelay = window.MathJax.Hub.processSectionDelay;\n    // Set the process section delay to 0 when updating the formula.\n    window.MathJax.Hub.processSectionDelay = 0;\n    // When content is updated never position to hash, it may cause unexpected document scrolling.\n    window.MathJax.Hub.Config({positionToHash: false});\n    setLocale();\n    listOfElementContainMathJax.forEach((mathjaxElements) => {\n        mathjaxElements.forEach((node) => typesetNode(node));\n    });\n    window.MathJax.Hub.processSectionDelay = processDelay;\n};\n"],"names":["lang","configured","params","script","document","createElement","type","window","opera","mathjaxconfig","getElementsByTagName","appendChild","addEventListener","eventTypes","filterContentUpdated","contentUpdated","setLocale","MathJax","Hub","Queue","Localization","Configured","typesetNode","node","HTMLElement","elements","getElementsByClassName","element","event","listOfElementContainMathJax","hasMathJax","detail","nodes","forEach","mathjaxElements","querySelectorAll","length","push","processDelay","processSectionDelay","Config","positionToHash"],"mappings":";;;;;;;;IAgCIA,KAAO,GAQPC,YAAa,qBASSC,eAGhBC,OAASC,SAASC,cAAc,UACtCF,OAAOG,KAAO,wBACdH,OAAQI,OAAOC,MAAQ,YAAc,QAAWN,OAAOO,cACvDL,SAASM,qBAAqB,QAAQ,GAAGC,YAAYR,QAGrDH,KAAOE,OAAOF,KAIdI,SAASQ,iBAAiBC,mBAAWC,qBAAsBC,uBAQzDC,UAAY,KACTf,iBAC6B,IAAnBM,OAAOU,UACdV,OAAOU,QAAQC,IAAIC,OAAM,WACrBZ,OAAOU,QAAQG,aAAaJ,UAAUhB,SAE1CO,OAAOU,QAAQC,IAAIG,aACnBpB,YAAa,IAWnBqB,YAAeC,OACXA,gBAAgBC,cAatBjB,OAAOU,QAAQC,IAAIC,MAAM,CAAC,UAAWZ,OAAOU,QAAQC,IAAKK,OACzDhB,OAAOU,QAAQC,IAAIC,MAAM,CAAEI,wDAGc,CAACA,QACvCA,0BAMgB,SACdtB,WAAY,CACbe,kBACMS,SAAWrB,SAASsB,uBAAuB,qCAC5C,MAAMC,WAAWF,cACY,IAAnBlB,OAAOU,SACdK,YAAYK,iBAWfZ,eAAkBa,gBACG,IAAnBrB,OAAOU,mBAIdY,4BAA8B,GAC9BC,YAAa,KAEjBF,MAAMG,OAAOC,MAAMC,SAASV,YAClBA,gBAAgBC,0BAIhBU,gBAAkBX,KAAKY,iBAAiB,kCAC1CD,gBAAgBE,OAAS,IACzBN,YAAa,GAEjBD,4BAA4BQ,KAAKH,qBAEhCJ,wBAGCQ,aAAe/B,OAAOU,QAAQC,IAAIqB,oBAExChC,OAAOU,QAAQC,IAAIqB,oBAAsB,EAEzChC,OAAOU,QAAQC,IAAIsB,OAAO,CAACC,gBAAgB,IAC3CzB,YACAa,4BAA4BI,SAASC,kBACjCA,gBAAgBD,SAASV,MAASD,YAAYC,WAElDhB,OAAOU,QAAQC,IAAIqB,oBAAsBD"}